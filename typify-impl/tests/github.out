#[doc = "AlertInstance"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Alert Instance\",\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"dismissed\",\n        \"fixed\"\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstance {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<AlertInstanceLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AlertInstanceMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "State of a code scanning alert."]
    pub state: AlertInstanceState,
}
impl From<&AlertInstance> for AlertInstance {
    fn from(value: &AlertInstance) -> Self {
        value.clone()
    }
}
#[doc = "AlertInstanceLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&AlertInstanceLocation> for AlertInstanceLocation {
    fn from(value: &AlertInstanceLocation) -> Self {
        value.clone()
    }
}
#[doc = "AlertInstanceMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&AlertInstanceMessage> for AlertInstanceMessage {
    fn from(value: &AlertInstanceMessage) -> Self {
        value.clone()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"dismissed\",\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlertInstanceState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&AlertInstanceState> for AlertInstanceState {
    fn from(value: &AlertInstanceState) -> Self {
        value.clone()
    }
}
impl ToString for AlertInstanceState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for AlertInstanceState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"App\",\n  \"description\": \"GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"external_url\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"owner\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"events\": {\n      \"description\": \"The list of events for the GitHub app\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"check_run\",\n          \"check_suite\",\n          \"code_scanning_alert\",\n          \"commit_comment\",\n          \"content_reference\",\n          \"create\",\n          \"delete\",\n          \"deployment\",\n          \"deployment_review\",\n          \"deployment_status\",\n          \"deploy_key\",\n          \"discussion\",\n          \"discussion_comment\",\n          \"fork\",\n          \"gollum\",\n          \"issues\",\n          \"issue_comment\",\n          \"label\",\n          \"member\",\n          \"membership\",\n          \"milestone\",\n          \"organization\",\n          \"org_block\",\n          \"page_build\",\n          \"project\",\n          \"project_card\",\n          \"project_column\",\n          \"public\",\n          \"pull_request\",\n          \"pull_request_review\",\n          \"pull_request_review_comment\",\n          \"push\",\n          \"registry_package\",\n          \"release\",\n          \"repository\",\n          \"repository_dispatch\",\n          \"secret_scanning_alert\",\n          \"star\",\n          \"status\",\n          \"team\",\n          \"team_add\",\n          \"watch\",\n          \"workflow_dispatch\",\n          \"workflow_run\"\n        ]\n      }\n    },\n    \"external_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the GitHub app\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the GitHub app\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"description\": \"The set of permissions for the GitHub app\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"actions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"checks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"content_references\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"contents\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"deployments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"emails\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"environments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"issues\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"members\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"metadata\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_plan\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_self_hosted_runners\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_user_blocking\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pull_requests\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secret_scanning_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_scanning_alert\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"single_file\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"statuses\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"team_discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"vulnerability_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"workflows\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"slug\": {\n      \"description\": \"The slug name of the GitHub app\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct App {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    #[doc = "The list of events for the GitHub app"]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<AppEventsItem>,
    pub external_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The name of the GitHub app"]
    pub name: String,
    pub node_id: String,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slug: Option<String>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&App> for App {
    fn from(value: &App) -> Self {
        value.clone()
    }
}
#[doc = "AppEventsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"check_run\",\n    \"check_suite\",\n    \"code_scanning_alert\",\n    \"commit_comment\",\n    \"content_reference\",\n    \"create\",\n    \"delete\",\n    \"deployment\",\n    \"deployment_review\",\n    \"deployment_status\",\n    \"deploy_key\",\n    \"discussion\",\n    \"discussion_comment\",\n    \"fork\",\n    \"gollum\",\n    \"issues\",\n    \"issue_comment\",\n    \"label\",\n    \"member\",\n    \"membership\",\n    \"milestone\",\n    \"organization\",\n    \"org_block\",\n    \"page_build\",\n    \"project\",\n    \"project_card\",\n    \"project_column\",\n    \"public\",\n    \"pull_request\",\n    \"pull_request_review\",\n    \"pull_request_review_comment\",\n    \"push\",\n    \"registry_package\",\n    \"release\",\n    \"repository\",\n    \"repository_dispatch\",\n    \"secret_scanning_alert\",\n    \"star\",\n    \"status\",\n    \"team\",\n    \"team_add\",\n    \"watch\",\n    \"workflow_dispatch\",\n    \"workflow_run\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&AppEventsItem> for AppEventsItem {
    fn from(value: &AppEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for AppEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for AppEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The set of permissions for the GitHub app"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The set of permissions for the GitHub app\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"actions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"checks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"content_references\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"contents\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"deployments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"emails\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"environments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"issues\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"members\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"metadata\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_plan\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_self_hosted_runners\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_user_blocking\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pull_requests\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secret_scanning_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_scanning_alert\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"single_file\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"statuses\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"team_discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"vulnerability_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"workflows\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AppPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<AppPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<AppPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<AppPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<AppPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<AppPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<AppPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<AppPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<AppPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<AppPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<AppPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<AppPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<AppPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<AppPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<AppPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<AppPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<AppPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<AppPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<AppPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners: Option<AppPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<AppPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<AppPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<AppPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<AppPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<AppPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<AppPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<AppPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<AppPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<AppPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<AppPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<AppPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<AppPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<AppPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<AppPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<AppPermissionsWorkflows>,
}
impl From<&AppPermissions> for AppPermissions {
    fn from(value: &AppPermissions) -> Self {
        value.clone()
    }
}
#[doc = "AppPermissionsActions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsActions> for AppPermissionsActions {
    fn from(value: &AppPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsAdministration> for AppPermissionsAdministration {
    fn from(value: &AppPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsChecks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsChecks> for AppPermissionsChecks {
    fn from(value: &AppPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsContentReferences"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsContentReferences> for AppPermissionsContentReferences {
    fn from(value: &AppPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsContents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsContents> for AppPermissionsContents {
    fn from(value: &AppPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsDeployments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsDeployments> for AppPermissionsDeployments {
    fn from(value: &AppPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsDiscussions> for AppPermissionsDiscussions {
    fn from(value: &AppPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsEmails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsEmails> for AppPermissionsEmails {
    fn from(value: &AppPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsEnvironments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsEnvironments> for AppPermissionsEnvironments {
    fn from(value: &AppPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsIssues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsIssues> for AppPermissionsIssues {
    fn from(value: &AppPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsMembers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsMembers> for AppPermissionsMembers {
    fn from(value: &AppPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsMetadata> for AppPermissionsMetadata {
    fn from(value: &AppPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationAdministration> for AppPermissionsOrganizationAdministration {
    fn from(value: &AppPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationHooks> for AppPermissionsOrganizationHooks {
    fn from(value: &AppPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationPackages> for AppPermissionsOrganizationPackages {
    fn from(value: &AppPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationPlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationPlan> for AppPermissionsOrganizationPlan {
    fn from(value: &AppPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationProjects> for AppPermissionsOrganizationProjects {
    fn from(value: &AppPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationSecrets> for AppPermissionsOrganizationSecrets {
    fn from(value: &AppPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationSelfHostedRunners"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationSelfHostedRunners>
    for AppPermissionsOrganizationSelfHostedRunners
{
    fn from(value: &AppPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsOrganizationUserBlocking"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationUserBlocking> for AppPermissionsOrganizationUserBlocking {
    fn from(value: &AppPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPackages> for AppPermissionsPackages {
    fn from(value: &AppPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsPages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPages> for AppPermissionsPages {
    fn from(value: &AppPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsPullRequests"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPullRequests> for AppPermissionsPullRequests {
    fn from(value: &AppPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsRepositoryHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsRepositoryHooks> for AppPermissionsRepositoryHooks {
    fn from(value: &AppPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsRepositoryProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsRepositoryProjects> for AppPermissionsRepositoryProjects {
    fn from(value: &AppPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsSecretScanningAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecretScanningAlerts> for AppPermissionsSecretScanningAlerts {
    fn from(value: &AppPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecrets> for AppPermissionsSecrets {
    fn from(value: &AppPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsSecurityEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecurityEvents> for AppPermissionsSecurityEvents {
    fn from(value: &AppPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsSecurityScanningAlert"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecurityScanningAlert> for AppPermissionsSecurityScanningAlert {
    fn from(value: &AppPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsSingleFile"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSingleFile> for AppPermissionsSingleFile {
    fn from(value: &AppPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsStatuses"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsStatuses> for AppPermissionsStatuses {
    fn from(value: &AppPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsTeamDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsTeamDiscussions> for AppPermissionsTeamDiscussions {
    fn from(value: &AppPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsVulnerabilityAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsVulnerabilityAlerts> for AppPermissionsVulnerabilityAlerts {
    fn from(value: &AppPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "AppPermissionsWorkflows"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsWorkflows> for AppPermissionsWorkflows {
    fn from(value: &AppPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "How the author is associated with the repository."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"AuthorAssociation\",\n  \"description\": \"How the author is associated with the repository.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"COLLABORATOR\",\n    \"CONTRIBUTOR\",\n    \"FIRST_TIMER\",\n    \"FIRST_TIME_CONTRIBUTOR\",\n    \"MANNEQUIN\",\n    \"MEMBER\",\n    \"NONE\",\n    \"OWNER\"\n  ],\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AuthorAssociation {
    #[serde(rename = "COLLABORATOR")]
    Collaborator,
    #[serde(rename = "CONTRIBUTOR")]
    Contributor,
    #[serde(rename = "FIRST_TIMER")]
    FirstTimer,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    FirstTimeContributor,
    #[serde(rename = "MANNEQUIN")]
    Mannequin,
    #[serde(rename = "MEMBER")]
    Member,
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OWNER")]
    Owner,
}
impl From<&AuthorAssociation> for AuthorAssociation {
    fn from(value: &AuthorAssociation) -> Self {
        value.clone()
    }
}
impl ToString for AuthorAssociation {
    fn to_string(&self) -> String {
        match *self {
            Self::Collaborator => "COLLABORATOR".to_string(),
            Self::Contributor => "CONTRIBUTOR".to_string(),
            Self::FirstTimer => "FIRST_TIMER".to_string(),
            Self::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR".to_string(),
            Self::Mannequin => "MANNEQUIN".to_string(),
            Self::Member => "MEMBER".to_string(),
            Self::None => "NONE".to_string(),
            Self::Owner => "OWNER".to_string(),
        }
    }
}
impl std::str::FromStr for AuthorAssociation {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "COLLABORATOR" => Ok(Self::Collaborator),
            "CONTRIBUTOR" => Ok(Self::Contributor),
            "FIRST_TIMER" => Ok(Self::FirstTimer),
            "FIRST_TIME_CONTRIBUTOR" => Ok(Self::FirstTimeContributor),
            "MANNEQUIN" => Ok(Self::Mannequin),
            "MEMBER" => Ok(Self::Member),
            "NONE" => Ok(Self::None),
            "OWNER" => Ok(Self::Owner),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"branch protection rule\",\n  \"description\": \"The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"admin_enforced\",\n    \"allow_deletions_enforcement_level\",\n    \"allow_force_pushes_enforcement_level\",\n    \"authorized_actor_names\",\n    \"authorized_actors_only\",\n    \"authorized_dismissal_actors_only\",\n    \"created_at\",\n    \"dismiss_stale_reviews_on_push\",\n    \"id\",\n    \"ignore_approvals_from_contributors\",\n    \"linear_history_requirement_enforcement_level\",\n    \"merge_queue_enforcement_level\",\n    \"name\",\n    \"pull_request_reviews_enforcement_level\",\n    \"repository_id\",\n    \"require_code_owner_review\",\n    \"required_approving_review_count\",\n    \"required_conversation_resolution_level\",\n    \"required_deployments_enforcement_level\",\n    \"required_status_checks\",\n    \"required_status_checks_enforcement_level\",\n    \"signature_requirement_enforcement_level\",\n    \"strict_required_status_checks_policy\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"admin_enforced\": {\n      \"type\": \"boolean\"\n    },\n    \"allow_deletions_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"allow_force_pushes_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"authorized_actor_names\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"authorized_actors_only\": {\n      \"type\": \"boolean\"\n    },\n    \"authorized_dismissal_actors_only\": {\n      \"type\": \"boolean\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismiss_stale_reviews_on_push\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"ignore_approvals_from_contributors\": {\n      \"type\": \"boolean\"\n    },\n    \"linear_history_requirement_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"merge_queue_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"pull_request_reviews_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"require_code_owner_review\": {\n      \"type\": \"boolean\"\n    },\n    \"required_approving_review_count\": {\n      \"type\": \"integer\"\n    },\n    \"required_conversation_resolution_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"required_deployments_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"required_status_checks\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"required_status_checks_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"signature_requirement_enforcement_level\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"off\",\n        \"non_admins\",\n        \"everyone\"\n      ]\n    },\n    \"strict_required_status_checks_policy\": {\n      \"type\": \"boolean\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRule {
    pub admin_enforced: bool,
    pub allow_deletions_enforcement_level: BranchProtectionRuleAllowDeletionsEnforcementLevel,
    pub allow_force_pushes_enforcement_level: BranchProtectionRuleAllowForcePushesEnforcementLevel,
    pub authorized_actor_names: Vec<String>,
    pub authorized_actors_only: bool,
    pub authorized_dismissal_actors_only: bool,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismiss_stale_reviews_on_push: bool,
    pub id: i64,
    pub ignore_approvals_from_contributors: bool,
    pub linear_history_requirement_enforcement_level:
        BranchProtectionRuleLinearHistoryRequirementEnforcementLevel,
    pub merge_queue_enforcement_level: BranchProtectionRuleMergeQueueEnforcementLevel,
    pub name: String,
    pub pull_request_reviews_enforcement_level:
        BranchProtectionRulePullRequestReviewsEnforcementLevel,
    pub repository_id: i64,
    pub require_code_owner_review: bool,
    pub required_approving_review_count: i64,
    pub required_conversation_resolution_level:
        BranchProtectionRuleRequiredConversationResolutionLevel,
    pub required_deployments_enforcement_level:
        BranchProtectionRuleRequiredDeploymentsEnforcementLevel,
    pub required_status_checks: Vec<String>,
    pub required_status_checks_enforcement_level:
        BranchProtectionRuleRequiredStatusChecksEnforcementLevel,
    pub signature_requirement_enforcement_level:
        BranchProtectionRuleSignatureRequirementEnforcementLevel,
    pub strict_required_status_checks_policy: bool,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&BranchProtectionRule> for BranchProtectionRule {
    fn from(value: &BranchProtectionRule) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleAllowDeletionsEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleAllowDeletionsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleAllowDeletionsEnforcementLevel>
    for BranchProtectionRuleAllowDeletionsEnforcementLevel
{
    fn from(value: &BranchProtectionRuleAllowDeletionsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleAllowForcePushesEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleAllowForcePushesEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleAllowForcePushesEnforcementLevel>
    for BranchProtectionRuleAllowForcePushesEnforcementLevel
{
    fn from(value: &BranchProtectionRuleAllowForcePushesEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"branch protection rule created event\",\n  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"rule\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"rule\": {\n      \"$ref\": \"#/definitions/branch-protection-rule\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleCreated {
    pub action: BranchProtectionRuleCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleCreated> for BranchProtectionRuleCreated {
    fn from(value: &BranchProtectionRuleCreated) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&BranchProtectionRuleCreatedAction> for BranchProtectionRuleCreatedAction {
    fn from(value: &BranchProtectionRuleCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"branch protection rule deleted event\",\n  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"rule\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"rule\": {\n      \"$ref\": \"#/definitions/branch-protection-rule\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleDeleted {
    pub action: BranchProtectionRuleDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleDeleted> for BranchProtectionRuleDeleted {
    fn from(value: &BranchProtectionRuleDeleted) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&BranchProtectionRuleDeletedAction> for BranchProtectionRuleDeletedAction {
    fn from(value: &BranchProtectionRuleDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"branch protection rule edited event\",\n  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"repository\",\n    \"rule\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"If the action was `edited`, the changes to the rule.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"authorized_actor_names\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"authorized_actors_only\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"boolean\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"rule\": {\n      \"$ref\": \"#/definitions/branch-protection-rule\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEdited {
    pub action: BranchProtectionRuleEditedAction,
    pub changes: BranchProtectionRuleEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleEdited> for BranchProtectionRuleEdited {
    fn from(value: &BranchProtectionRuleEdited) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&BranchProtectionRuleEditedAction> for BranchProtectionRuleEditedAction {
    fn from(value: &BranchProtectionRuleEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "If the action was `edited`, the changes to the rule."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"If the action was `edited`, the changes to the rule.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"authorized_actor_names\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"authorized_actors_only\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actor_names: Option<BranchProtectionRuleEditedChangesAuthorizedActorNames>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actors_only: Option<BranchProtectionRuleEditedChangesAuthorizedActorsOnly>,
}
impl From<&BranchProtectionRuleEditedChanges> for BranchProtectionRuleEditedChanges {
    fn from(value: &BranchProtectionRuleEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleEditedChangesAuthorizedActorNames"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorNames {
    pub from: Vec<String>,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorNames>
    for BranchProtectionRuleEditedChangesAuthorizedActorNames
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorNames) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleEditedChangesAuthorizedActorsOnly"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorsOnly {
    pub from: bool,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorsOnly>
    for BranchProtectionRuleEditedChangesAuthorizedActorsOnly
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorsOnly) -> Self {
        value.clone()
    }
}
#[doc = "BranchProtectionRuleEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/branch_protection_rule$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/branch_protection_rule$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/branch_protection_rule$edited\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BranchProtectionRuleEvent {
    Created(BranchProtectionRuleCreated),
    Deleted(BranchProtectionRuleDeleted),
    Edited(BranchProtectionRuleEdited),
}
impl From<&BranchProtectionRuleEvent> for BranchProtectionRuleEvent {
    fn from(value: &BranchProtectionRuleEvent) -> Self {
        value.clone()
    }
}
impl From<BranchProtectionRuleCreated> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleCreated) -> Self {
        Self::Created(value)
    }
}
impl From<BranchProtectionRuleDeleted> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<BranchProtectionRuleEdited> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "BranchProtectionRuleLinearHistoryRequirementEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleLinearHistoryRequirementEnforcementLevel>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    fn from(value: &BranchProtectionRuleLinearHistoryRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleMergeQueueEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleMergeQueueEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleMergeQueueEnforcementLevel>
    for BranchProtectionRuleMergeQueueEnforcementLevel
{
    fn from(value: &BranchProtectionRuleMergeQueueEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleMergeQueueEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRulePullRequestReviewsEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRulePullRequestReviewsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRulePullRequestReviewsEnforcementLevel>
    for BranchProtectionRulePullRequestReviewsEnforcementLevel
{
    fn from(value: &BranchProtectionRulePullRequestReviewsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleRequiredConversationResolutionLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredConversationResolutionLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredConversationResolutionLevel>
    for BranchProtectionRuleRequiredConversationResolutionLevel
{
    fn from(value: &BranchProtectionRuleRequiredConversationResolutionLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredConversationResolutionLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleRequiredDeploymentsEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredDeploymentsEnforcementLevel>
    for BranchProtectionRuleRequiredDeploymentsEnforcementLevel
{
    fn from(value: &BranchProtectionRuleRequiredDeploymentsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleRequiredStatusChecksEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredStatusChecksEnforcementLevel>
    for BranchProtectionRuleRequiredStatusChecksEnforcementLevel
{
    fn from(value: &BranchProtectionRuleRequiredStatusChecksEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "BranchProtectionRuleSignatureRequirementEnforcementLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"off\",\n    \"non_admins\",\n    \"everyone\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleSignatureRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleSignatureRequirementEnforcementLevel>
    for BranchProtectionRuleSignatureRequirementEnforcementLevel
{
    fn from(value: &BranchProtectionRuleSignatureRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunCompleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_run completed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_run\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"check_run\": {\n      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"app\",\n        \"check_suite\",\n        \"completed_at\",\n        \"conclusion\",\n        \"external_id\",\n        \"head_sha\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"output\",\n        \"pull_requests\",\n        \"started_at\",\n        \"status\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"check_suite\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"after\",\n            \"app\",\n            \"before\",\n            \"conclusion\",\n            \"created_at\",\n            \"head_branch\",\n            \"head_sha\",\n            \"id\",\n            \"pull_requests\",\n            \"status\",\n            \"updated_at\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"after\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"app\": {\n              \"$ref\": \"#/definitions/app\"\n            },\n            \"before\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"conclusion\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"success\",\n                \"failure\",\n                \"neutral\",\n                \"cancelled\",\n                \"timed_out\",\n                \"action_required\",\n                \"stale\",\n                null\n              ]\n            },\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"deployment\": {\n              \"$ref\": \"#/definitions/check-run-deployment\"\n            },\n            \"head_branch\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"head_sha\": {\n              \"description\": \"The SHA of the head commit that is being checked.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"The id of the check suite that this check run is part of.\",\n              \"type\": \"integer\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"pull_requests\": {\n              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/check-run-pull-request\"\n              }\n            },\n            \"status\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"in_progress\",\n                \"completed\",\n                \"queued\"\n              ]\n            },\n            \"updated_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"completed_at\": {\n          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"conclusion\": {\n          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            \"skipped\",\n            null\n          ]\n        },\n        \"details_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"external_id\": {\n          \"type\": \"string\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check.\",\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"description\": \"The name of the check run.\",\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"output\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"annotations_count\",\n            \"annotations_url\",\n            \"summary\",\n            \"text\"\n          ],\n          \"properties\": {\n            \"annotations_count\": {\n              \"type\": \"integer\"\n            },\n            \"annotations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"summary\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"text\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"title\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"pull_requests\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"started_at\": {\n          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"status\": {\n          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"completed\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"requested_action\": {\n      \"description\": \"The action requested by the user.\",\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"description\": \"The integrator reference of the action requested by the user.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompleted {
    pub action: CheckRunCompletedAction,
    pub check_run: CheckRunCompletedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCompletedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunCompleted> for CheckRunCompleted {
    fn from(value: &CheckRunCompleted) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCompletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCompletedAction> for CheckRunCompletedAction {
    fn from(value: &CheckRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"app\",\n    \"check_suite\",\n    \"completed_at\",\n    \"conclusion\",\n    \"external_id\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"output\",\n    \"pull_requests\",\n    \"started_at\",\n    \"status\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"check_suite\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_sha\",\n        \"id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"deployment\": {\n          \"$ref\": \"#/definitions/check-run-deployment\"\n        },\n        \"head_branch\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check suite that this check run is part of.\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"in_progress\",\n            \"completed\",\n            \"queued\"\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"completed_at\": {\n      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"conclusion\": {\n      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        \"skipped\",\n        null\n      ]\n    },\n    \"details_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"external_id\": {\n      \"type\": \"string\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check.\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the check run.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"annotations_count\",\n        \"annotations_url\",\n        \"summary\",\n        \"text\"\n      ],\n      \"properties\": {\n        \"annotations_count\": {\n          \"type\": \"integer\"\n        },\n        \"annotations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"summary\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"text\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"title\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"started_at\": {\n      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCompletedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCompletedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCompletedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCompletedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunCompletedCheckRun> for CheckRunCompletedCheckRun {
    fn from(value: &CheckRunCompletedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCompletedCheckRunCheckSuite"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_sha\",\n    \"id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deployment\": {\n      \"$ref\": \"#/definitions/check-run-deployment\"\n    },\n    \"head_branch\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check suite that this check run is part of.\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"in_progress\",\n        \"completed\",\n        \"queued\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCompletedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCompletedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunCompletedCheckRunCheckSuite> for CheckRunCompletedCheckRunCheckSuite {
    fn from(value: &CheckRunCompletedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCompletedCheckRunCheckSuiteConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteConclusion>
    for CheckRunCompletedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunCompletedCheckRunCheckSuiteStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteStatus {
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteStatus>
    for CheckRunCompletedCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\",\n    \"skipped\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunCompletedCheckRunConclusion> for CheckRunCompletedCheckRunConclusion {
    fn from(value: &CheckRunCompletedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunCompletedCheckRunOutput"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"annotations_count\",\n    \"annotations_url\",\n    \"summary\",\n    \"text\"\n  ],\n  \"properties\": {\n    \"annotations_count\": {\n      \"type\": \"integer\"\n    },\n    \"annotations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"summary\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"text\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"title\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunCompletedCheckRunOutput> for CheckRunCompletedCheckRunOutput {
    fn from(value: &CheckRunCompletedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCompletedCheckRunStatus> for CheckRunCompletedCheckRunStatus {
    fn from(value: &CheckRunCompletedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action requested by the user.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"identifier\": {\n      \"description\": \"The integrator reference of the action requested by the user.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunCompletedRequestedAction> for CheckRunCompletedRequestedAction {
    fn from(value: &CheckRunCompletedRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_run created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_run\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"check_run\": {\n      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"app\",\n        \"check_suite\",\n        \"completed_at\",\n        \"conclusion\",\n        \"external_id\",\n        \"head_sha\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"output\",\n        \"pull_requests\",\n        \"started_at\",\n        \"status\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"check_suite\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"after\",\n            \"app\",\n            \"before\",\n            \"conclusion\",\n            \"created_at\",\n            \"head_branch\",\n            \"head_sha\",\n            \"id\",\n            \"pull_requests\",\n            \"status\",\n            \"updated_at\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"after\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"app\": {\n              \"$ref\": \"#/definitions/app\"\n            },\n            \"before\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"conclusion\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"success\",\n                \"failure\",\n                \"neutral\",\n                \"cancelled\",\n                \"timed_out\",\n                \"action_required\",\n                \"stale\",\n                null\n              ]\n            },\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"deployment\": {\n              \"$ref\": \"#/definitions/check-run-deployment\"\n            },\n            \"head_branch\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"head_sha\": {\n              \"description\": \"The SHA of the head commit that is being checked.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"The id of the check suite that this check run is part of.\",\n              \"type\": \"integer\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"pull_requests\": {\n              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/check-run-pull-request\"\n              }\n            },\n            \"status\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"queued\",\n                \"in_progress\",\n                \"completed\"\n              ]\n            },\n            \"updated_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"completed_at\": {\n          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            \"skipped\",\n            null\n          ]\n        },\n        \"details_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"external_id\": {\n          \"type\": \"string\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check.\",\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"description\": \"The name of the check run.\",\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"output\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"annotations_count\",\n            \"annotations_url\",\n            \"summary\",\n            \"text\"\n          ],\n          \"properties\": {\n            \"annotations_count\": {\n              \"type\": \"integer\"\n            },\n            \"annotations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"summary\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"text\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"title\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"pull_requests\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"started_at\": {\n          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"status\": {\n          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"queued\",\n            \"in_progress\",\n            \"completed\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"requested_action\": {\n      \"description\": \"The action requested by the user.\",\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"description\": \"The integrator reference of the action requested by the user.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreated {
    pub action: CheckRunCreatedAction,
    pub check_run: CheckRunCreatedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCreatedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunCreated> for CheckRunCreated {
    fn from(value: &CheckRunCreated) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CheckRunCreatedAction> for CheckRunCreatedAction {
    fn from(value: &CheckRunCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"app\",\n    \"check_suite\",\n    \"completed_at\",\n    \"conclusion\",\n    \"external_id\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"output\",\n    \"pull_requests\",\n    \"started_at\",\n    \"status\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"check_suite\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_sha\",\n        \"id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"deployment\": {\n          \"$ref\": \"#/definitions/check-run-deployment\"\n        },\n        \"head_branch\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check suite that this check run is part of.\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"queued\",\n            \"in_progress\",\n            \"completed\"\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"completed_at\": {\n      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        \"skipped\",\n        null\n      ]\n    },\n    \"details_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"external_id\": {\n      \"type\": \"string\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check.\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the check run.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"annotations_count\",\n        \"annotations_url\",\n        \"summary\",\n        \"text\"\n      ],\n      \"properties\": {\n        \"annotations_count\": {\n          \"type\": \"integer\"\n        },\n        \"annotations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"summary\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"text\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"title\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"started_at\": {\n      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCreatedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCreatedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCreatedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCreatedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunCreatedCheckRun> for CheckRunCreatedCheckRun {
    fn from(value: &CheckRunCreatedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCreatedCheckRunCheckSuite"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_sha\",\n    \"id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deployment\": {\n      \"$ref\": \"#/definitions/check-run-deployment\"\n    },\n    \"head_branch\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check suite that this check run is part of.\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCreatedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCreatedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunCreatedCheckRunCheckSuite> for CheckRunCreatedCheckRunCheckSuite {
    fn from(value: &CheckRunCreatedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunCreatedCheckRunCheckSuiteConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteConclusion>
    for CheckRunCreatedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunCreatedCheckRunCheckSuiteStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteStatus> for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\",\n    \"skipped\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunCreatedCheckRunConclusion> for CheckRunCreatedCheckRunConclusion {
    fn from(value: &CheckRunCreatedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunCreatedCheckRunOutput"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"annotations_count\",\n    \"annotations_url\",\n    \"summary\",\n    \"text\"\n  ],\n  \"properties\": {\n    \"annotations_count\": {\n      \"type\": \"integer\"\n    },\n    \"annotations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"summary\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"text\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"title\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunCreatedCheckRunOutput> for CheckRunCreatedCheckRunOutput {
    fn from(value: &CheckRunCreatedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCreatedCheckRunStatus> for CheckRunCreatedCheckRunStatus {
    fn from(value: &CheckRunCreatedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action requested by the user.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"identifier\": {\n      \"description\": \"The integrator reference of the action requested by the user.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunCreatedRequestedAction> for CheckRunCreatedRequestedAction {
    fn from(value: &CheckRunCreatedRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Check Run Deployment\",\n  \"description\": \"A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"environment\",\n    \"id\",\n    \"node_id\",\n    \"original_environment\",\n    \"repository_url\",\n    \"statuses_url\",\n    \"task\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"environment\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"original_environment\": {\n      \"type\": \"string\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"task\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunDeployment {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub repository_url: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunDeployment> for CheckRunDeployment {
    fn from(value: &CheckRunDeployment) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/check_run$completed\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_run$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_run$requested_action\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_run$rerequested\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckRunEvent {
    Completed(CheckRunCompleted),
    Created(CheckRunCreated),
    RequestedAction(CheckRunRequestedAction),
    Rerequested(CheckRunRerequested),
}
impl From<&CheckRunEvent> for CheckRunEvent {
    fn from(value: &CheckRunEvent) -> Self {
        value.clone()
    }
}
impl From<CheckRunCompleted> for CheckRunEvent {
    fn from(value: CheckRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<CheckRunCreated> for CheckRunEvent {
    fn from(value: CheckRunCreated) -> Self {
        Self::Created(value)
    }
}
impl From<CheckRunRequestedAction> for CheckRunEvent {
    fn from(value: CheckRunRequestedAction) -> Self {
        Self::RequestedAction(value)
    }
}
impl From<CheckRunRerequested> for CheckRunEvent {
    fn from(value: CheckRunRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[doc = "CheckRunPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Check Run Pull Request\",\n  \"type\": \"object\",\n  \"required\": [\n    \"base\",\n    \"head\",\n    \"id\",\n    \"number\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequest {
    pub base: CheckRunPullRequestBase,
    pub head: CheckRunPullRequestHead,
    pub id: i64,
    pub number: i64,
    pub url: String,
}
impl From<&CheckRunPullRequest> for CheckRunPullRequest {
    fn from(value: &CheckRunPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&CheckRunPullRequestBase> for CheckRunPullRequestBase {
    fn from(value: &CheckRunPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&CheckRunPullRequestHead> for CheckRunPullRequestHead {
    fn from(value: &CheckRunPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRequestedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_run requested_action event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_run\",\n    \"repository\",\n    \"requested_action\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"requested_action\"\n      ]\n    },\n    \"check_run\": {\n      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"app\",\n        \"check_suite\",\n        \"completed_at\",\n        \"conclusion\",\n        \"external_id\",\n        \"head_sha\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"output\",\n        \"pull_requests\",\n        \"started_at\",\n        \"status\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"check_suite\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"after\",\n            \"app\",\n            \"before\",\n            \"conclusion\",\n            \"created_at\",\n            \"head_branch\",\n            \"head_sha\",\n            \"id\",\n            \"pull_requests\",\n            \"status\",\n            \"updated_at\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"after\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"app\": {\n              \"$ref\": \"#/definitions/app\"\n            },\n            \"before\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"conclusion\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"success\",\n                \"failure\",\n                \"neutral\",\n                \"cancelled\",\n                \"timed_out\",\n                \"action_required\",\n                \"stale\",\n                null\n              ]\n            },\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"deployment\": {\n              \"$ref\": \"#/definitions/check-run-deployment\"\n            },\n            \"head_branch\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"head_sha\": {\n              \"description\": \"The SHA of the head commit that is being checked.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"The id of the check suite that this check run is part of.\",\n              \"type\": \"integer\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"pull_requests\": {\n              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/check-run-pull-request\"\n              }\n            },\n            \"status\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"queued\",\n                \"in_progress\",\n                \"completed\"\n              ]\n            },\n            \"updated_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"completed_at\": {\n          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            \"skipped\",\n            null\n          ]\n        },\n        \"details_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"external_id\": {\n          \"type\": \"string\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check.\",\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"description\": \"The name of the check run.\",\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"output\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"annotations_count\",\n            \"annotations_url\",\n            \"summary\",\n            \"text\"\n          ],\n          \"properties\": {\n            \"annotations_count\": {\n              \"type\": \"integer\"\n            },\n            \"annotations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"summary\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"text\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"title\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"pull_requests\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"started_at\": {\n          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"status\": {\n          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"queued\",\n            \"in_progress\",\n            \"completed\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"requested_action\": {\n      \"description\": \"The action requested by the user.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"identifier\": {\n          \"description\": \"The integrator reference of the action requested by the user.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedAction {
    pub action: CheckRunRequestedActionAction,
    pub check_run: CheckRunRequestedActionCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub requested_action: CheckRunRequestedActionRequestedAction,
    pub sender: User,
}
impl From<&CheckRunRequestedAction> for CheckRunRequestedAction {
    fn from(value: &CheckRunRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRequestedActionAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested_action\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionAction {
    #[serde(rename = "requested_action")]
    RequestedAction,
}
impl From<&CheckRunRequestedActionAction> for CheckRunRequestedActionAction {
    fn from(value: &CheckRunRequestedActionAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RequestedAction => "requested_action".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested_action" => Ok(Self::RequestedAction),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"app\",\n    \"check_suite\",\n    \"completed_at\",\n    \"conclusion\",\n    \"external_id\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"output\",\n    \"pull_requests\",\n    \"started_at\",\n    \"status\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"check_suite\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_sha\",\n        \"id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"deployment\": {\n          \"$ref\": \"#/definitions/check-run-deployment\"\n        },\n        \"head_branch\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check suite that this check run is part of.\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"queued\",\n            \"in_progress\",\n            \"completed\"\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"completed_at\": {\n      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        \"skipped\",\n        null\n      ]\n    },\n    \"details_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"external_id\": {\n      \"type\": \"string\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check.\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the check run.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"annotations_count\",\n        \"annotations_url\",\n        \"summary\",\n        \"text\"\n      ],\n      \"properties\": {\n        \"annotations_count\": {\n          \"type\": \"integer\"\n        },\n        \"annotations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"summary\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"text\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"title\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"started_at\": {\n      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRun {
    pub app: App,
    pub check_suite: CheckRunRequestedActionCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunRequestedActionCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRequestedActionCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunRequestedActionCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunRequestedActionCheckRun> for CheckRunRequestedActionCheckRun {
    fn from(value: &CheckRunRequestedActionCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRequestedActionCheckRunCheckSuite"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_sha\",\n    \"id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deployment\": {\n      \"$ref\": \"#/definitions/check-run-deployment\"\n    },\n    \"head_branch\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check suite that this check run is part of.\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunRequestedActionCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRequestedActionCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuite>
    for CheckRunRequestedActionCheckRunCheckSuite
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRequestedActionCheckRunCheckSuiteConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteConclusion>
    for CheckRunRequestedActionCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunRequestedActionCheckRunCheckSuiteStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteStatus>
    for CheckRunRequestedActionCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\",\n    \"skipped\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunRequestedActionCheckRunConclusion>
    for CheckRunRequestedActionCheckRunConclusion
{
    fn from(value: &CheckRunRequestedActionCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunRequestedActionCheckRunOutput"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"annotations_count\",\n    \"annotations_url\",\n    \"summary\",\n    \"text\"\n  ],\n  \"properties\": {\n    \"annotations_count\": {\n      \"type\": \"integer\"\n    },\n    \"annotations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"summary\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"text\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"title\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunRequestedActionCheckRunOutput> for CheckRunRequestedActionCheckRunOutput {
    fn from(value: &CheckRunRequestedActionCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRequestedActionCheckRunStatus> for CheckRunRequestedActionCheckRunStatus {
    fn from(value: &CheckRunRequestedActionCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action requested by the user.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"identifier\": {\n      \"description\": \"The integrator reference of the action requested by the user.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunRequestedActionRequestedAction> for CheckRunRequestedActionRequestedAction {
    fn from(value: &CheckRunRequestedActionRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRerequested"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_run rerequested event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_run\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"rerequested\"\n      ]\n    },\n    \"check_run\": {\n      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"app\",\n        \"check_suite\",\n        \"completed_at\",\n        \"conclusion\",\n        \"external_id\",\n        \"head_sha\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"output\",\n        \"pull_requests\",\n        \"started_at\",\n        \"status\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"check_suite\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"after\",\n            \"app\",\n            \"before\",\n            \"conclusion\",\n            \"created_at\",\n            \"head_branch\",\n            \"head_sha\",\n            \"id\",\n            \"pull_requests\",\n            \"status\",\n            \"updated_at\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"after\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"app\": {\n              \"$ref\": \"#/definitions/app\"\n            },\n            \"before\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"conclusion\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"success\",\n                \"failure\",\n                \"neutral\",\n                \"cancelled\",\n                \"timed_out\",\n                \"action_required\",\n                \"stale\"\n              ]\n            },\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"deployment\": {\n              \"$ref\": \"#/definitions/check-run-deployment\"\n            },\n            \"head_branch\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"head_sha\": {\n              \"description\": \"The SHA of the head commit that is being checked.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"The id of the check suite that this check run is part of.\",\n              \"type\": \"integer\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"pull_requests\": {\n              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/check-run-pull-request\"\n              }\n            },\n            \"status\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"completed\"\n              ]\n            },\n            \"updated_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"completed_at\": {\n          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"conclusion\": {\n          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            \"skipped\",\n            null\n          ]\n        },\n        \"details_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"external_id\": {\n          \"type\": \"string\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check.\",\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"description\": \"The name of the check.\",\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"output\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"annotations_count\",\n            \"annotations_url\",\n            \"summary\",\n            \"text\"\n          ],\n          \"properties\": {\n            \"annotations_count\": {\n              \"type\": \"integer\"\n            },\n            \"annotations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"summary\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"text\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"title\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"pull_requests\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"started_at\": {\n          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\"\n        },\n        \"status\": {\n          \"description\": \"The phase of the lifecycle that the check is currently in.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"completed\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"requested_action\": {\n      \"description\": \"The action requested by the user.\",\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"description\": \"The integrator reference of the action requested by the user.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequested {
    pub action: CheckRunRerequestedAction,
    pub check_run: CheckRunRerequestedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunRerequestedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunRerequested> for CheckRunRerequested {
    fn from(value: &CheckRunRerequested) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRerequestedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"rerequested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl From<&CheckRunRerequestedAction> for CheckRunRerequestedAction {
    fn from(value: &CheckRunRerequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"app\",\n    \"check_suite\",\n    \"completed_at\",\n    \"conclusion\",\n    \"external_id\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"output\",\n    \"pull_requests\",\n    \"started_at\",\n    \"status\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"check_suite\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_sha\",\n        \"id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"conclusion\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\"\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"deployment\": {\n          \"$ref\": \"#/definitions/check-run-deployment\"\n        },\n        \"head_branch\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"The id of the check suite that this check run is part of.\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"completed\"\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"completed_at\": {\n      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"conclusion\": {\n      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        \"skipped\",\n        null\n      ]\n    },\n    \"details_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"external_id\": {\n      \"type\": \"string\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check.\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the check.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"annotations_count\",\n        \"annotations_url\",\n        \"summary\",\n        \"text\"\n      ],\n      \"properties\": {\n        \"annotations_count\": {\n          \"type\": \"integer\"\n        },\n        \"annotations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"summary\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"text\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"title\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"started_at\": {\n      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"description\": \"The phase of the lifecycle that the check is currently in.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRun {
    pub app: App,
    pub check_suite: CheckRunRerequestedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckRunRerequestedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRerequestedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: CheckRunRerequestedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunRerequestedCheckRun> for CheckRunRerequestedCheckRun {
    fn from(value: &CheckRunRerequestedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRerequestedCheckRunCheckSuite"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_sha\",\n    \"id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\"\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deployment\": {\n      \"$ref\": \"#/definitions/check-run-deployment\"\n    },\n    \"head_branch\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"The id of the check suite that this check run is part of.\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: CheckRunRerequestedCheckRunCheckSuiteConclusion,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRerequestedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunRerequestedCheckRunCheckSuite> for CheckRunRerequestedCheckRunCheckSuite {
    fn from(value: &CheckRunRerequestedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "CheckRunRerequestedCheckRunCheckSuiteConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteConclusion>
    for CheckRunRerequestedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunRerequestedCheckRunCheckSuiteStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteStatus>
    for CheckRunRerequestedCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\",\n    \"skipped\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunRerequestedCheckRunConclusion> for CheckRunRerequestedCheckRunConclusion {
    fn from(value: &CheckRunRerequestedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckRunRerequestedCheckRunOutput"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"annotations_count\",\n    \"annotations_url\",\n    \"summary\",\n    \"text\"\n  ],\n  \"properties\": {\n    \"annotations_count\": {\n      \"type\": \"integer\"\n    },\n    \"annotations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"summary\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"text\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"title\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunRerequestedCheckRunOutput> for CheckRunRerequestedCheckRunOutput {
    fn from(value: &CheckRunRerequestedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The phase of the lifecycle that the check is currently in."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The phase of the lifecycle that the check is currently in.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRerequestedCheckRunStatus> for CheckRunRerequestedCheckRunStatus {
    fn from(value: &CheckRunRerequestedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action requested by the user.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"identifier\": {\n      \"description\": \"The integrator reference of the action requested by the user.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunRerequestedRequestedAction> for CheckRunRerequestedRequestedAction {
    fn from(value: &CheckRunRerequestedRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "CheckSuiteCompleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_suite completed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_suite\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"check_suite\": {\n      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"check_runs_url\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_commit\",\n        \"head_sha\",\n        \"id\",\n        \"latest_check_runs_count\",\n        \"node_id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": \"string\"\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"check_runs_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"conclusion\": {\n          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"head_branch\": {\n          \"description\": \"The head branch name the changes are on.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_commit\": {\n          \"$ref\": \"#/definitions/commit-simple\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"latest_check_runs_count\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"requested\",\n            \"in_progress\",\n            \"completed\",\n            \"queued\",\n            null\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"description\": \"URL that points to the check suite API resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompleted {
    pub action: CheckSuiteCompletedAction,
    pub check_suite: CheckSuiteCompletedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteCompleted> for CheckSuiteCompleted {
    fn from(value: &CheckSuiteCompleted) -> Self {
        value.clone()
    }
}
#[doc = "CheckSuiteCompletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckSuiteCompletedAction> for CheckSuiteCompletedAction {
    fn from(value: &CheckSuiteCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"check_runs_url\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_commit\",\n    \"head_sha\",\n    \"id\",\n    \"latest_check_runs_count\",\n    \"node_id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": \"string\"\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"check_runs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"conclusion\": {\n      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"head_branch\": {\n      \"description\": \"The head branch name the changes are on.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_commit\": {\n      \"$ref\": \"#/definitions/commit-simple\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"latest_check_runs_count\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"requested\",\n        \"in_progress\",\n        \"completed\",\n        \"queued\",\n        null\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL that points to the check suite API resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompletedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckSuiteCompletedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteCompletedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteCompletedCheckSuite> for CheckSuiteCompletedCheckSuite {
    fn from(value: &CheckSuiteCompletedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteCompletedCheckSuiteConclusion> for CheckSuiteCompletedCheckSuiteConclusion {
    fn from(value: &CheckSuiteCompletedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\",\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteCompletedCheckSuiteStatus> for CheckSuiteCompletedCheckSuiteStatus {
    fn from(value: &CheckSuiteCompletedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckSuiteEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/check_suite$completed\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_suite$requested\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_suite$rerequested\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckSuiteEvent {
    Completed(CheckSuiteCompleted),
    Requested(CheckSuiteRequested),
    Rerequested(CheckSuiteRerequested),
}
impl From<&CheckSuiteEvent> for CheckSuiteEvent {
    fn from(value: &CheckSuiteEvent) -> Self {
        value.clone()
    }
}
impl From<CheckSuiteCompleted> for CheckSuiteEvent {
    fn from(value: CheckSuiteCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<CheckSuiteRequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRequested) -> Self {
        Self::Requested(value)
    }
}
impl From<CheckSuiteRerequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[doc = "CheckSuiteRequested"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_suite requested event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_suite\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"requested\"\n      ]\n    },\n    \"check_suite\": {\n      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"check_runs_url\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_commit\",\n        \"head_sha\",\n        \"id\",\n        \"latest_check_runs_count\",\n        \"node_id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": \"string\"\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"check_runs_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"conclusion\": {\n          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"head_branch\": {\n          \"description\": \"The head branch name the changes are on.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_commit\": {\n          \"$ref\": \"#/definitions/commit-simple\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"latest_check_runs_count\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"requested\",\n            \"in_progress\",\n            \"completed\",\n            \"queued\",\n            null\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"description\": \"URL that points to the check suite API resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequested {
    pub action: CheckSuiteRequestedAction,
    pub check_suite: CheckSuiteRequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteRequested> for CheckSuiteRequested {
    fn from(value: &CheckSuiteRequested) -> Self {
        value.clone()
    }
}
#[doc = "CheckSuiteRequestedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl From<&CheckSuiteRequestedAction> for CheckSuiteRequestedAction {
    fn from(value: &CheckSuiteRequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"check_runs_url\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_commit\",\n    \"head_sha\",\n    \"id\",\n    \"latest_check_runs_count\",\n    \"node_id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": \"string\"\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"check_runs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"conclusion\": {\n      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"head_branch\": {\n      \"description\": \"The head branch name the changes are on.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_commit\": {\n      \"$ref\": \"#/definitions/commit-simple\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"latest_check_runs_count\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"requested\",\n        \"in_progress\",\n        \"completed\",\n        \"queued\",\n        null\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL that points to the check suite API resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteRequestedCheckSuite> for CheckSuiteRequestedCheckSuite {
    fn from(value: &CheckSuiteRequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteRequestedCheckSuiteConclusion> for CheckSuiteRequestedCheckSuiteConclusion {
    fn from(value: &CheckSuiteRequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\",\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteRequestedCheckSuiteStatus> for CheckSuiteRequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CheckSuiteRerequested"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"check_suite rerequested event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"check_suite\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"rerequested\"\n      ]\n    },\n    \"check_suite\": {\n      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"after\",\n        \"app\",\n        \"before\",\n        \"check_runs_url\",\n        \"conclusion\",\n        \"created_at\",\n        \"head_branch\",\n        \"head_commit\",\n        \"head_sha\",\n        \"id\",\n        \"latest_check_runs_count\",\n        \"node_id\",\n        \"pull_requests\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"after\": {\n          \"type\": \"string\"\n        },\n        \"app\": {\n          \"$ref\": \"#/definitions/app\"\n        },\n        \"before\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"check_runs_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"conclusion\": {\n          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"success\",\n            \"failure\",\n            \"neutral\",\n            \"cancelled\",\n            \"timed_out\",\n            \"action_required\",\n            \"stale\",\n            null\n          ]\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"head_branch\": {\n          \"description\": \"The head branch name the changes are on.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"head_commit\": {\n          \"$ref\": \"#/definitions/commit-simple\"\n        },\n        \"head_sha\": {\n          \"description\": \"The SHA of the head commit that is being checked.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"latest_check_runs_count\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_requests\": {\n          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/check-run-pull-request\"\n          }\n        },\n        \"status\": {\n          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"requested\",\n            \"in_progress\",\n            \"completed\",\n            \"queued\",\n            null\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"url\": {\n          \"description\": \"URL that points to the check suite API resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequested {
    pub action: CheckSuiteRerequestedAction,
    pub check_suite: CheckSuiteRerequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteRerequested> for CheckSuiteRerequested {
    fn from(value: &CheckSuiteRerequested) -> Self {
        value.clone()
    }
}
#[doc = "CheckSuiteRerequestedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"rerequested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl From<&CheckSuiteRerequestedAction> for CheckSuiteRerequestedAction {
    fn from(value: &CheckSuiteRerequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"app\",\n    \"before\",\n    \"check_runs_url\",\n    \"conclusion\",\n    \"created_at\",\n    \"head_branch\",\n    \"head_commit\",\n    \"head_sha\",\n    \"id\",\n    \"latest_check_runs_count\",\n    \"node_id\",\n    \"pull_requests\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"type\": \"string\"\n    },\n    \"app\": {\n      \"$ref\": \"#/definitions/app\"\n    },\n    \"before\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"check_runs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"conclusion\": {\n      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"head_branch\": {\n      \"description\": \"The head branch name the changes are on.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"head_commit\": {\n      \"$ref\": \"#/definitions/commit-simple\"\n    },\n    \"head_sha\": {\n      \"description\": \"The SHA of the head commit that is being checked.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"latest_check_runs_count\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/check-run-pull-request\"\n      }\n    },\n    \"status\": {\n      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"requested\",\n        \"in_progress\",\n        \"completed\",\n        \"queued\",\n        null\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL that points to the check suite API resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRerequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRerequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteRerequestedCheckSuite> for CheckSuiteRerequestedCheckSuite {
    fn from(value: &CheckSuiteRerequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteRerequestedCheckSuiteConclusion>
    for CheckSuiteRerequestedCheckSuiteConclusion
{
    fn from(value: &CheckSuiteRerequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\",\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteRerequestedCheckSuiteStatus> for CheckSuiteRerequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRerequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertAppearedInBranch"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert appeared_in_branch event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"appeared_in_branch\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"format\": \"date-time\"\n        },\n        \"dismissed_by\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"false positive\",\n            \"won't fix\",\n            \"used in tests\",\n            null\n          ]\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/alert-instance\"\n          }\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"dismissed\",\n            \"fixed\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/github-org\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranch {
    pub action: CodeScanningAlertAppearedInBranchAction,
    pub alert: CodeScanningAlertAppearedInBranchAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertAppearedInBranch> for CodeScanningAlertAppearedInBranch {
    fn from(value: &CodeScanningAlertAppearedInBranch) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertAppearedInBranchAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"appeared_in_branch\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAction {
    #[serde(rename = "appeared_in_branch")]
    AppearedInBranch,
}
impl From<&CodeScanningAlertAppearedInBranchAction> for CodeScanningAlertAppearedInBranchAction {
    fn from(value: &CodeScanningAlertAppearedInBranchAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AppearedInBranch => "appeared_in_branch".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "appeared_in_branch" => Ok(Self::AppearedInBranch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"dismissed_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"false positive\",\n        \"won't fix\",\n        \"used in tests\",\n        null\n      ]\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/alert-instance\"\n      }\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"dismissed\",\n        \"fixed\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertAppearedInBranchAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertAppearedInBranchAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertAppearedInBranchAlertState,
    pub tool: CodeScanningAlertAppearedInBranchAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertAppearedInBranchAlert> for CodeScanningAlertAppearedInBranchAlert {
    fn from(value: &CodeScanningAlertAppearedInBranchAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"false positive\",\n    \"won't fix\",\n    \"used in tests\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertAppearedInBranchAlertDismissedReason>
    for CodeScanningAlertAppearedInBranchAlertDismissedReason
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertAppearedInBranchAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertAppearedInBranchAlertRuleSeverity>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRule>
    for CodeScanningAlertAppearedInBranchAlertRule
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRuleSeverity>
    for CodeScanningAlertAppearedInBranchAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"dismissed\",\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertAppearedInBranchAlertState>
    for CodeScanningAlertAppearedInBranchAlertState
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertAppearedInBranchAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertTool>
    for CodeScanningAlertAppearedInBranchAlertTool
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertClosedByUser"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert closed_by_user event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed_by_user\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_by\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"false positive\",\n            \"won't fix\",\n            \"used in tests\",\n            null\n          ]\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [\n              {\n                \"$ref\": \"#/definitions/alert-instance\"\n              },\n              {\n                \"type\": \"object\",\n                \"required\": [\n                  \"state\"\n                ],\n                \"properties\": {\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"dismissed\"\n                    ]\n                  }\n                },\n                \"tsAdditionalProperties\": false\n              }\n            ]\n          }\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"full_description\": {\n              \"type\": \"string\"\n            },\n            \"help\": {\n              \"type\": \"null\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            },\n            \"tags\": {\n              \"type\": \"null\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"dismissed\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"guid\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUser {
    pub action: CodeScanningAlertClosedByUserAction,
    pub alert: CodeScanningAlertClosedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CodeScanningAlertClosedByUser> for CodeScanningAlertClosedByUser {
    fn from(value: &CodeScanningAlertClosedByUser) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertClosedByUserAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed_by_user\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAction {
    #[serde(rename = "closed_by_user")]
    ClosedByUser,
}
impl From<&CodeScanningAlertClosedByUserAction> for CodeScanningAlertClosedByUserAction {
    fn from(value: &CodeScanningAlertClosedByUserAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ClosedByUser => "closed_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed_by_user" => Ok(Self::ClosedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_by\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"false positive\",\n        \"won't fix\",\n        \"used in tests\",\n        null\n      ]\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [\n          {\n            \"$ref\": \"#/definitions/alert-instance\"\n          },\n          {\n            \"type\": \"object\",\n            \"required\": [\n              \"state\"\n            ],\n            \"properties\": {\n              \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"dismissed\"\n                ]\n              }\n            },\n            \"tsAdditionalProperties\": false\n          }\n        ]\n      }\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"full_description\": {\n          \"type\": \"string\"\n        },\n        \"help\": {\n          \"type\": \"null\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        },\n        \"tags\": {\n          \"type\": \"null\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"dismissed\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"guid\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismissed_by: User,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertClosedByUserAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<CodeScanningAlertClosedByUserAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertClosedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertClosedByUserAlertState,
    pub tool: CodeScanningAlertClosedByUserAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertClosedByUserAlert> for CodeScanningAlertClosedByUserAlert {
    fn from(value: &CodeScanningAlertClosedByUserAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"false positive\",\n    \"won't fix\",\n    \"used in tests\",\n    null\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertClosedByUserAlertDismissedReason>
    for CodeScanningAlertClosedByUserAlertDismissedReason
{
    fn from(value: &CodeScanningAlertClosedByUserAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertInstancesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dismissed\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertClosedByUserAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<CodeScanningAlertClosedByUserAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub state: CodeScanningAlertClosedByUserAlertInstancesItemState,
}
impl From<&CodeScanningAlertClosedByUserAlertInstancesItem>
    for CodeScanningAlertClosedByUserAlertInstancesItem
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertInstancesItemLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&CodeScanningAlertClosedByUserAlertInstancesItemLocation>
    for CodeScanningAlertClosedByUserAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertInstancesItemMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&CodeScanningAlertClosedByUserAlertInstancesItemMessage>
    for CodeScanningAlertClosedByUserAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertInstancesItemState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertInstancesItemState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertClosedByUserAlertInstancesItemState>
    for CodeScanningAlertClosedByUserAlertInstancesItemState
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertInstancesItemState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"full_description\": {\n      \"type\": \"string\"\n    },\n    \"help\": {\n      \"type\": \"null\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    },\n    \"tags\": {\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertClosedByUserAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertClosedByUserAlertRule> for CodeScanningAlertClosedByUserAlertRule {
    fn from(value: &CodeScanningAlertClosedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertClosedByUserAlertRuleSeverity>
    for CodeScanningAlertClosedByUserAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertClosedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertClosedByUserAlertState> for CodeScanningAlertClosedByUserAlertState {
    fn from(value: &CodeScanningAlertClosedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertClosedByUserAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"guid\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertClosedByUserAlertTool> for CodeScanningAlertClosedByUserAlertTool {
    fn from(value: &CodeScanningAlertClosedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"null\"\n        },\n        \"dismissed_by\": {\n          \"type\": \"null\"\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": \"null\"\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [\n              {\n                \"$ref\": \"#/definitions/alert-instance\"\n              },\n              {\n                \"type\": \"object\",\n                \"required\": [\n                  \"state\"\n                ],\n                \"properties\": {\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"open\",\n                      \"dismissed\"\n                    ]\n                  }\n                },\n                \"tsAdditionalProperties\": false\n              }\n            ]\n          }\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"full_description\": {\n              \"type\": \"string\"\n            },\n            \"help\": {\n              \"type\": \"null\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            },\n            \"tags\": {\n              \"type\": \"null\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"dismissed\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"guid\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/github-org\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreated {
    pub action: CodeScanningAlertCreatedAction,
    pub alert: CodeScanningAlertCreatedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertCreated> for CodeScanningAlertCreated {
    fn from(value: &CodeScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CodeScanningAlertCreatedAction> for CodeScanningAlertCreatedAction {
    fn from(value: &CodeScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"null\"\n    },\n    \"dismissed_by\": {\n      \"type\": \"null\"\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": \"null\"\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [\n          {\n            \"$ref\": \"#/definitions/alert-instance\"\n          },\n          {\n            \"type\": \"object\",\n            \"required\": [\n              \"state\"\n            ],\n            \"properties\": {\n              \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"open\",\n                  \"dismissed\"\n                ]\n              }\n            },\n            \"tsAdditionalProperties\": false\n          }\n        ]\n      }\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"full_description\": {\n          \"type\": \"string\"\n        },\n        \"help\": {\n          \"type\": \"null\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        },\n        \"tags\": {\n          \"type\": \"null\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"dismissed\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"guid\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<CodeScanningAlertCreatedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertCreatedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertCreatedAlertState,
    pub tool: CodeScanningAlertCreatedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertCreatedAlert> for CodeScanningAlertCreatedAlert {
    fn from(value: &CodeScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreatedAlertInstancesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"dismissed\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertCreatedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<CodeScanningAlertCreatedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub state: CodeScanningAlertCreatedAlertInstancesItemState,
}
impl From<&CodeScanningAlertCreatedAlertInstancesItem>
    for CodeScanningAlertCreatedAlertInstancesItem
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreatedAlertInstancesItemLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&CodeScanningAlertCreatedAlertInstancesItemLocation>
    for CodeScanningAlertCreatedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreatedAlertInstancesItemMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&CodeScanningAlertCreatedAlertInstancesItemMessage>
    for CodeScanningAlertCreatedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertCreatedAlertInstancesItemState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertCreatedAlertInstancesItemState>
    for CodeScanningAlertCreatedAlertInstancesItemState
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAlertInstancesItemState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertInstancesItemState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertCreatedAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"full_description\": {\n      \"type\": \"string\"\n    },\n    \"help\": {\n      \"type\": \"null\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    },\n    \"tags\": {\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertCreatedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertCreatedAlertRule> for CodeScanningAlertCreatedAlertRule {
    fn from(value: &CodeScanningAlertCreatedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertCreatedAlertRuleSeverity>
    for CodeScanningAlertCreatedAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertCreatedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertCreatedAlertState> for CodeScanningAlertCreatedAlertState {
    fn from(value: &CodeScanningAlertCreatedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertCreatedAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"guid\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertCreatedAlertTool> for CodeScanningAlertCreatedAlertTool {
    fn from(value: &CodeScanningAlertCreatedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$appeared_in_branch\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$closed_by_user\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$fixed\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$reopened\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert$reopened_by_user\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CodeScanningAlertEvent {
    AppearedInBranch(CodeScanningAlertAppearedInBranch),
    ClosedByUser(CodeScanningAlertClosedByUser),
    Created(CodeScanningAlertCreated),
    Fixed(CodeScanningAlertFixed),
    Reopened(CodeScanningAlertReopened),
    ReopenedByUser(CodeScanningAlertReopenedByUser),
}
impl From<&CodeScanningAlertEvent> for CodeScanningAlertEvent {
    fn from(value: &CodeScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl From<CodeScanningAlertAppearedInBranch> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertAppearedInBranch) -> Self {
        Self::AppearedInBranch(value)
    }
}
impl From<CodeScanningAlertClosedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertClosedByUser) -> Self {
        Self::ClosedByUser(value)
    }
}
impl From<CodeScanningAlertCreated> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl From<CodeScanningAlertFixed> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertFixed) -> Self {
        Self::Fixed(value)
    }
}
impl From<CodeScanningAlertReopened> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<CodeScanningAlertReopenedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopenedByUser) -> Self {
        Self::ReopenedByUser(value)
    }
}
#[doc = "CodeScanningAlertFixed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert fixed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"fixed\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"format\": \"date-time\"\n        },\n        \"dismissed_by\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"false positive\",\n            \"won't fix\",\n            \"used in tests\",\n            null\n          ]\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [\n              {\n                \"$ref\": \"#/definitions/alert-instance\"\n              },\n              {\n                \"type\": \"object\",\n                \"required\": [\n                  \"state\"\n                ],\n                \"properties\": {\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"fixed\"\n                    ]\n                  }\n                },\n                \"tsAdditionalProperties\": false\n              }\n            ]\n          }\n        },\n        \"instances_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"full_description\": {\n              \"type\": \"string\"\n            },\n            \"help\": {\n              \"type\": \"null\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            },\n            \"tags\": {\n              \"type\": \"null\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"fixed\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"guid\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/github-org\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixed {
    pub action: CodeScanningAlertFixedAction,
    pub alert: CodeScanningAlertFixedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertFixed> for CodeScanningAlertFixed {
    fn from(value: &CodeScanningAlertFixed) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertFixedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAction {
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertFixedAction> for CodeScanningAlertFixedAction {
    fn from(value: &CodeScanningAlertFixedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"dismissed_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"false positive\",\n        \"won't fix\",\n        \"used in tests\",\n        null\n      ]\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [\n          {\n            \"$ref\": \"#/definitions/alert-instance\"\n          },\n          {\n            \"type\": \"object\",\n            \"required\": [\n              \"state\"\n            ],\n            \"properties\": {\n              \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"fixed\"\n                ]\n              }\n            },\n            \"tsAdditionalProperties\": false\n          }\n        ]\n      }\n    },\n    \"instances_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"full_description\": {\n          \"type\": \"string\"\n        },\n        \"help\": {\n          \"type\": \"null\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        },\n        \"tags\": {\n          \"type\": \"null\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"fixed\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"guid\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertFixedAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<CodeScanningAlertFixedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertFixedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertFixedAlertState,
    pub tool: CodeScanningAlertFixedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertFixedAlert> for CodeScanningAlertFixedAlert {
    fn from(value: &CodeScanningAlertFixedAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"false positive\",\n    \"won't fix\",\n    \"used in tests\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertFixedAlertDismissedReason>
    for CodeScanningAlertFixedAlertDismissedReason
{
    fn from(value: &CodeScanningAlertFixedAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertFixedAlertInstancesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"fixed\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertFixedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<CodeScanningAlertFixedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub state: CodeScanningAlertFixedAlertInstancesItemState,
}
impl From<&CodeScanningAlertFixedAlertInstancesItem> for CodeScanningAlertFixedAlertInstancesItem {
    fn from(value: &CodeScanningAlertFixedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertFixedAlertInstancesItemLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&CodeScanningAlertFixedAlertInstancesItemLocation>
    for CodeScanningAlertFixedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertFixedAlertInstancesItemMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&CodeScanningAlertFixedAlertInstancesItemMessage>
    for CodeScanningAlertFixedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertFixedAlertInstancesItemState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertInstancesItemState {
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertFixedAlertInstancesItemState>
    for CodeScanningAlertFixedAlertInstancesItemState
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertInstancesItemState {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertInstancesItemState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertFixedAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"full_description\": {\n      \"type\": \"string\"\n    },\n    \"help\": {\n      \"type\": \"null\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    },\n    \"tags\": {\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertFixedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertFixedAlertRule> for CodeScanningAlertFixedAlertRule {
    fn from(value: &CodeScanningAlertFixedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertFixedAlertRuleSeverity> for CodeScanningAlertFixedAlertRuleSeverity {
    fn from(value: &CodeScanningAlertFixedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertState {
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertFixedAlertState> for CodeScanningAlertFixedAlertState {
    fn from(value: &CodeScanningAlertFixedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertFixedAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"guid\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertFixedAlertTool> for CodeScanningAlertFixedAlertTool {
    fn from(value: &CodeScanningAlertFixedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert reopened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"null\"\n        },\n        \"dismissed_by\": {\n          \"type\": \"null\"\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": \"null\"\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [\n              {\n                \"$ref\": \"#/definitions/alert-instance\"\n              },\n              {\n                \"type\": \"object\",\n                \"required\": [\n                  \"state\"\n                ],\n                \"properties\": {\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"open\"\n                    ]\n                  }\n                },\n                \"tsAdditionalProperties\": false\n              }\n            ]\n          }\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"full_description\": {\n              \"type\": \"string\"\n            },\n            \"help\": {\n              \"type\": \"null\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            },\n            \"tags\": {\n              \"type\": \"null\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"dismissed\",\n            \"fixed\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"guid\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/github-org\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopened {
    pub action: CodeScanningAlertReopenedAction,
    pub alert: CodeScanningAlertReopenedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertReopened> for CodeScanningAlertReopened {
    fn from(value: &CodeScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&CodeScanningAlertReopenedAction> for CodeScanningAlertReopenedAction {
    fn from(value: &CodeScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"null\"\n    },\n    \"dismissed_by\": {\n      \"type\": \"null\"\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": \"null\"\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [\n          {\n            \"$ref\": \"#/definitions/alert-instance\"\n          },\n          {\n            \"type\": \"object\",\n            \"required\": [\n              \"state\"\n            ],\n            \"properties\": {\n              \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"open\"\n                ]\n              }\n            },\n            \"tsAdditionalProperties\": false\n          }\n        ]\n      }\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"full_description\": {\n          \"type\": \"string\"\n        },\n        \"help\": {\n          \"type\": \"null\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        },\n        \"tags\": {\n          \"type\": \"null\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"dismissed\",\n        \"fixed\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"guid\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<CodeScanningAlertReopenedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedAlertState,
    pub tool: CodeScanningAlertReopenedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertReopenedAlert> for CodeScanningAlertReopenedAlert {
    fn from(value: &CodeScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedAlertInstancesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertReopenedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<CodeScanningAlertReopenedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub state: CodeScanningAlertReopenedAlertInstancesItemState,
}
impl From<&CodeScanningAlertReopenedAlertInstancesItem>
    for CodeScanningAlertReopenedAlertInstancesItem
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedAlertInstancesItemLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&CodeScanningAlertReopenedAlertInstancesItemLocation>
    for CodeScanningAlertReopenedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedAlertInstancesItemMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&CodeScanningAlertReopenedAlertInstancesItemMessage>
    for CodeScanningAlertReopenedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedAlertInstancesItemState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
}
impl From<&CodeScanningAlertReopenedAlertInstancesItemState>
    for CodeScanningAlertReopenedAlertInstancesItemState
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAlertInstancesItemState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertInstancesItemState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertReopenedAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"full_description\": {\n      \"type\": \"string\"\n    },\n    \"help\": {\n      \"type\": \"null\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    },\n    \"tags\": {\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertReopenedAlertRule> for CodeScanningAlertReopenedAlertRule {
    fn from(value: &CodeScanningAlertReopenedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertReopenedAlertRuleSeverity>
    for CodeScanningAlertReopenedAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertReopenedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"dismissed\",\n    \"fixed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertReopenedAlertState> for CodeScanningAlertReopenedAlertState {
    fn from(value: &CodeScanningAlertReopenedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertReopenedAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"guid\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedAlertTool> for CodeScanningAlertReopenedAlertTool {
    fn from(value: &CodeScanningAlertReopenedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUser"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"code_scanning_alert reopened_by_user event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"commit_oid\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened_by_user\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The code scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"dismissed_at\",\n        \"dismissed_by\",\n        \"dismissed_reason\",\n        \"html_url\",\n        \"instances\",\n        \"number\",\n        \"rule\",\n        \"state\",\n        \"tool\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"dismissed_at\": {\n          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n          \"type\": \"null\"\n        },\n        \"dismissed_by\": {\n          \"type\": \"null\"\n        },\n        \"dismissed_reason\": {\n          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n          \"type\": \"null\"\n        },\n        \"html_url\": {\n          \"description\": \"The GitHub URL of the alert resource.\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"instances\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [\n              {\n                \"$ref\": \"#/definitions/alert-instance\"\n              },\n              {\n                \"type\": \"object\",\n                \"required\": [\n                  \"state\"\n                ],\n                \"properties\": {\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"open\"\n                    ]\n                  }\n                },\n                \"tsAdditionalProperties\": false\n              }\n            ]\n          }\n        },\n        \"most_recent_instance\": {\n          \"$ref\": \"#/definitions/alert-instance\"\n        },\n        \"number\": {\n          \"description\": \"The code scanning alert number.\",\n          \"type\": \"integer\"\n        },\n        \"rule\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"description\",\n            \"id\",\n            \"severity\"\n          ],\n          \"properties\": {\n            \"description\": {\n              \"description\": \"A short description of the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"description\": \"A unique identifier for the rule used to detect the alert.\",\n              \"type\": \"string\"\n            },\n            \"severity\": {\n              \"description\": \"The severity of the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"none\",\n                \"note\",\n                \"warning\",\n                \"error\",\n                null\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"state\": {\n          \"description\": \"State of a code scanning alert.\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\"\n          ]\n        },\n        \"tool\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"name\": {\n              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"description\": \"The version of the tool used to detect the alert.\",\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"commit_oid\": {\n      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUser {
    pub action: CodeScanningAlertReopenedByUserAction,
    pub alert: CodeScanningAlertReopenedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CodeScanningAlertReopenedByUser> for CodeScanningAlertReopenedByUser {
    fn from(value: &CodeScanningAlertReopenedByUser) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened_by_user\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAction {
    #[serde(rename = "reopened_by_user")]
    ReopenedByUser,
}
impl From<&CodeScanningAlertReopenedByUserAction> for CodeScanningAlertReopenedByUserAction {
    fn from(value: &CodeScanningAlertReopenedByUserAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReopenedByUser => "reopened_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened_by_user" => Ok(Self::ReopenedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The code scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"dismissed_at\",\n    \"dismissed_by\",\n    \"dismissed_reason\",\n    \"html_url\",\n    \"instances\",\n    \"number\",\n    \"rule\",\n    \"state\",\n    \"tool\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\",\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"dismissed_at\": {\n      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\",\n      \"type\": \"null\"\n    },\n    \"dismissed_by\": {\n      \"type\": \"null\"\n    },\n    \"dismissed_reason\": {\n      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\",\n      \"type\": \"null\"\n    },\n    \"html_url\": {\n      \"description\": \"The GitHub URL of the alert resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"instances\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [\n          {\n            \"$ref\": \"#/definitions/alert-instance\"\n          },\n          {\n            \"type\": \"object\",\n            \"required\": [\n              \"state\"\n            ],\n            \"properties\": {\n              \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"open\"\n                ]\n              }\n            },\n            \"tsAdditionalProperties\": false\n          }\n        ]\n      }\n    },\n    \"most_recent_instance\": {\n      \"$ref\": \"#/definitions/alert-instance\"\n    },\n    \"number\": {\n      \"description\": \"The code scanning alert number.\",\n      \"type\": \"integer\"\n    },\n    \"rule\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"description\",\n        \"id\",\n        \"severity\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"A short description of the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"description\": \"A unique identifier for the rule used to detect the alert.\",\n          \"type\": \"string\"\n        },\n        \"severity\": {\n          \"description\": \"The severity of the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"none\",\n            \"note\",\n            \"warning\",\n            \"error\",\n            null\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"state\": {\n      \"description\": \"State of a code scanning alert.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"The version of the tool used to detect the alert.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<CodeScanningAlertReopenedByUserAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedByUserAlertState,
    pub tool: CodeScanningAlertReopenedByUserAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertReopenedByUserAlert> for CodeScanningAlertReopenedByUserAlert {
    fn from(value: &CodeScanningAlertReopenedByUserAlert) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertInstancesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"analysis_key\",\n    \"environment\",\n    \"ref\",\n    \"state\"\n  ],\n  \"properties\": {\n    \"analysis_key\": {\n      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\",\n      \"type\": \"string\"\n    },\n    \"classifications\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"commit_sha\": {\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\",\n      \"type\": \"string\"\n    },\n    \"location\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"end_column\": {\n          \"type\": \"integer\"\n        },\n        \"end_line\": {\n          \"type\": \"integer\"\n        },\n        \"path\": {\n          \"type\": \"string\"\n        },\n        \"start_column\": {\n          \"type\": \"integer\"\n        },\n        \"start_line\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"message\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"text\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"ref\": {\n      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<CodeScanningAlertReopenedByUserAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<CodeScanningAlertReopenedByUserAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub state: CodeScanningAlertReopenedByUserAlertInstancesItemState,
}
impl From<&CodeScanningAlertReopenedByUserAlertInstancesItem>
    for CodeScanningAlertReopenedByUserAlertInstancesItem
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertInstancesItemLocation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"end_column\": {\n      \"type\": \"integer\"\n    },\n    \"end_line\": {\n      \"type\": \"integer\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"start_column\": {\n      \"type\": \"integer\"\n    },\n    \"start_line\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&CodeScanningAlertReopenedByUserAlertInstancesItemLocation>
    for CodeScanningAlertReopenedByUserAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertInstancesItemMessage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"text\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&CodeScanningAlertReopenedByUserAlertInstancesItemMessage>
    for CodeScanningAlertReopenedByUserAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertInstancesItemState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
}
impl From<&CodeScanningAlertReopenedByUserAlertInstancesItemState>
    for CodeScanningAlertReopenedByUserAlertInstancesItemState
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertRule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"id\",\n    \"severity\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"A short description of the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"A unique identifier for the rule used to detect the alert.\",\n      \"type\": \"string\"\n    },\n    \"severity\": {\n      \"description\": \"The severity of the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"none\",\n        \"note\",\n        \"warning\",\n        \"error\",\n        null\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedByUserAlertRuleSeverity>,
}
impl From<&CodeScanningAlertReopenedByUserAlertRule> for CodeScanningAlertReopenedByUserAlertRule {
    fn from(value: &CodeScanningAlertReopenedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The severity of the alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"none\",\n    \"note\",\n    \"warning\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertReopenedByUserAlertRuleSeverity>
    for CodeScanningAlertReopenedByUserAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of a code scanning alert.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertState {
    #[serde(rename = "open")]
    Open,
}
impl From<&CodeScanningAlertReopenedByUserAlertState>
    for CodeScanningAlertReopenedByUserAlertState
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "CodeScanningAlertReopenedByUserAlertTool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"name\": {\n      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\",\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"description\": \"The version of the tool used to detect the alert.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedByUserAlertTool> for CodeScanningAlertReopenedByUserAlertTool {
    fn from(value: &CodeScanningAlertReopenedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "Commit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Commit\",\n  \"type\": \"object\",\n  \"required\": [\n    \"added\",\n    \"author\",\n    \"committer\",\n    \"distinct\",\n    \"id\",\n    \"message\",\n    \"modified\",\n    \"removed\",\n    \"timestamp\",\n    \"tree_id\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"added\": {\n      \"description\": \"An array of files added in the commit.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"author\": {\n      \"$ref\": \"#/definitions/committer\"\n    },\n    \"committer\": {\n      \"$ref\": \"#/definitions/committer\"\n    },\n    \"distinct\": {\n      \"description\": \"Whether this commit is distinct from any that have been pushed before.\",\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"string\"\n    },\n    \"message\": {\n      \"description\": \"The commit message.\",\n      \"type\": \"string\"\n    },\n    \"modified\": {\n      \"description\": \"An array of files modified by the commit.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"removed\": {\n      \"description\": \"An array of files removed in the commit.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"timestamp\": {\n      \"description\": \"The ISO 8601 timestamp of the commit.\",\n      \"type\": \"string\"\n    },\n    \"tree_id\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"description\": \"URL that points to the commit API resource.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Commit {
    #[doc = "An array of files added in the commit."]
    pub added: Vec<String>,
    pub author: Committer,
    pub committer: Committer,
    #[doc = "Whether this commit is distinct from any that have been pushed before."]
    pub distinct: bool,
    pub id: String,
    #[doc = "The commit message."]
    pub message: String,
    #[doc = "An array of files modified by the commit."]
    pub modified: Vec<String>,
    #[doc = "An array of files removed in the commit."]
    pub removed: Vec<String>,
    #[doc = "The ISO 8601 timestamp of the commit."]
    pub timestamp: String,
    pub tree_id: String,
    #[doc = "URL that points to the commit API resource."]
    pub url: String,
}
impl From<&Commit> for Commit {
    fn from(value: &Commit) -> Self {
        value.clone()
    }
}
#[doc = "A commit comment is created. The type of activity is specified in the `action` property. "]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"commit_comment created event\",\n  \"description\": \"A commit comment is created. The type of activity is specified in the `action` property. \",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"description\": \"The action performed. Can be `created`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"comment\": {\n      \"description\": \"The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"commit_id\",\n        \"created_at\",\n        \"html_url\",\n        \"id\",\n        \"line\",\n        \"node_id\",\n        \"path\",\n        \"position\",\n        \"updated_at\",\n        \"url\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"description\": \"The text of the comment.\",\n          \"type\": \"string\"\n        },\n        \"commit_id\": {\n          \"description\": \"The SHA of the commit to which the comment applies.\",\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"The ID of the commit comment.\",\n          \"type\": \"integer\"\n        },\n        \"line\": {\n          \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\",\n          \"type\": [\n            \"integer\",\n            \"null\"\n          ]\n        },\n        \"node_id\": {\n          \"description\": \"The node ID of the commit comment.\",\n          \"type\": \"string\"\n        },\n        \"path\": {\n          \"description\": \"The relative path of the file to which the comment applies.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"position\": {\n          \"description\": \"The line index in the diff to which the comment applies.\",\n          \"type\": [\n            \"integer\",\n            \"null\"\n          ]\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreated {
    #[doc = "The action performed. Can be `created`."]
    pub action: CommitCommentCreatedAction,
    pub comment: CommitCommentCreatedComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CommitCommentCreated> for CommitCommentCreated {
    fn from(value: &CommitCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "The action performed. Can be `created`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action performed. Can be `created`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CommitCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CommitCommentCreatedAction> for CommitCommentCreatedAction {
    fn from(value: &CommitCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CommitCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CommitCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"commit_id\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"line\",\n    \"node_id\",\n    \"path\",\n    \"position\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"The text of the comment.\",\n      \"type\": \"string\"\n    },\n    \"commit_id\": {\n      \"description\": \"The SHA of the commit to which the comment applies.\",\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The ID of the commit comment.\",\n      \"type\": \"integer\"\n    },\n    \"line\": {\n      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"node_id\": {\n      \"description\": \"The node ID of the commit comment.\",\n      \"type\": \"string\"\n    },\n    \"path\": {\n      \"description\": \"The relative path of the file to which the comment applies.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"position\": {\n      \"description\": \"The line index in the diff to which the comment applies.\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreatedComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: String,
    pub html_url: String,
    #[doc = "The ID of the commit comment."]
    pub id: i64,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[doc = "The node ID of the commit comment."]
    pub node_id: String,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: Option<String>,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&CommitCommentCreatedComment> for CommitCommentCreatedComment {
    fn from(value: &CommitCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[doc = "CommitCommentEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/commit_comment$created\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CommitCommentEvent(pub CommitCommentCreated);
impl std::ops::Deref for CommitCommentEvent {
    type Target = CommitCommentCreated;
    fn deref(&self) -> &CommitCommentCreated {
        &self.0
    }
}
impl From<CommitCommentEvent> for CommitCommentCreated {
    fn from(value: CommitCommentEvent) -> Self {
        value.0
    }
}
impl From<&CommitCommentEvent> for CommitCommentEvent {
    fn from(value: &CommitCommentEvent) -> Self {
        value.clone()
    }
}
impl From<CommitCommentCreated> for CommitCommentEvent {
    fn from(value: CommitCommentCreated) -> Self {
        Self(value)
    }
}
#[doc = "CommitSimple"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"SimpleCommit\",\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"committer\",\n    \"id\",\n    \"message\",\n    \"timestamp\",\n    \"tree_id\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"$ref\": \"#/definitions/committer\"\n    },\n    \"committer\": {\n      \"$ref\": \"#/definitions/committer\"\n    },\n    \"id\": {\n      \"type\": \"string\"\n    },\n    \"message\": {\n      \"type\": \"string\"\n    },\n    \"timestamp\": {\n      \"type\": \"string\"\n    },\n    \"tree_id\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitSimple {
    pub author: Committer,
    pub committer: Committer,
    pub id: String,
    pub message: String,
    pub timestamp: String,
    pub tree_id: String,
}
impl From<&CommitSimple> for CommitSimple {
    fn from(value: &CommitSimple) -> Self {
        value.clone()
    }
}
#[doc = "Metaproperties for Git author/committer information."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Committer\",\n  \"description\": \"Metaproperties for Git author/committer information.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"email\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"date\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"email\": {\n      \"description\": \"The git author's email address.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"name\": {\n      \"description\": \"The git author's name.\",\n      \"type\": \"string\"\n    },\n    \"username\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Committer {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The git author's email address."]
    pub email: Option<String>,
    #[doc = "The git author's name."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}
impl From<&Committer> for Committer {
    fn from(value: &Committer) -> Self {
        value.clone()
    }
}
#[doc = "ContentReferenceCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"content_reference created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"content_reference\",\n    \"installation\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"content_reference\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"node_id\",\n        \"reference\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"reference\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreated {
    pub action: ContentReferenceCreatedAction,
    pub content_reference: ContentReferenceCreatedContentReference,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ContentReferenceCreated> for ContentReferenceCreated {
    fn from(value: &ContentReferenceCreated) -> Self {
        value.clone()
    }
}
#[doc = "ContentReferenceCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ContentReferenceCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ContentReferenceCreatedAction> for ContentReferenceCreatedAction {
    fn from(value: &ContentReferenceCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ContentReferenceCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ContentReferenceCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ContentReferenceCreatedContentReference"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"node_id\",\n    \"reference\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"reference\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreatedContentReference {
    pub id: i64,
    pub node_id: String,
    pub reference: String,
}
impl From<&ContentReferenceCreatedContentReference> for ContentReferenceCreatedContentReference {
    fn from(value: &ContentReferenceCreatedContentReference) -> Self {
        value.clone()
    }
}
#[doc = "ContentReferenceEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/content_reference$created\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ContentReferenceEvent(pub ContentReferenceCreated);
impl std::ops::Deref for ContentReferenceEvent {
    type Target = ContentReferenceCreated;
    fn deref(&self) -> &ContentReferenceCreated {
        &self.0
    }
}
impl From<ContentReferenceEvent> for ContentReferenceCreated {
    fn from(value: ContentReferenceEvent) -> Self {
        value.0
    }
}
impl From<&ContentReferenceEvent> for ContentReferenceEvent {
    fn from(value: &ContentReferenceEvent) -> Self {
        value.clone()
    }
}
impl From<ContentReferenceCreated> for ContentReferenceEvent {
    fn from(value: ContentReferenceCreated) -> Self {
        Self(value)
    }
}
#[doc = "A Git branch or tag is created."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"create event\",\n  \"description\": \"A Git branch or tag is created.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"master_branch\",\n    \"pusher_type\",\n    \"ref\",\n    \"ref_type\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"The repository's current description.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"master_branch\": {\n      \"description\": \"The name of the repository's default branch (usually `main`).\",\n      \"type\": \"string\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pusher_type\": {\n      \"description\": \"The pusher type for the event. Can be either `user` or a deploy key.\",\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"description\": \"The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.\",\n      \"type\": \"string\"\n    },\n    \"ref_type\": {\n      \"description\": \"The type of Git ref object created in the repository. Can be either `branch` or `tag`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"tag\",\n        \"branch\"\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CreateEvent {
    #[doc = "The repository's current description."]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The name of the repository's default branch (usually `main`)."]
    pub master_branch: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
    pub ref_type: CreateEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CreateEvent> for CreateEvent {
    fn from(value: &CreateEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The type of Git ref object created in the repository. Can be either `branch` or `tag`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"tag\",\n    \"branch\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CreateEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl From<&CreateEventRefType> for CreateEventRefType {
    fn from(value: &CreateEventRefType) -> Self {
        value.clone()
    }
}
impl ToString for CreateEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for CreateEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "A Git branch or tag is deleted."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"delete event\",\n  \"description\": \"A Git branch or tag is deleted.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"pusher_type\",\n    \"ref\",\n    \"ref_type\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pusher_type\": {\n      \"description\": \"The pusher type for the event. Can be either `user` or a deploy key.\",\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"description\": \"The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.\",\n      \"type\": \"string\"\n    },\n    \"ref_type\": {\n      \"description\": \"The type of Git ref object deleted in the repository. Can be either `branch` or `tag`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"tag\",\n        \"branch\"\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeleteEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
    pub ref_type: DeleteEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeleteEvent> for DeleteEvent {
    fn from(value: &DeleteEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The type of Git ref object deleted in the repository. Can be either `branch` or `tag`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"tag\",\n    \"branch\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeleteEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl From<&DeleteEventRefType> for DeleteEventRefType {
    fn from(value: &DeleteEventRefType) -> Self {
        value.clone()
    }
}
impl ToString for DeleteEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for DeleteEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DeployKeyCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"deploy_key created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"key\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"key\": {\n      \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"id\",\n        \"key\",\n        \"read_only\",\n        \"title\",\n        \"url\",\n        \"verified\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"key\": {\n          \"type\": \"string\"\n        },\n        \"read_only\": {\n          \"type\": \"boolean\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"verified\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreated {
    pub action: DeployKeyCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyCreatedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeployKeyCreated> for DeployKeyCreated {
    fn from(value: &DeployKeyCreated) -> Self {
        value.clone()
    }
}
#[doc = "DeployKeyCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeployKeyCreatedAction> for DeployKeyCreatedAction {
    fn from(value: &DeployKeyCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeployKeyCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"id\",\n    \"key\",\n    \"read_only\",\n    \"title\",\n    \"url\",\n    \"verified\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"key\": {\n      \"type\": \"string\"\n    },\n    \"read_only\": {\n      \"type\": \"boolean\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"verified\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreatedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
impl From<&DeployKeyCreatedKey> for DeployKeyCreatedKey {
    fn from(value: &DeployKeyCreatedKey) -> Self {
        value.clone()
    }
}
#[doc = "DeployKeyDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"deploy_key deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"key\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"key\": {\n      \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"id\",\n        \"key\",\n        \"read_only\",\n        \"title\",\n        \"url\",\n        \"verified\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"key\": {\n          \"type\": \"string\"\n        },\n        \"read_only\": {\n          \"type\": \"boolean\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"verified\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeleted {
    pub action: DeployKeyDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyDeletedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeployKeyDeleted> for DeployKeyDeleted {
    fn from(value: &DeployKeyDeleted) -> Self {
        value.clone()
    }
}
#[doc = "DeployKeyDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DeployKeyDeletedAction> for DeployKeyDeletedAction {
    fn from(value: &DeployKeyDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeployKeyDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"id\",\n    \"key\",\n    \"read_only\",\n    \"title\",\n    \"url\",\n    \"verified\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"key\": {\n      \"type\": \"string\"\n    },\n    \"read_only\": {\n      \"type\": \"boolean\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"verified\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeletedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
impl From<&DeployKeyDeletedKey> for DeployKeyDeletedKey {
    fn from(value: &DeployKeyDeletedKey) -> Self {
        value.clone()
    }
}
#[doc = "DeployKeyEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/deploy_key$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/deploy_key$deleted\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DeployKeyEvent {
    Created(DeployKeyCreated),
    Deleted(DeployKeyDeleted),
}
impl From<&DeployKeyEvent> for DeployKeyEvent {
    fn from(value: &DeployKeyEvent) -> Self {
        value.clone()
    }
}
impl From<DeployKeyCreated> for DeployKeyEvent {
    fn from(value: DeployKeyCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DeployKeyDeleted> for DeployKeyEvent {
    fn from(value: DeployKeyDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[doc = "DeploymentCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"deployment created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"deployment\",\n    \"repository\",\n    \"sender\",\n    \"workflow\",\n    \"workflow_run\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"deployment\": {\n      \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"creator\",\n        \"description\",\n        \"environment\",\n        \"id\",\n        \"node_id\",\n        \"original_environment\",\n        \"payload\",\n        \"ref\",\n        \"repository_url\",\n        \"sha\",\n        \"statuses_url\",\n        \"task\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"creator\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"description\": {\n          \"type\": \"null\"\n        },\n        \"environment\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"original_environment\": {\n          \"type\": \"string\"\n        },\n        \"payload\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false\n        },\n        \"performed_via_github_app\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/app\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repository_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"statuses_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"task\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow\": {\n      \"type\": \"null\"\n    },\n    \"workflow_run\": {\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreated {
    pub action: DeploymentCreatedAction,
    pub deployment: DeploymentCreatedDeployment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: (),
    pub workflow_run: (),
}
impl From<&DeploymentCreated> for DeploymentCreated {
    fn from(value: &DeploymentCreated) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeploymentCreatedAction> for DeploymentCreatedAction {
    fn from(value: &DeploymentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeploymentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"environment\",\n    \"id\",\n    \"node_id\",\n    \"original_environment\",\n    \"payload\",\n    \"ref\",\n    \"repository_url\",\n    \"sha\",\n    \"statuses_url\",\n    \"task\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": \"null\"\n    },\n    \"environment\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"original_environment\": {\n      \"type\": \"string\"\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"task\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentCreatedDeploymentPayload,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentCreatedDeployment> for DeploymentCreatedDeployment {
    fn from(value: &DeploymentCreatedDeployment) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentCreatedDeploymentPayload"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeploymentPayload {}
impl From<&DeploymentCreatedDeploymentPayload> for DeploymentCreatedDeploymentPayload {
    fn from(value: &DeploymentCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/deployment$created\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentEvent(pub DeploymentCreated);
impl std::ops::Deref for DeploymentEvent {
    type Target = DeploymentCreated;
    fn deref(&self) -> &DeploymentCreated {
        &self.0
    }
}
impl From<DeploymentEvent> for DeploymentCreated {
    fn from(value: DeploymentEvent) -> Self {
        value.0
    }
}
impl From<&DeploymentEvent> for DeploymentEvent {
    fn from(value: &DeploymentEvent) -> Self {
        value.clone()
    }
}
impl From<DeploymentCreated> for DeploymentEvent {
    fn from(value: DeploymentCreated) -> Self {
        Self(value)
    }
}
#[doc = "DeploymentStatusCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"deployment_status created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"deployment\",\n    \"deployment_status\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"deployment\": {\n      \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"creator\",\n        \"description\",\n        \"environment\",\n        \"id\",\n        \"node_id\",\n        \"original_environment\",\n        \"payload\",\n        \"performed_via_github_app\",\n        \"ref\",\n        \"repository_url\",\n        \"sha\",\n        \"statuses_url\",\n        \"task\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"creator\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"description\": {\n          \"type\": \"null\"\n        },\n        \"environment\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"original_environment\": {\n          \"type\": \"string\"\n        },\n        \"payload\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false\n        },\n        \"performed_via_github_app\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/app\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repository_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"statuses_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"task\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"deployment_status\": {\n      \"description\": \"The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"creator\",\n        \"deployment_url\",\n        \"description\",\n        \"environment\",\n        \"id\",\n        \"node_id\",\n        \"repository_url\",\n        \"state\",\n        \"target_url\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"creator\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"deployment_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"description\": {\n          \"description\": \"The optional human-readable description added to the status.\",\n          \"type\": \"string\"\n        },\n        \"environment\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"performed_via_github_app\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/app\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"repository_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\",\n          \"type\": \"string\"\n        },\n        \"target_url\": {\n          \"description\": \"The optional link added to the status.\",\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreated {
    pub action: DeploymentStatusCreatedAction,
    pub deployment: DeploymentStatusCreatedDeployment,
    pub deployment_status: DeploymentStatusCreatedDeploymentStatus,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeploymentStatusCreated> for DeploymentStatusCreated {
    fn from(value: &DeploymentStatusCreated) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentStatusCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeploymentStatusCreatedAction> for DeploymentStatusCreatedAction {
    fn from(value: &DeploymentStatusCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeploymentStatusCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentStatusCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"environment\",\n    \"id\",\n    \"node_id\",\n    \"original_environment\",\n    \"payload\",\n    \"performed_via_github_app\",\n    \"ref\",\n    \"repository_url\",\n    \"sha\",\n    \"statuses_url\",\n    \"task\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": \"null\"\n    },\n    \"environment\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"original_environment\": {\n      \"type\": \"string\"\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"task\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentStatusCreatedDeploymentPayload,
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentStatusCreatedDeployment> for DeploymentStatusCreatedDeployment {
    fn from(value: &DeploymentStatusCreatedDeployment) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentStatusCreatedDeploymentPayload"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentPayload {}
impl From<&DeploymentStatusCreatedDeploymentPayload> for DeploymentStatusCreatedDeploymentPayload {
    fn from(value: &DeploymentStatusCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
#[doc = "The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"creator\",\n    \"deployment_url\",\n    \"description\",\n    \"environment\",\n    \"id\",\n    \"node_id\",\n    \"repository_url\",\n    \"state\",\n    \"target_url\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"deployment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"description\": \"The optional human-readable description added to the status.\",\n      \"type\": \"string\"\n    },\n    \"environment\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\",\n      \"type\": \"string\"\n    },\n    \"target_url\": {\n      \"description\": \"The optional link added to the status.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentStatus {
    pub created_at: String,
    pub creator: User,
    pub deployment_url: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: String,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    pub repository_url: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: String,
    #[doc = "The optional link added to the status."]
    pub target_url: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentStatusCreatedDeploymentStatus> for DeploymentStatusCreatedDeploymentStatus {
    fn from(value: &DeploymentStatusCreatedDeploymentStatus) -> Self {
        value.clone()
    }
}
#[doc = "DeploymentStatusEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/deployment_status$created\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentStatusEvent(pub DeploymentStatusCreated);
impl std::ops::Deref for DeploymentStatusEvent {
    type Target = DeploymentStatusCreated;
    fn deref(&self) -> &DeploymentStatusCreated {
        &self.0
    }
}
impl From<DeploymentStatusEvent> for DeploymentStatusCreated {
    fn from(value: DeploymentStatusEvent) -> Self {
        value.0
    }
}
impl From<&DeploymentStatusEvent> for DeploymentStatusEvent {
    fn from(value: &DeploymentStatusEvent) -> Self {
        value.clone()
    }
}
impl From<DeploymentStatusCreated> for DeploymentStatusEvent {
    fn from(value: DeploymentStatusCreated) -> Self {
        Self(value)
    }
}
#[doc = "Discussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Discussion\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"answer_html_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"locked\",\n        \"converting\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Discussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: Option<String>,
    pub answer_chosen_by: Option<User>,
    pub answer_html_url: Option<String>,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&Discussion> for Discussion {
    fn from(value: &Discussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnswered"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion answered event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"answer\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"answered\"\n      ]\n    },\n    \"answer\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"child_comment_count\",\n        \"created_at\",\n        \"discussion_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"parent_id\",\n        \"repository_url\",\n        \"updated_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"child_comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"discussion_id\": {\n          \"type\": \"integer\"\n        },\n        \"html_url\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parent_id\": {\n          \"type\": \"null\"\n        },\n        \"repository_url\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"answer_chosen_at\",\n            \"answer_chosen_by\",\n            \"answer_html_url\",\n            \"category\"\n          ],\n          \"properties\": {\n            \"answer_chosen_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"answer_chosen_by\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"answer_html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"category\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"is_answerable\"\n              ],\n              \"properties\": {\n                \"is_answerable\": {\n                  \"type\": \"boolean\",\n                  \"enum\": [\n                    true\n                  ]\n                }\n              },\n              \"tsAdditionalProperties\": false\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnswered {
    pub action: DiscussionAnsweredAction,
    pub answer: DiscussionAnsweredAnswer,
    pub discussion: DiscussionAnsweredDiscussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionAnswered> for DiscussionAnswered {
    fn from(value: &DiscussionAnswered) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnsweredAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"answered\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionAnsweredAction {
    #[serde(rename = "answered")]
    Answered,
}
impl From<&DiscussionAnsweredAction> for DiscussionAnsweredAction {
    fn from(value: &DiscussionAnsweredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionAnsweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Answered => "answered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionAnsweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "answered" => Ok(Self::Answered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionAnsweredAnswer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"child_comment_count\",\n    \"created_at\",\n    \"discussion_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"parent_id\",\n    \"repository_url\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"child_comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"discussion_id\": {\n      \"type\": \"integer\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent_id\": {\n      \"type\": \"null\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionAnsweredAnswer> for DiscussionAnsweredAnswer {
    fn from(value: &DiscussionAnsweredAnswer) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnsweredDiscussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"answer_chosen_by\": {\n      \"allOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"avatar_url\",\n            \"events_url\",\n            \"followers_url\",\n            \"following_url\",\n            \"gists_url\",\n            \"gravatar_id\",\n            \"html_url\",\n            \"id\",\n            \"login\",\n            \"node_id\",\n            \"organizations_url\",\n            \"received_events_url\",\n            \"repos_url\",\n            \"site_admin\",\n            \"starred_url\",\n            \"subscriptions_url\",\n            \"type\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"avatar_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"email\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"events_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"followers_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"following_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"gists_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"gravatar_id\": {\n              \"type\": \"string\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"login\": {\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"organizations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"received_events_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"repos_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"site_admin\": {\n              \"type\": \"boolean\"\n            },\n            \"starred_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"subscriptions_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"type\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"Bot\",\n                \"User\",\n                \"Organization\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"$ref\": \"#/definitions/user\"\n        }\n      ]\n    },\n    \"answer_html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\",\n          \"enum\": [\n            true\n          ]\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"locked\",\n        \"converting\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: chrono::DateTime<chrono::offset::Utc>,
    pub answer_chosen_by: DiscussionAnsweredDiscussionAnswerChosenBy,
    pub answer_html_url: String,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionAnsweredDiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionAnsweredDiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionAnsweredDiscussion> for DiscussionAnsweredDiscussion {
    fn from(value: &DiscussionAnsweredDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnsweredDiscussionAnswerChosenBy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussionAnswerChosenBy {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: DiscussionAnsweredDiscussionAnswerChosenByType,
    pub url: String,
}
impl From<&DiscussionAnsweredDiscussionAnswerChosenBy>
    for DiscussionAnsweredDiscussionAnswerChosenBy
{
    fn from(value: &DiscussionAnsweredDiscussionAnswerChosenBy) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnsweredDiscussionAnswerChosenByType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionAnsweredDiscussionAnswerChosenByType {
    Bot,
    User,
    Organization,
}
impl From<&DiscussionAnsweredDiscussionAnswerChosenByType>
    for DiscussionAnsweredDiscussionAnswerChosenByType
{
    fn from(value: &DiscussionAnsweredDiscussionAnswerChosenByType) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionAnsweredDiscussionAnswerChosenByType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionAnsweredDiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionAnsweredDiscussionCategory> for DiscussionAnsweredDiscussionCategory {
    fn from(value: &DiscussionAnsweredDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionAnsweredDiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"locked\",\n    \"converting\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionAnsweredDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl From<&DiscussionAnsweredDiscussionState> for DiscussionAnsweredDiscussionState {
    fn from(value: &DiscussionAnsweredDiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionAnsweredDiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Locked => "locked".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionAnsweredDiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionAnsweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionCategory> for DiscussionCategory {
    fn from(value: &DiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCategoryChanged"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion category changed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"category_changed\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"category\"\n      ],\n      \"properties\": {\n        \"category\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"created_at\",\n                \"description\",\n                \"emoji\",\n                \"id\",\n                \"is_answerable\",\n                \"name\",\n                \"repository_id\",\n                \"slug\",\n                \"updated_at\"\n              ],\n              \"properties\": {\n                \"created_at\": {\n                  \"type\": \"string\",\n                  \"format\": \"date-time\"\n                },\n                \"description\": {\n                  \"type\": \"string\"\n                },\n                \"emoji\": {\n                  \"type\": \"string\"\n                },\n                \"id\": {\n                  \"type\": \"integer\"\n                },\n                \"is_answerable\": {\n                  \"type\": \"boolean\"\n                },\n                \"name\": {\n                  \"type\": \"string\"\n                },\n                \"repository_id\": {\n                  \"type\": \"integer\"\n                },\n                \"slug\": {\n                  \"type\": \"string\"\n                },\n                \"updated_at\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChanged {
    pub action: DiscussionCategoryChangedAction,
    pub changes: DiscussionCategoryChangedChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCategoryChanged> for DiscussionCategoryChanged {
    fn from(value: &DiscussionCategoryChanged) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCategoryChangedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"category_changed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCategoryChangedAction {
    #[serde(rename = "category_changed")]
    CategoryChanged,
}
impl From<&DiscussionCategoryChangedAction> for DiscussionCategoryChangedAction {
    fn from(value: &DiscussionCategoryChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCategoryChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::CategoryChanged => "category_changed".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCategoryChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "category_changed" => Ok(Self::CategoryChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCategoryChangedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"category\"\n  ],\n  \"properties\": {\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"created_at\",\n            \"description\",\n            \"emoji\",\n            \"id\",\n            \"is_answerable\",\n            \"name\",\n            \"repository_id\",\n            \"slug\",\n            \"updated_at\"\n          ],\n          \"properties\": {\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"description\": {\n              \"type\": \"string\"\n            },\n            \"emoji\": {\n              \"type\": \"string\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"is_answerable\": {\n              \"type\": \"boolean\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"repository_id\": {\n              \"type\": \"integer\"\n            },\n            \"slug\": {\n              \"type\": \"string\"\n            },\n            \"updated_at\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChanges {
    pub category: DiscussionCategoryChangedChangesCategory,
}
impl From<&DiscussionCategoryChangedChanges> for DiscussionCategoryChangedChanges {
    fn from(value: &DiscussionCategoryChangedChanges) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCategoryChangedChangesCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategory {
    pub from: DiscussionCategoryChangedChangesCategoryFrom,
}
impl From<&DiscussionCategoryChangedChangesCategory> for DiscussionCategoryChangedChangesCategory {
    fn from(value: &DiscussionCategoryChangedChangesCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCategoryChangedChangesCategoryFrom"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategoryFrom {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionCategoryChangedChangesCategoryFrom>
    for DiscussionCategoryChangedChangesCategoryFrom
{
    fn from(value: &DiscussionCategoryChangedChangesCategoryFrom) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion_comment created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"discussion\",\n    \"installation\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"comment\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"child_comment_count\",\n        \"created_at\",\n        \"discussion_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"parent_id\",\n        \"repository_url\",\n        \"updated_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"child_comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"discussion_id\": {\n          \"type\": \"integer\"\n        },\n        \"html_url\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parent_id\": {\n          \"type\": [\n            \"integer\",\n            \"null\"\n          ]\n        },\n        \"repository_url\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreated {
    pub action: DiscussionCommentCreatedAction,
    pub comment: DiscussionCommentCreatedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentCreated> for DiscussionCommentCreated {
    fn from(value: &DiscussionCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DiscussionCommentCreatedAction> for DiscussionCommentCreatedAction {
    fn from(value: &DiscussionCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCommentCreatedComment"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"child_comment_count\",\n    \"created_at\",\n    \"discussion_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"parent_id\",\n    \"repository_url\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"child_comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"discussion_id\": {\n      \"type\": \"integer\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent_id\": {\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreatedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentCreatedComment> for DiscussionCommentCreatedComment {
    fn from(value: &DiscussionCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion_comment deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"discussion\",\n    \"installation\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"comment\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"child_comment_count\",\n        \"created_at\",\n        \"discussion_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"parent_id\",\n        \"repository_url\",\n        \"updated_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"child_comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"discussion_id\": {\n          \"type\": \"integer\"\n        },\n        \"html_url\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parent_id\": {\n          \"type\": [\n            \"integer\",\n            \"null\"\n          ]\n        },\n        \"repository_url\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeleted {
    pub action: DiscussionCommentDeletedAction,
    pub comment: DiscussionCommentDeletedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentDeleted> for DiscussionCommentDeleted {
    fn from(value: &DiscussionCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DiscussionCommentDeletedAction> for DiscussionCommentDeletedAction {
    fn from(value: &DiscussionCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCommentDeletedComment"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"child_comment_count\",\n    \"created_at\",\n    \"discussion_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"parent_id\",\n    \"repository_url\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"child_comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"discussion_id\": {\n      \"type\": \"integer\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent_id\": {\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeletedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentDeletedComment> for DiscussionCommentDeletedComment {
    fn from(value: &DiscussionCommentDeletedComment) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion_comment edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"comment\",\n    \"discussion\",\n    \"installation\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"body\"\n      ],\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comment\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"child_comment_count\",\n        \"created_at\",\n        \"discussion_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"parent_id\",\n        \"repository_url\",\n        \"updated_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"child_comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"discussion_id\": {\n          \"type\": \"integer\"\n        },\n        \"html_url\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parent_id\": {\n          \"type\": [\n            \"integer\",\n            \"null\"\n          ]\n        },\n        \"repository_url\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEdited {
    pub action: DiscussionCommentEditedAction,
    pub changes: DiscussionCommentEditedChanges,
    pub comment: DiscussionCommentEditedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentEdited> for DiscussionCommentEdited {
    fn from(value: &DiscussionCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&DiscussionCommentEditedAction> for DiscussionCommentEditedAction {
    fn from(value: &DiscussionCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCommentEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"body\"\n  ],\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChanges {
    pub body: DiscussionCommentEditedChangesBody,
}
impl From<&DiscussionCommentEditedChanges> for DiscussionCommentEditedChanges {
    fn from(value: &DiscussionCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChangesBody {
    pub from: String,
}
impl From<&DiscussionCommentEditedChangesBody> for DiscussionCommentEditedChangesBody {
    fn from(value: &DiscussionCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentEditedComment"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"child_comment_count\",\n    \"created_at\",\n    \"discussion_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"parent_id\",\n    \"repository_url\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"child_comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"discussion_id\": {\n      \"type\": \"integer\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent_id\": {\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentEditedComment> for DiscussionCommentEditedComment {
    fn from(value: &DiscussionCommentEditedComment) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCommentEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/discussion_comment$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion_comment$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion_comment$edited\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionCommentEvent {
    Created(DiscussionCommentCreated),
    Deleted(DiscussionCommentDeleted),
    Edited(DiscussionCommentEdited),
}
impl From<&DiscussionCommentEvent> for DiscussionCommentEvent {
    fn from(value: &DiscussionCommentEvent) -> Self {
        value.clone()
    }
}
impl From<DiscussionCommentCreated> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DiscussionCommentDeleted> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<DiscussionCommentEdited> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "DiscussionCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"discussion\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"answer_chosen_at\",\n            \"answer_chosen_by\",\n            \"answer_html_url\",\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"answer_chosen_at\": {\n              \"type\": \"null\"\n            },\n            \"answer_chosen_by\": {\n              \"type\": \"null\"\n            },\n            \"answer_html_url\": {\n              \"type\": \"null\"\n            },\n            \"locked\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\",\n                \"converting\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreated {
    pub action: DiscussionCreatedAction,
    pub discussion: DiscussionCreatedDiscussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCreated> for DiscussionCreated {
    fn from(value: &DiscussionCreated) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DiscussionCreatedAction> for DiscussionCreatedAction {
    fn from(value: &DiscussionCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionCreatedDiscussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": \"null\"\n    },\n    \"answer_chosen_by\": {\n      \"type\": \"null\"\n    },\n    \"answer_html_url\": {\n      \"type\": \"null\"\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"converting\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreatedDiscussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: (),
    pub answer_chosen_by: (),
    pub answer_html_url: (),
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionCreatedDiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionCreatedDiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionCreatedDiscussion> for DiscussionCreatedDiscussion {
    fn from(value: &DiscussionCreatedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCreatedDiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreatedDiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionCreatedDiscussionCategory> for DiscussionCreatedDiscussionCategory {
    fn from(value: &DiscussionCreatedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionCreatedDiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"converting\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCreatedDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "converting")]
    Converting,
}
impl From<&DiscussionCreatedDiscussionState> for DiscussionCreatedDiscussionState {
    fn from(value: &DiscussionCreatedDiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCreatedDiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCreatedDiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCreatedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCreatedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCreatedDiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionDeleted {
    pub action: DiscussionDeletedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionDeleted> for DiscussionDeleted {
    fn from(value: &DiscussionDeleted) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DiscussionDeletedAction> for DiscussionDeletedAction {
    fn from(value: &DiscussionDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"title\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEdited {
    pub action: DiscussionEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<DiscussionEditedChanges>,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionEdited> for DiscussionEdited {
    fn from(value: &DiscussionEdited) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&DiscussionEditedAction> for DiscussionEditedAction {
    fn from(value: &DiscussionEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"title\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<DiscussionEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<DiscussionEditedChangesTitle>,
}
impl From<&DiscussionEditedChanges> for DiscussionEditedChanges {
    fn from(value: &DiscussionEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesBody {
    pub from: String,
}
impl From<&DiscussionEditedChangesBody> for DiscussionEditedChangesBody {
    fn from(value: &DiscussionEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionEditedChangesTitle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesTitle {
    pub from: String,
}
impl From<&DiscussionEditedChangesTitle> for DiscussionEditedChangesTitle {
    fn from(value: &DiscussionEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/discussion$answered\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$category_changed\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$labeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$locked\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$pinned\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$transferred\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$unanswered\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$unlabeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$unlocked\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion$unpinned\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionEvent {
    Answered(DiscussionAnswered),
    CategoryChanged(DiscussionCategoryChanged),
    Created(DiscussionCreated),
    Deleted(DiscussionDeleted),
    Edited(DiscussionEdited),
    Labeled(DiscussionLabeled),
    Locked(DiscussionLocked),
    Pinned(DiscussionPinned),
    Transferred(DiscussionTransferred),
    Unanswered(DiscussionUnanswered),
    Unlabeled(DiscussionUnlabeled),
    Unlocked(DiscussionUnlocked),
    Unpinned(DiscussionUnpinned),
}
impl From<&DiscussionEvent> for DiscussionEvent {
    fn from(value: &DiscussionEvent) -> Self {
        value.clone()
    }
}
impl From<DiscussionAnswered> for DiscussionEvent {
    fn from(value: DiscussionAnswered) -> Self {
        Self::Answered(value)
    }
}
impl From<DiscussionCategoryChanged> for DiscussionEvent {
    fn from(value: DiscussionCategoryChanged) -> Self {
        Self::CategoryChanged(value)
    }
}
impl From<DiscussionCreated> for DiscussionEvent {
    fn from(value: DiscussionCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DiscussionDeleted> for DiscussionEvent {
    fn from(value: DiscussionDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<DiscussionEdited> for DiscussionEvent {
    fn from(value: DiscussionEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<DiscussionLabeled> for DiscussionEvent {
    fn from(value: DiscussionLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<DiscussionLocked> for DiscussionEvent {
    fn from(value: DiscussionLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<DiscussionPinned> for DiscussionEvent {
    fn from(value: DiscussionPinned) -> Self {
        Self::Pinned(value)
    }
}
impl From<DiscussionTransferred> for DiscussionEvent {
    fn from(value: DiscussionTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<DiscussionUnanswered> for DiscussionEvent {
    fn from(value: DiscussionUnanswered) -> Self {
        Self::Unanswered(value)
    }
}
impl From<DiscussionUnlabeled> for DiscussionEvent {
    fn from(value: DiscussionUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<DiscussionUnlocked> for DiscussionEvent {
    fn from(value: DiscussionUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl From<DiscussionUnpinned> for DiscussionEvent {
    fn from(value: DiscussionUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[doc = "DiscussionLabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion labeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"label\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"labeled\"\n      ]\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLabeled {
    pub action: DiscussionLabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionLabeled> for DiscussionLabeled {
    fn from(value: &DiscussionLabeled) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionLabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"labeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&DiscussionLabeledAction> for DiscussionLabeledAction {
    fn from(value: &DiscussionLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionLocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion locked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"locked\"\n      ]\n    },\n    \"discussion\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"locked\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"locked\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLocked {
    pub action: DiscussionLockedAction,
    pub discussion: DiscussionLockedDiscussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionLocked> for DiscussionLocked {
    fn from(value: &DiscussionLocked) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionLockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"locked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&DiscussionLockedAction> for DiscussionLockedAction {
    fn from(value: &DiscussionLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionLockedDiscussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"answer_html_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"locked\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLockedDiscussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: Option<String>,
    pub answer_chosen_by: Option<User>,
    pub answer_html_url: Option<String>,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionLockedDiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionLockedDiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionLockedDiscussion> for DiscussionLockedDiscussion {
    fn from(value: &DiscussionLockedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionLockedDiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLockedDiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionLockedDiscussionCategory> for DiscussionLockedDiscussionCategory {
    fn from(value: &DiscussionLockedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionLockedDiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"locked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLockedDiscussionState {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&DiscussionLockedDiscussionState> for DiscussionLockedDiscussionState {
    fn from(value: &DiscussionLockedDiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionLockedDiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLockedDiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionLockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionPinned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion pinned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pinned\"\n      ]\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionPinned {
    pub action: DiscussionPinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionPinned> for DiscussionPinned {
    fn from(value: &DiscussionPinned) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionPinnedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pinned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl From<&DiscussionPinnedAction> for DiscussionPinnedAction {
    fn from(value: &DiscussionPinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"locked\",\n    \"converting\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl From<&DiscussionState> for DiscussionState {
    fn from(value: &DiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Locked => "locked".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionTransferred"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion transferred event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"transferred\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"new_discussion\",\n        \"new_repository\"\n      ],\n      \"properties\": {\n        \"new_discussion\": {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        \"new_repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferred {
    pub action: DiscussionTransferredAction,
    pub changes: DiscussionTransferredChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionTransferred> for DiscussionTransferred {
    fn from(value: &DiscussionTransferred) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionTransferredAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"transferred\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&DiscussionTransferredAction> for DiscussionTransferredAction {
    fn from(value: &DiscussionTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionTransferredChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"new_discussion\",\n    \"new_repository\"\n  ],\n  \"properties\": {\n    \"new_discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"new_repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferredChanges {
    pub new_discussion: Discussion,
    pub new_repository: Repository,
}
impl From<&DiscussionTransferredChanges> for DiscussionTransferredChanges {
    fn from(value: &DiscussionTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnanswered"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion unanswered event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"old_answer\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unanswered\"\n      ]\n    },\n    \"discussion\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"answer_chosen_at\",\n            \"answer_chosen_by\",\n            \"answer_html_url\",\n            \"category\"\n          ],\n          \"properties\": {\n            \"answer_chosen_at\": {\n              \"type\": \"null\"\n            },\n            \"answer_chosen_by\": {\n              \"type\": \"null\"\n            },\n            \"answer_html_url\": {\n              \"type\": \"null\"\n            },\n            \"category\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"is_answerable\"\n              ],\n              \"properties\": {\n                \"is_answerable\": {\n                  \"type\": \"boolean\",\n                  \"enum\": [\n                    true\n                  ]\n                }\n              },\n              \"tsAdditionalProperties\": false\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"old_answer\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author_association\",\n        \"body\",\n        \"child_comment_count\",\n        \"created_at\",\n        \"discussion_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"parent_id\",\n        \"repository_url\",\n        \"updated_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"child_comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"discussion_id\": {\n          \"type\": \"integer\"\n        },\n        \"html_url\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parent_id\": {\n          \"type\": \"null\"\n        },\n        \"repository_url\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnanswered {
    pub action: DiscussionUnansweredAction,
    pub discussion: DiscussionUnansweredDiscussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub old_answer: DiscussionUnansweredOldAnswer,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnanswered> for DiscussionUnanswered {
    fn from(value: &DiscussionUnanswered) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnansweredAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unanswered\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnansweredAction {
    #[serde(rename = "unanswered")]
    Unanswered,
}
impl From<&DiscussionUnansweredAction> for DiscussionUnansweredAction {
    fn from(value: &DiscussionUnansweredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnansweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unanswered => "unanswered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnansweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unanswered" => Ok(Self::Unanswered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionUnansweredDiscussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": \"null\"\n    },\n    \"answer_chosen_by\": {\n      \"type\": \"null\"\n    },\n    \"answer_html_url\": {\n      \"type\": \"null\"\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\",\n          \"enum\": [\n            true\n          ]\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"locked\",\n        \"converting\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredDiscussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: (),
    pub answer_chosen_by: (),
    pub answer_html_url: (),
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionUnansweredDiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionUnansweredDiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionUnansweredDiscussion> for DiscussionUnansweredDiscussion {
    fn from(value: &DiscussionUnansweredDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnansweredDiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredDiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionUnansweredDiscussionCategory> for DiscussionUnansweredDiscussionCategory {
    fn from(value: &DiscussionUnansweredDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnansweredDiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"locked\",\n    \"converting\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnansweredDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl From<&DiscussionUnansweredDiscussionState> for DiscussionUnansweredDiscussionState {
    fn from(value: &DiscussionUnansweredDiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnansweredDiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Locked => "locked".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnansweredDiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnansweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnansweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnansweredDiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionUnansweredOldAnswer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"child_comment_count\",\n    \"created_at\",\n    \"discussion_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"parent_id\",\n    \"repository_url\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"child_comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"discussion_id\": {\n      \"type\": \"integer\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent_id\": {\n      \"type\": \"null\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredOldAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionUnansweredOldAnswer> for DiscussionUnansweredOldAnswer {
    fn from(value: &DiscussionUnansweredOldAnswer) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnlabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion unlabeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"label\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlabeled\"\n      ]\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlabeled {
    pub action: DiscussionUnlabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnlabeled> for DiscussionUnlabeled {
    fn from(value: &DiscussionUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnlabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlabeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&DiscussionUnlabeledAction> for DiscussionUnlabeledAction {
    fn from(value: &DiscussionUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionUnlocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion unlocked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlocked\"\n      ]\n    },\n    \"discussion\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/discussion\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"locked\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlocked {
    pub action: DiscussionUnlockedAction,
    pub discussion: DiscussionUnlockedDiscussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnlocked> for DiscussionUnlocked {
    fn from(value: &DiscussionUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnlockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlocked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&DiscussionUnlockedAction> for DiscussionUnlockedAction {
    fn from(value: &DiscussionUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionUnlockedDiscussion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"answer_chosen_at\",\n    \"answer_chosen_by\",\n    \"answer_html_url\",\n    \"author_association\",\n    \"body\",\n    \"category\",\n    \"comments\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"locked\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"answer_chosen_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"answer_html_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"category\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"emoji\",\n        \"id\",\n        \"is_answerable\",\n        \"name\",\n        \"repository_id\",\n        \"slug\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"emoji\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"is_answerable\": {\n          \"type\": \"boolean\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"repository_id\": {\n          \"type\": \"integer\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"repository_url\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlockedDiscussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: Option<String>,
    pub answer_chosen_by: Option<User>,
    pub answer_html_url: Option<String>,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionUnlockedDiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionUnlockedDiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionUnlockedDiscussion> for DiscussionUnlockedDiscussion {
    fn from(value: &DiscussionUnlockedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnlockedDiscussionCategory"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"emoji\",\n    \"id\",\n    \"is_answerable\",\n    \"name\",\n    \"repository_id\",\n    \"slug\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"emoji\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"is_answerable\": {\n      \"type\": \"boolean\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"repository_id\": {\n      \"type\": \"integer\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlockedDiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionUnlockedDiscussionCategory> for DiscussionUnlockedDiscussionCategory {
    fn from(value: &DiscussionUnlockedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnlockedDiscussionState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlockedDiscussionState {
    #[serde(rename = "open")]
    Open,
}
impl From<&DiscussionUnlockedDiscussionState> for DiscussionUnlockedDiscussionState {
    fn from(value: &DiscussionUnlockedDiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnlockedDiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlockedDiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnlockedDiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "DiscussionUnpinned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"discussion unpinned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"discussion\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unpinned\"\n      ]\n    },\n    \"discussion\": {\n      \"$ref\": \"#/definitions/discussion\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnpinned {
    pub action: DiscussionUnpinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnpinned> for DiscussionUnpinned {
    fn from(value: &DiscussionUnpinned) -> Self {
        value.clone()
    }
}
#[doc = "DiscussionUnpinnedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unpinned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl From<&DiscussionUnpinnedAction> for DiscussionUnpinnedAction {
    fn from(value: &DiscussionUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Everything"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Everything\",\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/branch_protection_rule_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_run_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/check_suite_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/code_scanning_alert_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/commit_comment_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/content_reference_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/create$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/delete$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/deploy_key_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/deployment_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/deployment_status_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/discussion_comment_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/fork$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/github_app_authorization_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/gollum$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation_repositories_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/issue_comment_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/label_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/member_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/membership_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/meta_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/milestone_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/org_block_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/organization_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/package_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/page_build$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/ping$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_card_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_column_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/public$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review_comment_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/push$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/release_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_dispatch_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_import$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_vulnerability_alert_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/secret_scanning_alert_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/security_advisory_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/star_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/status$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/team_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/team_add$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/watch_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_dispatch$event\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_job_event\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_run_event\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Everything {
    BranchProtectionRuleEvent(BranchProtectionRuleEvent),
    CheckRunEvent(CheckRunEvent),
    CheckSuiteEvent(CheckSuiteEvent),
    CodeScanningAlertEvent(CodeScanningAlertEvent),
    CommitCommentEvent(CommitCommentEvent),
    ContentReferenceEvent(ContentReferenceEvent),
    CreateEvent(CreateEvent),
    DeleteEvent(DeleteEvent),
    DeployKeyEvent(DeployKeyEvent),
    DeploymentEvent(DeploymentEvent),
    DeploymentStatusEvent(DeploymentStatusEvent),
    DiscussionEvent(DiscussionEvent),
    DiscussionCommentEvent(DiscussionCommentEvent),
    ForkEvent(ForkEvent),
    GithubAppAuthorizationEvent(GithubAppAuthorizationEvent),
    GollumEvent(GollumEvent),
    InstallationEvent(InstallationEvent),
    InstallationRepositoriesEvent(InstallationRepositoriesEvent),
    IssueCommentEvent(IssueCommentEvent),
    IssuesEvent(IssuesEvent),
    LabelEvent(LabelEvent),
    MarketplacePurchaseEvent(MarketplacePurchaseEvent),
    MemberEvent(MemberEvent),
    MembershipEvent(MembershipEvent),
    MetaEvent(MetaEvent),
    MilestoneEvent(MilestoneEvent),
    OrgBlockEvent(OrgBlockEvent),
    OrganizationEvent(OrganizationEvent),
    PackageEvent(PackageEvent),
    PageBuildEvent(PageBuildEvent),
    PingEvent(PingEvent),
    ProjectEvent(ProjectEvent),
    ProjectCardEvent(ProjectCardEvent),
    ProjectColumnEvent(ProjectColumnEvent),
    PublicEvent(PublicEvent),
    PullRequestEvent(PullRequestEvent),
    PullRequestReviewEvent(PullRequestReviewEvent),
    PullRequestReviewCommentEvent(PullRequestReviewCommentEvent),
    PushEvent(PushEvent),
    ReleaseEvent(ReleaseEvent),
    RepositoryEvent(RepositoryEvent),
    RepositoryDispatchEvent(RepositoryDispatchEvent),
    RepositoryImportEvent(RepositoryImportEvent),
    RepositoryVulnerabilityAlertEvent(RepositoryVulnerabilityAlertEvent),
    SecretScanningAlertEvent(SecretScanningAlertEvent),
    SecurityAdvisoryEvent(SecurityAdvisoryEvent),
    SponsorshipEvent(SponsorshipEvent),
    StarEvent(StarEvent),
    StatusEvent(StatusEvent),
    TeamEvent(TeamEvent),
    TeamAddEvent(TeamAddEvent),
    WatchEvent(WatchEvent),
    WorkflowDispatchEvent(WorkflowDispatchEvent),
    WorkflowJobEvent(WorkflowJobEvent),
    WorkflowRunEvent(WorkflowRunEvent),
}
impl From<&Everything> for Everything {
    fn from(value: &Everything) -> Self {
        value.clone()
    }
}
impl From<BranchProtectionRuleEvent> for Everything {
    fn from(value: BranchProtectionRuleEvent) -> Self {
        Self::BranchProtectionRuleEvent(value)
    }
}
impl From<CheckRunEvent> for Everything {
    fn from(value: CheckRunEvent) -> Self {
        Self::CheckRunEvent(value)
    }
}
impl From<CheckSuiteEvent> for Everything {
    fn from(value: CheckSuiteEvent) -> Self {
        Self::CheckSuiteEvent(value)
    }
}
impl From<CodeScanningAlertEvent> for Everything {
    fn from(value: CodeScanningAlertEvent) -> Self {
        Self::CodeScanningAlertEvent(value)
    }
}
impl From<CommitCommentEvent> for Everything {
    fn from(value: CommitCommentEvent) -> Self {
        Self::CommitCommentEvent(value)
    }
}
impl From<ContentReferenceEvent> for Everything {
    fn from(value: ContentReferenceEvent) -> Self {
        Self::ContentReferenceEvent(value)
    }
}
impl From<CreateEvent> for Everything {
    fn from(value: CreateEvent) -> Self {
        Self::CreateEvent(value)
    }
}
impl From<DeleteEvent> for Everything {
    fn from(value: DeleteEvent) -> Self {
        Self::DeleteEvent(value)
    }
}
impl From<DeployKeyEvent> for Everything {
    fn from(value: DeployKeyEvent) -> Self {
        Self::DeployKeyEvent(value)
    }
}
impl From<DeploymentEvent> for Everything {
    fn from(value: DeploymentEvent) -> Self {
        Self::DeploymentEvent(value)
    }
}
impl From<DeploymentStatusEvent> for Everything {
    fn from(value: DeploymentStatusEvent) -> Self {
        Self::DeploymentStatusEvent(value)
    }
}
impl From<DiscussionEvent> for Everything {
    fn from(value: DiscussionEvent) -> Self {
        Self::DiscussionEvent(value)
    }
}
impl From<DiscussionCommentEvent> for Everything {
    fn from(value: DiscussionCommentEvent) -> Self {
        Self::DiscussionCommentEvent(value)
    }
}
impl From<ForkEvent> for Everything {
    fn from(value: ForkEvent) -> Self {
        Self::ForkEvent(value)
    }
}
impl From<GithubAppAuthorizationEvent> for Everything {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        Self::GithubAppAuthorizationEvent(value)
    }
}
impl From<GollumEvent> for Everything {
    fn from(value: GollumEvent) -> Self {
        Self::GollumEvent(value)
    }
}
impl From<InstallationEvent> for Everything {
    fn from(value: InstallationEvent) -> Self {
        Self::InstallationEvent(value)
    }
}
impl From<InstallationRepositoriesEvent> for Everything {
    fn from(value: InstallationRepositoriesEvent) -> Self {
        Self::InstallationRepositoriesEvent(value)
    }
}
impl From<IssueCommentEvent> for Everything {
    fn from(value: IssueCommentEvent) -> Self {
        Self::IssueCommentEvent(value)
    }
}
impl From<IssuesEvent> for Everything {
    fn from(value: IssuesEvent) -> Self {
        Self::IssuesEvent(value)
    }
}
impl From<LabelEvent> for Everything {
    fn from(value: LabelEvent) -> Self {
        Self::LabelEvent(value)
    }
}
impl From<MarketplacePurchaseEvent> for Everything {
    fn from(value: MarketplacePurchaseEvent) -> Self {
        Self::MarketplacePurchaseEvent(value)
    }
}
impl From<MemberEvent> for Everything {
    fn from(value: MemberEvent) -> Self {
        Self::MemberEvent(value)
    }
}
impl From<MembershipEvent> for Everything {
    fn from(value: MembershipEvent) -> Self {
        Self::MembershipEvent(value)
    }
}
impl From<MetaEvent> for Everything {
    fn from(value: MetaEvent) -> Self {
        Self::MetaEvent(value)
    }
}
impl From<MilestoneEvent> for Everything {
    fn from(value: MilestoneEvent) -> Self {
        Self::MilestoneEvent(value)
    }
}
impl From<OrgBlockEvent> for Everything {
    fn from(value: OrgBlockEvent) -> Self {
        Self::OrgBlockEvent(value)
    }
}
impl From<OrganizationEvent> for Everything {
    fn from(value: OrganizationEvent) -> Self {
        Self::OrganizationEvent(value)
    }
}
impl From<PackageEvent> for Everything {
    fn from(value: PackageEvent) -> Self {
        Self::PackageEvent(value)
    }
}
impl From<PageBuildEvent> for Everything {
    fn from(value: PageBuildEvent) -> Self {
        Self::PageBuildEvent(value)
    }
}
impl From<PingEvent> for Everything {
    fn from(value: PingEvent) -> Self {
        Self::PingEvent(value)
    }
}
impl From<ProjectEvent> for Everything {
    fn from(value: ProjectEvent) -> Self {
        Self::ProjectEvent(value)
    }
}
impl From<ProjectCardEvent> for Everything {
    fn from(value: ProjectCardEvent) -> Self {
        Self::ProjectCardEvent(value)
    }
}
impl From<ProjectColumnEvent> for Everything {
    fn from(value: ProjectColumnEvent) -> Self {
        Self::ProjectColumnEvent(value)
    }
}
impl From<PublicEvent> for Everything {
    fn from(value: PublicEvent) -> Self {
        Self::PublicEvent(value)
    }
}
impl From<PullRequestEvent> for Everything {
    fn from(value: PullRequestEvent) -> Self {
        Self::PullRequestEvent(value)
    }
}
impl From<PullRequestReviewEvent> for Everything {
    fn from(value: PullRequestReviewEvent) -> Self {
        Self::PullRequestReviewEvent(value)
    }
}
impl From<PullRequestReviewCommentEvent> for Everything {
    fn from(value: PullRequestReviewCommentEvent) -> Self {
        Self::PullRequestReviewCommentEvent(value)
    }
}
impl From<PushEvent> for Everything {
    fn from(value: PushEvent) -> Self {
        Self::PushEvent(value)
    }
}
impl From<ReleaseEvent> for Everything {
    fn from(value: ReleaseEvent) -> Self {
        Self::ReleaseEvent(value)
    }
}
impl From<RepositoryEvent> for Everything {
    fn from(value: RepositoryEvent) -> Self {
        Self::RepositoryEvent(value)
    }
}
impl From<RepositoryDispatchEvent> for Everything {
    fn from(value: RepositoryDispatchEvent) -> Self {
        Self::RepositoryDispatchEvent(value)
    }
}
impl From<RepositoryImportEvent> for Everything {
    fn from(value: RepositoryImportEvent) -> Self {
        Self::RepositoryImportEvent(value)
    }
}
impl From<RepositoryVulnerabilityAlertEvent> for Everything {
    fn from(value: RepositoryVulnerabilityAlertEvent) -> Self {
        Self::RepositoryVulnerabilityAlertEvent(value)
    }
}
impl From<SecretScanningAlertEvent> for Everything {
    fn from(value: SecretScanningAlertEvent) -> Self {
        Self::SecretScanningAlertEvent(value)
    }
}
impl From<SecurityAdvisoryEvent> for Everything {
    fn from(value: SecurityAdvisoryEvent) -> Self {
        Self::SecurityAdvisoryEvent(value)
    }
}
impl From<SponsorshipEvent> for Everything {
    fn from(value: SponsorshipEvent) -> Self {
        Self::SponsorshipEvent(value)
    }
}
impl From<StarEvent> for Everything {
    fn from(value: StarEvent) -> Self {
        Self::StarEvent(value)
    }
}
impl From<StatusEvent> for Everything {
    fn from(value: StatusEvent) -> Self {
        Self::StatusEvent(value)
    }
}
impl From<TeamEvent> for Everything {
    fn from(value: TeamEvent) -> Self {
        Self::TeamEvent(value)
    }
}
impl From<TeamAddEvent> for Everything {
    fn from(value: TeamAddEvent) -> Self {
        Self::TeamAddEvent(value)
    }
}
impl From<WatchEvent> for Everything {
    fn from(value: WatchEvent) -> Self {
        Self::WatchEvent(value)
    }
}
impl From<WorkflowDispatchEvent> for Everything {
    fn from(value: WorkflowDispatchEvent) -> Self {
        Self::WorkflowDispatchEvent(value)
    }
}
impl From<WorkflowJobEvent> for Everything {
    fn from(value: WorkflowJobEvent) -> Self {
        Self::WorkflowJobEvent(value)
    }
}
impl From<WorkflowRunEvent> for Everything {
    fn from(value: WorkflowRunEvent) -> Self {
        Self::WorkflowRunEvent(value)
    }
}
#[doc = "A user forks a repository."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"fork event\",\n  \"description\": \"A user forks a repository.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"forkee\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"forkee\": {\n      \"description\": \"The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"fork\": {\n              \"enum\": [\n                true\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEvent {
    pub forkee: ForkEventForkee,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ForkEvent> for ForkEvent {
    fn from(value: &ForkEvent) -> Self {
        value.clone()
    }
}
#[doc = "The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"description\": \"Whether the repository is archived.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEventForkee {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: ForkEventForkeeCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<ForkEventForkeePermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: ForkEventForkeePushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&ForkEventForkee> for ForkEventForkee {
    fn from(value: &ForkEventForkee) -> Self {
        value.clone()
    }
}
#[doc = "ForkEventForkeeCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForkEventForkeeCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&ForkEventForkeeCreatedAt> for ForkEventForkeeCreatedAt {
    fn from(value: &ForkEventForkeeCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ForkEventForkeeCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for ForkEventForkeeCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForkEventForkeeCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForkEventForkeeCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for ForkEventForkeeCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for ForkEventForkeeCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for ForkEventForkeeCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForkEventForkeePermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEventForkeePermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&ForkEventForkeePermissions> for ForkEventForkeePermissions {
    fn from(value: &ForkEventForkeePermissions) -> Self {
        value.clone()
    }
}
#[doc = "ForkEventForkeePushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForkEventForkeePushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&ForkEventForkeePushedAt> for ForkEventForkeePushedAt {
    fn from(value: &ForkEventForkeePushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for ForkEventForkeePushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for ForkEventForkeePushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GithubAppAuthorizationEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/github_app_authorization$revoked\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GithubAppAuthorizationEvent(pub GithubAppAuthorizationRevoked);
impl std::ops::Deref for GithubAppAuthorizationEvent {
    type Target = GithubAppAuthorizationRevoked;
    fn deref(&self) -> &GithubAppAuthorizationRevoked {
        &self.0
    }
}
impl From<GithubAppAuthorizationEvent> for GithubAppAuthorizationRevoked {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        value.0
    }
}
impl From<&GithubAppAuthorizationEvent> for GithubAppAuthorizationEvent {
    fn from(value: &GithubAppAuthorizationEvent) -> Self {
        value.clone()
    }
}
impl From<GithubAppAuthorizationRevoked> for GithubAppAuthorizationEvent {
    fn from(value: GithubAppAuthorizationRevoked) -> Self {
        Self(value)
    }
}
#[doc = "GithubAppAuthorizationRevoked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"github_app_authorization revoked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"revoked\"\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubAppAuthorizationRevoked {
    pub action: GithubAppAuthorizationRevokedAction,
    pub sender: User,
}
impl From<&GithubAppAuthorizationRevoked> for GithubAppAuthorizationRevoked {
    fn from(value: &GithubAppAuthorizationRevoked) -> Self {
        value.clone()
    }
}
#[doc = "GithubAppAuthorizationRevokedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"revoked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GithubAppAuthorizationRevokedAction {
    #[serde(rename = "revoked")]
    Revoked,
}
impl From<&GithubAppAuthorizationRevokedAction> for GithubAppAuthorizationRevokedAction {
    fn from(value: &GithubAppAuthorizationRevokedAction) -> Self {
        value.clone()
    }
}
impl ToString for GithubAppAuthorizationRevokedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Revoked => "revoked".to_string(),
        }
    }
}
impl std::str::FromStr for GithubAppAuthorizationRevokedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "revoked" => Ok(Self::Revoked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "GithubOrg"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"GitHub Org\",\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://avatars.githubusercontent.com/u/9919?v=4\"\n    },\n    \"email\": {\n      \"type\": \"null\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\",\n      \"const\": \"https://api.github.com/users/github/events{/privacy}\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github/followers\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\",\n      \"const\": \"https://api.github.com/users/github/following{/other_user}\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\",\n      \"const\": \"https://api.github.com/users/github/gists{/gist_id}\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\",\n      \"const\": \"\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://github.com/github\"\n    },\n    \"id\": {\n      \"type\": \"integer\",\n      \"const\": 9919\n    },\n    \"login\": {\n      \"type\": \"string\",\n      \"const\": \"github\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"const\": \"GitHub\"\n    },\n    \"node_id\": {\n      \"type\": \"string\",\n      \"const\": \"MDEyOk9yZ2FuaXphdGlvbjk5MTk=\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github/orgs\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github/received_events\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github/repos\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\",\n      \"const\": false\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\",\n      \"const\": \"https://api.github.com/users/github/starred{/owner}{/repo}\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github/subscriptions\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"const\": \"Organization\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\",\n      \"const\": \"https://api.github.com/users/github\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubOrg {
    pub avatar_url: String,
    #[serde(default)]
    pub email: (),
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&GithubOrg> for GithubOrg {
    fn from(value: &GithubOrg) -> Self {
        value.clone()
    }
}
#[doc = "A wiki page is created or updated."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"gollum event\",\n  \"description\": \"A wiki page is created or updated.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"pages\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pages\": {\n      \"description\": \"The pages that were updated.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"action\",\n          \"html_url\",\n          \"page_name\",\n          \"sha\",\n          \"summary\",\n          \"title\"\n        ],\n        \"properties\": {\n          \"action\": {\n            \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\",\n            \"type\": \"string\",\n            \"enum\": [\n              \"created\",\n              \"edited\"\n            ]\n          },\n          \"html_url\": {\n            \"description\": \"Points to the HTML wiki page.\",\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"page_name\": {\n            \"description\": \"The name of the page.\",\n            \"type\": \"string\"\n          },\n          \"sha\": {\n            \"description\": \"The latest commit SHA of the page.\",\n            \"type\": \"string\"\n          },\n          \"summary\": {\n            \"type\": \"null\"\n          },\n          \"title\": {\n            \"description\": \"The current page title.\",\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pages that were updated."]
    pub pages: Vec<GollumEventPagesItem>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&GollumEvent> for GollumEvent {
    fn from(value: &GollumEvent) -> Self {
        value.clone()
    }
}
#[doc = "GollumEventPagesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"html_url\",\n    \"page_name\",\n    \"sha\",\n    \"summary\",\n    \"title\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\",\n        \"edited\"\n      ]\n    },\n    \"html_url\": {\n      \"description\": \"Points to the HTML wiki page.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"page_name\": {\n      \"description\": \"The name of the page.\",\n      \"type\": \"string\"\n    },\n    \"sha\": {\n      \"description\": \"The latest commit SHA of the page.\",\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"null\"\n    },\n    \"title\": {\n      \"description\": \"The current page title.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEventPagesItem {
    #[doc = "The action that was performed on the page. Can be `created` or `edited`."]
    pub action: GollumEventPagesItemAction,
    #[doc = "Points to the HTML wiki page."]
    pub html_url: String,
    #[doc = "The name of the page."]
    pub page_name: String,
    #[doc = "The latest commit SHA of the page."]
    pub sha: String,
    pub summary: (),
    #[doc = "The current page title."]
    pub title: String,
}
impl From<&GollumEventPagesItem> for GollumEventPagesItem {
    fn from(value: &GollumEventPagesItem) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed on the page. Can be `created` or `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\",\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GollumEventPagesItemAction {
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "edited")]
    Edited,
}
impl From<&GollumEventPagesItemAction> for GollumEventPagesItemAction {
    fn from(value: &GollumEventPagesItemAction) -> Self {
        value.clone()
    }
}
impl ToString for GollumEventPagesItemAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for GollumEventPagesItemAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The GitHub App installation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Installation\",\n  \"description\": \"The GitHub App installation.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"access_tokens_url\",\n    \"account\",\n    \"app_id\",\n    \"created_at\",\n    \"events\",\n    \"html_url\",\n    \"id\",\n    \"permissions\",\n    \"repositories_url\",\n    \"repository_selection\",\n    \"single_file_name\",\n    \"suspended_at\",\n    \"suspended_by\",\n    \"target_id\",\n    \"target_type\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"access_tokens_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"account\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"app_id\": {\n      \"type\": \"integer\"\n    },\n    \"app_slug\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    },\n    \"events\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"check_run\",\n          \"check_suite\",\n          \"code_scanning_alert\",\n          \"commit_comment\",\n          \"content_reference\",\n          \"create\",\n          \"delete\",\n          \"deployment\",\n          \"deployment_review\",\n          \"deployment_status\",\n          \"deploy_key\",\n          \"discussion\",\n          \"discussion_comment\",\n          \"fork\",\n          \"gollum\",\n          \"issues\",\n          \"issue_comment\",\n          \"label\",\n          \"member\",\n          \"membership\",\n          \"merge_queue_entry\",\n          \"milestone\",\n          \"organization\",\n          \"org_block\",\n          \"page_build\",\n          \"project\",\n          \"project_card\",\n          \"project_column\",\n          \"public\",\n          \"pull_request\",\n          \"pull_request_review\",\n          \"pull_request_review_comment\",\n          \"push\",\n          \"registry_package\",\n          \"release\",\n          \"repository\",\n          \"repository_dispatch\",\n          \"secret_scanning_alert\",\n          \"star\",\n          \"status\",\n          \"team\",\n          \"team_add\",\n          \"watch\",\n          \"workflow_dispatch\",\n          \"workflow_run\"\n        ]\n      }\n    },\n    \"has_multiple_single_files\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The ID of the installation.\",\n      \"type\": \"integer\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"actions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"checks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"content_references\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"contents\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"deployments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"emails\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"environments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"issues\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"members\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"metadata\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_plan\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_self_hosted_runners\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_user_blocking\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pull_requests\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secret_scanning_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_scanning_alert\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"single_file\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"statuses\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"team_discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"vulnerability_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"workflows\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repositories_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repository_selection\": {\n      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"selected\"\n      ]\n    },\n    \"single_file_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"single_file_paths\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"suspended_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"suspended_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"target_id\": {\n      \"description\": \"The ID of the user or organization this token is being scoped to.\",\n      \"type\": \"integer\"\n    },\n    \"target_type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"updated_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Installation {
    pub access_tokens_url: String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_slug: Option<String>,
    pub created_at: InstallationCreatedAt,
    pub events: Vec<InstallationEventsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    pub html_url: String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationPermissions,
    pub repositories_url: String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositorySelection,
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub single_file_paths: Vec<String>,
    pub suspended_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub suspended_by: Option<User>,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationTargetType,
    pub updated_at: InstallationUpdatedAt,
}
impl From<&Installation> for Installation {
    fn from(value: &Installation) -> Self {
        value.clone()
    }
}
#[doc = "InstallationCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation\"\n    },\n    \"repositories\": {\n      \"description\": \"An array of repository objects that the installation can access.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"requester\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreated {
    pub action: InstallationCreatedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationCreatedRepositoriesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationCreated> for InstallationCreated {
    fn from(value: &InstallationCreated) -> Self {
        value.clone()
    }
}
#[doc = "InstallationCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&InstallationCreatedAction> for InstallationCreatedAction {
    fn from(value: &InstallationCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationCreatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationCreatedAt> for InstallationCreatedAt {
    fn from(value: &InstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "InstallationCreatedRepositoriesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreatedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationCreatedRepositoriesItem> for InstallationCreatedRepositoriesItem {
    fn from(value: &InstallationCreatedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation\"\n    },\n    \"repositories\": {\n      \"description\": \"An array of repository objects that the installation can access.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"requester\": {\n      \"type\": \"null\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeleted {
    pub action: InstallationDeletedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationDeletedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationDeleted> for InstallationDeleted {
    fn from(value: &InstallationDeleted) -> Self {
        value.clone()
    }
}
#[doc = "InstallationDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&InstallationDeletedAction> for InstallationDeletedAction {
    fn from(value: &InstallationDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationDeletedRepositoriesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeletedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationDeletedRepositoriesItem> for InstallationDeletedRepositoriesItem {
    fn from(value: &InstallationDeletedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/installation$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation$new_permissions_accepted\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation$suspend\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation$unsuspend\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationEvent {
    Created(InstallationCreated),
    Deleted(InstallationDeleted),
    NewPermissionsAccepted(InstallationNewPermissionsAccepted),
    Suspend(InstallationSuspend),
    Unsuspend(InstallationUnsuspend),
}
impl From<&InstallationEvent> for InstallationEvent {
    fn from(value: &InstallationEvent) -> Self {
        value.clone()
    }
}
impl From<InstallationCreated> for InstallationEvent {
    fn from(value: InstallationCreated) -> Self {
        Self::Created(value)
    }
}
impl From<InstallationDeleted> for InstallationEvent {
    fn from(value: InstallationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<InstallationNewPermissionsAccepted> for InstallationEvent {
    fn from(value: InstallationNewPermissionsAccepted) -> Self {
        Self::NewPermissionsAccepted(value)
    }
}
impl From<InstallationSuspend> for InstallationEvent {
    fn from(value: InstallationSuspend) -> Self {
        Self::Suspend(value)
    }
}
impl From<InstallationUnsuspend> for InstallationEvent {
    fn from(value: InstallationUnsuspend) -> Self {
        Self::Unsuspend(value)
    }
}
#[doc = "InstallationEventsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"check_run\",\n    \"check_suite\",\n    \"code_scanning_alert\",\n    \"commit_comment\",\n    \"content_reference\",\n    \"create\",\n    \"delete\",\n    \"deployment\",\n    \"deployment_review\",\n    \"deployment_status\",\n    \"deploy_key\",\n    \"discussion\",\n    \"discussion_comment\",\n    \"fork\",\n    \"gollum\",\n    \"issues\",\n    \"issue_comment\",\n    \"label\",\n    \"member\",\n    \"membership\",\n    \"merge_queue_entry\",\n    \"milestone\",\n    \"organization\",\n    \"org_block\",\n    \"page_build\",\n    \"project\",\n    \"project_card\",\n    \"project_column\",\n    \"public\",\n    \"pull_request\",\n    \"pull_request_review\",\n    \"pull_request_review_comment\",\n    \"push\",\n    \"registry_package\",\n    \"release\",\n    \"repository\",\n    \"repository_dispatch\",\n    \"secret_scanning_alert\",\n    \"star\",\n    \"status\",\n    \"team\",\n    \"team_add\",\n    \"watch\",\n    \"workflow_dispatch\",\n    \"workflow_run\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&InstallationEventsItem> for InstallationEventsItem {
    fn from(value: &InstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for InstallationEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::MergeQueueEntry => "merge_queue_entry".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Installation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"InstallationLite\",\n  \"description\": \"Installation\",\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"node_id\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"description\": \"The ID of the installation.\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationLite {
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub node_id: String,
}
impl From<&InstallationLite> for InstallationLite {
    fn from(value: &InstallationLite) -> Self {
        value.clone()
    }
}
#[doc = "InstallationNewPermissionsAccepted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation new_permissions_accepted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"new_permissions_accepted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation\"\n    },\n    \"repositories\": {\n      \"description\": \"An array of repository objects that the installation can access.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"requester\": {\n      \"type\": \"null\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAccepted {
    pub action: InstallationNewPermissionsAcceptedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationNewPermissionsAccepted> for InstallationNewPermissionsAccepted {
    fn from(value: &InstallationNewPermissionsAccepted) -> Self {
        value.clone()
    }
}
#[doc = "InstallationNewPermissionsAcceptedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"new_permissions_accepted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationNewPermissionsAcceptedAction {
    #[serde(rename = "new_permissions_accepted")]
    NewPermissionsAccepted,
}
impl From<&InstallationNewPermissionsAcceptedAction> for InstallationNewPermissionsAcceptedAction {
    fn from(value: &InstallationNewPermissionsAcceptedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationNewPermissionsAcceptedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::NewPermissionsAccepted => "new_permissions_accepted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationNewPermissionsAcceptedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "new_permissions_accepted" => Ok(Self::NewPermissionsAccepted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationNewPermissionsAcceptedRepositoriesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAcceptedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationNewPermissionsAcceptedRepositoriesItem>
    for InstallationNewPermissionsAcceptedRepositoriesItem
{
    fn from(value: &InstallationNewPermissionsAcceptedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"actions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"checks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"content_references\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"contents\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"deployments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"emails\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"environments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"issues\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"members\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"metadata\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_plan\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_self_hosted_runners\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_user_blocking\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pull_requests\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secret_scanning_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_scanning_alert\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"single_file\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"statuses\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"team_discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"vulnerability_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"workflows\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<InstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<InstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<InstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<InstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<InstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<InstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<InstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<InstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<InstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<InstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<InstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<InstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_events: Option<InstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<InstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<InstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<InstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<InstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<InstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners:
        Option<InstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<InstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<InstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<InstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<InstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<InstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<InstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<InstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<InstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<InstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<InstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<InstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<InstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<InstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<InstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<InstallationPermissionsWorkflows>,
}
impl From<&InstallationPermissions> for InstallationPermissions {
    fn from(value: &InstallationPermissions) -> Self {
        value.clone()
    }
}
#[doc = "InstallationPermissionsActions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsActions> for InstallationPermissionsActions {
    fn from(value: &InstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsAdministration> for InstallationPermissionsAdministration {
    fn from(value: &InstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsChecks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsChecks> for InstallationPermissionsChecks {
    fn from(value: &InstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsContentReferences"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsContentReferences> for InstallationPermissionsContentReferences {
    fn from(value: &InstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsContents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsContents> for InstallationPermissionsContents {
    fn from(value: &InstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsDeployments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsDeployments> for InstallationPermissionsDeployments {
    fn from(value: &InstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsDiscussions> for InstallationPermissionsDiscussions {
    fn from(value: &InstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsEmails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsEmails> for InstallationPermissionsEmails {
    fn from(value: &InstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsEnvironments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsEnvironments> for InstallationPermissionsEnvironments {
    fn from(value: &InstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsIssues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsIssues> for InstallationPermissionsIssues {
    fn from(value: &InstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsMembers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsMembers> for InstallationPermissionsMembers {
    fn from(value: &InstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsMetadata> for InstallationPermissionsMetadata {
    fn from(value: &InstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationAdministration>
    for InstallationPermissionsOrganizationAdministration
{
    fn from(value: &InstallationPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationEvents>
    for InstallationPermissionsOrganizationEvents
{
    fn from(value: &InstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationHooks> for InstallationPermissionsOrganizationHooks {
    fn from(value: &InstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationPackages>
    for InstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationPlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationPlan> for InstallationPermissionsOrganizationPlan {
    fn from(value: &InstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationProjects>
    for InstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationSecrets>
    for InstallationPermissionsOrganizationSecrets
{
    fn from(value: &InstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationSelfHostedRunners"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationSelfHostedRunners>
    for InstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(value: &InstallationPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsOrganizationUserBlocking"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationUserBlocking>
    for InstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPackages> for InstallationPermissionsPackages {
    fn from(value: &InstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsPages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPages> for InstallationPermissionsPages {
    fn from(value: &InstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsPullRequests"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPullRequests> for InstallationPermissionsPullRequests {
    fn from(value: &InstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsRepositoryHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsRepositoryHooks> for InstallationPermissionsRepositoryHooks {
    fn from(value: &InstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsRepositoryProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsRepositoryProjects>
    for InstallationPermissionsRepositoryProjects
{
    fn from(value: &InstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsSecretScanningAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecretScanningAlerts>
    for InstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecrets> for InstallationPermissionsSecrets {
    fn from(value: &InstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsSecurityEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecurityEvents> for InstallationPermissionsSecurityEvents {
    fn from(value: &InstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsSecurityScanningAlert"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecurityScanningAlert>
    for InstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsSingleFile"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSingleFile> for InstallationPermissionsSingleFile {
    fn from(value: &InstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsStatuses"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsStatuses> for InstallationPermissionsStatuses {
    fn from(value: &InstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsTeamDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsTeamDiscussions> for InstallationPermissionsTeamDiscussions {
    fn from(value: &InstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsVulnerabilityAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsVulnerabilityAlerts>
    for InstallationPermissionsVulnerabilityAlerts
{
    fn from(value: &InstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationPermissionsWorkflows"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsWorkflows> for InstallationPermissionsWorkflows {
    fn from(value: &InstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationRepositoriesAdded"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation_repositories added event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"repositories_added\",\n    \"repositories_removed\",\n    \"repository_selection\",\n    \"requester\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"added\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation\"\n    },\n    \"repositories_added\": {\n      \"description\": \"An array of repository objects, which were added to the installation.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"repositories_removed\": {\n      \"description\": \"An array of repository objects, which were removed from the installation.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      },\n      \"maxItems\": 0\n    },\n    \"repository_selection\": {\n      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"selected\"\n      ]\n    },\n    \"requester\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAdded {
    pub action: InstallationRepositoriesAddedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesAddedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationRepositoriesAdded> for InstallationRepositoriesAdded {
    fn from(value: &InstallationRepositoriesAdded) -> Self {
        value.clone()
    }
}
#[doc = "InstallationRepositoriesAddedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"added\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&InstallationRepositoriesAddedAction> for InstallationRepositoriesAddedAction {
    fn from(value: &InstallationRepositoriesAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationRepositoriesAddedRepositoriesAddedItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesAddedRepositoriesAddedItem>
    for InstallationRepositoriesAddedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationRepositoriesAddedRepositoriesRemovedItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesRemovedItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_name: Option<String>,
    #[doc = "Unique identifier of the repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "Whether the repository is private or public."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
}
impl From<&InstallationRepositoriesAddedRepositoriesRemovedItem>
    for InstallationRepositoriesAddedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"all\",\n    \"selected\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositoriesAddedRepositorySelection>
    for InstallationRepositoriesAddedRepositorySelection
{
    fn from(value: &InstallationRepositoriesAddedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesAddedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationRepositoriesEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/installation_repositories$added\"\n    },\n    {\n      \"$ref\": \"#/definitions/installation_repositories$removed\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationRepositoriesEvent {
    Added(InstallationRepositoriesAdded),
    Removed(InstallationRepositoriesRemoved),
}
impl From<&InstallationRepositoriesEvent> for InstallationRepositoriesEvent {
    fn from(value: &InstallationRepositoriesEvent) -> Self {
        value.clone()
    }
}
impl From<InstallationRepositoriesAdded> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesAdded) -> Self {
        Self::Added(value)
    }
}
impl From<InstallationRepositoriesRemoved> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "InstallationRepositoriesRemoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation_repositories removed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"repositories_added\",\n    \"repositories_removed\",\n    \"repository_selection\",\n    \"requester\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"removed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation\"\n    },\n    \"repositories_added\": {\n      \"description\": \"An array of repository objects, which were added to the installation.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      },\n      \"maxItems\": 0\n    },\n    \"repositories_removed\": {\n      \"description\": \"An array of repository objects, which were removed from the installation.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"repository_selection\": {\n      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"selected\"\n      ]\n    },\n    \"requester\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemoved {
    pub action: InstallationRepositoriesRemovedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesRemovedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationRepositoriesRemoved> for InstallationRepositoriesRemoved {
    fn from(value: &InstallationRepositoriesRemoved) -> Self {
        value.clone()
    }
}
#[doc = "InstallationRepositoriesRemovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&InstallationRepositoriesRemovedAction> for InstallationRepositoriesRemovedAction {
    fn from(value: &InstallationRepositoriesRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationRepositoriesRemovedRepositoriesAddedItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesAddedItem>
    for InstallationRepositoriesRemovedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationRepositoriesRemovedRepositoriesRemovedItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesRemovedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesRemovedItem>
    for InstallationRepositoriesRemovedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"all\",\n    \"selected\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositoriesRemovedRepositorySelection>
    for InstallationRepositoriesRemovedRepositorySelection
{
    fn from(value: &InstallationRepositoriesRemovedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesRemovedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"all\",\n    \"selected\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositorySelection> for InstallationRepositorySelection {
    fn from(value: &InstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspend"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation suspend event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"suspend\"\n      ]\n    },\n    \"installation\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/installation\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"suspended_at\",\n            \"suspended_by\"\n          ],\n          \"properties\": {\n            \"suspended_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"suspended_by\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repositories\": {\n      \"description\": \"An array of repository objects that the installation can access.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"requester\": {\n      \"type\": \"null\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspend {
    pub action: InstallationSuspendAction,
    pub installation: InstallationSuspendInstallation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationSuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationSuspend> for InstallationSuspend {
    fn from(value: &InstallationSuspend) -> Self {
        value.clone()
    }
}
#[doc = "InstallationSuspendAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"suspend\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendAction {
    #[serde(rename = "suspend")]
    Suspend,
}
impl From<&InstallationSuspendAction> for InstallationSuspendAction {
    fn from(value: &InstallationSuspendAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Suspend => "suspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "suspend" => Ok(Self::Suspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"access_tokens_url\",\n    \"account\",\n    \"app_id\",\n    \"created_at\",\n    \"events\",\n    \"html_url\",\n    \"id\",\n    \"permissions\",\n    \"repositories_url\",\n    \"repository_selection\",\n    \"single_file_name\",\n    \"suspended_at\",\n    \"suspended_by\",\n    \"target_id\",\n    \"target_type\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"access_tokens_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"account\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"app_id\": {\n      \"type\": \"integer\"\n    },\n    \"app_slug\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    },\n    \"events\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"check_run\",\n          \"check_suite\",\n          \"code_scanning_alert\",\n          \"commit_comment\",\n          \"content_reference\",\n          \"create\",\n          \"delete\",\n          \"deployment\",\n          \"deployment_review\",\n          \"deployment_status\",\n          \"deploy_key\",\n          \"discussion\",\n          \"discussion_comment\",\n          \"fork\",\n          \"gollum\",\n          \"issues\",\n          \"issue_comment\",\n          \"label\",\n          \"member\",\n          \"membership\",\n          \"merge_queue_entry\",\n          \"milestone\",\n          \"organization\",\n          \"org_block\",\n          \"page_build\",\n          \"project\",\n          \"project_card\",\n          \"project_column\",\n          \"public\",\n          \"pull_request\",\n          \"pull_request_review\",\n          \"pull_request_review_comment\",\n          \"push\",\n          \"registry_package\",\n          \"release\",\n          \"repository\",\n          \"repository_dispatch\",\n          \"secret_scanning_alert\",\n          \"star\",\n          \"status\",\n          \"team\",\n          \"team_add\",\n          \"watch\",\n          \"workflow_dispatch\",\n          \"workflow_run\"\n        ]\n      }\n    },\n    \"has_multiple_single_files\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The ID of the installation.\",\n      \"type\": \"integer\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"actions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"checks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"content_references\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"contents\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"deployments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"emails\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"environments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"issues\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"members\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"metadata\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_plan\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_self_hosted_runners\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_user_blocking\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pull_requests\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secret_scanning_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_scanning_alert\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"single_file\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"statuses\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"team_discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"vulnerability_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"workflows\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repositories_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repository_selection\": {\n      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"selected\"\n      ]\n    },\n    \"single_file_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"single_file_paths\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"suspended_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"suspended_by\": {\n      \"allOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"avatar_url\",\n            \"events_url\",\n            \"followers_url\",\n            \"following_url\",\n            \"gists_url\",\n            \"gravatar_id\",\n            \"html_url\",\n            \"id\",\n            \"login\",\n            \"node_id\",\n            \"organizations_url\",\n            \"received_events_url\",\n            \"repos_url\",\n            \"site_admin\",\n            \"starred_url\",\n            \"subscriptions_url\",\n            \"type\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"avatar_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"email\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"events_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"followers_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"following_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"gists_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"gravatar_id\": {\n              \"type\": \"string\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"login\": {\n              \"type\": \"string\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"organizations_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"received_events_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"repos_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"site_admin\": {\n              \"type\": \"boolean\"\n            },\n            \"starred_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri-template\"\n            },\n            \"subscriptions_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"type\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"Bot\",\n                \"User\",\n                \"Organization\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"$ref\": \"#/definitions/user\"\n        }\n      ]\n    },\n    \"target_id\": {\n      \"description\": \"The ID of the user or organization this token is being scoped to.\",\n      \"type\": \"integer\"\n    },\n    \"target_type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"updated_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallation {
    pub access_tokens_url: String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_slug: Option<String>,
    pub created_at: InstallationSuspendInstallationCreatedAt,
    pub events: Vec<InstallationSuspendInstallationEventsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    pub html_url: String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationSuspendInstallationPermissions,
    pub repositories_url: String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationSuspendInstallationRepositorySelection,
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub single_file_paths: Vec<String>,
    pub suspended_at: chrono::DateTime<chrono::offset::Utc>,
    pub suspended_by: InstallationSuspendInstallationSuspendedBy,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationSuspendInstallationTargetType,
    pub updated_at: InstallationSuspendInstallationUpdatedAt,
}
impl From<&InstallationSuspendInstallation> for InstallationSuspendInstallation {
    fn from(value: &InstallationSuspendInstallation) -> Self {
        value.clone()
    }
}
#[doc = "InstallationSuspendInstallationCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationSuspendInstallationCreatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationSuspendInstallationCreatedAt> for InstallationSuspendInstallationCreatedAt {
    fn from(value: &InstallationSuspendInstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationSuspendInstallationCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationSuspendInstallationCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationSuspendInstallationCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationSuspendInstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "InstallationSuspendInstallationEventsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"check_run\",\n    \"check_suite\",\n    \"code_scanning_alert\",\n    \"commit_comment\",\n    \"content_reference\",\n    \"create\",\n    \"delete\",\n    \"deployment\",\n    \"deployment_review\",\n    \"deployment_status\",\n    \"deploy_key\",\n    \"discussion\",\n    \"discussion_comment\",\n    \"fork\",\n    \"gollum\",\n    \"issues\",\n    \"issue_comment\",\n    \"label\",\n    \"member\",\n    \"membership\",\n    \"merge_queue_entry\",\n    \"milestone\",\n    \"organization\",\n    \"org_block\",\n    \"page_build\",\n    \"project\",\n    \"project_card\",\n    \"project_column\",\n    \"public\",\n    \"pull_request\",\n    \"pull_request_review\",\n    \"pull_request_review_comment\",\n    \"push\",\n    \"registry_package\",\n    \"release\",\n    \"repository\",\n    \"repository_dispatch\",\n    \"secret_scanning_alert\",\n    \"star\",\n    \"status\",\n    \"team\",\n    \"team_add\",\n    \"watch\",\n    \"workflow_dispatch\",\n    \"workflow_run\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&InstallationSuspendInstallationEventsItem>
    for InstallationSuspendInstallationEventsItem
{
    fn from(value: &InstallationSuspendInstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::MergeQueueEntry => "merge_queue_entry".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"actions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"checks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"content_references\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"contents\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"deployments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"emails\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"environments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"issues\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"members\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"metadata\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_plan\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_self_hosted_runners\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_user_blocking\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pull_requests\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secret_scanning_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_scanning_alert\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"single_file\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"statuses\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"team_discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"vulnerability_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"workflows\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallationPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<InstallationSuspendInstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<InstallationSuspendInstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<InstallationSuspendInstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<InstallationSuspendInstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<InstallationSuspendInstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<InstallationSuspendInstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<InstallationSuspendInstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<InstallationSuspendInstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<InstallationSuspendInstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<InstallationSuspendInstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<InstallationSuspendInstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstallationSuspendInstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration:
        Option<InstallationSuspendInstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_events: Option<InstallationSuspendInstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<InstallationSuspendInstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages:
        Option<InstallationSuspendInstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<InstallationSuspendInstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects:
        Option<InstallationSuspendInstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<InstallationSuspendInstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners:
        Option<InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking:
        Option<InstallationSuspendInstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<InstallationSuspendInstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<InstallationSuspendInstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<InstallationSuspendInstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<InstallationSuspendInstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<InstallationSuspendInstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts:
        Option<InstallationSuspendInstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<InstallationSuspendInstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<InstallationSuspendInstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert:
        Option<InstallationSuspendInstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<InstallationSuspendInstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<InstallationSuspendInstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<InstallationSuspendInstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<InstallationSuspendInstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<InstallationSuspendInstallationPermissionsWorkflows>,
}
impl From<&InstallationSuspendInstallationPermissions>
    for InstallationSuspendInstallationPermissions
{
    fn from(value: &InstallationSuspendInstallationPermissions) -> Self {
        value.clone()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsActions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsActions>
    for InstallationSuspendInstallationPermissionsActions
{
    fn from(value: &InstallationSuspendInstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsAdministration>
    for InstallationSuspendInstallationPermissionsAdministration
{
    fn from(value: &InstallationSuspendInstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsChecks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsChecks>
    for InstallationSuspendInstallationPermissionsChecks
{
    fn from(value: &InstallationSuspendInstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsContentReferences"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsContentReferences>
    for InstallationSuspendInstallationPermissionsContentReferences
{
    fn from(value: &InstallationSuspendInstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsContentReferences
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsContents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsContents>
    for InstallationSuspendInstallationPermissionsContents
{
    fn from(value: &InstallationSuspendInstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsDeployments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsDeployments>
    for InstallationSuspendInstallationPermissionsDeployments
{
    fn from(value: &InstallationSuspendInstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsDiscussions>
    for InstallationSuspendInstallationPermissionsDiscussions
{
    fn from(value: &InstallationSuspendInstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsEmails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsEmails>
    for InstallationSuspendInstallationPermissionsEmails
{
    fn from(value: &InstallationSuspendInstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsEnvironments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsEnvironments>
    for InstallationSuspendInstallationPermissionsEnvironments
{
    fn from(value: &InstallationSuspendInstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsIssues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsIssues>
    for InstallationSuspendInstallationPermissionsIssues
{
    fn from(value: &InstallationSuspendInstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsMembers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsMembers>
    for InstallationSuspendInstallationPermissionsMembers
{
    fn from(value: &InstallationSuspendInstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsMetadata>
    for InstallationSuspendInstallationPermissionsMetadata
{
    fn from(value: &InstallationSuspendInstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationAdministration>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationEvents>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationHooks>
    for InstallationSuspendInstallationPermissionsOrganizationHooks
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationHooks
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationPackages>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationPlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationPlan>
    for InstallationSuspendInstallationPermissionsOrganizationPlan
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationProjects>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationSecrets>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(
        value: &InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners,
    ) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsOrganizationUserBlocking"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsOrganizationUserBlocking>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsPackages>
    for InstallationSuspendInstallationPermissionsPackages
{
    fn from(value: &InstallationSuspendInstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsPages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsPages>
    for InstallationSuspendInstallationPermissionsPages
{
    fn from(value: &InstallationSuspendInstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsPullRequests"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsPullRequests>
    for InstallationSuspendInstallationPermissionsPullRequests
{
    fn from(value: &InstallationSuspendInstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsRepositoryHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsRepositoryHooks>
    for InstallationSuspendInstallationPermissionsRepositoryHooks
{
    fn from(value: &InstallationSuspendInstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsRepositoryProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsRepositoryProjects>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    fn from(value: &InstallationSuspendInstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsSecretScanningAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsSecretScanningAlerts>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsSecrets>
    for InstallationSuspendInstallationPermissionsSecrets
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsSecurityEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsSecurityEvents>
    for InstallationSuspendInstallationPermissionsSecurityEvents
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsSecurityScanningAlert"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsSecurityScanningAlert>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsSingleFile"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsSingleFile>
    for InstallationSuspendInstallationPermissionsSingleFile
{
    fn from(value: &InstallationSuspendInstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsStatuses"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsStatuses>
    for InstallationSuspendInstallationPermissionsStatuses
{
    fn from(value: &InstallationSuspendInstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsTeamDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsTeamDiscussions>
    for InstallationSuspendInstallationPermissionsTeamDiscussions
{
    fn from(value: &InstallationSuspendInstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsVulnerabilityAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsVulnerabilityAlerts>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    fn from(value: &InstallationSuspendInstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationPermissionsWorkflows"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationSuspendInstallationPermissionsWorkflows>
    for InstallationSuspendInstallationPermissionsWorkflows
{
    fn from(value: &InstallationSuspendInstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"all\",\n    \"selected\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationSuspendInstallationRepositorySelection>
    for InstallationSuspendInstallationRepositorySelection
{
    fn from(value: &InstallationSuspendInstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationSuspendedBy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallationSuspendedBy {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: InstallationSuspendInstallationSuspendedByType,
    pub url: String,
}
impl From<&InstallationSuspendInstallationSuspendedBy>
    for InstallationSuspendInstallationSuspendedBy
{
    fn from(value: &InstallationSuspendInstallationSuspendedBy) -> Self {
        value.clone()
    }
}
#[doc = "InstallationSuspendInstallationSuspendedByType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationSuspendedByType {
    Bot,
    User,
    Organization,
}
impl From<&InstallationSuspendInstallationSuspendedByType>
    for InstallationSuspendInstallationSuspendedByType
{
    fn from(value: &InstallationSuspendInstallationSuspendedByType) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationSuspendedByType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationSuspendedByType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationSuspendedByType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationSuspendedByType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationSuspendedByType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationTargetType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendInstallationTargetType {
    User,
    Organization,
}
impl From<&InstallationSuspendInstallationTargetType>
    for InstallationSuspendInstallationTargetType
{
    fn from(value: &InstallationSuspendInstallationTargetType) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendInstallationTargetType {
    fn to_string(&self) -> String {
        match *self {
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendInstallationTargetType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationSuspendInstallationUpdatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationSuspendInstallationUpdatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationSuspendInstallationUpdatedAt> for InstallationSuspendInstallationUpdatedAt {
    fn from(value: &InstallationSuspendInstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationSuspendInstallationUpdatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationSuspendInstallationUpdatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationSuspendInstallationUpdatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationSuspendInstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "InstallationSuspendRepositoriesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationSuspendRepositoriesItem> for InstallationSuspendRepositoriesItem {
    fn from(value: &InstallationSuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationTargetType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationTargetType {
    User,
    Organization,
}
impl From<&InstallationTargetType> for InstallationTargetType {
    fn from(value: &InstallationTargetType) -> Self {
        value.clone()
    }
}
impl ToString for InstallationTargetType {
    fn to_string(&self) -> String {
        match *self {
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationTargetType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspend"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"installation unsuspend event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"installation\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unsuspend\"\n      ]\n    },\n    \"installation\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/installation\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"suspended_at\",\n            \"suspended_by\"\n          ],\n          \"properties\": {\n            \"suspended_at\": {\n              \"type\": \"null\"\n            },\n            \"suspended_by\": {\n              \"type\": \"null\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repositories\": {\n      \"description\": \"An array of repository objects that the installation can access.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"full_name\",\n          \"id\",\n          \"name\",\n          \"node_id\",\n          \"private\"\n        ],\n        \"properties\": {\n          \"full_name\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Unique identifier of the repository\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"The name of the repository.\",\n            \"type\": \"string\"\n          },\n          \"node_id\": {\n            \"type\": \"string\"\n          },\n          \"private\": {\n            \"description\": \"Whether the repository is private or public.\",\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"requester\": {\n      \"type\": \"null\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspend {
    pub action: InstallationUnsuspendAction,
    pub installation: InstallationUnsuspendInstallation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationUnsuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationUnsuspend> for InstallationUnsuspend {
    fn from(value: &InstallationUnsuspend) -> Self {
        value.clone()
    }
}
#[doc = "InstallationUnsuspendAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unsuspend\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendAction {
    #[serde(rename = "unsuspend")]
    Unsuspend,
}
impl From<&InstallationUnsuspendAction> for InstallationUnsuspendAction {
    fn from(value: &InstallationUnsuspendAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unsuspend => "unsuspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unsuspend" => Ok(Self::Unsuspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"access_tokens_url\",\n    \"account\",\n    \"app_id\",\n    \"created_at\",\n    \"events\",\n    \"html_url\",\n    \"id\",\n    \"permissions\",\n    \"repositories_url\",\n    \"repository_selection\",\n    \"single_file_name\",\n    \"suspended_at\",\n    \"suspended_by\",\n    \"target_id\",\n    \"target_type\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"access_tokens_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"account\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"app_id\": {\n      \"type\": \"integer\"\n    },\n    \"app_slug\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    },\n    \"events\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"check_run\",\n          \"check_suite\",\n          \"code_scanning_alert\",\n          \"commit_comment\",\n          \"content_reference\",\n          \"create\",\n          \"delete\",\n          \"deployment\",\n          \"deployment_review\",\n          \"deployment_status\",\n          \"deploy_key\",\n          \"discussion\",\n          \"discussion_comment\",\n          \"fork\",\n          \"gollum\",\n          \"issues\",\n          \"issue_comment\",\n          \"label\",\n          \"member\",\n          \"membership\",\n          \"merge_queue_entry\",\n          \"milestone\",\n          \"organization\",\n          \"org_block\",\n          \"page_build\",\n          \"project\",\n          \"project_card\",\n          \"project_column\",\n          \"public\",\n          \"pull_request\",\n          \"pull_request_review\",\n          \"pull_request_review_comment\",\n          \"push\",\n          \"registry_package\",\n          \"release\",\n          \"repository\",\n          \"repository_dispatch\",\n          \"secret_scanning_alert\",\n          \"star\",\n          \"status\",\n          \"team\",\n          \"team_add\",\n          \"watch\",\n          \"workflow_dispatch\",\n          \"workflow_run\"\n        ]\n      }\n    },\n    \"has_multiple_single_files\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The ID of the installation.\",\n      \"type\": \"integer\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"actions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"checks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"content_references\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"contents\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"deployments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"emails\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"environments\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"issues\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"members\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"metadata\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_administration\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_plan\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_self_hosted_runners\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"organization_user_blocking\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"packages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pages\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"pull_requests\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_hooks\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"repository_projects\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secret_scanning_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"secrets\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_events\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"security_scanning_alert\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"single_file\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"statuses\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"team_discussions\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"vulnerability_alerts\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        },\n        \"workflows\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repositories_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repository_selection\": {\n      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"selected\"\n      ]\n    },\n    \"single_file_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"single_file_paths\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"suspended_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"suspended_by\": {\n      \"type\": \"null\"\n    },\n    \"target_id\": {\n      \"description\": \"The ID of the user or organization this token is being scoped to.\",\n      \"type\": \"integer\"\n    },\n    \"target_type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"updated_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"integer\"\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendInstallation {
    pub access_tokens_url: String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_slug: Option<String>,
    pub created_at: InstallationUnsuspendInstallationCreatedAt,
    pub events: Vec<InstallationUnsuspendInstallationEventsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    pub html_url: String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationUnsuspendInstallationPermissions,
    pub repositories_url: String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationUnsuspendInstallationRepositorySelection,
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub single_file_paths: Vec<String>,
    pub suspended_at: (),
    pub suspended_by: (),
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationUnsuspendInstallationTargetType,
    pub updated_at: InstallationUnsuspendInstallationUpdatedAt,
}
impl From<&InstallationUnsuspendInstallation> for InstallationUnsuspendInstallation {
    fn from(value: &InstallationUnsuspendInstallation) -> Self {
        value.clone()
    }
}
#[doc = "InstallationUnsuspendInstallationCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationUnsuspendInstallationCreatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationUnsuspendInstallationCreatedAt>
    for InstallationUnsuspendInstallationCreatedAt
{
    fn from(value: &InstallationUnsuspendInstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationUnsuspendInstallationCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationUnsuspendInstallationCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationUnsuspendInstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "InstallationUnsuspendInstallationEventsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"check_run\",\n    \"check_suite\",\n    \"code_scanning_alert\",\n    \"commit_comment\",\n    \"content_reference\",\n    \"create\",\n    \"delete\",\n    \"deployment\",\n    \"deployment_review\",\n    \"deployment_status\",\n    \"deploy_key\",\n    \"discussion\",\n    \"discussion_comment\",\n    \"fork\",\n    \"gollum\",\n    \"issues\",\n    \"issue_comment\",\n    \"label\",\n    \"member\",\n    \"membership\",\n    \"merge_queue_entry\",\n    \"milestone\",\n    \"organization\",\n    \"org_block\",\n    \"page_build\",\n    \"project\",\n    \"project_card\",\n    \"project_column\",\n    \"public\",\n    \"pull_request\",\n    \"pull_request_review\",\n    \"pull_request_review_comment\",\n    \"push\",\n    \"registry_package\",\n    \"release\",\n    \"repository\",\n    \"repository_dispatch\",\n    \"secret_scanning_alert\",\n    \"star\",\n    \"status\",\n    \"team\",\n    \"team_add\",\n    \"watch\",\n    \"workflow_dispatch\",\n    \"workflow_run\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&InstallationUnsuspendInstallationEventsItem>
    for InstallationUnsuspendInstallationEventsItem
{
    fn from(value: &InstallationUnsuspendInstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::MergeQueueEntry => "merge_queue_entry".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"actions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"checks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"content_references\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"contents\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"deployments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"emails\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"environments\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"issues\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"members\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"metadata\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_administration\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_plan\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_self_hosted_runners\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"organization_user_blocking\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"packages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pages\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"pull_requests\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_hooks\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"repository_projects\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secret_scanning_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"secrets\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_events\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"security_scanning_alert\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"single_file\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"statuses\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"team_discussions\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"vulnerability_alerts\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    },\n    \"workflows\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"read\",\n        \"write\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendInstallationPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<InstallationUnsuspendInstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<InstallationUnsuspendInstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<InstallationUnsuspendInstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<InstallationUnsuspendInstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<InstallationUnsuspendInstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<InstallationUnsuspendInstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<InstallationUnsuspendInstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<InstallationUnsuspendInstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<InstallationUnsuspendInstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<InstallationUnsuspendInstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<InstallationUnsuspendInstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstallationUnsuspendInstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_events: Option<InstallationUnsuspendInstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<InstallationUnsuspendInstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<InstallationUnsuspendInstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking:
        Option<InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<InstallationUnsuspendInstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<InstallationUnsuspendInstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<InstallationUnsuspendInstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<InstallationUnsuspendInstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<InstallationUnsuspendInstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts:
        Option<InstallationUnsuspendInstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<InstallationUnsuspendInstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<InstallationUnsuspendInstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert:
        Option<InstallationUnsuspendInstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<InstallationUnsuspendInstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<InstallationUnsuspendInstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<InstallationUnsuspendInstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts:
        Option<InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<InstallationUnsuspendInstallationPermissionsWorkflows>,
}
impl From<&InstallationUnsuspendInstallationPermissions>
    for InstallationUnsuspendInstallationPermissions
{
    fn from(value: &InstallationUnsuspendInstallationPermissions) -> Self {
        value.clone()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsActions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsActions>
    for InstallationUnsuspendInstallationPermissionsActions
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsAdministration>
    for InstallationUnsuspendInstallationPermissionsAdministration
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsChecks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsChecks>
    for InstallationUnsuspendInstallationPermissionsChecks
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsContentReferences"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsContentReferences>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsContents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsContents>
    for InstallationUnsuspendInstallationPermissionsContents
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsDeployments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsDeployments>
    for InstallationUnsuspendInstallationPermissionsDeployments
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsDiscussions>
    for InstallationUnsuspendInstallationPermissionsDiscussions
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsEmails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsEmails>
    for InstallationUnsuspendInstallationPermissionsEmails
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsEnvironments"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsEnvironments>
    for InstallationUnsuspendInstallationPermissionsEnvironments
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsIssues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsIssues>
    for InstallationUnsuspendInstallationPermissionsIssues
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsMembers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsMembers>
    for InstallationUnsuspendInstallationPermissionsMembers
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsMetadata>
    for InstallationUnsuspendInstallationPermissionsMetadata
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationAdministration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationAdministration>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    fn from(
        value: &InstallationUnsuspendInstallationPermissionsOrganizationAdministration,
    ) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationEvents>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationHooks>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationPackages>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationPlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationPlan>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationProjects>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationSecrets>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(
        value: &InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners,
    ) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsPackages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsPackages>
    for InstallationUnsuspendInstallationPermissionsPackages
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsPages"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsPages>
    for InstallationUnsuspendInstallationPermissionsPages
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsPullRequests"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsPullRequests>
    for InstallationUnsuspendInstallationPermissionsPullRequests
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsRepositoryHooks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsRepositoryHooks>
    for InstallationUnsuspendInstallationPermissionsRepositoryHooks
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsRepositoryHooks
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsRepositoryProjects"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsRepositoryProjects>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsSecretScanningAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsSecretScanningAlerts>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsSecrets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsSecrets>
    for InstallationUnsuspendInstallationPermissionsSecrets
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsSecurityEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsSecurityEvents>
    for InstallationUnsuspendInstallationPermissionsSecurityEvents
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsSecurityScanningAlert"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsSecurityScanningAlert>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsSingleFile"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsSingleFile>
    for InstallationUnsuspendInstallationPermissionsSingleFile
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsStatuses"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsStatuses>
    for InstallationUnsuspendInstallationPermissionsStatuses
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsTeamDiscussions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsTeamDiscussions>
    for InstallationUnsuspendInstallationPermissionsTeamDiscussions
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsTeamDiscussions
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationPermissionsWorkflows"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"read\",\n    \"write\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationUnsuspendInstallationPermissionsWorkflows>
    for InstallationUnsuspendInstallationPermissionsWorkflows
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"all\",\n    \"selected\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationUnsuspendInstallationRepositorySelection>
    for InstallationUnsuspendInstallationRepositorySelection
{
    fn from(value: &InstallationUnsuspendInstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationTargetType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendInstallationTargetType {
    User,
    Organization,
}
impl From<&InstallationUnsuspendInstallationTargetType>
    for InstallationUnsuspendInstallationTargetType
{
    fn from(value: &InstallationUnsuspendInstallationTargetType) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendInstallationTargetType {
    fn to_string(&self) -> String {
        match *self {
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationTargetType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationTargetType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "InstallationUnsuspendInstallationUpdatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationUnsuspendInstallationUpdatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationUnsuspendInstallationUpdatedAt>
    for InstallationUnsuspendInstallationUpdatedAt
{
    fn from(value: &InstallationUnsuspendInstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationUnsuspendInstallationUpdatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendInstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationUnsuspendInstallationUpdatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationUnsuspendInstallationUpdatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationUnsuspendInstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "InstallationUnsuspendRepositoriesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"full_name\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"private\"\n  ],\n  \"properties\": {\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationUnsuspendRepositoriesItem> for InstallationUnsuspendRepositoriesItem {
    fn from(value: &InstallationUnsuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "InstallationUpdatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"integer\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationUpdatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationUpdatedAt> for InstallationUpdatedAt {
    fn from(value: &InstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationUpdatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationUpdatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationUpdatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Issue\",\n  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the issue; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Issue {
    pub active_lock_reason: Option<IssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&Issue> for Issue {
    fn from(value: &Issue) -> Self {
        value.clone()
    }
}
#[doc = "IssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssueActiveLockReason> for IssueActiveLockReason {
    fn from(value: &IssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issue comment\",\n  \"description\": \"The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"author_association\",\n    \"body\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"node_id\",\n    \"performed_via_github_app\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue comment\",\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the issue comment\",\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue comment\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueComment {
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue comment"]
    pub body: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub issue_url: String,
    pub node_id: String,
    pub performed_via_github_app: Option<App>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue comment"]
    pub url: String,
    pub user: User,
}
impl From<&IssueComment> for IssueComment {
    fn from(value: &IssueComment) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issue_comment created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/issue-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"assignee\",\n            \"labels\",\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"assignee\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            \"labels\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/label\"\n              }\n            },\n            \"locked\": {\n              \"type\": \"boolean\"\n            },\n            \"pull_request\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"diff_url\",\n                \"html_url\",\n                \"patch_url\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"diff_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"html_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"patch_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"state\": {\n              \"description\": \"State of the issue; either 'open' or 'closed'\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\",\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreated {
    pub action: IssueCommentCreatedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssueCommentCreatedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentCreated> for IssueCommentCreated {
    fn from(value: &IssueCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&IssueCommentCreatedAction> for IssueCommentCreatedAction {
    fn from(value: &IssueCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"labels_url\",\n    \"locked\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"allOf\": [\n            {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            {\n              \"$ref\": \"#/definitions/user\"\n            }\n          ]\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"diff_url\",\n        \"html_url\",\n        \"patch_url\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssue {
    pub active_lock_reason: Option<IssueCommentCreatedIssueActiveLockReason>,
    pub assignee: Option<IssueCommentCreatedIssueAssignee>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<Label>,
    pub labels_url: String,
    pub locked: bool,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssueCommentCreatedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssueCommentCreatedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssueCommentCreatedIssue> for IssueCommentCreatedIssue {
    fn from(value: &IssueCommentCreatedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentCreatedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssueCommentCreatedIssueActiveLockReason> for IssueCommentCreatedIssueActiveLockReason {
    fn from(value: &IssueCommentCreatedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentCreatedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentCreatedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentCreatedIssueAssignee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssueAssignee {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: IssueCommentCreatedIssueAssigneeType,
    pub url: String,
}
impl From<&IssueCommentCreatedIssueAssignee> for IssueCommentCreatedIssueAssignee {
    fn from(value: &IssueCommentCreatedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentCreatedIssueAssigneeType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl From<&IssueCommentCreatedIssueAssigneeType> for IssueCommentCreatedIssueAssigneeType {
    fn from(value: &IssueCommentCreatedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentCreatedIssueAssigneeType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedIssueAssigneeType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentCreatedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentCreatedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"diff_url\",\n    \"html_url\",\n    \"patch_url\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssuePullRequest {
    pub diff_url: String,
    pub html_url: String,
    pub patch_url: String,
    pub url: String,
}
impl From<&IssueCommentCreatedIssuePullRequest> for IssueCommentCreatedIssuePullRequest {
    fn from(value: &IssueCommentCreatedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentCreatedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssueCommentCreatedIssueState> for IssueCommentCreatedIssueState {
    fn from(value: &IssueCommentCreatedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentCreatedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentCreatedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issue_comment deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/issue-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"assignee\",\n            \"labels\",\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"assignee\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            \"labels\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/label\"\n              }\n            },\n            \"locked\": {\n              \"type\": \"boolean\"\n            },\n            \"pull_request\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"diff_url\",\n                \"html_url\",\n                \"patch_url\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"diff_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"html_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"patch_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"state\": {\n              \"description\": \"State of the issue; either 'open' or 'closed'\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\",\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeleted {
    pub action: IssueCommentDeletedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssueCommentDeletedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentDeleted> for IssueCommentDeleted {
    fn from(value: &IssueCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&IssueCommentDeletedAction> for IssueCommentDeletedAction {
    fn from(value: &IssueCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"labels_url\",\n    \"locked\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"allOf\": [\n            {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            {\n              \"$ref\": \"#/definitions/user\"\n            }\n          ]\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"diff_url\",\n        \"html_url\",\n        \"patch_url\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssue {
    pub active_lock_reason: Option<IssueCommentDeletedIssueActiveLockReason>,
    pub assignee: Option<IssueCommentDeletedIssueAssignee>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<Label>,
    pub labels_url: String,
    pub locked: bool,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssueCommentDeletedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssueCommentDeletedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssueCommentDeletedIssue> for IssueCommentDeletedIssue {
    fn from(value: &IssueCommentDeletedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentDeletedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssueCommentDeletedIssueActiveLockReason> for IssueCommentDeletedIssueActiveLockReason {
    fn from(value: &IssueCommentDeletedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentDeletedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentDeletedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentDeletedIssueAssignee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssueAssignee {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: IssueCommentDeletedIssueAssigneeType,
    pub url: String,
}
impl From<&IssueCommentDeletedIssueAssignee> for IssueCommentDeletedIssueAssignee {
    fn from(value: &IssueCommentDeletedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentDeletedIssueAssigneeType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl From<&IssueCommentDeletedIssueAssigneeType> for IssueCommentDeletedIssueAssigneeType {
    fn from(value: &IssueCommentDeletedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentDeletedIssueAssigneeType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedIssueAssigneeType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentDeletedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentDeletedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"diff_url\",\n    \"html_url\",\n    \"patch_url\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssuePullRequest {
    pub diff_url: String,
    pub html_url: String,
    pub patch_url: String,
    pub url: String,
}
impl From<&IssueCommentDeletedIssuePullRequest> for IssueCommentDeletedIssuePullRequest {
    fn from(value: &IssueCommentDeletedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentDeletedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssueCommentDeletedIssueState> for IssueCommentDeletedIssueState {
    fn from(value: &IssueCommentDeletedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentDeletedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentDeletedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issue_comment edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"comment\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the comment.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/issue-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"assignee\",\n            \"labels\",\n            \"locked\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"assignee\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            \"labels\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/label\"\n              }\n            },\n            \"locked\": {\n              \"type\": \"boolean\"\n            },\n            \"pull_request\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"diff_url\",\n                \"html_url\",\n                \"patch_url\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"diff_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"html_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"patch_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"state\": {\n              \"description\": \"State of the issue; either 'open' or 'closed'\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\",\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEdited {
    pub action: IssueCommentEditedAction,
    pub changes: IssueCommentEditedChanges,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssueCommentEditedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentEdited> for IssueCommentEdited {
    fn from(value: &IssueCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&IssueCommentEditedAction> for IssueCommentEditedAction {
    fn from(value: &IssueCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the comment.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssueCommentEditedChangesBody>,
}
impl From<&IssueCommentEditedChanges> for IssueCommentEditedChanges {
    fn from(value: &IssueCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&IssueCommentEditedChangesBody> for IssueCommentEditedChangesBody {
    fn from(value: &IssueCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"labels_url\",\n    \"locked\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"allOf\": [\n            {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                {\n                  \"type\": \"null\"\n                }\n              ]\n            },\n            {\n              \"$ref\": \"#/definitions/user\"\n            }\n          ]\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"diff_url\",\n        \"html_url\",\n        \"patch_url\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssue {
    pub active_lock_reason: Option<IssueCommentEditedIssueActiveLockReason>,
    pub assignee: Option<IssueCommentEditedIssueAssignee>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<Label>,
    pub labels_url: String,
    pub locked: bool,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssueCommentEditedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssueCommentEditedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssueCommentEditedIssue> for IssueCommentEditedIssue {
    fn from(value: &IssueCommentEditedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentEditedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssueCommentEditedIssueActiveLockReason> for IssueCommentEditedIssueActiveLockReason {
    fn from(value: &IssueCommentEditedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentEditedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentEditedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentEditedIssueAssignee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssueAssignee {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: IssueCommentEditedIssueAssigneeType,
    pub url: String,
}
impl From<&IssueCommentEditedIssueAssignee> for IssueCommentEditedIssueAssignee {
    fn from(value: &IssueCommentEditedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentEditedIssueAssigneeType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl From<&IssueCommentEditedIssueAssigneeType> for IssueCommentEditedIssueAssigneeType {
    fn from(value: &IssueCommentEditedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentEditedIssueAssigneeType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedIssueAssigneeType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentEditedIssueAssigneeType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentEditedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"diff_url\",\n    \"html_url\",\n    \"patch_url\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssuePullRequest {
    pub diff_url: String,
    pub html_url: String,
    pub patch_url: String,
    pub url: String,
}
impl From<&IssueCommentEditedIssuePullRequest> for IssueCommentEditedIssuePullRequest {
    fn from(value: &IssueCommentEditedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssueCommentEditedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssueCommentEditedIssueState> for IssueCommentEditedIssueState {
    fn from(value: &IssueCommentEditedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentEditedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentEditedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssueCommentEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/issue_comment$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/issue_comment$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/issue_comment$edited\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssueCommentEvent {
    Created(IssueCommentCreated),
    Deleted(IssueCommentDeleted),
    Edited(IssueCommentEdited),
}
impl From<&IssueCommentEvent> for IssueCommentEvent {
    fn from(value: &IssueCommentEvent) -> Self {
        value.clone()
    }
}
impl From<IssueCommentCreated> for IssueCommentEvent {
    fn from(value: IssueCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<IssueCommentDeleted> for IssueCommentEvent {
    fn from(value: IssueCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<IssueCommentEdited> for IssueCommentEvent {
    fn from(value: IssueCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "IssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuePullRequest> for IssuePullRequest {
    fn from(value: &IssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the issue; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssueState> for IssueState {
    fn from(value: &IssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to an issue. The type of activity is specified in the action property."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues assigned event\",\n  \"description\": \"Activity related to an issue. The type of activity is specified in the action property.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"description\": \"The action that was performed.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"assigned\"\n      ]\n    },\n    \"assignee\": {\n      \"description\": \"The optional user who was assigned or unassigned from the issue.\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesAssigned {
    #[doc = "The action that was performed."]
    pub action: IssuesAssignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesAssigned> for IssuesAssigned {
    fn from(value: &IssuesAssigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action that was performed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"assigned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl From<&IssuesAssignedAction> for IssuesAssignedAction {
    fn from(value: &IssuesAssignedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesClosed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues closed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"description\": \"The action that was performed.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"string\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosed {
    #[doc = "The action that was performed."]
    pub action: IssuesClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesClosedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesClosed> for IssuesClosed {
    fn from(value: &IssuesClosed) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action that was performed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesClosedAction> for IssuesClosedAction {
    fn from(value: &IssuesClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosedIssue {
    pub active_lock_reason: Option<IssuesClosedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: chrono::DateTime<chrono::offset::Utc>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesClosedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssuesClosedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesClosedIssue> for IssuesClosedIssue {
    fn from(value: &IssuesClosedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesClosedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesClosedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesClosedIssueActiveLockReason> for IssuesClosedIssueActiveLockReason {
    fn from(value: &IssuesClosedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesClosedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesClosedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesClosedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesClosedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesClosedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesClosedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesClosedIssuePullRequest> for IssuesClosedIssuePullRequest {
    fn from(value: &IssuesClosedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssuesClosedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesClosedIssueState {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesClosedIssueState> for IssuesClosedIssueState {
    fn from(value: &IssuesClosedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesClosedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesClosedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesClosedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesClosedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesClosedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDeleted {
    pub action: IssuesDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesDeleted> for IssuesDeleted {
    fn from(value: &IssuesDeleted) -> Self {
        value.clone()
    }
}
#[doc = "IssuesDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&IssuesDeletedAction> for IssuesDeletedAction {
    fn from(value: &IssuesDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesDemilestoned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues demilestoned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"demilestoned\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"milestone\"\n          ],\n          \"properties\": {\n            \"milestone\": {\n              \"type\": \"null\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"milestone\": {\n      \"$ref\": \"#/definitions/milestone\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestoned {
    pub action: IssuesDemilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesDemilestonedIssue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesDemilestoned> for IssuesDemilestoned {
    fn from(value: &IssuesDemilestoned) -> Self {
        value.clone()
    }
}
#[doc = "IssuesDemilestonedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"demilestoned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDemilestonedAction {
    #[serde(rename = "demilestoned")]
    Demilestoned,
}
impl From<&IssuesDemilestonedAction> for IssuesDemilestonedAction {
    fn from(value: &IssuesDemilestonedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDemilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Demilestoned => "demilestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDemilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "demilestoned" => Ok(Self::Demilestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesDemilestonedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"type\": \"null\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the issue; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestonedIssue {
    pub active_lock_reason: Option<IssuesDemilestonedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: (),
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesDemilestonedIssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssuesDemilestonedIssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesDemilestonedIssue> for IssuesDemilestonedIssue {
    fn from(value: &IssuesDemilestonedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesDemilestonedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDemilestonedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesDemilestonedIssueActiveLockReason> for IssuesDemilestonedIssueActiveLockReason {
    fn from(value: &IssuesDemilestonedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDemilestonedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDemilestonedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDemilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesDemilestonedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestonedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesDemilestonedIssuePullRequest> for IssuesDemilestonedIssuePullRequest {
    fn from(value: &IssuesDemilestonedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the issue; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDemilestonedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesDemilestonedIssueState> for IssuesDemilestonedIssueState {
    fn from(value: &IssuesDemilestonedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDemilestonedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDemilestonedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDemilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the issue.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"title\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the title.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"label\": {\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEdited {
    pub action: IssuesEditedAction,
    pub changes: IssuesEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesEdited> for IssuesEdited {
    fn from(value: &IssuesEdited) -> Self {
        value.clone()
    }
}
#[doc = "IssuesEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&IssuesEditedAction> for IssuesEditedAction {
    fn from(value: &IssuesEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the issue."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the issue.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"title\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the title.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssuesEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<IssuesEditedChangesTitle>,
}
impl From<&IssuesEditedChanges> for IssuesEditedChanges {
    fn from(value: &IssuesEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "IssuesEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&IssuesEditedChangesBody> for IssuesEditedChangesBody {
    fn from(value: &IssuesEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "IssuesEditedChangesTitle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the title.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesTitle {
    #[doc = "The previous version of the title."]
    pub from: String,
}
impl From<&IssuesEditedChangesTitle> for IssuesEditedChangesTitle {
    fn from(value: &IssuesEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "IssuesEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/issues$assigned\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$closed\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$demilestoned\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$labeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$locked\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$milestoned\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$opened\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$pinned\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$reopened\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$transferred\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$unassigned\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$unlabeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$unlocked\"\n    },\n    {\n      \"$ref\": \"#/definitions/issues$unpinned\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssuesEvent {
    Assigned(IssuesAssigned),
    Closed(IssuesClosed),
    Deleted(IssuesDeleted),
    Demilestoned(IssuesDemilestoned),
    Edited(IssuesEdited),
    Labeled(IssuesLabeled),
    Locked(IssuesLocked),
    Milestoned(IssuesMilestoned),
    Opened(IssuesOpened),
    Pinned(IssuesPinned),
    Reopened(IssuesReopened),
    Transferred(IssuesTransferred),
    Unassigned(IssuesUnassigned),
    Unlabeled(IssuesUnlabeled),
    Unlocked(IssuesUnlocked),
    Unpinned(IssuesUnpinned),
}
impl From<&IssuesEvent> for IssuesEvent {
    fn from(value: &IssuesEvent) -> Self {
        value.clone()
    }
}
impl From<IssuesAssigned> for IssuesEvent {
    fn from(value: IssuesAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl From<IssuesClosed> for IssuesEvent {
    fn from(value: IssuesClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<IssuesDeleted> for IssuesEvent {
    fn from(value: IssuesDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<IssuesDemilestoned> for IssuesEvent {
    fn from(value: IssuesDemilestoned) -> Self {
        Self::Demilestoned(value)
    }
}
impl From<IssuesEdited> for IssuesEvent {
    fn from(value: IssuesEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<IssuesLabeled> for IssuesEvent {
    fn from(value: IssuesLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<IssuesLocked> for IssuesEvent {
    fn from(value: IssuesLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<IssuesMilestoned> for IssuesEvent {
    fn from(value: IssuesMilestoned) -> Self {
        Self::Milestoned(value)
    }
}
impl From<IssuesOpened> for IssuesEvent {
    fn from(value: IssuesOpened) -> Self {
        Self::Opened(value)
    }
}
impl From<IssuesPinned> for IssuesEvent {
    fn from(value: IssuesPinned) -> Self {
        Self::Pinned(value)
    }
}
impl From<IssuesReopened> for IssuesEvent {
    fn from(value: IssuesReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<IssuesTransferred> for IssuesEvent {
    fn from(value: IssuesTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<IssuesUnassigned> for IssuesEvent {
    fn from(value: IssuesUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl From<IssuesUnlabeled> for IssuesEvent {
    fn from(value: IssuesUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<IssuesUnlocked> for IssuesEvent {
    fn from(value: IssuesUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl From<IssuesUnpinned> for IssuesEvent {
    fn from(value: IssuesUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[doc = "IssuesLabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues labeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"labeled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"label\": {\n      \"description\": \"The label that was added to the issue.\",\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLabeled {
    pub action: IssuesLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was added to the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesLabeled> for IssuesLabeled {
    fn from(value: &IssuesLabeled) -> Self {
        value.clone()
    }
}
#[doc = "IssuesLabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"labeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&IssuesLabeledAction> for IssuesLabeledAction {
    fn from(value: &IssuesLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesLocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues locked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"locked\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"active_lock_reason\",\n            \"locked\"\n          ],\n          \"properties\": {\n            \"active_lock_reason\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"enum\": [\n                \"resolved\",\n                \"off-topic\",\n                \"too heated\",\n                \"spam\",\n                null\n              ]\n            },\n            \"locked\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLocked {
    pub action: IssuesLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesLockedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesLocked> for IssuesLocked {
    fn from(value: &IssuesLocked) -> Self {
        value.clone()
    }
}
#[doc = "IssuesLockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"locked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&IssuesLockedAction> for IssuesLockedAction {
    fn from(value: &IssuesLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesLockedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"locked\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the issue; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLockedIssue {
    pub active_lock_reason: Option<IssuesLockedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    pub locked: bool,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesLockedIssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssuesLockedIssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesLockedIssue> for IssuesLockedIssue {
    fn from(value: &IssuesLockedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesLockedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLockedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesLockedIssueActiveLockReason> for IssuesLockedIssueActiveLockReason {
    fn from(value: &IssuesLockedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLockedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLockedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLockedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLockedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLockedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesLockedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLockedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesLockedIssuePullRequest> for IssuesLockedIssuePullRequest {
    fn from(value: &IssuesLockedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the issue; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLockedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesLockedIssueState> for IssuesLockedIssueState {
    fn from(value: &IssuesLockedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLockedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLockedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLockedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLockedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLockedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesMilestoned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues milestoned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"milestoned\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"milestone\"\n          ],\n          \"properties\": {\n            \"milestone\": {\n              \"$ref\": \"#/definitions/milestone\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"milestone\": {\n      \"$ref\": \"#/definitions/milestone\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestoned {
    pub action: IssuesMilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesMilestonedIssue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesMilestoned> for IssuesMilestoned {
    fn from(value: &IssuesMilestoned) -> Self {
        value.clone()
    }
}
#[doc = "IssuesMilestonedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"milestoned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedAction {
    #[serde(rename = "milestoned")]
    Milestoned,
}
impl From<&IssuesMilestonedAction> for IssuesMilestonedAction {
    fn from(value: &IssuesMilestonedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesMilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Milestoned => "milestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "milestoned" => Ok(Self::Milestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesMilestonedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"allOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"closed_issues\",\n            \"created_at\",\n            \"creator\",\n            \"description\",\n            \"due_on\",\n            \"html_url\",\n            \"id\",\n            \"labels_url\",\n            \"node_id\",\n            \"number\",\n            \"open_issues\",\n            \"state\",\n            \"title\",\n            \"updated_at\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"format\": \"date-time\"\n            },\n            \"closed_issues\": {\n              \"type\": \"integer\"\n            },\n            \"created_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"creator\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"description\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"due_on\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ],\n              \"format\": \"date-time\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"labels_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"node_id\": {\n              \"type\": \"string\"\n            },\n            \"number\": {\n              \"description\": \"The number of the milestone.\",\n              \"type\": \"integer\"\n            },\n            \"open_issues\": {\n              \"type\": \"integer\"\n            },\n            \"state\": {\n              \"description\": \"The state of the milestone.\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\",\n                \"closed\"\n              ]\n            },\n            \"title\": {\n              \"description\": \"The title of the milestone.\",\n              \"type\": \"string\"\n            },\n            \"updated_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the issue; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssue {
    pub active_lock_reason: Option<IssuesMilestonedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: IssuesMilestonedIssueMilestone,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesMilestonedIssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssuesMilestonedIssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesMilestonedIssue> for IssuesMilestonedIssue {
    fn from(value: &IssuesMilestonedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesMilestonedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesMilestonedIssueActiveLockReason> for IssuesMilestonedIssueActiveLockReason {
    fn from(value: &IssuesMilestonedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesMilestonedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesMilestonedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesMilestonedIssueMilestone"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"closed_at\",\n    \"closed_issues\",\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"due_on\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"node_id\",\n    \"number\",\n    \"open_issues\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"closed_at\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"closed_issues\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ]\n    },\n    \"due_on\": {\n      \"type\": [\n        \"null\",\n        \"string\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssueMilestone {
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    pub number: i64,
    pub open_issues: i64,
    pub state: IssuesMilestonedIssueMilestoneState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&IssuesMilestonedIssueMilestone> for IssuesMilestonedIssueMilestone {
    fn from(value: &IssuesMilestonedIssueMilestone) -> Self {
        value.clone()
    }
}
#[doc = "IssuesMilestonedIssueMilestoneState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedIssueMilestoneState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesMilestonedIssueMilestoneState> for IssuesMilestonedIssueMilestoneState {
    fn from(value: &IssuesMilestonedIssueMilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesMilestonedIssueMilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedIssueMilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedIssueMilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedIssueMilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesMilestonedIssueMilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesMilestonedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesMilestonedIssuePullRequest> for IssuesMilestonedIssuePullRequest {
    fn from(value: &IssuesMilestonedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the issue; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesMilestonedIssueState> for IssuesMilestonedIssueState {
    fn from(value: &IssuesMilestonedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesMilestonedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesMilestonedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesOpened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues opened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"opened\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"old_issue\",\n        \"old_repository\"\n      ],\n      \"properties\": {\n        \"old_issue\": {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        \"old_repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpened {
    pub action: IssuesOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<IssuesOpenedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesOpenedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesOpened> for IssuesOpened {
    fn from(value: &IssuesOpened) -> Self {
        value.clone()
    }
}
#[doc = "IssuesOpenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"opened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&IssuesOpenedAction> for IssuesOpenedAction {
    fn from(value: &IssuesOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesOpenedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"old_issue\",\n    \"old_repository\"\n  ],\n  \"properties\": {\n    \"old_issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"old_repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedChanges {
    pub old_issue: Issue,
    pub old_repository: Repository,
}
impl From<&IssuesOpenedChanges> for IssuesOpenedChanges {
    fn from(value: &IssuesOpenedChanges) -> Self {
        value.clone()
    }
}
#[doc = "IssuesOpenedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedIssue {
    pub active_lock_reason: Option<IssuesOpenedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesOpenedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssuesOpenedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesOpenedIssue> for IssuesOpenedIssue {
    fn from(value: &IssuesOpenedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesOpenedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesOpenedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesOpenedIssueActiveLockReason> for IssuesOpenedIssueActiveLockReason {
    fn from(value: &IssuesOpenedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesOpenedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesOpenedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesOpenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesOpenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesOpenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesOpenedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesOpenedIssuePullRequest> for IssuesOpenedIssuePullRequest {
    fn from(value: &IssuesOpenedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssuesOpenedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesOpenedIssueState {
    #[serde(rename = "open")]
    Open,
}
impl From<&IssuesOpenedIssueState> for IssuesOpenedIssueState {
    fn from(value: &IssuesOpenedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesOpenedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesOpenedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesOpenedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesOpenedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesOpenedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesPinned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues pinned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pinned\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesPinned {
    pub action: IssuesPinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesPinned> for IssuesPinned {
    fn from(value: &IssuesPinned) -> Self {
        value.clone()
    }
}
#[doc = "IssuesPinnedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pinned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl From<&IssuesPinnedAction> for IssuesPinnedAction {
    fn from(value: &IssuesPinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesReopened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues reopened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"state\"\n          ],\n          \"properties\": {\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopened {
    pub action: IssuesReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesReopenedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesReopened> for IssuesReopened {
    fn from(value: &IssuesReopened) -> Self {
        value.clone()
    }
}
#[doc = "IssuesReopenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&IssuesReopenedAction> for IssuesReopenedAction {
    fn from(value: &IssuesReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesReopenedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopenedIssue {
    pub active_lock_reason: Option<IssuesReopenedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesReopenedIssuePullRequest>,
    pub repository_url: String,
    pub state: IssuesReopenedIssueState,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesReopenedIssue> for IssuesReopenedIssue {
    fn from(value: &IssuesReopenedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesReopenedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesReopenedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssuesReopenedIssueActiveLockReason> for IssuesReopenedIssueActiveLockReason {
    fn from(value: &IssuesReopenedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssuesReopenedIssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesReopenedIssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesReopenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesReopenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesReopenedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesReopenedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopenedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesReopenedIssuePullRequest> for IssuesReopenedIssuePullRequest {
    fn from(value: &IssuesReopenedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "IssuesReopenedIssueState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesReopenedIssueState {
    #[serde(rename = "open")]
    Open,
}
impl From<&IssuesReopenedIssueState> for IssuesReopenedIssueState {
    fn from(value: &IssuesReopenedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesReopenedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesReopenedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesReopenedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesReopenedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesReopenedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesTransferred"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues transferred event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"transferred\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"new_issue\",\n        \"new_repository\"\n      ],\n      \"properties\": {\n        \"new_issue\": {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        \"new_repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferred {
    pub action: IssuesTransferredAction,
    pub changes: IssuesTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesTransferred> for IssuesTransferred {
    fn from(value: &IssuesTransferred) -> Self {
        value.clone()
    }
}
#[doc = "IssuesTransferredAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"transferred\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&IssuesTransferredAction> for IssuesTransferredAction {
    fn from(value: &IssuesTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesTransferredChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"new_issue\",\n    \"new_repository\"\n  ],\n  \"properties\": {\n    \"new_issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"new_repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferredChanges {
    pub new_issue: Issue,
    pub new_repository: Repository,
}
impl From<&IssuesTransferredChanges> for IssuesTransferredChanges {
    fn from(value: &IssuesTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "IssuesUnassigned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues unassigned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"description\": \"The action that was performed.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"unassigned\"\n      ]\n    },\n    \"assignee\": {\n      \"description\": \"The optional user who was assigned or unassigned from the issue.\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnassigned {
    #[doc = "The action that was performed."]
    pub action: IssuesUnassignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnassigned> for IssuesUnassigned {
    fn from(value: &IssuesUnassigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The action that was performed.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"unassigned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl From<&IssuesUnassignedAction> for IssuesUnassignedAction {
    fn from(value: &IssuesUnassignedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesUnlabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues unlabeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlabeled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"label\": {\n      \"description\": \"The label that was removed from the issue.\",\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlabeled {
    pub action: IssuesUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was removed from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnlabeled> for IssuesUnlabeled {
    fn from(value: &IssuesUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "IssuesUnlabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlabeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&IssuesUnlabeledAction> for IssuesUnlabeledAction {
    fn from(value: &IssuesUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesUnlocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues unlocked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlocked\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/issue\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"active_lock_reason\",\n            \"locked\"\n          ],\n          \"properties\": {\n            \"active_lock_reason\": {\n              \"type\": \"null\"\n            },\n            \"locked\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlocked {
    pub action: IssuesUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: IssuesUnlockedIssue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnlocked> for IssuesUnlocked {
    fn from(value: &IssuesUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "IssuesUnlockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlocked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&IssuesUnlockedAction> for IssuesUnlockedAction {
    fn from(value: &IssuesUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesUnlockedIssue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"active_lock_reason\",\n    \"assignees\",\n    \"author_association\",\n    \"body\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"created_at\",\n    \"events_url\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"locked\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"repository_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"active_lock_reason\": {\n      \"type\": \"null\",\n      \"enum\": [\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"Contents of the issue\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"locked\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"performed_via_github_app\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/app\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the issue; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"Title of the issue\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the issue\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlockedIssue {
    pub active_lock_reason: IssuesUnlockedIssueActiveLockReason,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    pub locked: bool,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuesUnlockedIssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssuesUnlockedIssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&IssuesUnlockedIssue> for IssuesUnlockedIssue {
    fn from(value: &IssuesUnlockedIssue) -> Self {
        value.clone()
    }
}
#[doc = "IssuesUnlockedIssueActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"null\",\n  \"enum\": [\n    null\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Serialize)]
pub struct IssuesUnlockedIssueActiveLockReason(());
impl std::ops::Deref for IssuesUnlockedIssueActiveLockReason {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl From<IssuesUnlockedIssueActiveLockReason> for () {
    fn from(value: IssuesUnlockedIssueActiveLockReason) -> Self {
        value.0
    }
}
impl From<&IssuesUnlockedIssueActiveLockReason> for IssuesUnlockedIssueActiveLockReason {
    fn from(value: &IssuesUnlockedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<()> for IssuesUnlockedIssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: ()) -> Result<Self, &'static str> {
        if ![()].contains(&value) {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for IssuesUnlockedIssueActiveLockReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "IssuesUnlockedIssuePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlockedIssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuesUnlockedIssuePullRequest> for IssuesUnlockedIssuePullRequest {
    fn from(value: &IssuesUnlockedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the issue; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlockedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesUnlockedIssueState> for IssuesUnlockedIssueState {
    fn from(value: &IssuesUnlockedIssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnlockedIssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlockedIssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlockedIssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlockedIssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnlockedIssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "IssuesUnpinned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"issues unpinned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"issue\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unpinned\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/issue\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnpinned {
    pub action: IssuesUnpinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnpinned> for IssuesUnpinned {
    fn from(value: &IssuesUnpinned) -> Self {
        value.clone()
    }
}
#[doc = "IssuesUnpinnedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unpinned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl From<&IssuesUnpinnedAction> for IssuesUnpinnedAction {
    fn from(value: &IssuesUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Label"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Label\",\n  \"type\": \"object\",\n  \"required\": [\n    \"color\",\n    \"default\",\n    \"description\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"color\": {\n      \"description\": \"6-character hex code, without the leading #, identifying the color\",\n      \"type\": \"string\"\n    },\n    \"default\": {\n      \"type\": \"boolean\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"The name of the label.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"description\": \"URL for the label\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Label {
    #[doc = "6-character hex code, without the leading #, identifying the color"]
    pub color: String,
    pub default: bool,
    pub description: Option<String>,
    pub id: i64,
    #[doc = "The name of the label."]
    pub name: String,
    pub node_id: String,
    #[doc = "URL for the label"]
    pub url: String,
}
impl From<&Label> for Label {
    fn from(value: &Label) -> Self {
        value.clone()
    }
}
#[doc = "LabelCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"label created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"label\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"description\": \"The label that was added.\",\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelCreated {
    pub action: LabelCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was added."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelCreated> for LabelCreated {
    fn from(value: &LabelCreated) -> Self {
        value.clone()
    }
}
#[doc = "LabelCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&LabelCreatedAction> for LabelCreatedAction {
    fn from(value: &LabelCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for LabelCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "LabelDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"label deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"label\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"description\": \"The label that was removed.\",\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelDeleted {
    pub action: LabelDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was removed."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelDeleted> for LabelDeleted {
    fn from(value: &LabelDeleted) -> Self {
        value.clone()
    }
}
#[doc = "LabelDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&LabelDeletedAction> for LabelDeletedAction {
    fn from(value: &LabelDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for LabelDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "LabelEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"label edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"label\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the label if the action was `edited`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"color\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the color if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"description\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the description if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the name if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"description\": \"The label that was edited.\",\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEdited {
    pub action: LabelEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<LabelEditedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was edited."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelEdited> for LabelEdited {
    fn from(value: &LabelEdited) -> Self {
        value.clone()
    }
}
#[doc = "LabelEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&LabelEditedAction> for LabelEditedAction {
    fn from(value: &LabelEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for LabelEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the label if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the label if the action was `edited`.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"color\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the color if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"description\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the description if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the name if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<LabelEditedChangesColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<LabelEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<LabelEditedChangesName>,
}
impl From<&LabelEditedChanges> for LabelEditedChanges {
    fn from(value: &LabelEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "LabelEditedChangesColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the color if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesColor {
    #[doc = "The previous version of the color if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesColor> for LabelEditedChangesColor {
    fn from(value: &LabelEditedChangesColor) -> Self {
        value.clone()
    }
}
#[doc = "LabelEditedChangesDescription"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the description if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesDescription> for LabelEditedChangesDescription {
    fn from(value: &LabelEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "LabelEditedChangesName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the name if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesName> for LabelEditedChangesName {
    fn from(value: &LabelEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "LabelEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/label$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/label$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/label$edited\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelEvent {
    Created(LabelCreated),
    Deleted(LabelDeleted),
    Edited(LabelEdited),
}
impl From<&LabelEvent> for LabelEvent {
    fn from(value: &LabelEvent) -> Self {
        value.clone()
    }
}
impl From<LabelCreated> for LabelEvent {
    fn from(value: LabelCreated) -> Self {
        Self::Created(value)
    }
}
impl From<LabelDeleted> for LabelEvent {
    fn from(value: LabelDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<LabelEdited> for LabelEvent {
    fn from(value: LabelEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "License"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"License\",\n  \"type\": \"object\",\n  \"required\": [\n    \"key\",\n    \"name\",\n    \"node_id\",\n    \"spdx_id\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"key\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"spdx_id\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct License {
    pub key: String,
    pub name: String,
    pub node_id: String,
    pub spdx_id: String,
    pub url: Option<String>,
}
impl From<&License> for License {
    fn from(value: &License) -> Self {
        value.clone()
    }
}
#[doc = "Link"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Link\",\n  \"type\": \"object\",\n  \"required\": [\n    \"href\"\n  ],\n  \"properties\": {\n    \"href\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Link {
    pub href: String,
}
impl From<&Link> for Link {
    fn from(value: &Link) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Marketplace Purchase\",\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchase {
    pub account: MarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_billing_date: Option<String>,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchase> for MarketplacePurchase {
    fn from(value: &MarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchaseAccount> for MarketplacePurchaseAccount {
    fn from(value: &MarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseCancelled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"marketplace_purchase cancelled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"effective_date\",\n    \"marketplace_purchase\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"cancelled\"\n      ]\n    },\n    \"effective_date\": {\n      \"type\": \"string\"\n    },\n    \"marketplace_purchase\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/marketplace-purchase\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"next_billing_date\"\n          ],\n          \"properties\": {\n            \"next_billing_date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"previous_marketplace_purchase\": {\n      \"$ref\": \"#/definitions/marketplace-purchase\"\n    },\n    \"sender\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"avatar_url\",\n        \"email\",\n        \"events_url\",\n        \"followers_url\",\n        \"following_url\",\n        \"gists_url\",\n        \"gravatar_id\",\n        \"html_url\",\n        \"id\",\n        \"login\",\n        \"organizations_url\",\n        \"received_events_url\",\n        \"repos_url\",\n        \"site_admin\",\n        \"starred_url\",\n        \"subscriptions_url\",\n        \"type\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"avatar_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"email\": {\n          \"type\": \"string\"\n        },\n        \"events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"followers_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"following_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gists_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gravatar_id\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"organizations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"received_events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"repos_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"site_admin\": {\n          \"type\": \"boolean\"\n        },\n        \"starred_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"subscriptions_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelled {
    pub action: MarketplacePurchaseCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchaseCancelledMarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseCancelledSender,
}
impl From<&MarketplacePurchaseCancelled> for MarketplacePurchaseCancelled {
    fn from(value: &MarketplacePurchaseCancelled) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseCancelledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"cancelled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl From<&MarketplacePurchaseCancelledAction> for MarketplacePurchaseCancelledAction {
    fn from(value: &MarketplacePurchaseCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchaseCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MarketplacePurchaseCancelledMarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"next_billing_date\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchase {
    pub account: MarketplacePurchaseCancelledMarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    pub next_billing_date: String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchaseCancelledMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchaseCancelledMarketplacePurchase>
    for MarketplacePurchaseCancelledMarketplacePurchase
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseCancelledMarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchaseCancelledMarketplacePurchaseAccount>
    for MarketplacePurchaseCancelledMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseCancelledMarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchaseCancelledMarketplacePurchasePlan>
    for MarketplacePurchaseCancelledMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseCancelledSender"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"email\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": \"string\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchaseCancelledSender> for MarketplacePurchaseCancelledSender {
    fn from(value: &MarketplacePurchaseCancelledSender) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseChanged"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"marketplace_purchase changed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"effective_date\",\n    \"marketplace_purchase\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"changed\"\n      ]\n    },\n    \"effective_date\": {\n      \"type\": \"string\"\n    },\n    \"marketplace_purchase\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/marketplace-purchase\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"next_billing_date\"\n          ],\n          \"properties\": {\n            \"next_billing_date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"previous_marketplace_purchase\": {\n      \"$ref\": \"#/definitions/marketplace-purchase\"\n    },\n    \"sender\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"avatar_url\",\n        \"email\",\n        \"events_url\",\n        \"followers_url\",\n        \"following_url\",\n        \"gists_url\",\n        \"gravatar_id\",\n        \"html_url\",\n        \"id\",\n        \"login\",\n        \"organizations_url\",\n        \"received_events_url\",\n        \"repos_url\",\n        \"site_admin\",\n        \"starred_url\",\n        \"subscriptions_url\",\n        \"type\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"avatar_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"email\": {\n          \"type\": \"string\"\n        },\n        \"events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"followers_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"following_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gists_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gravatar_id\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"organizations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"received_events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"repos_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"site_admin\": {\n          \"type\": \"boolean\"\n        },\n        \"starred_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"subscriptions_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChanged {
    pub action: MarketplacePurchaseChangedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchaseChangedMarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseChangedSender,
}
impl From<&MarketplacePurchaseChanged> for MarketplacePurchaseChanged {
    fn from(value: &MarketplacePurchaseChanged) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseChangedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"changed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseChangedAction {
    #[serde(rename = "changed")]
    Changed,
}
impl From<&MarketplacePurchaseChangedAction> for MarketplacePurchaseChangedAction {
    fn from(value: &MarketplacePurchaseChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchaseChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Changed => "changed".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "changed" => Ok(Self::Changed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MarketplacePurchaseChangedMarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"next_billing_date\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchase {
    pub account: MarketplacePurchaseChangedMarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    pub next_billing_date: String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchaseChangedMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchaseChangedMarketplacePurchase>
    for MarketplacePurchaseChangedMarketplacePurchase
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseChangedMarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchaseChangedMarketplacePurchaseAccount>
    for MarketplacePurchaseChangedMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseChangedMarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchaseChangedMarketplacePurchasePlan>
    for MarketplacePurchaseChangedMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseChangedSender"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"email\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": \"string\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchaseChangedSender> for MarketplacePurchaseChangedSender {
    fn from(value: &MarketplacePurchaseChangedSender) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchaseEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase$cancelled\"\n    },\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase$changed\"\n    },\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase$pending_change\"\n    },\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase$pending_change_cancelled\"\n    },\n    {\n      \"$ref\": \"#/definitions/marketplace_purchase$purchased\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarketplacePurchaseEvent {
    Cancelled(MarketplacePurchaseCancelled),
    Changed(MarketplacePurchaseChanged),
    PendingChange(MarketplacePurchasePendingChange),
    PendingChangeCancelled(MarketplacePurchasePendingChangeCancelled),
    Purchased(MarketplacePurchasePurchased),
}
impl From<&MarketplacePurchaseEvent> for MarketplacePurchaseEvent {
    fn from(value: &MarketplacePurchaseEvent) -> Self {
        value.clone()
    }
}
impl From<MarketplacePurchaseCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl From<MarketplacePurchaseChanged> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseChanged) -> Self {
        Self::Changed(value)
    }
}
impl From<MarketplacePurchasePendingChange> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChange) -> Self {
        Self::PendingChange(value)
    }
}
impl From<MarketplacePurchasePendingChangeCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChangeCancelled) -> Self {
        Self::PendingChangeCancelled(value)
    }
}
impl From<MarketplacePurchasePurchased> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePurchased) -> Self {
        Self::Purchased(value)
    }
}
#[doc = "MarketplacePurchasePendingChange"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"marketplace_purchase pending_change event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"effective_date\",\n    \"marketplace_purchase\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pending_change\"\n      ]\n    },\n    \"effective_date\": {\n      \"type\": \"string\"\n    },\n    \"marketplace_purchase\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/marketplace-purchase\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"next_billing_date\"\n          ],\n          \"properties\": {\n            \"next_billing_date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"previous_marketplace_purchase\": {\n      \"$ref\": \"#/definitions/marketplace-purchase\"\n    },\n    \"sender\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"avatar_url\",\n        \"email\",\n        \"events_url\",\n        \"followers_url\",\n        \"following_url\",\n        \"gists_url\",\n        \"gravatar_id\",\n        \"html_url\",\n        \"id\",\n        \"login\",\n        \"organizations_url\",\n        \"received_events_url\",\n        \"repos_url\",\n        \"site_admin\",\n        \"starred_url\",\n        \"subscriptions_url\",\n        \"type\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"avatar_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"email\": {\n          \"type\": \"string\"\n        },\n        \"events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"followers_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"following_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gists_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gravatar_id\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"organizations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"received_events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"repos_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"site_admin\": {\n          \"type\": \"boolean\"\n        },\n        \"starred_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"subscriptions_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChange {
    pub action: MarketplacePurchasePendingChangeAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchasePendingChangeMarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeSender,
}
impl From<&MarketplacePurchasePendingChange> for MarketplacePurchasePendingChange {
    fn from(value: &MarketplacePurchasePendingChange) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pending_change\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeAction {
    #[serde(rename = "pending_change")]
    PendingChange,
}
impl From<&MarketplacePurchasePendingChangeAction> for MarketplacePurchasePendingChangeAction {
    fn from(value: &MarketplacePurchasePendingChangeAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePendingChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChange => "pending_change".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change" => Ok(Self::PendingChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"marketplace_purchase pending_change_cancelled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"effective_date\",\n    \"marketplace_purchase\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pending_change_cancelled\"\n      ]\n    },\n    \"effective_date\": {\n      \"type\": \"string\"\n    },\n    \"marketplace_purchase\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/marketplace-purchase\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"next_billing_date\"\n          ],\n          \"properties\": {\n            \"next_billing_date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"previous_marketplace_purchase\": {\n      \"$ref\": \"#/definitions/marketplace-purchase\"\n    },\n    \"sender\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"avatar_url\",\n        \"email\",\n        \"events_url\",\n        \"followers_url\",\n        \"following_url\",\n        \"gists_url\",\n        \"gravatar_id\",\n        \"html_url\",\n        \"id\",\n        \"login\",\n        \"organizations_url\",\n        \"received_events_url\",\n        \"repos_url\",\n        \"site_admin\",\n        \"starred_url\",\n        \"subscriptions_url\",\n        \"type\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"avatar_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"email\": {\n          \"type\": \"string\"\n        },\n        \"events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"followers_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"following_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gists_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gravatar_id\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"organizations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"received_events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"repos_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"site_admin\": {\n          \"type\": \"boolean\"\n        },\n        \"starred_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"subscriptions_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelled {
    pub action: MarketplacePurchasePendingChangeCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchasePendingChangeCancelledMarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeCancelledSender,
}
impl From<&MarketplacePurchasePendingChangeCancelled>
    for MarketplacePurchasePendingChangeCancelled
{
    fn from(value: &MarketplacePurchasePendingChangeCancelled) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pending_change_cancelled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeCancelledAction {
    #[serde(rename = "pending_change_cancelled")]
    PendingChangeCancelled,
}
impl From<&MarketplacePurchasePendingChangeCancelledAction>
    for MarketplacePurchasePendingChangeCancelledAction
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePendingChangeCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChangeCancelled => "pending_change_cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change_cancelled" => Ok(Self::PendingChangeCancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelledMarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"next_billing_date\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchase {
    pub account: MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    pub next_billing_date: String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchase>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeCancelledSender"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"email\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": \"string\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePendingChangeCancelledSender>
    for MarketplacePurchasePendingChangeCancelledSender
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledSender) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeMarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"next_billing_date\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchase {
    pub account: MarketplacePurchasePendingChangeMarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    pub next_billing_date: String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePendingChangeMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchasePendingChangeMarketplacePurchase>
    for MarketplacePurchasePendingChangeMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeMarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchasePendingChangeMarketplacePurchaseAccount>
    for MarketplacePurchasePendingChangeMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeMarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchasePendingChangeMarketplacePurchasePlan>
    for MarketplacePurchasePendingChangeMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePendingChangeSender"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"email\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": \"string\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePendingChangeSender> for MarketplacePurchasePendingChangeSender {
    fn from(value: &MarketplacePurchasePendingChangeSender) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchasePlan> for MarketplacePurchasePlan {
    fn from(value: &MarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePurchased"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"marketplace_purchase purchased event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"effective_date\",\n    \"marketplace_purchase\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"purchased\"\n      ]\n    },\n    \"effective_date\": {\n      \"type\": \"string\"\n    },\n    \"marketplace_purchase\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/marketplace-purchase\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"next_billing_date\"\n          ],\n          \"properties\": {\n            \"next_billing_date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"previous_marketplace_purchase\": {\n      \"$ref\": \"#/definitions/marketplace-purchase\"\n    },\n    \"sender\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"avatar_url\",\n        \"email\",\n        \"events_url\",\n        \"followers_url\",\n        \"following_url\",\n        \"gists_url\",\n        \"gravatar_id\",\n        \"html_url\",\n        \"id\",\n        \"login\",\n        \"organizations_url\",\n        \"received_events_url\",\n        \"repos_url\",\n        \"site_admin\",\n        \"starred_url\",\n        \"subscriptions_url\",\n        \"type\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"avatar_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"email\": {\n          \"type\": \"string\"\n        },\n        \"events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"followers_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"following_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gists_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"gravatar_id\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"organizations_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"received_events_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"repos_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"site_admin\": {\n          \"type\": \"boolean\"\n        },\n        \"starred_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"subscriptions_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchased {
    pub action: MarketplacePurchasePurchasedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchasePurchasedMarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePurchasedSender,
}
impl From<&MarketplacePurchasePurchased> for MarketplacePurchasePurchased {
    fn from(value: &MarketplacePurchasePurchased) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePurchasedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"purchased\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePurchasedAction {
    #[serde(rename = "purchased")]
    Purchased,
}
impl From<&MarketplacePurchasePurchasedAction> for MarketplacePurchasePurchasedAction {
    fn from(value: &MarketplacePurchasePurchasedAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePurchasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Purchased => "purchased".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePurchasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "purchased" => Ok(Self::Purchased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MarketplacePurchasePurchasedMarketplacePurchase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"account\",\n    \"billing_cycle\",\n    \"free_trial_ends_on\",\n    \"next_billing_date\",\n    \"on_free_trial\",\n    \"plan\",\n    \"unit_count\"\n  ],\n  \"properties\": {\n    \"account\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"login\",\n        \"node_id\",\n        \"organization_billing_email\",\n        \"type\"\n      ],\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"organization_billing_email\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"billing_cycle\": {\n      \"type\": \"string\"\n    },\n    \"free_trial_ends_on\": {\n      \"type\": \"null\"\n    },\n    \"next_billing_date\": {\n      \"type\": \"string\"\n    },\n    \"on_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"plan\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"bullets\",\n        \"description\",\n        \"has_free_trial\",\n        \"id\",\n        \"monthly_price_in_cents\",\n        \"name\",\n        \"price_model\",\n        \"unit_name\",\n        \"yearly_price_in_cents\"\n      ],\n      \"properties\": {\n        \"bullets\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"has_free_trial\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"monthly_price_in_cents\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"price_model\": {\n          \"type\": \"string\"\n        },\n        \"unit_name\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"yearly_price_in_cents\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"unit_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchase {
    pub account: MarketplacePurchasePurchasedMarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    pub next_billing_date: String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePurchasedMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchasePurchasedMarketplacePurchase>
    for MarketplacePurchasePurchasedMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePurchasedMarketplacePurchaseAccount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organization_billing_email\",\n    \"type\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organization_billing_email\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchasePurchasedMarketplacePurchaseAccount>
    for MarketplacePurchasePurchasedMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePurchasedMarketplacePurchasePlan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"bullets\",\n    \"description\",\n    \"has_free_trial\",\n    \"id\",\n    \"monthly_price_in_cents\",\n    \"name\",\n    \"price_model\",\n    \"unit_name\",\n    \"yearly_price_in_cents\"\n  ],\n  \"properties\": {\n    \"bullets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"has_free_trial\": {\n      \"type\": \"boolean\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"price_model\": {\n      \"type\": \"string\"\n    },\n    \"unit_name\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"yearly_price_in_cents\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchasePurchasedMarketplacePurchasePlan>
    for MarketplacePurchasePurchasedMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "MarketplacePurchasePurchasedSender"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"email\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": \"string\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePurchasedSender> for MarketplacePurchasePurchasedSender {
    fn from(value: &MarketplacePurchasePurchasedSender) -> Self {
        value.clone()
    }
}
#[doc = "Activity related to repository collaborators. The type of activity is specified in the action property."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"member added event\",\n  \"description\": \"Activity related to repository collaborators. The type of activity is specified in the action property.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"member\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"added\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"permission\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"to\"\n          ],\n          \"properties\": {\n            \"to\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"write\",\n                \"admin\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"member\": {\n      \"description\": \"The user that was added.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAdded {
    pub action: MemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<MemberAddedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was added."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberAdded> for MemberAdded {
    fn from(value: &MemberAdded) -> Self {
        value.clone()
    }
}
#[doc = "MemberAddedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"added\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&MemberAddedAction> for MemberAddedAction {
    fn from(value: &MemberAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MemberAddedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"permission\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"to\"\n      ],\n      \"properties\": {\n        \"to\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"write\",\n            \"admin\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<MemberAddedChangesPermission>,
}
impl From<&MemberAddedChanges> for MemberAddedChanges {
    fn from(value: &MemberAddedChanges) -> Self {
        value.clone()
    }
}
#[doc = "MemberAddedChangesPermission"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"to\"\n  ],\n  \"properties\": {\n    \"to\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"write\",\n        \"admin\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChangesPermission {
    pub to: MemberAddedChangesPermissionTo,
}
impl From<&MemberAddedChangesPermission> for MemberAddedChangesPermission {
    fn from(value: &MemberAddedChangesPermission) -> Self {
        value.clone()
    }
}
#[doc = "MemberAddedChangesPermissionTo"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"write\",\n    \"admin\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedChangesPermissionTo {
    #[serde(rename = "write")]
    Write,
    #[serde(rename = "admin")]
    Admin,
}
impl From<&MemberAddedChangesPermissionTo> for MemberAddedChangesPermissionTo {
    fn from(value: &MemberAddedChangesPermissionTo) -> Self {
        value.clone()
    }
}
impl ToString for MemberAddedChangesPermissionTo {
    fn to_string(&self) -> String {
        match *self {
            Self::Write => "write".to_string(),
            Self::Admin => "admin".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedChangesPermissionTo {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "write" => Ok(Self::Write),
            "admin" => Ok(Self::Admin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MemberEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"member edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"member\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the collaborator permissions\",\n      \"type\": \"object\",\n      \"required\": [\n        \"old_permission\"\n      ],\n      \"properties\": {\n        \"old_permission\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous permissions of the collaborator if the action was edited.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"member\": {\n      \"description\": \"The user who's permissions are changed.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEdited {
    pub action: MemberEditedAction,
    pub changes: MemberEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user who's permissions are changed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberEdited> for MemberEdited {
    fn from(value: &MemberEdited) -> Self {
        value.clone()
    }
}
#[doc = "MemberEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&MemberEditedAction> for MemberEditedAction {
    fn from(value: &MemberEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MemberEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the collaborator permissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the collaborator permissions\",\n  \"type\": \"object\",\n  \"required\": [\n    \"old_permission\"\n  ],\n  \"properties\": {\n    \"old_permission\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous permissions of the collaborator if the action was edited.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChanges {
    pub old_permission: MemberEditedChangesOldPermission,
}
impl From<&MemberEditedChanges> for MemberEditedChanges {
    fn from(value: &MemberEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "MemberEditedChangesOldPermission"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous permissions of the collaborator if the action was edited.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChangesOldPermission {
    #[doc = "The previous permissions of the collaborator if the action was edited."]
    pub from: String,
}
impl From<&MemberEditedChangesOldPermission> for MemberEditedChangesOldPermission {
    fn from(value: &MemberEditedChangesOldPermission) -> Self {
        value.clone()
    }
}
#[doc = "MemberEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/member$added\"\n    },\n    {\n      \"$ref\": \"#/definitions/member$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/member$removed\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MemberEvent {
    Added(MemberAdded),
    Edited(MemberEdited),
    Removed(MemberRemoved),
}
impl From<&MemberEvent> for MemberEvent {
    fn from(value: &MemberEvent) -> Self {
        value.clone()
    }
}
impl From<MemberAdded> for MemberEvent {
    fn from(value: MemberAdded) -> Self {
        Self::Added(value)
    }
}
impl From<MemberEdited> for MemberEvent {
    fn from(value: MemberEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<MemberRemoved> for MemberEvent {
    fn from(value: MemberRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "MemberRemoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"member removed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"member\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"removed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"member\": {\n      \"description\": \"The user that was removed.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberRemoved {
    pub action: MemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was removed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberRemoved> for MemberRemoved {
    fn from(value: &MemberRemoved) -> Self {
        value.clone()
    }
}
#[doc = "MemberRemovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&MemberRemovedAction> for MemberRemovedAction {
    fn from(value: &MemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Membership\",\n  \"description\": \"The membership between the user and the organization. Not present when the action is `member_invited`.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"organization_url\",\n    \"role\",\n    \"state\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"organization_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"role\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Membership {
    pub organization_url: String,
    pub role: String,
    pub state: String,
    pub url: String,
    pub user: User,
}
impl From<&Membership> for Membership {
    fn from(value: &Membership) -> Self {
        value.clone()
    }
}
#[doc = "MembershipAdded"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"membership added event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"member\",\n    \"organization\",\n    \"scope\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"added\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"member\": {\n      \"description\": \"The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"scope\": {\n      \"description\": \"The scope of the membership. Currently, can only be `team`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"team\"\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\",\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipAdded {
    pub action: MembershipAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipAddedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: Team,
}
impl From<&MembershipAdded> for MembershipAdded {
    fn from(value: &MembershipAdded) -> Self {
        value.clone()
    }
}
#[doc = "MembershipAddedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"added\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&MembershipAddedAction> for MembershipAddedAction {
    fn from(value: &MembershipAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for MembershipAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The scope of the membership. Currently, can only be `team`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"team\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedScope {
    #[serde(rename = "team")]
    Team,
}
impl From<&MembershipAddedScope> for MembershipAddedScope {
    fn from(value: &MembershipAddedScope) -> Self {
        value.clone()
    }
}
impl ToString for MembershipAddedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MembershipEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/membership$added\"\n    },\n    {\n      \"$ref\": \"#/definitions/membership$removed\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MembershipEvent {
    Added(MembershipAdded),
    Removed(MembershipRemoved),
}
impl From<&MembershipEvent> for MembershipEvent {
    fn from(value: &MembershipEvent) -> Self {
        value.clone()
    }
}
impl From<MembershipAdded> for MembershipEvent {
    fn from(value: MembershipAdded) -> Self {
        Self::Added(value)
    }
}
impl From<MembershipRemoved> for MembershipEvent {
    fn from(value: MembershipRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "MembershipRemoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"membership removed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"member\",\n    \"organization\",\n    \"scope\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"removed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"member\": {\n      \"description\": \"The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"scope\": {\n      \"description\": \"The scope of the membership. Currently, can only be `team`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"team\",\n        \"organization\"\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/team\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"id\",\n            \"name\"\n          ],\n          \"properties\": {\n            \"deleted\": {\n              \"type\": \"boolean\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipRemoved {
    pub action: MembershipRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipRemovedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: MembershipRemovedTeam,
}
impl From<&MembershipRemoved> for MembershipRemoved {
    fn from(value: &MembershipRemoved) -> Self {
        value.clone()
    }
}
#[doc = "MembershipRemovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&MembershipRemovedAction> for MembershipRemovedAction {
    fn from(value: &MembershipRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for MembershipRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The scope of the membership. Currently, can only be `team`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"team\",\n    \"organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedScope {
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "organization")]
    Organization,
}
impl From<&MembershipRemovedScope> for MembershipRemovedScope {
    fn from(value: &MembershipRemovedScope) -> Self {
        value.clone()
    }
}
impl ToString for MembershipRemovedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
            Self::Organization => "organization".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            "organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\",\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/team\"\n    },\n    {\n      \"type\": \"object\",\n      \"required\": [\n        \"id\",\n        \"name\"\n      ],\n      \"properties\": {\n        \"deleted\": {\n          \"type\": \"boolean\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum MembershipRemovedTeam {
    Variant0(Team),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        deleted: Option<bool>,
        id: i64,
        name: String,
    },
}
impl From<&MembershipRemovedTeam> for MembershipRemovedTeam {
    fn from(value: &MembershipRemovedTeam) -> Self {
        value.clone()
    }
}
impl From<Team> for MembershipRemovedTeam {
    fn from(value: Team) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "MetaDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"meta deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"hook\",\n    \"hook_id\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"hook\": {\n      \"description\": \"The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"active\",\n        \"config\",\n        \"created_at\",\n        \"events\",\n        \"id\",\n        \"name\",\n        \"type\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"active\": {\n          \"type\": \"boolean\"\n        },\n        \"config\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"content_type\",\n            \"insecure_ssl\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"content_type\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"json\",\n                \"form\"\n              ]\n            },\n            \"insecure_ssl\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"events\": {\n          \"$ref\": \"#/definitions/webhook-events\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"hook_id\": {\n      \"description\": \"The id of the modified webhook.\",\n      \"type\": \"integer\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeleted {
    pub action: MetaDeletedAction,
    pub hook: MetaDeletedHook,
    #[doc = "The id of the modified webhook."]
    pub hook_id: i64,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MetaDeleted> for MetaDeleted {
    fn from(value: &MetaDeleted) -> Self {
        value.clone()
    }
}
#[doc = "MetaDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&MetaDeletedAction> for MetaDeletedAction {
    fn from(value: &MetaDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for MetaDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active\",\n    \"config\",\n    \"created_at\",\n    \"events\",\n    \"id\",\n    \"name\",\n    \"type\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"active\": {\n      \"type\": \"boolean\"\n    },\n    \"config\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"content_type\",\n        \"insecure_ssl\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"content_type\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"json\",\n            \"form\"\n          ]\n        },\n        \"insecure_ssl\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"events\": {\n      \"$ref\": \"#/definitions/webhook-events\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHook {
    pub active: bool,
    pub config: MetaDeletedHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
}
impl From<&MetaDeletedHook> for MetaDeletedHook {
    fn from(value: &MetaDeletedHook) -> Self {
        value.clone()
    }
}
#[doc = "MetaDeletedHookConfig"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"content_type\",\n    \"insecure_ssl\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"content_type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"json\",\n        \"form\"\n      ]\n    },\n    \"insecure_ssl\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHookConfig {
    pub content_type: MetaDeletedHookConfigContentType,
    pub insecure_ssl: String,
    pub url: String,
}
impl From<&MetaDeletedHookConfig> for MetaDeletedHookConfig {
    fn from(value: &MetaDeletedHookConfig) -> Self {
        value.clone()
    }
}
#[doc = "MetaDeletedHookConfigContentType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"json\",\n    \"form\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl From<&MetaDeletedHookConfigContentType> for MetaDeletedHookConfigContentType {
    fn from(value: &MetaDeletedHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ToString for MetaDeletedHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MetaEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/meta$deleted\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MetaEvent(pub MetaDeleted);
impl std::ops::Deref for MetaEvent {
    type Target = MetaDeleted;
    fn deref(&self) -> &MetaDeleted {
        &self.0
    }
}
impl From<MetaEvent> for MetaDeleted {
    fn from(value: MetaEvent) -> Self {
        value.0
    }
}
impl From<&MetaEvent> for MetaEvent {
    fn from(value: &MetaEvent) -> Self {
        value.clone()
    }
}
impl From<MetaDeleted> for MetaEvent {
    fn from(value: MetaDeleted) -> Self {
        Self(value)
    }
}
#[doc = "A collection of related issues and pull requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Milestone\",\n  \"description\": \"A collection of related issues and pull requests.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"closed_at\",\n    \"closed_issues\",\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"due_on\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"node_id\",\n    \"number\",\n    \"open_issues\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"closed_issues\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"due_on\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"The number of the milestone.\",\n      \"type\": \"integer\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"description\": \"The state of the milestone.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"The title of the milestone.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Milestone {
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    #[doc = "The state of the milestone."]
    pub state: MilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&Milestone> for Milestone {
    fn from(value: &Milestone) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneClosed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"milestone closed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"milestone\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"string\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosed {
    pub action: MilestoneClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: MilestoneClosedMilestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneClosed> for MilestoneClosed {
    fn from(value: &MilestoneClosed) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneClosedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&MilestoneClosedAction> for MilestoneClosedAction {
    fn from(value: &MilestoneClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneClosedMilestone"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"closed_at\",\n    \"closed_issues\",\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"due_on\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"node_id\",\n    \"number\",\n    \"open_issues\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"closed_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"closed_issues\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"due_on\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"The number of the milestone.\",\n      \"type\": \"integer\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"The title of the milestone.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosedMilestone {
    pub closed_at: chrono::DateTime<chrono::offset::Utc>,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneClosedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&MilestoneClosedMilestone> for MilestoneClosedMilestone {
    fn from(value: &MilestoneClosedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneClosedMilestoneState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneClosedMilestoneState {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&MilestoneClosedMilestoneState> for MilestoneClosedMilestoneState {
    fn from(value: &MilestoneClosedMilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneClosedMilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneClosedMilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneClosedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneClosedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneClosedMilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"milestone created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"milestone\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreated {
    pub action: MilestoneCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: MilestoneCreatedMilestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneCreated> for MilestoneCreated {
    fn from(value: &MilestoneCreated) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&MilestoneCreatedAction> for MilestoneCreatedAction {
    fn from(value: &MilestoneCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneCreatedMilestone"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"closed_at\",\n    \"closed_issues\",\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"due_on\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"node_id\",\n    \"number\",\n    \"open_issues\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"closed_issues\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"due_on\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"The number of the milestone.\",\n      \"type\": \"integer\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"The title of the milestone.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreatedMilestone {
    pub closed_at: (),
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneCreatedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&MilestoneCreatedMilestone> for MilestoneCreatedMilestone {
    fn from(value: &MilestoneCreatedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneCreatedMilestoneState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneCreatedMilestoneState {
    #[serde(rename = "open")]
    Open,
}
impl From<&MilestoneCreatedMilestoneState> for MilestoneCreatedMilestoneState {
    fn from(value: &MilestoneCreatedMilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneCreatedMilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneCreatedMilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneCreatedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneCreatedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneCreatedMilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"milestone deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"milestone\": {\n      \"$ref\": \"#/definitions/milestone\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneDeleted {
    pub action: MilestoneDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneDeleted> for MilestoneDeleted {
    fn from(value: &MilestoneDeleted) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&MilestoneDeletedAction> for MilestoneDeletedAction {
    fn from(value: &MilestoneDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"milestone edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the milestone if the action was `edited`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"description\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the description if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"due_on\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the due date if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"title\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the title if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"milestone\": {\n      \"$ref\": \"#/definitions/milestone\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEdited {
    pub action: MilestoneEditedAction,
    pub changes: MilestoneEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneEdited> for MilestoneEdited {
    fn from(value: &MilestoneEdited) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&MilestoneEditedAction> for MilestoneEditedAction {
    fn from(value: &MilestoneEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the milestone if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the milestone if the action was `edited`.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"description\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the description if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"due_on\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the due date if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"title\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the title if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<MilestoneEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub due_on: Option<MilestoneEditedChangesDueOn>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<MilestoneEditedChangesTitle>,
}
impl From<&MilestoneEditedChanges> for MilestoneEditedChanges {
    fn from(value: &MilestoneEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneEditedChangesDescription"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the description if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesDescription> for MilestoneEditedChangesDescription {
    fn from(value: &MilestoneEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneEditedChangesDueOn"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the due date if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDueOn {
    #[doc = "The previous version of the due date if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesDueOn> for MilestoneEditedChangesDueOn {
    fn from(value: &MilestoneEditedChangesDueOn) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneEditedChangesTitle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the title if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesTitle> for MilestoneEditedChangesTitle {
    fn from(value: &MilestoneEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/milestone$closed\"\n    },\n    {\n      \"$ref\": \"#/definitions/milestone$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/milestone$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/milestone$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/milestone$opened\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MilestoneEvent {
    Closed(MilestoneClosed),
    Created(MilestoneCreated),
    Deleted(MilestoneDeleted),
    Edited(MilestoneEdited),
    Opened(MilestoneOpened),
}
impl From<&MilestoneEvent> for MilestoneEvent {
    fn from(value: &MilestoneEvent) -> Self {
        value.clone()
    }
}
impl From<MilestoneClosed> for MilestoneEvent {
    fn from(value: MilestoneClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<MilestoneCreated> for MilestoneEvent {
    fn from(value: MilestoneCreated) -> Self {
        Self::Created(value)
    }
}
impl From<MilestoneDeleted> for MilestoneEvent {
    fn from(value: MilestoneDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<MilestoneEdited> for MilestoneEvent {
    fn from(value: MilestoneEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<MilestoneOpened> for MilestoneEvent {
    fn from(value: MilestoneOpened) -> Self {
        Self::Opened(value)
    }
}
#[doc = "MilestoneOpened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"milestone opened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"milestone\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"opened\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"milestone\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpened {
    pub action: MilestoneOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: MilestoneOpenedMilestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneOpened> for MilestoneOpened {
    fn from(value: &MilestoneOpened) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneOpenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"opened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&MilestoneOpenedAction> for MilestoneOpenedAction {
    fn from(value: &MilestoneOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "MilestoneOpenedMilestone"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"closed_at\",\n    \"closed_issues\",\n    \"created_at\",\n    \"creator\",\n    \"description\",\n    \"due_on\",\n    \"html_url\",\n    \"id\",\n    \"labels_url\",\n    \"node_id\",\n    \"number\",\n    \"open_issues\",\n    \"state\",\n    \"title\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"closed_issues\": {\n      \"type\": \"integer\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"due_on\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"The number of the milestone.\",\n      \"type\": \"integer\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"title\": {\n      \"description\": \"The title of the milestone.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpenedMilestone {
    pub closed_at: (),
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneOpenedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&MilestoneOpenedMilestone> for MilestoneOpenedMilestone {
    fn from(value: &MilestoneOpenedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "MilestoneOpenedMilestoneState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneOpenedMilestoneState {
    #[serde(rename = "open")]
    Open,
}
impl From<&MilestoneOpenedMilestoneState> for MilestoneOpenedMilestoneState {
    fn from(value: &MilestoneOpenedMilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneOpenedMilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneOpenedMilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneOpenedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneOpenedMilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneOpenedMilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The state of the milestone."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The state of the milestone.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&MilestoneState> for MilestoneState {
    fn from(value: &MilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "OrgBlockBlocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"org_block blocked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"blocked_user\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"blocked\"\n      ]\n    },\n    \"blocked_user\": {\n      \"description\": \"Information about the user that was blocked or unblocked.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockBlocked {
    pub action: OrgBlockBlockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrgBlockBlocked> for OrgBlockBlocked {
    fn from(value: &OrgBlockBlocked) -> Self {
        value.clone()
    }
}
#[doc = "OrgBlockBlockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"blocked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockBlockedAction {
    #[serde(rename = "blocked")]
    Blocked,
}
impl From<&OrgBlockBlockedAction> for OrgBlockBlockedAction {
    fn from(value: &OrgBlockBlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrgBlockBlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Blocked => "blocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockBlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "blocked" => Ok(Self::Blocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "OrgBlockEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/org_block$blocked\"\n    },\n    {\n      \"$ref\": \"#/definitions/org_block$unblocked\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrgBlockEvent {
    Blocked(OrgBlockBlocked),
    Unblocked(OrgBlockUnblocked),
}
impl From<&OrgBlockEvent> for OrgBlockEvent {
    fn from(value: &OrgBlockEvent) -> Self {
        value.clone()
    }
}
impl From<OrgBlockBlocked> for OrgBlockEvent {
    fn from(value: OrgBlockBlocked) -> Self {
        Self::Blocked(value)
    }
}
impl From<OrgBlockUnblocked> for OrgBlockEvent {
    fn from(value: OrgBlockUnblocked) -> Self {
        Self::Unblocked(value)
    }
}
#[doc = "OrgBlockUnblocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"org_block unblocked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"blocked_user\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unblocked\"\n      ]\n    },\n    \"blocked_user\": {\n      \"description\": \"Information about the user that was blocked or unblocked.\",\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockUnblocked {
    pub action: OrgBlockUnblockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrgBlockUnblocked> for OrgBlockUnblocked {
    fn from(value: &OrgBlockUnblocked) -> Self {
        value.clone()
    }
}
#[doc = "OrgBlockUnblockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unblocked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockUnblockedAction {
    #[serde(rename = "unblocked")]
    Unblocked,
}
impl From<&OrgBlockUnblockedAction> for OrgBlockUnblockedAction {
    fn from(value: &OrgBlockUnblockedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrgBlockUnblockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unblocked => "unblocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockUnblockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unblocked" => Ok(Self::Unblocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Organization"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Organization\",\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"description\",\n    \"events_url\",\n    \"hooks_url\",\n    \"id\",\n    \"issues_url\",\n    \"login\",\n    \"members_url\",\n    \"node_id\",\n    \"public_members_url\",\n    \"repos_url\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"members_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"public_members_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Organization {
    pub avatar_url: String,
    pub description: Option<String>,
    pub events_url: String,
    pub hooks_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    pub id: i64,
    pub issues_url: String,
    pub login: String,
    pub members_url: String,
    pub node_id: String,
    pub public_members_url: String,
    pub repos_url: String,
    pub url: String,
}
impl From<&Organization> for Organization {
    fn from(value: &Organization) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"organization deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"membership\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"membership\": {\n      \"$ref\": \"#/definitions/membership\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationDeleted {
    pub action: OrganizationDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationDeleted> for OrganizationDeleted {
    fn from(value: &OrganizationDeleted) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&OrganizationDeletedAction> for OrganizationDeletedAction {
    fn from(value: &OrganizationDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "OrganizationEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/organization$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/organization$member_added\"\n    },\n    {\n      \"$ref\": \"#/definitions/organization$member_invited\"\n    },\n    {\n      \"$ref\": \"#/definitions/organization$member_removed\"\n    },\n    {\n      \"$ref\": \"#/definitions/organization$renamed\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrganizationEvent {
    Deleted(OrganizationDeleted),
    MemberAdded(OrganizationMemberAdded),
    MemberInvited(OrganizationMemberInvited),
    MemberRemoved(OrganizationMemberRemoved),
    Renamed(OrganizationRenamed),
}
impl From<&OrganizationEvent> for OrganizationEvent {
    fn from(value: &OrganizationEvent) -> Self {
        value.clone()
    }
}
impl From<OrganizationDeleted> for OrganizationEvent {
    fn from(value: OrganizationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<OrganizationMemberAdded> for OrganizationEvent {
    fn from(value: OrganizationMemberAdded) -> Self {
        Self::MemberAdded(value)
    }
}
impl From<OrganizationMemberInvited> for OrganizationEvent {
    fn from(value: OrganizationMemberInvited) -> Self {
        Self::MemberInvited(value)
    }
}
impl From<OrganizationMemberRemoved> for OrganizationEvent {
    fn from(value: OrganizationMemberRemoved) -> Self {
        Self::MemberRemoved(value)
    }
}
impl From<OrganizationRenamed> for OrganizationEvent {
    fn from(value: OrganizationRenamed) -> Self {
        Self::Renamed(value)
    }
}
#[doc = "OrganizationMemberAdded"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"organization member_added event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"membership\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"member_added\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"membership\": {\n      \"$ref\": \"#/definitions/membership\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberAdded {
    pub action: OrganizationMemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationMemberAdded> for OrganizationMemberAdded {
    fn from(value: &OrganizationMemberAdded) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationMemberAddedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"member_added\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberAddedAction {
    #[serde(rename = "member_added")]
    MemberAdded,
}
impl From<&OrganizationMemberAddedAction> for OrganizationMemberAddedAction {
    fn from(value: &OrganizationMemberAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberAdded => "member_added".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_added" => Ok(Self::MemberAdded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "OrganizationMemberInvited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"organization member_invited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"invitation\",\n    \"organization\",\n    \"sender\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"member_invited\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"invitation\": {\n      \"description\": \"The invitation for the user or email if the action is `member_invited`.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"email\",\n        \"failed_at\",\n        \"failed_reason\",\n        \"id\",\n        \"invitation_teams_url\",\n        \"inviter\",\n        \"login\",\n        \"node_id\",\n        \"role\",\n        \"team_count\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"email\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"failed_at\": {\n          \"oneOf\": [\n            {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"failed_reason\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"id\": {\n          \"type\": \"number\"\n        },\n        \"invitation_teams_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"inviter\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"login\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"role\": {\n          \"type\": \"string\"\n        },\n        \"team_count\": {\n          \"type\": \"number\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvited {
    pub action: OrganizationMemberInvitedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub invitation: OrganizationMemberInvitedInvitation,
    pub organization: Organization,
    pub sender: User,
    pub user: User,
}
impl From<&OrganizationMemberInvited> for OrganizationMemberInvited {
    fn from(value: &OrganizationMemberInvited) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationMemberInvitedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"member_invited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberInvitedAction {
    #[serde(rename = "member_invited")]
    MemberInvited,
}
impl From<&OrganizationMemberInvitedAction> for OrganizationMemberInvitedAction {
    fn from(value: &OrganizationMemberInvitedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberInvitedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberInvited => "member_invited".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberInvitedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_invited" => Ok(Self::MemberInvited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The invitation for the user or email if the action is `member_invited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The invitation for the user or email if the action is `member_invited`.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"email\",\n    \"failed_at\",\n    \"failed_reason\",\n    \"id\",\n    \"invitation_teams_url\",\n    \"inviter\",\n    \"login\",\n    \"node_id\",\n    \"role\",\n    \"team_count\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"email\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"failed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"failed_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"id\": {\n      \"type\": \"number\"\n    },\n    \"invitation_teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"inviter\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"role\": {\n      \"type\": \"string\"\n    },\n    \"team_count\": {\n      \"type\": \"number\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvitedInvitation {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub email: Option<String>,
    pub failed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub failed_reason: Option<String>,
    pub id: f64,
    pub invitation_teams_url: String,
    pub inviter: User,
    pub login: String,
    pub node_id: String,
    pub role: String,
    pub team_count: f64,
}
impl From<&OrganizationMemberInvitedInvitation> for OrganizationMemberInvitedInvitation {
    fn from(value: &OrganizationMemberInvitedInvitation) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationMemberRemoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"organization member_removed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"membership\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"member_removed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"membership\": {\n      \"$ref\": \"#/definitions/membership\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberRemoved {
    pub action: OrganizationMemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationMemberRemoved> for OrganizationMemberRemoved {
    fn from(value: &OrganizationMemberRemoved) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationMemberRemovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"member_removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberRemovedAction {
    #[serde(rename = "member_removed")]
    MemberRemoved,
}
impl From<&OrganizationMemberRemovedAction> for OrganizationMemberRemovedAction {
    fn from(value: &OrganizationMemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberRemoved => "member_removed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_removed" => Ok(Self::MemberRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "OrganizationRenamed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"organization renamed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"membership\",\n    \"organization\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"renamed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"membership\": {\n      \"$ref\": \"#/definitions/membership\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamed {
    pub action: OrganizationRenamedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationRenamed> for OrganizationRenamed {
    fn from(value: &OrganizationRenamed) -> Self {
        value.clone()
    }
}
#[doc = "OrganizationRenamedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"renamed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl From<&OrganizationRenamedAction> for OrganizationRenamedAction {
    fn from(value: &OrganizationRenamedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PackageEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/package$published\"\n    },\n    {\n      \"$ref\": \"#/definitions/package$updated\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackageEvent {
    Published(PackagePublished),
    Updated(PackageUpdated),
}
impl From<&PackageEvent> for PackageEvent {
    fn from(value: &PackageEvent) -> Self {
        value.clone()
    }
}
impl From<PackagePublished> for PackageEvent {
    fn from(value: PackagePublished) -> Self {
        Self::Published(value)
    }
}
impl From<PackageUpdated> for PackageEvent {
    fn from(value: PackageUpdated) -> Self {
        Self::Updated(value)
    }
}
#[doc = "PackagePublished"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"package published event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"package\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"published\"\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"package\": {\n      \"description\": \"Information about the package.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"ecosystem\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"namespace\",\n        \"owner\",\n        \"package_type\",\n        \"package_version\",\n        \"registry\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"namespace\": {\n          \"type\": \"string\"\n        },\n        \"owner\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"package_type\": {\n          \"type\": \"string\"\n        },\n        \"package_version\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"author\",\n            \"body\",\n            \"body_html\",\n            \"created_at\",\n            \"description\",\n            \"docker_metadata\",\n            \"draft\",\n            \"html_url\",\n            \"id\",\n            \"installation_command\",\n            \"manifest\",\n            \"metadata\",\n            \"name\",\n            \"package_files\",\n            \"prerelease\",\n            \"release\",\n            \"source_url\",\n            \"summary\",\n            \"tag_name\",\n            \"target_commitish\",\n            \"target_oid\",\n            \"updated_at\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"author\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"body\": {\n              \"type\": \"string\"\n            },\n            \"body_html\": {\n              \"type\": \"string\"\n            },\n            \"created_at\": {\n              \"type\": \"string\"\n            },\n            \"description\": {\n              \"type\": \"string\"\n            },\n            \"docker_metadata\": {\n              \"type\": \"array\",\n              \"items\": {}\n            },\n            \"draft\": {\n              \"type\": \"boolean\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"installation_command\": {\n              \"type\": \"string\"\n            },\n            \"manifest\": {\n              \"type\": \"string\"\n            },\n            \"metadata\": {\n              \"type\": \"array\",\n              \"items\": {}\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"package_files\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"content_type\",\n                  \"created_at\",\n                  \"download_url\",\n                  \"id\",\n                  \"md5\",\n                  \"name\",\n                  \"sha1\",\n                  \"sha256\",\n                  \"size\",\n                  \"state\",\n                  \"updated_at\"\n                ],\n                \"properties\": {\n                  \"content_type\": {\n                    \"type\": \"string\"\n                  },\n                  \"created_at\": {\n                    \"type\": \"string\"\n                  },\n                  \"download_url\": {\n                    \"type\": \"string\",\n                    \"format\": \"uri\"\n                  },\n                  \"id\": {\n                    \"type\": \"integer\"\n                  },\n                  \"md5\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  },\n                  \"sha1\": {\n                    \"type\": \"string\"\n                  },\n                  \"sha256\": {\n                    \"type\": \"string\"\n                  },\n                  \"size\": {\n                    \"type\": \"integer\"\n                  },\n                  \"state\": {\n                    \"type\": \"string\"\n                  },\n                  \"updated_at\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              }\n            },\n            \"prerelease\": {\n              \"type\": \"boolean\"\n            },\n            \"release\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"author\",\n                \"created_at\",\n                \"draft\",\n                \"html_url\",\n                \"id\",\n                \"name\",\n                \"prerelease\",\n                \"published_at\",\n                \"tag_name\",\n                \"target_commitish\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"author\": {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                \"created_at\": {\n                  \"type\": \"string\"\n                },\n                \"draft\": {\n                  \"type\": \"boolean\"\n                },\n                \"html_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"id\": {\n                  \"type\": \"integer\"\n                },\n                \"name\": {\n                  \"type\": \"string\"\n                },\n                \"prerelease\": {\n                  \"type\": \"boolean\"\n                },\n                \"published_at\": {\n                  \"type\": \"string\"\n                },\n                \"tag_name\": {\n                  \"type\": \"string\"\n                },\n                \"target_commitish\": {\n                  \"type\": \"string\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"source_url\": {\n              \"type\": \"string\"\n            },\n            \"summary\": {\n              \"type\": \"string\"\n            },\n            \"tag_name\": {\n              \"type\": \"string\"\n            },\n            \"target_commitish\": {\n              \"type\": \"string\"\n            },\n            \"target_oid\": {\n              \"type\": \"string\"\n            },\n            \"updated_at\": {\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"registry\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"about_url\",\n            \"name\",\n            \"type\",\n            \"url\",\n            \"vendor\"\n          ],\n          \"properties\": {\n            \"about_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"type\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"vendor\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublished {
    pub action: PackagePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackagePublishedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PackagePublished> for PackagePublished {
    fn from(value: &PackagePublished) -> Self {
        value.clone()
    }
}
#[doc = "PackagePublishedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"published\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackagePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&PackagePublishedAction> for PackagePublishedAction {
    fn from(value: &PackagePublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for PackagePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for PackagePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Information about the package.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"ecosystem\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"namespace\",\n    \"owner\",\n    \"package_type\",\n    \"package_version\",\n    \"registry\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"namespace\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"package_type\": {\n      \"type\": \"string\"\n    },\n    \"package_version\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"body\",\n        \"body_html\",\n        \"created_at\",\n        \"description\",\n        \"docker_metadata\",\n        \"draft\",\n        \"html_url\",\n        \"id\",\n        \"installation_command\",\n        \"manifest\",\n        \"metadata\",\n        \"name\",\n        \"package_files\",\n        \"prerelease\",\n        \"release\",\n        \"source_url\",\n        \"summary\",\n        \"tag_name\",\n        \"target_commitish\",\n        \"target_oid\",\n        \"updated_at\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"body_html\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"docker_metadata\": {\n          \"type\": \"array\",\n          \"items\": {}\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"installation_command\": {\n          \"type\": \"string\"\n        },\n        \"manifest\": {\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"type\": \"array\",\n          \"items\": {}\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"package_files\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"content_type\",\n              \"created_at\",\n              \"download_url\",\n              \"id\",\n              \"md5\",\n              \"name\",\n              \"sha1\",\n              \"sha256\",\n              \"size\",\n              \"state\",\n              \"updated_at\"\n            ],\n            \"properties\": {\n              \"content_type\": {\n                \"type\": \"string\"\n              },\n              \"created_at\": {\n                \"type\": \"string\"\n              },\n              \"download_url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              \"id\": {\n                \"type\": \"integer\"\n              },\n              \"md5\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              },\n              \"sha1\": {\n                \"type\": \"string\"\n              },\n              \"sha256\": {\n                \"type\": \"string\"\n              },\n              \"size\": {\n                \"type\": \"integer\"\n              },\n              \"state\": {\n                \"type\": \"string\"\n              },\n              \"updated_at\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"prerelease\": {\n          \"type\": \"boolean\"\n        },\n        \"release\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"author\",\n            \"created_at\",\n            \"draft\",\n            \"html_url\",\n            \"id\",\n            \"name\",\n            \"prerelease\",\n            \"published_at\",\n            \"tag_name\",\n            \"target_commitish\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"author\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"created_at\": {\n              \"type\": \"string\"\n            },\n            \"draft\": {\n              \"type\": \"boolean\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"prerelease\": {\n              \"type\": \"boolean\"\n            },\n            \"published_at\": {\n              \"type\": \"string\"\n            },\n            \"tag_name\": {\n              \"type\": \"string\"\n            },\n            \"target_commitish\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"source_url\": {\n          \"type\": \"string\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"tag_name\": {\n          \"type\": \"string\"\n        },\n        \"target_commitish\": {\n          \"type\": \"string\"\n        },\n        \"target_oid\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"registry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"about_url\",\n        \"name\",\n        \"type\",\n        \"url\",\n        \"vendor\"\n      ],\n      \"properties\": {\n        \"about_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"vendor\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackagePublishedPackagePackageVersion,
    pub registry: PackagePublishedPackageRegistry,
    pub updated_at: String,
}
impl From<&PackagePublishedPackage> for PackagePublishedPackage {
    fn from(value: &PackagePublishedPackage) -> Self {
        value.clone()
    }
}
#[doc = "PackagePublishedPackagePackageVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"body\",\n    \"body_html\",\n    \"created_at\",\n    \"description\",\n    \"docker_metadata\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"installation_command\",\n    \"manifest\",\n    \"metadata\",\n    \"name\",\n    \"package_files\",\n    \"prerelease\",\n    \"release\",\n    \"source_url\",\n    \"summary\",\n    \"tag_name\",\n    \"target_commitish\",\n    \"target_oid\",\n    \"updated_at\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"body_html\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"docker_metadata\": {\n      \"type\": \"array\",\n      \"items\": {}\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"installation_command\": {\n      \"type\": \"string\"\n    },\n    \"manifest\": {\n      \"type\": \"string\"\n    },\n    \"metadata\": {\n      \"type\": \"array\",\n      \"items\": {}\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"package_files\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"content_type\",\n          \"created_at\",\n          \"download_url\",\n          \"id\",\n          \"md5\",\n          \"name\",\n          \"sha1\",\n          \"sha256\",\n          \"size\",\n          \"state\",\n          \"updated_at\"\n        ],\n        \"properties\": {\n          \"content_type\": {\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"type\": \"string\"\n          },\n          \"download_url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"id\": {\n            \"type\": \"integer\"\n          },\n          \"md5\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"sha1\": {\n            \"type\": \"string\"\n          },\n          \"sha256\": {\n            \"type\": \"string\"\n          },\n          \"size\": {\n            \"type\": \"integer\"\n          },\n          \"state\": {\n            \"type\": \"string\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"prerelease\": {\n      \"type\": \"boolean\"\n    },\n    \"release\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"created_at\",\n        \"draft\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"prerelease\",\n        \"published_at\",\n        \"tag_name\",\n        \"target_commitish\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"prerelease\": {\n          \"type\": \"boolean\"\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"tag_name\": {\n          \"type\": \"string\"\n        },\n        \"target_commitish\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"source_url\": {\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"tag_name\": {\n      \"type\": \"string\"\n    },\n    \"target_commitish\": {\n      \"type\": \"string\"\n    },\n    \"target_oid\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackagePublishedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackagePublishedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
impl From<&PackagePublishedPackagePackageVersion> for PackagePublishedPackagePackageVersion {
    fn from(value: &PackagePublishedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[doc = "PackagePublishedPackagePackageVersionPackageFilesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"content_type\",\n    \"created_at\",\n    \"download_url\",\n    \"id\",\n    \"md5\",\n    \"name\",\n    \"sha1\",\n    \"sha256\",\n    \"size\",\n    \"state\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"content_type\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"download_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"md5\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"sha1\": {\n      \"type\": \"string\"\n    },\n    \"sha256\": {\n      \"type\": \"string\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
impl From<&PackagePublishedPackagePackageVersionPackageFilesItem>
    for PackagePublishedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackagePublishedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[doc = "PackagePublishedPackagePackageVersionRelease"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"target_commitish\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"type\": \"boolean\"\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"tag_name\": {\n      \"type\": \"string\"\n    },\n    \"target_commitish\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
impl From<&PackagePublishedPackagePackageVersionRelease>
    for PackagePublishedPackagePackageVersionRelease
{
    fn from(value: &PackagePublishedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[doc = "PackagePublishedPackageRegistry"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"about_url\",\n    \"name\",\n    \"type\",\n    \"url\",\n    \"vendor\"\n  ],\n  \"properties\": {\n    \"about_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"vendor\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
impl From<&PackagePublishedPackageRegistry> for PackagePublishedPackageRegistry {
    fn from(value: &PackagePublishedPackageRegistry) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"package updated event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"package\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"updated\"\n      ]\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"package\": {\n      \"description\": \"Information about the package.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"description\",\n        \"ecosystem\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"namespace\",\n        \"owner\",\n        \"package_type\",\n        \"package_version\",\n        \"registry\",\n        \"updated_at\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"namespace\": {\n          \"type\": \"string\"\n        },\n        \"owner\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"package_type\": {\n          \"type\": \"string\"\n        },\n        \"package_version\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"author\",\n            \"body\",\n            \"body_html\",\n            \"created_at\",\n            \"description\",\n            \"docker_metadata\",\n            \"draft\",\n            \"html_url\",\n            \"id\",\n            \"installation_command\",\n            \"manifest\",\n            \"metadata\",\n            \"name\",\n            \"package_files\",\n            \"prerelease\",\n            \"release\",\n            \"source_url\",\n            \"summary\",\n            \"tag_name\",\n            \"target_commitish\",\n            \"target_oid\",\n            \"updated_at\",\n            \"version\"\n          ],\n          \"properties\": {\n            \"author\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"body\": {\n              \"type\": \"string\"\n            },\n            \"body_html\": {\n              \"type\": \"string\"\n            },\n            \"created_at\": {\n              \"type\": \"string\"\n            },\n            \"description\": {\n              \"type\": \"string\"\n            },\n            \"docker_metadata\": {\n              \"type\": \"array\",\n              \"items\": {}\n            },\n            \"draft\": {\n              \"type\": \"boolean\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"installation_command\": {\n              \"type\": \"string\"\n            },\n            \"manifest\": {\n              \"type\": \"string\"\n            },\n            \"metadata\": {\n              \"type\": \"array\",\n              \"items\": {}\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"package_files\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"content_type\",\n                  \"created_at\",\n                  \"download_url\",\n                  \"id\",\n                  \"md5\",\n                  \"name\",\n                  \"sha1\",\n                  \"sha256\",\n                  \"size\",\n                  \"state\",\n                  \"updated_at\"\n                ],\n                \"properties\": {\n                  \"content_type\": {\n                    \"type\": \"string\"\n                  },\n                  \"created_at\": {\n                    \"type\": \"string\"\n                  },\n                  \"download_url\": {\n                    \"type\": \"string\",\n                    \"format\": \"uri\"\n                  },\n                  \"id\": {\n                    \"type\": \"integer\"\n                  },\n                  \"md5\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  },\n                  \"sha1\": {\n                    \"type\": \"string\"\n                  },\n                  \"sha256\": {\n                    \"type\": \"string\"\n                  },\n                  \"size\": {\n                    \"type\": \"integer\"\n                  },\n                  \"state\": {\n                    \"type\": \"string\"\n                  },\n                  \"updated_at\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              }\n            },\n            \"prerelease\": {\n              \"type\": \"boolean\"\n            },\n            \"release\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"author\",\n                \"created_at\",\n                \"draft\",\n                \"html_url\",\n                \"id\",\n                \"name\",\n                \"prerelease\",\n                \"published_at\",\n                \"tag_name\",\n                \"target_commitish\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"author\": {\n                  \"$ref\": \"#/definitions/user\"\n                },\n                \"created_at\": {\n                  \"type\": \"string\"\n                },\n                \"draft\": {\n                  \"type\": \"boolean\"\n                },\n                \"html_url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                },\n                \"id\": {\n                  \"type\": \"integer\"\n                },\n                \"name\": {\n                  \"type\": \"string\"\n                },\n                \"prerelease\": {\n                  \"type\": \"boolean\"\n                },\n                \"published_at\": {\n                  \"type\": \"string\"\n                },\n                \"tag_name\": {\n                  \"type\": \"string\"\n                },\n                \"target_commitish\": {\n                  \"type\": \"string\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"source_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"summary\": {\n              \"type\": \"string\"\n            },\n            \"tag_name\": {\n              \"type\": \"string\"\n            },\n            \"target_commitish\": {\n              \"type\": \"string\"\n            },\n            \"target_oid\": {\n              \"type\": \"string\"\n            },\n            \"updated_at\": {\n              \"type\": \"string\"\n            },\n            \"version\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"registry\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"about_url\",\n            \"name\",\n            \"type\",\n            \"url\",\n            \"vendor\"\n          ],\n          \"properties\": {\n            \"about_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"type\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"vendor\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdated {
    pub action: PackageUpdatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackageUpdatedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PackageUpdated> for PackageUpdated {
    fn from(value: &PackageUpdated) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"updated\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackageUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl From<&PackageUpdatedAction> for PackageUpdatedAction {
    fn from(value: &PackageUpdatedAction) -> Self {
        value.clone()
    }
}
impl ToString for PackageUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for PackageUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"Information about the package.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"ecosystem\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"namespace\",\n    \"owner\",\n    \"package_type\",\n    \"package_version\",\n    \"registry\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"namespace\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"package_type\": {\n      \"type\": \"string\"\n    },\n    \"package_version\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"body\",\n        \"body_html\",\n        \"created_at\",\n        \"description\",\n        \"docker_metadata\",\n        \"draft\",\n        \"html_url\",\n        \"id\",\n        \"installation_command\",\n        \"manifest\",\n        \"metadata\",\n        \"name\",\n        \"package_files\",\n        \"prerelease\",\n        \"release\",\n        \"source_url\",\n        \"summary\",\n        \"tag_name\",\n        \"target_commitish\",\n        \"target_oid\",\n        \"updated_at\",\n        \"version\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"body_html\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"docker_metadata\": {\n          \"type\": \"array\",\n          \"items\": {}\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"installation_command\": {\n          \"type\": \"string\"\n        },\n        \"manifest\": {\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"type\": \"array\",\n          \"items\": {}\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"package_files\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"content_type\",\n              \"created_at\",\n              \"download_url\",\n              \"id\",\n              \"md5\",\n              \"name\",\n              \"sha1\",\n              \"sha256\",\n              \"size\",\n              \"state\",\n              \"updated_at\"\n            ],\n            \"properties\": {\n              \"content_type\": {\n                \"type\": \"string\"\n              },\n              \"created_at\": {\n                \"type\": \"string\"\n              },\n              \"download_url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              \"id\": {\n                \"type\": \"integer\"\n              },\n              \"md5\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              },\n              \"sha1\": {\n                \"type\": \"string\"\n              },\n              \"sha256\": {\n                \"type\": \"string\"\n              },\n              \"size\": {\n                \"type\": \"integer\"\n              },\n              \"state\": {\n                \"type\": \"string\"\n              },\n              \"updated_at\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"prerelease\": {\n          \"type\": \"boolean\"\n        },\n        \"release\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"author\",\n            \"created_at\",\n            \"draft\",\n            \"html_url\",\n            \"id\",\n            \"name\",\n            \"prerelease\",\n            \"published_at\",\n            \"tag_name\",\n            \"target_commitish\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"author\": {\n              \"$ref\": \"#/definitions/user\"\n            },\n            \"created_at\": {\n              \"type\": \"string\"\n            },\n            \"draft\": {\n              \"type\": \"boolean\"\n            },\n            \"html_url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"prerelease\": {\n              \"type\": \"boolean\"\n            },\n            \"published_at\": {\n              \"type\": \"string\"\n            },\n            \"tag_name\": {\n              \"type\": \"string\"\n            },\n            \"target_commitish\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"source_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"tag_name\": {\n          \"type\": \"string\"\n        },\n        \"target_commitish\": {\n          \"type\": \"string\"\n        },\n        \"target_oid\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"registry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"about_url\",\n        \"name\",\n        \"type\",\n        \"url\",\n        \"vendor\"\n      ],\n      \"properties\": {\n        \"about_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"vendor\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackageUpdatedPackagePackageVersion,
    pub registry: PackageUpdatedPackageRegistry,
    pub updated_at: String,
}
impl From<&PackageUpdatedPackage> for PackageUpdatedPackage {
    fn from(value: &PackageUpdatedPackage) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdatedPackagePackageVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"body\",\n    \"body_html\",\n    \"created_at\",\n    \"description\",\n    \"docker_metadata\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"installation_command\",\n    \"manifest\",\n    \"metadata\",\n    \"name\",\n    \"package_files\",\n    \"prerelease\",\n    \"release\",\n    \"source_url\",\n    \"summary\",\n    \"tag_name\",\n    \"target_commitish\",\n    \"target_oid\",\n    \"updated_at\",\n    \"version\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"body_html\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"docker_metadata\": {\n      \"type\": \"array\",\n      \"items\": {}\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"installation_command\": {\n      \"type\": \"string\"\n    },\n    \"manifest\": {\n      \"type\": \"string\"\n    },\n    \"metadata\": {\n      \"type\": \"array\",\n      \"items\": {}\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"package_files\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"content_type\",\n          \"created_at\",\n          \"download_url\",\n          \"id\",\n          \"md5\",\n          \"name\",\n          \"sha1\",\n          \"sha256\",\n          \"size\",\n          \"state\",\n          \"updated_at\"\n        ],\n        \"properties\": {\n          \"content_type\": {\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"type\": \"string\"\n          },\n          \"download_url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"id\": {\n            \"type\": \"integer\"\n          },\n          \"md5\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"sha1\": {\n            \"type\": \"string\"\n          },\n          \"sha256\": {\n            \"type\": \"string\"\n          },\n          \"size\": {\n            \"type\": \"integer\"\n          },\n          \"state\": {\n            \"type\": \"string\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"prerelease\": {\n      \"type\": \"boolean\"\n    },\n    \"release\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"created_at\",\n        \"draft\",\n        \"html_url\",\n        \"id\",\n        \"name\",\n        \"prerelease\",\n        \"published_at\",\n        \"tag_name\",\n        \"target_commitish\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"prerelease\": {\n          \"type\": \"boolean\"\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"tag_name\": {\n          \"type\": \"string\"\n        },\n        \"target_commitish\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"source_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"tag_name\": {\n      \"type\": \"string\"\n    },\n    \"target_commitish\": {\n      \"type\": \"string\"\n    },\n    \"target_oid\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"version\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackageUpdatedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackageUpdatedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
impl From<&PackageUpdatedPackagePackageVersion> for PackageUpdatedPackagePackageVersion {
    fn from(value: &PackageUpdatedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdatedPackagePackageVersionPackageFilesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"content_type\",\n    \"created_at\",\n    \"download_url\",\n    \"id\",\n    \"md5\",\n    \"name\",\n    \"sha1\",\n    \"sha256\",\n    \"size\",\n    \"state\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"content_type\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"download_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"md5\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"sha1\": {\n      \"type\": \"string\"\n    },\n    \"sha256\": {\n      \"type\": \"string\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
impl From<&PackageUpdatedPackagePackageVersionPackageFilesItem>
    for PackageUpdatedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackageUpdatedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdatedPackagePackageVersionRelease"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"target_commitish\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"type\": \"boolean\"\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"tag_name\": {\n      \"type\": \"string\"\n    },\n    \"target_commitish\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
impl From<&PackageUpdatedPackagePackageVersionRelease>
    for PackageUpdatedPackagePackageVersionRelease
{
    fn from(value: &PackageUpdatedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[doc = "PackageUpdatedPackageRegistry"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"about_url\",\n    \"name\",\n    \"type\",\n    \"url\",\n    \"vendor\"\n  ],\n  \"properties\": {\n    \"about_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"vendor\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
impl From<&PackageUpdatedPackageRegistry> for PackageUpdatedPackageRegistry {
    fn from(value: &PackageUpdatedPackageRegistry) -> Self {
        value.clone()
    }
}
#[doc = "Page Build"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"page_build event\",\n  \"description\": \"Page Build\",\n  \"type\": \"object\",\n  \"required\": [\n    \"build\",\n    \"id\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"build\": {\n      \"description\": \"The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"commit\",\n        \"created_at\",\n        \"duration\",\n        \"error\",\n        \"pusher\",\n        \"status\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"commit\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"duration\": {\n          \"type\": \"integer\"\n        },\n        \"error\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"message\"\n          ],\n          \"properties\": {\n            \"message\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"pusher\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"status\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEvent {
    pub build: PageBuildEventBuild,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PageBuildEvent> for PageBuildEvent {
    fn from(value: &PageBuildEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"commit\",\n    \"created_at\",\n    \"duration\",\n    \"error\",\n    \"pusher\",\n    \"status\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"commit\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"duration\": {\n      \"type\": \"integer\"\n    },\n    \"error\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"message\"\n      ],\n      \"properties\": {\n        \"message\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"pusher\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"status\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuild {
    pub commit: String,
    pub created_at: String,
    pub duration: i64,
    pub error: PageBuildEventBuildError,
    pub pusher: User,
    pub status: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&PageBuildEventBuild> for PageBuildEventBuild {
    fn from(value: &PageBuildEventBuild) -> Self {
        value.clone()
    }
}
#[doc = "PageBuildEventBuildError"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"message\"\n  ],\n  \"properties\": {\n    \"message\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuildError {
    pub message: Option<String>,
}
impl From<&PageBuildEventBuildError> for PageBuildEventBuildError {
    fn from(value: &PageBuildEventBuildError) -> Self {
        value.clone()
    }
}
#[doc = "PingEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"ping event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"hook\",\n    \"hook_id\",\n    \"zen\"\n  ],\n  \"properties\": {\n    \"hook\": {\n      \"description\": \"The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).\",\n      \"type\": \"object\",\n      \"required\": [\n        \"active\",\n        \"config\",\n        \"created_at\",\n        \"events\",\n        \"id\",\n        \"name\",\n        \"ping_url\",\n        \"type\",\n        \"updated_at\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"active\": {\n          \"type\": \"boolean\"\n        },\n        \"app_id\": {\n          \"description\": \"When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app.\",\n          \"type\": \"integer\"\n        },\n        \"config\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"content_type\",\n            \"insecure_ssl\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"content_type\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"json\",\n                \"form\"\n              ]\n            },\n            \"insecure_ssl\": {\n              \"type\": \"string\"\n            },\n            \"secret\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"events\": {\n          \"$ref\": \"#/definitions/webhook-events\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"last_response\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"code\",\n            \"message\",\n            \"status\"\n          ],\n          \"properties\": {\n            \"code\": {\n              \"type\": \"null\"\n            },\n            \"message\": {\n              \"type\": \"null\"\n            },\n            \"status\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"ping_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"test_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"hook_id\": {\n      \"description\": \"The ID of the webhook that triggered the ping.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"zen\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEvent {
    pub hook: PingEventHook,
    #[doc = "The ID of the webhook that triggered the ping."]
    pub hook_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<User>,
    pub zen: String,
}
impl From<&PingEvent> for PingEvent {
    fn from(value: &PingEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).\",\n  \"type\": \"object\",\n  \"required\": [\n    \"active\",\n    \"config\",\n    \"created_at\",\n    \"events\",\n    \"id\",\n    \"name\",\n    \"ping_url\",\n    \"type\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"active\": {\n      \"type\": \"boolean\"\n    },\n    \"app_id\": {\n      \"description\": \"When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app.\",\n      \"type\": \"integer\"\n    },\n    \"config\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"content_type\",\n        \"insecure_ssl\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"content_type\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"json\",\n            \"form\"\n          ]\n        },\n        \"insecure_ssl\": {\n          \"type\": \"string\"\n        },\n        \"secret\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"events\": {\n      \"$ref\": \"#/definitions/webhook-events\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"last_response\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"code\",\n        \"message\",\n        \"status\"\n      ],\n      \"properties\": {\n        \"code\": {\n          \"type\": \"null\"\n        },\n        \"message\": {\n          \"type\": \"null\"\n        },\n        \"status\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"ping_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"test_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHook {
    pub active: bool,
    #[doc = "When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_id: Option<i64>,
    pub config: PingEventHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_response: Option<PingEventHookLastResponse>,
    pub name: String,
    pub ping_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test_url: Option<String>,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&PingEventHook> for PingEventHook {
    fn from(value: &PingEventHook) -> Self {
        value.clone()
    }
}
#[doc = "PingEventHookConfig"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"content_type\",\n    \"insecure_ssl\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"content_type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"json\",\n        \"form\"\n      ]\n    },\n    \"insecure_ssl\": {\n      \"type\": \"string\"\n    },\n    \"secret\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookConfig {
    pub content_type: PingEventHookConfigContentType,
    pub insecure_ssl: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    pub url: String,
}
impl From<&PingEventHookConfig> for PingEventHookConfig {
    fn from(value: &PingEventHookConfig) -> Self {
        value.clone()
    }
}
#[doc = "PingEventHookConfigContentType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"json\",\n    \"form\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PingEventHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl From<&PingEventHookConfigContentType> for PingEventHookConfigContentType {
    fn from(value: &PingEventHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ToString for PingEventHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for PingEventHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PingEventHookLastResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"code\",\n    \"message\",\n    \"status\"\n  ],\n  \"properties\": {\n    \"code\": {\n      \"type\": \"null\"\n    },\n    \"message\": {\n      \"type\": \"null\"\n    },\n    \"status\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookLastResponse {
    pub code: (),
    pub message: (),
    pub status: String,
}
impl From<&PingEventHookLastResponse> for PingEventHookLastResponse {
    fn from(value: &PingEventHookLastResponse) -> Self {
        value.clone()
    }
}
#[doc = "Project"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Project\",\n  \"type\": \"object\",\n  \"required\": [\n    \"body\",\n    \"columns_url\",\n    \"created_at\",\n    \"creator\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"number\",\n    \"owner_url\",\n    \"state\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"body\": {\n      \"description\": \"Body of the project\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"columns_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"Name of the project\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"owner_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of the project; either 'open' or 'closed'\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Project {
    #[doc = "Body of the project"]
    pub body: Option<String>,
    pub columns_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub html_url: String,
    pub id: i64,
    #[doc = "Name of the project"]
    pub name: String,
    pub node_id: String,
    pub number: i64,
    pub owner_url: String,
    #[doc = "State of the project; either 'open' or 'closed'"]
    pub state: ProjectState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&Project> for Project {
    fn from(value: &Project) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCard"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Project Card\",\n  \"type\": \"object\",\n  \"required\": [\n    \"archived\",\n    \"column_id\",\n    \"column_url\",\n    \"created_at\",\n    \"creator\",\n    \"id\",\n    \"node_id\",\n    \"note\",\n    \"project_url\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after_id\": {\n      \"type\": \"null\"\n    },\n    \"archived\": {\n      \"description\": \"Whether or not the card is archived\",\n      \"type\": \"boolean\"\n    },\n    \"column_id\": {\n      \"type\": \"integer\"\n    },\n    \"column_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"content_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"id\": {\n      \"description\": \"The project card's ID\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"note\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"project_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCard {
    #[serde(default)]
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: String,
    pub note: Option<String>,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&ProjectCard> for ProjectCard {
    fn from(value: &ProjectCard) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardConverted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_card converted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"project_card\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"converted\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"note\"\n      ],\n      \"properties\": {\n        \"note\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_card\": {\n      \"$ref\": \"#/definitions/project-card\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConverted {
    pub action: ProjectCardConvertedAction,
    pub changes: ProjectCardConvertedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardConverted> for ProjectCardConverted {
    fn from(value: &ProjectCardConverted) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardConvertedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"converted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardConvertedAction {
    #[serde(rename = "converted")]
    Converted,
}
impl From<&ProjectCardConvertedAction> for ProjectCardConvertedAction {
    fn from(value: &ProjectCardConvertedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardConvertedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Converted => "converted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardConvertedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted" => Ok(Self::Converted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCardConvertedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"note\"\n  ],\n  \"properties\": {\n    \"note\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChanges {
    pub note: ProjectCardConvertedChangesNote,
}
impl From<&ProjectCardConvertedChanges> for ProjectCardConvertedChanges {
    fn from(value: &ProjectCardConvertedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardConvertedChangesNote"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChangesNote {
    pub from: String,
}
impl From<&ProjectCardConvertedChangesNote> for ProjectCardConvertedChangesNote {
    fn from(value: &ProjectCardConvertedChangesNote) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_card created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project_card\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_card\": {\n      \"$ref\": \"#/definitions/project-card\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardCreated {
    pub action: ProjectCardCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardCreated> for ProjectCardCreated {
    fn from(value: &ProjectCardCreated) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectCardCreatedAction> for ProjectCardCreatedAction {
    fn from(value: &ProjectCardCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCardDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_card deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project_card\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_card\": {\n      \"$ref\": \"#/definitions/project-card\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardDeleted {
    pub action: ProjectCardDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardDeleted> for ProjectCardDeleted {
    fn from(value: &ProjectCardDeleted) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectCardDeletedAction> for ProjectCardDeletedAction {
    fn from(value: &ProjectCardDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCardEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_card edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"project_card\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"note\"\n      ],\n      \"properties\": {\n        \"note\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_card\": {\n      \"$ref\": \"#/definitions/project-card\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEdited {
    pub action: ProjectCardEditedAction,
    pub changes: ProjectCardEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardEdited> for ProjectCardEdited {
    fn from(value: &ProjectCardEdited) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectCardEditedAction> for ProjectCardEditedAction {
    fn from(value: &ProjectCardEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCardEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"note\"\n  ],\n  \"properties\": {\n    \"note\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChanges {
    pub note: ProjectCardEditedChangesNote,
}
impl From<&ProjectCardEditedChanges> for ProjectCardEditedChanges {
    fn from(value: &ProjectCardEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardEditedChangesNote"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChangesNote {
    pub from: String,
}
impl From<&ProjectCardEditedChangesNote> for ProjectCardEditedChangesNote {
    fn from(value: &ProjectCardEditedChangesNote) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/project_card$converted\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_card$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_card$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_card$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_card$moved\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectCardEvent {
    Converted(ProjectCardConverted),
    Created(ProjectCardCreated),
    Deleted(ProjectCardDeleted),
    Edited(ProjectCardEdited),
    Moved(ProjectCardMoved),
}
impl From<&ProjectCardEvent> for ProjectCardEvent {
    fn from(value: &ProjectCardEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectCardConverted> for ProjectCardEvent {
    fn from(value: ProjectCardConverted) -> Self {
        Self::Converted(value)
    }
}
impl From<ProjectCardCreated> for ProjectCardEvent {
    fn from(value: ProjectCardCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectCardDeleted> for ProjectCardEvent {
    fn from(value: ProjectCardDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectCardEdited> for ProjectCardEvent {
    fn from(value: ProjectCardEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectCardMoved> for ProjectCardEvent {
    fn from(value: ProjectCardMoved) -> Self {
        Self::Moved(value)
    }
}
#[doc = "ProjectCardMoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_card moved event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"project_card\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"moved\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"column_id\"\n      ],\n      \"properties\": {\n        \"column_id\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"integer\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_card\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/project-card\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"after_id\"\n          ],\n          \"properties\": {\n            \"after_id\": {\n              \"type\": [\n                \"number\",\n                \"null\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMoved {
    pub action: ProjectCardMovedAction,
    pub changes: ProjectCardMovedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCardMovedProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardMoved> for ProjectCardMoved {
    fn from(value: &ProjectCardMoved) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardMovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"moved\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl From<&ProjectCardMovedAction> for ProjectCardMovedAction {
    fn from(value: &ProjectCardMovedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCardMovedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"column_id\"\n  ],\n  \"properties\": {\n    \"column_id\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChanges {
    pub column_id: ProjectCardMovedChangesColumnId,
}
impl From<&ProjectCardMovedChanges> for ProjectCardMovedChanges {
    fn from(value: &ProjectCardMovedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardMovedChangesColumnId"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChangesColumnId {
    pub from: i64,
}
impl From<&ProjectCardMovedChangesColumnId> for ProjectCardMovedChangesColumnId {
    fn from(value: &ProjectCardMovedChangesColumnId) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCardMovedProjectCard"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"after_id\",\n    \"archived\",\n    \"column_id\",\n    \"column_url\",\n    \"created_at\",\n    \"creator\",\n    \"id\",\n    \"node_id\",\n    \"note\",\n    \"project_url\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"after_id\": {\n      \"type\": \"null\"\n    },\n    \"archived\": {\n      \"description\": \"Whether or not the card is archived\",\n      \"type\": \"boolean\"\n    },\n    \"column_id\": {\n      \"type\": \"integer\"\n    },\n    \"column_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"content_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"creator\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"id\": {\n      \"description\": \"The project card's ID\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"note\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"project_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedProjectCard {
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: String,
    pub note: Option<String>,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&ProjectCardMovedProjectCard> for ProjectCardMovedProjectCard {
    fn from(value: &ProjectCardMovedProjectCard) -> Self {
        value.clone()
    }
}
#[doc = "ProjectClosed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project closed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project\": {\n      \"$ref\": \"#/definitions/project\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectClosed {
    pub action: ProjectClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectClosed> for ProjectClosed {
    fn from(value: &ProjectClosed) -> Self {
        value.clone()
    }
}
#[doc = "ProjectClosedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&ProjectClosedAction> for ProjectClosedAction {
    fn from(value: &ProjectClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectColumn"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Project Column\",\n  \"type\": \"object\",\n  \"required\": [\n    \"cards_url\",\n    \"created_at\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"project_url\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"cards_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"id\": {\n      \"description\": \"The unique identifier of the project column\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"Name of the project column\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"project_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumn {
    pub cards_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The unique identifier of the project column"]
    pub id: i64,
    #[doc = "Name of the project column"]
    pub name: String,
    pub node_id: String,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&ProjectColumn> for ProjectColumn {
    fn from(value: &ProjectColumn) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_column created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project_column\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_column\": {\n      \"$ref\": \"#/definitions/project-column\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnCreated {
    pub action: ProjectColumnCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnCreated> for ProjectColumnCreated {
    fn from(value: &ProjectColumnCreated) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectColumnCreatedAction> for ProjectColumnCreatedAction {
    fn from(value: &ProjectColumnCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectColumnDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_column deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project_column\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_column\": {\n      \"$ref\": \"#/definitions/project-column\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnDeleted {
    pub action: ProjectColumnDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnDeleted> for ProjectColumnDeleted {
    fn from(value: &ProjectColumnDeleted) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectColumnDeletedAction> for ProjectColumnDeletedAction {
    fn from(value: &ProjectColumnDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectColumnEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_column edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"project_column\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_column\": {\n      \"$ref\": \"#/definitions/project-column\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEdited {
    pub action: ProjectColumnEditedAction,
    pub changes: ProjectColumnEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnEdited> for ProjectColumnEdited {
    fn from(value: &ProjectColumnEdited) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectColumnEditedAction> for ProjectColumnEditedAction {
    fn from(value: &ProjectColumnEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectColumnEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectColumnEditedChangesName>,
}
impl From<&ProjectColumnEditedChanges> for ProjectColumnEditedChanges {
    fn from(value: &ProjectColumnEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnEditedChangesName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChangesName {
    pub from: String,
}
impl From<&ProjectColumnEditedChangesName> for ProjectColumnEditedChangesName {
    fn from(value: &ProjectColumnEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/project_column$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_column$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_column$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/project_column$moved\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectColumnEvent {
    Created(ProjectColumnCreated),
    Deleted(ProjectColumnDeleted),
    Edited(ProjectColumnEdited),
    Moved(ProjectColumnMoved),
}
impl From<&ProjectColumnEvent> for ProjectColumnEvent {
    fn from(value: &ProjectColumnEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectColumnCreated> for ProjectColumnEvent {
    fn from(value: ProjectColumnCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectColumnDeleted> for ProjectColumnEvent {
    fn from(value: ProjectColumnDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectColumnEdited> for ProjectColumnEvent {
    fn from(value: ProjectColumnEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectColumnMoved> for ProjectColumnEvent {
    fn from(value: ProjectColumnMoved) -> Self {
        Self::Moved(value)
    }
}
#[doc = "ProjectColumnMoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project_column moved event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project_column\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"moved\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project_column\": {\n      \"$ref\": \"#/definitions/project-column\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnMoved {
    pub action: ProjectColumnMovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnMoved> for ProjectColumnMoved {
    fn from(value: &ProjectColumnMoved) -> Self {
        value.clone()
    }
}
#[doc = "ProjectColumnMovedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"moved\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl From<&ProjectColumnMovedAction> for ProjectColumnMovedAction {
    fn from(value: &ProjectColumnMovedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project\": {\n      \"$ref\": \"#/definitions/project\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCreated {
    pub action: ProjectCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCreated> for ProjectCreated {
    fn from(value: &ProjectCreated) -> Self {
        value.clone()
    }
}
#[doc = "ProjectCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectCreatedAction> for ProjectCreatedAction {
    fn from(value: &ProjectCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project\": {\n      \"$ref\": \"#/definitions/project\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectDeleted {
    pub action: ProjectDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectDeleted> for ProjectDeleted {
    fn from(value: &ProjectDeleted) -> Self {
        value.clone()
    }
}
#[doc = "ProjectDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectDeletedAction> for ProjectDeletedAction {
    fn from(value: &ProjectDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ProjectEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"project\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the project if the action was `edited`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The changes to the project if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project\": {\n      \"$ref\": \"#/definitions/project\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEdited {
    pub action: ProjectEditedAction,
    pub changes: ProjectEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectEdited> for ProjectEdited {
    fn from(value: &ProjectEdited) -> Self {
        value.clone()
    }
}
#[doc = "ProjectEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectEditedAction> for ProjectEditedAction {
    fn from(value: &ProjectEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the project if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the project if the action was `edited`.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The changes to the project if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ProjectEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectEditedChangesName>,
}
impl From<&ProjectEditedChanges> for ProjectEditedChanges {
    fn from(value: &ProjectEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ProjectEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&ProjectEditedChangesBody> for ProjectEditedChangesBody {
    fn from(value: &ProjectEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "ProjectEditedChangesName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The changes to the project if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesName {
    #[doc = "The changes to the project if the action was `edited`."]
    pub from: String,
}
impl From<&ProjectEditedChangesName> for ProjectEditedChangesName {
    fn from(value: &ProjectEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "ProjectEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/project$closed\"\n    },\n    {\n      \"$ref\": \"#/definitions/project$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/project$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/project$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/project$reopened\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectEvent {
    Closed(ProjectClosed),
    Created(ProjectCreated),
    Deleted(ProjectDeleted),
    Edited(ProjectEdited),
    Reopened(ProjectReopened),
}
impl From<&ProjectEvent> for ProjectEvent {
    fn from(value: &ProjectEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectClosed> for ProjectEvent {
    fn from(value: ProjectClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<ProjectCreated> for ProjectEvent {
    fn from(value: ProjectCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectDeleted> for ProjectEvent {
    fn from(value: ProjectDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectEdited> for ProjectEvent {
    fn from(value: ProjectEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectReopened> for ProjectEvent {
    fn from(value: ProjectReopened) -> Self {
        Self::Reopened(value)
    }
}
#[doc = "ProjectReopened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"project reopened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"project\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"project\": {\n      \"$ref\": \"#/definitions/project\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectReopened {
    pub action: ProjectReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectReopened> for ProjectReopened {
    fn from(value: &ProjectReopened) -> Self {
        value.clone()
    }
}
#[doc = "ProjectReopenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&ProjectReopenedAction> for ProjectReopenedAction {
    fn from(value: &ProjectReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of the project; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the project; either 'open' or 'closed'\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&ProjectState> for ProjectState {
    fn from(value: &ProjectState) -> Self {
        value.clone()
    }
}
impl ToString for ProjectState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "When a private repository is made public."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"public event\",\n  \"description\": \"When a private repository is made public.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"private\"\n          ],\n          \"properties\": {\n            \"private\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: PublicEventRepository,
    pub sender: User,
}
impl From<&PublicEvent> for PublicEvent {
    fn from(value: &PublicEvent) -> Self {
        value.clone()
    }
}
#[doc = "PublicEventRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"description\": \"Whether the repository is archived.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEventRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: PublicEventRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<PublicEventRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: PublicEventRepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&PublicEventRepository> for PublicEventRepository {
    fn from(value: &PublicEventRepository) -> Self {
        value.clone()
    }
}
#[doc = "PublicEventRepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PublicEventRepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&PublicEventRepositoryCreatedAt> for PublicEventRepositoryCreatedAt {
    fn from(value: &PublicEventRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for PublicEventRepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for PublicEventRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PublicEventRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PublicEventRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for PublicEventRepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for PublicEventRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for PublicEventRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PublicEventRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEventRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&PublicEventRepositoryPermissions> for PublicEventRepositoryPermissions {
    fn from(value: &PublicEventRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "PublicEventRepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PublicEventRepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&PublicEventRepositoryPushedAt> for PublicEventRepositoryPushedAt {
    fn from(value: &PublicEventRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for PublicEventRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for PublicEventRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Pull Request\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"description\": \"Indicates whether or not the pull request is a draft.\",\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of this Pull Request. Either `open` or `closed`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequest {
    pub active_lock_reason: Option<PullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: Option<bool>,
    pub merged_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub merged_by: Option<User>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequest> for PullRequest {
    fn from(value: &PullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestActiveLockReason> for PullRequestActiveLockReason {
    fn from(value: &PullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestAssigned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request assigned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"assignee\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"assigned\"\n      ]\n    },\n    \"assignee\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAssigned {
    pub action: PullRequestAssignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAssigned> for PullRequestAssigned {
    fn from(value: &PullRequestAssigned) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestAssignedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"assigned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl From<&PullRequestAssignedAction> for PullRequestAssignedAction {
    fn from(value: &PullRequestAssignedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestAutoMergeDisabled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request auto_merge_disabled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"auto_merge_disabled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeDisabled {
    pub action: PullRequestAutoMergeDisabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAutoMergeDisabled> for PullRequestAutoMergeDisabled {
    fn from(value: &PullRequestAutoMergeDisabled) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestAutoMergeDisabledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"auto_merge_disabled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeDisabledAction {
    #[serde(rename = "auto_merge_disabled")]
    AutoMergeDisabled,
}
impl From<&PullRequestAutoMergeDisabledAction> for PullRequestAutoMergeDisabledAction {
    fn from(value: &PullRequestAutoMergeDisabledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAutoMergeDisabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeDisabled => "auto_merge_disabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeDisabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_disabled" => Ok(Self::AutoMergeDisabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestAutoMergeEnabled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request auto_merge_enabled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"auto_merge_enabled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeEnabled {
    pub action: PullRequestAutoMergeEnabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAutoMergeEnabled> for PullRequestAutoMergeEnabled {
    fn from(value: &PullRequestAutoMergeEnabled) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestAutoMergeEnabledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"auto_merge_enabled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeEnabledAction {
    #[serde(rename = "auto_merge_enabled")]
    AutoMergeEnabled,
}
impl From<&PullRequestAutoMergeEnabledAction> for PullRequestAutoMergeEnabledAction {
    fn from(value: &PullRequestAutoMergeEnabledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAutoMergeEnabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeEnabled => "auto_merge_enabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeEnabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_enabled" => Ok(Self::AutoMergeEnabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestBase> for PullRequestBase {
    fn from(value: &PullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request closed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"merged\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            },\n            \"merged\": {\n              \"type\": \"boolean\"\n            },\n            \"state\": {\n              \"description\": \"State of this Pull Request. Either `open` or `closed`.\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"closed\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosed {
    pub action: PullRequestClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestClosedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestClosed> for PullRequestClosed {
    fn from(value: &PullRequestClosed) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestClosedAction> for PullRequestClosedAction {
    fn from(value: &PullRequestClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestClosedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"description\": \"Indicates whether or not the pull request is a draft.\",\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": \"boolean\"\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequest {
    pub active_lock_reason: Option<PullRequestClosedPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestClosedPullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: chrono::DateTime<chrono::offset::Utc>,
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestClosedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestClosedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: bool,
    pub merged_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub merged_by: Option<User>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestClosedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    pub state: PullRequestClosedPullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestClosedPullRequest> for PullRequestClosedPullRequest {
    fn from(value: &PullRequestClosedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestClosedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestClosedPullRequestActiveLockReason>
    for PullRequestClosedPullRequestActiveLockReason
{
    fn from(value: &PullRequestClosedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestClosedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestClosedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestClosedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestClosedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestClosedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestClosedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestClosedPullRequestBase> for PullRequestClosedPullRequestBase {
    fn from(value: &PullRequestClosedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestClosedPullRequestHead> for PullRequestClosedPullRequestHead {
    fn from(value: &PullRequestClosedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestClosedPullRequestLinks> for PullRequestClosedPullRequestLinks {
    fn from(value: &PullRequestClosedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestClosedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestClosedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestClosedPullRequestRequestedReviewersItem>
    for PullRequestClosedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestClosedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestClosedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestClosedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestClosedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestClosedPullRequestState {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestClosedPullRequestState> for PullRequestClosedPullRequestState {
    fn from(value: &PullRequestClosedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestClosedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestClosedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestClosedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestClosedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestClosedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestConvertedToDraft"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request converted_to_draft event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"converted_to_draft\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"draft\",\n            \"merged\",\n            \"merged_at\",\n            \"merged_by\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"draft\": {\n              \"description\": \"Indicates whether or not the pull request is a draft.\",\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            },\n            \"merged\": {\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            },\n            \"merged_at\": {\n              \"type\": \"null\"\n            },\n            \"merged_by\": {\n              \"type\": \"null\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraft {
    pub action: PullRequestConvertedToDraftAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestConvertedToDraftPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestConvertedToDraft> for PullRequestConvertedToDraft {
    fn from(value: &PullRequestConvertedToDraft) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestConvertedToDraftAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"converted_to_draft\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestConvertedToDraftAction {
    #[serde(rename = "converted_to_draft")]
    ConvertedToDraft,
}
impl From<&PullRequestConvertedToDraftAction> for PullRequestConvertedToDraftAction {
    fn from(value: &PullRequestConvertedToDraftAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestConvertedToDraftAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ConvertedToDraft => "converted_to_draft".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestConvertedToDraftAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted_to_draft" => Ok(Self::ConvertedToDraft),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"merged_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"type\": \"null\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"description\": \"State of this Pull Request. Either `open` or `closed`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequest {
    pub active_lock_reason: Option<PullRequestConvertedToDraftPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestConvertedToDraftPullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    pub draft: bool,
    pub head: PullRequestConvertedToDraftPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestConvertedToDraftPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestConvertedToDraftPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestConvertedToDraftPullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestConvertedToDraftPullRequest> for PullRequestConvertedToDraftPullRequest {
    fn from(value: &PullRequestConvertedToDraftPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestConvertedToDraftPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestConvertedToDraftPullRequestActiveLockReason>
    for PullRequestConvertedToDraftPullRequestActiveLockReason
{
    fn from(value: &PullRequestConvertedToDraftPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestConvertedToDraftPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestConvertedToDraftPullRequestBase>
    for PullRequestConvertedToDraftPullRequestBase
{
    fn from(value: &PullRequestConvertedToDraftPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestConvertedToDraftPullRequestHead>
    for PullRequestConvertedToDraftPullRequestHead
{
    fn from(value: &PullRequestConvertedToDraftPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestConvertedToDraftPullRequestLinks>
    for PullRequestConvertedToDraftPullRequestLinks
{
    fn from(value: &PullRequestConvertedToDraftPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestConvertedToDraftPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestConvertedToDraftPullRequestRequestedReviewersItem>
    for PullRequestConvertedToDraftPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestConvertedToDraftPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of this Pull Request. Either `open` or `closed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestConvertedToDraftPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestConvertedToDraftPullRequestState>
    for PullRequestConvertedToDraftPullRequestState
{
    fn from(value: &PullRequestConvertedToDraftPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestConvertedToDraftPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestConvertedToDraftPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestConvertedToDraftPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the comment if the action was `edited`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"title\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the title if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEdited {
    pub action: PullRequestEditedAction,
    pub changes: PullRequestEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestEdited> for PullRequestEdited {
    fn from(value: &PullRequestEdited) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestEditedAction> for PullRequestEditedAction {
    fn from(value: &PullRequestEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the comment if the action was `edited`.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"title\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the title if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<PullRequestEditedChangesTitle>,
}
impl From<&PullRequestEditedChanges> for PullRequestEditedChanges {
    fn from(value: &PullRequestEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestEditedChangesBody> for PullRequestEditedChangesBody {
    fn from(value: &PullRequestEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestEditedChangesTitle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the title if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestEditedChangesTitle> for PullRequestEditedChangesTitle {
    fn from(value: &PullRequestEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/pull_request$assigned\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$auto_merge_disabled\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$auto_merge_enabled\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$closed\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$converted_to_draft\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$labeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$locked\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$opened\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$ready_for_review\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$reopened\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$review_request_removed\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$review_requested\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$synchronize\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$unassigned\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$unlabeled\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request$unlocked\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestEvent {
    Assigned(PullRequestAssigned),
    AutoMergeDisabled(PullRequestAutoMergeDisabled),
    AutoMergeEnabled(PullRequestAutoMergeEnabled),
    Closed(PullRequestClosed),
    ConvertedToDraft(PullRequestConvertedToDraft),
    Edited(PullRequestEdited),
    Labeled(PullRequestLabeled),
    Locked(PullRequestLocked),
    Opened(PullRequestOpened),
    ReadyForReview(PullRequestReadyForReview),
    Reopened(PullRequestReopened),
    ReviewRequestRemoved(PullRequestReviewRequestRemoved),
    ReviewRequested(PullRequestReviewRequested),
    Synchronize(PullRequestSynchronize),
    Unassigned(PullRequestUnassigned),
    Unlabeled(PullRequestUnlabeled),
    Unlocked(PullRequestUnlocked),
}
impl From<&PullRequestEvent> for PullRequestEvent {
    fn from(value: &PullRequestEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestAssigned> for PullRequestEvent {
    fn from(value: PullRequestAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl From<PullRequestAutoMergeDisabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeDisabled) -> Self {
        Self::AutoMergeDisabled(value)
    }
}
impl From<PullRequestAutoMergeEnabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeEnabled) -> Self {
        Self::AutoMergeEnabled(value)
    }
}
impl From<PullRequestClosed> for PullRequestEvent {
    fn from(value: PullRequestClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<PullRequestConvertedToDraft> for PullRequestEvent {
    fn from(value: PullRequestConvertedToDraft) -> Self {
        Self::ConvertedToDraft(value)
    }
}
impl From<PullRequestEdited> for PullRequestEvent {
    fn from(value: PullRequestEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<PullRequestLabeled> for PullRequestEvent {
    fn from(value: PullRequestLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<PullRequestLocked> for PullRequestEvent {
    fn from(value: PullRequestLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<PullRequestOpened> for PullRequestEvent {
    fn from(value: PullRequestOpened) -> Self {
        Self::Opened(value)
    }
}
impl From<PullRequestReadyForReview> for PullRequestEvent {
    fn from(value: PullRequestReadyForReview) -> Self {
        Self::ReadyForReview(value)
    }
}
impl From<PullRequestReopened> for PullRequestEvent {
    fn from(value: PullRequestReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<PullRequestReviewRequestRemoved> for PullRequestEvent {
    fn from(value: PullRequestReviewRequestRemoved) -> Self {
        Self::ReviewRequestRemoved(value)
    }
}
impl From<PullRequestReviewRequested> for PullRequestEvent {
    fn from(value: PullRequestReviewRequested) -> Self {
        Self::ReviewRequested(value)
    }
}
impl From<PullRequestSynchronize> for PullRequestEvent {
    fn from(value: PullRequestSynchronize) -> Self {
        Self::Synchronize(value)
    }
}
impl From<PullRequestUnassigned> for PullRequestEvent {
    fn from(value: PullRequestUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl From<PullRequestUnlabeled> for PullRequestEvent {
    fn from(value: PullRequestUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<PullRequestUnlocked> for PullRequestEvent {
    fn from(value: PullRequestUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
#[doc = "PullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestHead> for PullRequestHead {
    fn from(value: &PullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestLabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request labeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"label\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"labeled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLabeled {
    pub action: PullRequestLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestLabeled> for PullRequestLabeled {
    fn from(value: &PullRequestLabeled) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestLabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"labeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&PullRequestLabeledAction> for PullRequestLabeledAction {
    fn from(value: &PullRequestLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestLinks> for PullRequestLinks {
    fn from(value: &PullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestLocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request locked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"locked\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLocked {
    pub action: PullRequestLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestLocked> for PullRequestLocked {
    fn from(value: &PullRequestLocked) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestLockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"locked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&PullRequestLockedAction> for PullRequestLockedAction {
    fn from(value: &PullRequestLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestOpened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request opened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"opened\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"active_lock_reason\",\n            \"closed_at\",\n            \"merge_commit_sha\",\n            \"merged_at\",\n            \"merged_by\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"active_lock_reason\": {\n              \"type\": \"null\"\n            },\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"merge_commit_sha\": {\n              \"type\": \"null\"\n            },\n            \"merged_at\": {\n              \"type\": \"null\"\n            },\n            \"merged_by\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpened {
    pub action: PullRequestOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestOpenedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestOpened> for PullRequestOpened {
    fn from(value: &PullRequestOpened) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestOpenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"opened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&PullRequestOpenedAction> for PullRequestOpenedAction {
    fn from(value: &PullRequestOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestOpenedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": \"null\",\n      \"enum\": [\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"description\": \"Indicates whether or not the pull request is a draft.\",\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": \"null\"\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"type\": \"null\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequest {
    pub active_lock_reason: PullRequestOpenedPullRequestActiveLockReason,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestOpenedPullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestOpenedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestOpenedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: (),
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: Option<bool>,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestOpenedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    pub state: PullRequestOpenedPullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestOpenedPullRequest> for PullRequestOpenedPullRequest {
    fn from(value: &PullRequestOpenedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestOpenedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"null\",\n  \"enum\": [\n    null\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Serialize)]
pub struct PullRequestOpenedPullRequestActiveLockReason(());
impl std::ops::Deref for PullRequestOpenedPullRequestActiveLockReason {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl From<PullRequestOpenedPullRequestActiveLockReason> for () {
    fn from(value: PullRequestOpenedPullRequestActiveLockReason) -> Self {
        value.0
    }
}
impl From<&PullRequestOpenedPullRequestActiveLockReason>
    for PullRequestOpenedPullRequestActiveLockReason
{
    fn from(value: &PullRequestOpenedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<()> for PullRequestOpenedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: ()) -> Result<Self, &'static str> {
        if ![()].contains(&value) {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for PullRequestOpenedPullRequestActiveLockReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "PullRequestOpenedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestOpenedPullRequestBase> for PullRequestOpenedPullRequestBase {
    fn from(value: &PullRequestOpenedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestOpenedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestOpenedPullRequestHead> for PullRequestOpenedPullRequestHead {
    fn from(value: &PullRequestOpenedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestOpenedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestOpenedPullRequestLinks> for PullRequestOpenedPullRequestLinks {
    fn from(value: &PullRequestOpenedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestOpenedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestOpenedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestOpenedPullRequestRequestedReviewersItem>
    for PullRequestOpenedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestOpenedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestOpenedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestOpenedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestOpenedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestOpenedPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl From<&PullRequestOpenedPullRequestState> for PullRequestOpenedPullRequestState {
    fn from(value: &PullRequestOpenedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestOpenedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestOpenedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestOpenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestOpenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestOpenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReadyForReview"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request ready_for_review event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"ready_for_review\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"draft\",\n            \"merged\",\n            \"merged_at\",\n            \"merged_by\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"draft\": {\n              \"description\": \"Indicates whether or not the pull request is a draft.\",\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            },\n            \"merged\": {\n              \"type\": \"boolean\"\n            },\n            \"merged_at\": {\n              \"type\": \"null\"\n            },\n            \"merged_by\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReview {
    pub action: PullRequestReadyForReviewAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReadyForReviewPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReadyForReview> for PullRequestReadyForReview {
    fn from(value: &PullRequestReadyForReview) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReadyForReviewAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"ready_for_review\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReadyForReviewAction {
    #[serde(rename = "ready_for_review")]
    ReadyForReview,
}
impl From<&PullRequestReadyForReviewAction> for PullRequestReadyForReviewAction {
    fn from(value: &PullRequestReadyForReviewAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReadyForReviewAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReadyForReview => "ready_for_review".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReadyForReviewAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ready_for_review" => Ok(Self::ReadyForReview),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReadyForReviewPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": \"boolean\"\n    },\n    \"merged_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"type\": \"null\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequest {
    pub active_lock_reason: Option<PullRequestReadyForReviewPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestReadyForReviewPullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    pub draft: bool,
    pub head: PullRequestReadyForReviewPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReadyForReviewPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestReadyForReviewPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    pub state: PullRequestReadyForReviewPullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReadyForReviewPullRequest> for PullRequestReadyForReviewPullRequest {
    fn from(value: &PullRequestReadyForReviewPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReadyForReviewPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReadyForReviewPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReadyForReviewPullRequestActiveLockReason>
    for PullRequestReadyForReviewPullRequestActiveLockReason
{
    fn from(value: &PullRequestReadyForReviewPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReadyForReviewPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReadyForReviewPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReadyForReviewPullRequestBase> for PullRequestReadyForReviewPullRequestBase {
    fn from(value: &PullRequestReadyForReviewPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReadyForReviewPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReadyForReviewPullRequestHead> for PullRequestReadyForReviewPullRequestHead {
    fn from(value: &PullRequestReadyForReviewPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReadyForReviewPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReadyForReviewPullRequestLinks>
    for PullRequestReadyForReviewPullRequestLinks
{
    fn from(value: &PullRequestReadyForReviewPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReadyForReviewPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReadyForReviewPullRequestRequestedReviewersItem>
    for PullRequestReadyForReviewPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReadyForReviewPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestReadyForReviewPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReadyForReviewPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl From<&PullRequestReadyForReviewPullRequestState>
    for PullRequestReadyForReviewPullRequestState
{
    fn from(value: &PullRequestReadyForReviewPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReadyForReviewPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReadyForReviewPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReadyForReviewPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReopened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request reopened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"closed_at\",\n            \"merge_commit_sha\",\n            \"merged\",\n            \"merged_at\",\n            \"merged_by\",\n            \"state\"\n          ],\n          \"properties\": {\n            \"closed_at\": {\n              \"type\": \"null\"\n            },\n            \"merge_commit_sha\": {\n              \"type\": \"null\"\n            },\n            \"merged\": {\n              \"type\": \"boolean\"\n            },\n            \"merged_at\": {\n              \"type\": \"null\"\n            },\n            \"merged_by\": {\n              \"type\": \"null\"\n            },\n            \"state\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"open\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopened {
    pub action: PullRequestReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReopenedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReopened> for PullRequestReopened {
    fn from(value: &PullRequestReopened) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReopenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&PullRequestReopenedAction> for PullRequestReopenedAction {
    fn from(value: &PullRequestReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReopenedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"additions\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"changed_files\",\n    \"closed_at\",\n    \"comments\",\n    \"comments_url\",\n    \"commits\",\n    \"commits_url\",\n    \"created_at\",\n    \"deletions\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"maintainer_can_modify\",\n    \"merge_commit_sha\",\n    \"mergeable\",\n    \"mergeable_state\",\n    \"merged\",\n    \"merged_at\",\n    \"merged_by\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"rebaseable\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"additions\": {\n      \"type\": \"integer\"\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"changed_files\": {\n      \"type\": \"integer\"\n    },\n    \"closed_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"comments\": {\n      \"type\": \"integer\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits\": {\n      \"type\": \"integer\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"deletions\": {\n      \"type\": \"integer\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"description\": \"Indicates whether or not the pull request is a draft.\",\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"maintainer_can_modify\": {\n      \"description\": \"Indicates whether maintainers can modify the pull request.\",\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": \"null\"\n    },\n    \"mergeable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"mergeable_state\": {\n      \"type\": \"string\"\n    },\n    \"merged\": {\n      \"type\": \"boolean\"\n    },\n    \"merged_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"merged_by\": {\n      \"type\": \"null\"\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"description\": \"Number uniquely identifying the pull request within its repository.\",\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"rebaseable\": {\n      \"type\": [\n        \"boolean\",\n        \"null\"\n      ]\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments\": {\n      \"type\": \"integer\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"description\": \"The title of the pull request.\",\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequest {
    pub active_lock_reason: Option<PullRequestReopenedPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestReopenedPullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestReopenedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReopenedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: (),
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestReopenedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    pub state: PullRequestReopenedPullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReopenedPullRequest> for PullRequestReopenedPullRequest {
    fn from(value: &PullRequestReopenedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReopenedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReopenedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReopenedPullRequestActiveLockReason>
    for PullRequestReopenedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReopenedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReopenedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReopenedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReopenedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReopenedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReopenedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReopenedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReopenedPullRequestBase> for PullRequestReopenedPullRequestBase {
    fn from(value: &PullRequestReopenedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReopenedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReopenedPullRequestHead> for PullRequestReopenedPullRequestHead {
    fn from(value: &PullRequestReopenedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReopenedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReopenedPullRequestLinks> for PullRequestReopenedPullRequestLinks {
    fn from(value: &PullRequestReopenedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReopenedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReopenedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReopenedPullRequestRequestedReviewersItem>
    for PullRequestReopenedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReopenedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReopenedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReopenedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestReopenedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReopenedPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl From<&PullRequestReopenedPullRequestState> for PullRequestReopenedPullRequestState {
    fn from(value: &PullRequestReopenedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReopenedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReopenedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReopenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReopenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReopenedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestRequestedReviewersItem> for PullRequestRequestedReviewersItem {
    fn from(value: &PullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Pull Request Review Comment\",\n  \"description\": \"The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"author_association\",\n    \"body\",\n    \"commit_id\",\n    \"created_at\",\n    \"diff_hunk\",\n    \"html_url\",\n    \"id\",\n    \"line\",\n    \"node_id\",\n    \"original_commit_id\",\n    \"original_line\",\n    \"original_position\",\n    \"original_start_line\",\n    \"path\",\n    \"position\",\n    \"pull_request_review_id\",\n    \"pull_request_url\",\n    \"side\",\n    \"start_line\",\n    \"start_side\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"html\",\n        \"pull_request\",\n        \"self\"\n      ],\n      \"properties\": {\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"The text of the comment.\",\n      \"type\": \"string\"\n    },\n    \"commit_id\": {\n      \"description\": \"The SHA of the commit to which the comment applies.\",\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"diff_hunk\": {\n      \"description\": \"The diff of the line that the comment refers to.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"description\": \"HTML URL for the pull request review comment.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"The ID of the pull request review comment.\",\n      \"type\": \"integer\"\n    },\n    \"in_reply_to_id\": {\n      \"description\": \"The comment ID to reply to.\",\n      \"type\": \"integer\"\n    },\n    \"line\": {\n      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"node_id\": {\n      \"description\": \"The node ID of the pull request review comment.\",\n      \"type\": \"string\"\n    },\n    \"original_commit_id\": {\n      \"description\": \"The SHA of the original commit to which the comment applies.\",\n      \"type\": \"string\"\n    },\n    \"original_line\": {\n      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\",\n      \"type\": \"integer\"\n    },\n    \"original_position\": {\n      \"description\": \"The index of the original line in the diff to which the comment applies.\",\n      \"type\": \"integer\"\n    },\n    \"original_start_line\": {\n      \"description\": \"The first line of the range for a multi-line comment.\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"path\": {\n      \"description\": \"The relative path of the file to which the comment applies.\",\n      \"type\": \"string\"\n    },\n    \"position\": {\n      \"description\": \"The line index in the diff to which the comment applies.\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"pull_request_review_id\": {\n      \"description\": \"The ID of the pull request review to which the comment belongs.\",\n      \"type\": \"integer\"\n    },\n    \"pull_request_url\": {\n      \"description\": \"URL for the pull request that the review comment belongs to.\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"side\": {\n      \"description\": \"The side of the first line of the range for a multi-line comment.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"LEFT\",\n        \"RIGHT\"\n      ]\n    },\n    \"start_line\": {\n      \"description\": \"The first line of the range for a multi-line comment.\",\n      \"type\": [\n        \"integer\",\n        \"null\"\n      ]\n    },\n    \"start_side\": {\n      \"description\": \"The side of the first line of the range for a multi-line comment.\",\n      \"default\": \"RIGHT\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"LEFT\",\n        \"RIGHT\",\n        null\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"description\": \"URL for the pull request review comment\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The diff of the line that the comment refers to."]
    pub diff_hunk: String,
    #[doc = "HTML URL for the pull request review comment."]
    pub html_url: String,
    #[doc = "The ID of the pull request review comment."]
    pub id: i64,
    #[doc = "The comment ID to reply to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentLinks,
    #[doc = "The node ID of the pull request review comment."]
    pub node_id: String,
    #[doc = "The SHA of the original commit to which the comment applies."]
    pub original_commit_id: String,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub original_line: i64,
    #[doc = "The index of the original line in the diff to which the comment applies."]
    pub original_position: i64,
    #[doc = "The first line of the range for a multi-line comment."]
    pub original_start_line: Option<i64>,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: String,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    pub pull_request_review_id: i64,
    #[doc = "URL for the pull request that the review comment belongs to."]
    pub pull_request_url: String,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub side: PullRequestReviewCommentSide,
    #[doc = "The first line of the range for a multi-line comment."]
    pub start_line: Option<i64>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub start_side: Option<PullRequestReviewCommentStartSide>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the pull request review comment"]
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewComment> for PullRequestReviewComment {
    fn from(value: &PullRequestReviewComment) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review_comment created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/pull-request-review-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"active_lock_reason\",\n        \"assignee\",\n        \"assignees\",\n        \"author_association\",\n        \"base\",\n        \"body\",\n        \"closed_at\",\n        \"comments_url\",\n        \"commits_url\",\n        \"created_at\",\n        \"diff_url\",\n        \"head\",\n        \"html_url\",\n        \"id\",\n        \"issue_url\",\n        \"labels\",\n        \"locked\",\n        \"merge_commit_sha\",\n        \"merged_at\",\n        \"milestone\",\n        \"node_id\",\n        \"number\",\n        \"patch_url\",\n        \"requested_reviewers\",\n        \"requested_teams\",\n        \"review_comment_url\",\n        \"review_comments_url\",\n        \"state\",\n        \"statuses_url\",\n        \"title\",\n        \"updated_at\",\n        \"url\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"comments\",\n            \"commits\",\n            \"html\",\n            \"issue\",\n            \"review_comment\",\n            \"review_comments\",\n            \"self\",\n            \"statuses\"\n          ],\n          \"properties\": {\n            \"comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"commits\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"issue\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comment\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"self\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"statuses\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"active_lock_reason\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"resolved\",\n            \"off-topic\",\n            \"too heated\",\n            \"spam\",\n            null\n          ]\n        },\n        \"assignee\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"assignees\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/user\"\n          }\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"auto_merge\": {\n          \"type\": \"null\"\n        },\n        \"base\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"closed_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"commits_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"head\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"issue_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"labels\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/label\"\n          }\n        },\n        \"locked\": {\n          \"type\": \"boolean\"\n        },\n        \"merge_commit_sha\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"merged_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"milestone\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/milestone\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"requested_reviewers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/definitions/user\"\n              },\n              {\n                \"$ref\": \"#/definitions/team\"\n              }\n            ]\n          }\n        },\n        \"requested_teams\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/team\"\n          }\n        },\n        \"review_comment_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"review_comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"closed\"\n          ]\n        },\n        \"statuses_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreated {
    pub action: PullRequestReviewCommentCreatedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentCreatedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentCreated> for PullRequestReviewCommentCreated {
    fn from(value: &PullRequestReviewCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&PullRequestReviewCommentCreatedAction> for PullRequestReviewCommentCreatedAction {
    fn from(value: &PullRequestReviewCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"base\",\n    \"body\",\n    \"closed_at\",\n    \"comments_url\",\n    \"commits_url\",\n    \"created_at\",\n    \"diff_url\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"merge_commit_sha\",\n    \"merged_at\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentCreatedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentCreatedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentCreatedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentCreatedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentCreatedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequest>
    for PullRequestReviewCommentCreatedPullRequest
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentCreatedPullRequestActiveLockReason>
    for PullRequestReviewCommentCreatedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestBase>
    for PullRequestReviewCommentCreatedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestHead>
    for PullRequestReviewCommentCreatedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentCreatedPullRequestLinks>
    for PullRequestReviewCommentCreatedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestReviewCommentCreatedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentCreatedPullRequestState>
    for PullRequestReviewCommentCreatedPullRequestState
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review_comment deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"comment\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/pull-request-review-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"active_lock_reason\",\n        \"assignee\",\n        \"assignees\",\n        \"author_association\",\n        \"base\",\n        \"body\",\n        \"closed_at\",\n        \"comments_url\",\n        \"commits_url\",\n        \"created_at\",\n        \"diff_url\",\n        \"head\",\n        \"html_url\",\n        \"id\",\n        \"issue_url\",\n        \"labels\",\n        \"locked\",\n        \"merge_commit_sha\",\n        \"merged_at\",\n        \"milestone\",\n        \"node_id\",\n        \"number\",\n        \"patch_url\",\n        \"requested_reviewers\",\n        \"requested_teams\",\n        \"review_comment_url\",\n        \"review_comments_url\",\n        \"state\",\n        \"statuses_url\",\n        \"title\",\n        \"updated_at\",\n        \"url\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"comments\",\n            \"commits\",\n            \"html\",\n            \"issue\",\n            \"review_comment\",\n            \"review_comments\",\n            \"self\",\n            \"statuses\"\n          ],\n          \"properties\": {\n            \"comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"commits\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"issue\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comment\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"self\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"statuses\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"active_lock_reason\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"resolved\",\n            \"off-topic\",\n            \"too heated\",\n            \"spam\",\n            null\n          ]\n        },\n        \"assignee\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"assignees\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/user\"\n          }\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"auto_merge\": {\n          \"type\": \"null\"\n        },\n        \"base\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"closed_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"commits_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"head\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"issue_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"labels\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/label\"\n          }\n        },\n        \"locked\": {\n          \"type\": \"boolean\"\n        },\n        \"merge_commit_sha\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"merged_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"milestone\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/milestone\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"requested_reviewers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/definitions/user\"\n              },\n              {\n                \"$ref\": \"#/definitions/team\"\n              }\n            ]\n          }\n        },\n        \"requested_teams\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/team\"\n          }\n        },\n        \"review_comment_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"review_comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"closed\"\n          ]\n        },\n        \"statuses_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeleted {
    pub action: PullRequestReviewCommentDeletedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentDeletedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentDeleted> for PullRequestReviewCommentDeleted {
    fn from(value: &PullRequestReviewCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&PullRequestReviewCommentDeletedAction> for PullRequestReviewCommentDeletedAction {
    fn from(value: &PullRequestReviewCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"base\",\n    \"body\",\n    \"closed_at\",\n    \"comments_url\",\n    \"commits_url\",\n    \"created_at\",\n    \"diff_url\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"merge_commit_sha\",\n    \"merged_at\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentDeletedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentDeletedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentDeletedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentDeletedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentDeletedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequest>
    for PullRequestReviewCommentDeletedPullRequest
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentDeletedPullRequestActiveLockReason>
    for PullRequestReviewCommentDeletedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestBase>
    for PullRequestReviewCommentDeletedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestHead>
    for PullRequestReviewCommentDeletedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentDeletedPullRequestLinks>
    for PullRequestReviewCommentDeletedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestReviewCommentDeletedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentDeletedPullRequestState>
    for PullRequestReviewCommentDeletedPullRequestState
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review_comment edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"comment\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the comment.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"comment\": {\n      \"$ref\": \"#/definitions/pull-request-review-comment\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"active_lock_reason\",\n        \"assignee\",\n        \"assignees\",\n        \"author_association\",\n        \"base\",\n        \"body\",\n        \"closed_at\",\n        \"comments_url\",\n        \"commits_url\",\n        \"created_at\",\n        \"diff_url\",\n        \"head\",\n        \"html_url\",\n        \"id\",\n        \"issue_url\",\n        \"labels\",\n        \"locked\",\n        \"merge_commit_sha\",\n        \"merged_at\",\n        \"milestone\",\n        \"node_id\",\n        \"number\",\n        \"patch_url\",\n        \"requested_reviewers\",\n        \"requested_teams\",\n        \"review_comment_url\",\n        \"review_comments_url\",\n        \"state\",\n        \"statuses_url\",\n        \"title\",\n        \"updated_at\",\n        \"url\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"comments\",\n            \"commits\",\n            \"html\",\n            \"issue\",\n            \"review_comment\",\n            \"review_comments\",\n            \"self\",\n            \"statuses\"\n          ],\n          \"properties\": {\n            \"comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"commits\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"issue\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comment\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"review_comments\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"self\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"statuses\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"active_lock_reason\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"resolved\",\n            \"off-topic\",\n            \"too heated\",\n            \"spam\",\n            null\n          ]\n        },\n        \"assignee\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"assignees\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/user\"\n          }\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"auto_merge\": {\n          \"type\": \"null\"\n        },\n        \"base\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"body\": {\n          \"type\": \"string\"\n        },\n        \"closed_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"commits_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"diff_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"draft\": {\n          \"type\": \"boolean\"\n        },\n        \"head\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"label\",\n            \"ref\",\n            \"repo\",\n            \"sha\",\n            \"user\"\n          ],\n          \"properties\": {\n            \"label\": {\n              \"type\": \"string\"\n            },\n            \"ref\": {\n              \"type\": \"string\"\n            },\n            \"repo\": {\n              \"$ref\": \"#/definitions/repository\"\n            },\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"issue_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"labels\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/label\"\n          }\n        },\n        \"locked\": {\n          \"type\": \"boolean\"\n        },\n        \"merge_commit_sha\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"merged_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"milestone\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/milestone\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"patch_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"requested_reviewers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/definitions/user\"\n              },\n              {\n                \"$ref\": \"#/definitions/team\"\n              }\n            ]\n          }\n        },\n        \"requested_teams\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/team\"\n          }\n        },\n        \"review_comment_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"review_comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"closed\"\n          ]\n        },\n        \"statuses_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEdited {
    pub action: PullRequestReviewCommentEditedAction,
    pub changes: PullRequestReviewCommentEditedChanges,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentEditedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentEdited> for PullRequestReviewCommentEdited {
    fn from(value: &PullRequestReviewCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestReviewCommentEditedAction> for PullRequestReviewCommentEditedAction {
    fn from(value: &PullRequestReviewCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the comment.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewCommentEditedChangesBody>,
}
impl From<&PullRequestReviewCommentEditedChanges> for PullRequestReviewCommentEditedChanges {
    fn from(value: &PullRequestReviewCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&PullRequestReviewCommentEditedChangesBody>
    for PullRequestReviewCommentEditedChangesBody
{
    fn from(value: &PullRequestReviewCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"base\",\n    \"body\",\n    \"closed_at\",\n    \"comments_url\",\n    \"commits_url\",\n    \"created_at\",\n    \"diff_url\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"merge_commit_sha\",\n    \"merged_at\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentEditedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentEditedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentEditedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentEditedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentEditedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequest>
    for PullRequestReviewCommentEditedPullRequest
{
    fn from(value: &PullRequestReviewCommentEditedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentEditedPullRequestActiveLockReason>
    for PullRequestReviewCommentEditedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequestBase>
    for PullRequestReviewCommentEditedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequestHead>
    for PullRequestReviewCommentEditedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentEditedPullRequestLinks>
    for PullRequestReviewCommentEditedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "PullRequestReviewCommentEditedPullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentEditedPullRequestState>
    for PullRequestReviewCommentEditedPullRequestState
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewCommentEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/pull_request_review_comment$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review_comment$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review_comment$edited\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEvent {
    Created(PullRequestReviewCommentCreated),
    Deleted(PullRequestReviewCommentDeleted),
    Edited(PullRequestReviewCommentEdited),
}
impl From<&PullRequestReviewCommentEvent> for PullRequestReviewCommentEvent {
    fn from(value: &PullRequestReviewCommentEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestReviewCommentCreated> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<PullRequestReviewCommentDeleted> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<PullRequestReviewCommentEdited> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "PullRequestReviewCommentLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"html\",\n    \"pull_request\",\n    \"self\"\n  ],\n  \"properties\": {\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentLinks {
    pub html: Link,
    pub pull_request: Link,
    #[serde(rename = "self")]
    pub self_: Link,
}
impl From<&PullRequestReviewCommentLinks> for PullRequestReviewCommentLinks {
    fn from(value: &PullRequestReviewCommentLinks) -> Self {
        value.clone()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The side of the first line of the range for a multi-line comment.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"LEFT\",\n    \"RIGHT\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl From<&PullRequestReviewCommentSide> for PullRequestReviewCommentSide {
    fn from(value: &PullRequestReviewCommentSide) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The side of the first line of the range for a multi-line comment.\",\n  \"default\": \"RIGHT\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"LEFT\",\n    \"RIGHT\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentStartSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl From<&PullRequestReviewCommentStartSide> for PullRequestReviewCommentStartSide {
    fn from(value: &PullRequestReviewCommentStartSide) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentStartSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentStartSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewDismissed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review dismissed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"pull_request\",\n    \"repository\",\n    \"review\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dismissed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/simple-pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"review\": {\n      \"description\": \"The review that was affected.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"author_association\",\n        \"body\",\n        \"commit_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"pull_request_url\",\n        \"state\",\n        \"submitted_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"html\",\n            \"pull_request\"\n          ],\n          \"properties\": {\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"pull_request\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"description\": \"The text of the review.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"commit_id\": {\n          \"description\": \"A commit SHA for the review.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"Unique identifier of the review\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_request_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"dismissed\"\n          ]\n        },\n        \"submitted_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissed {
    pub action: PullRequestReviewDismissedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewDismissedReview,
    pub sender: User,
}
impl From<&PullRequestReviewDismissed> for PullRequestReviewDismissed {
    fn from(value: &PullRequestReviewDismissed) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewDismissedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewDismissedAction {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&PullRequestReviewDismissedAction> for PullRequestReviewDismissedAction {
    fn from(value: &PullRequestReviewDismissedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewDismissedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The review that was affected.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"author_association\",\n    \"body\",\n    \"commit_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"pull_request_url\",\n    \"state\",\n    \"submitted_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"html\",\n        \"pull_request\"\n      ],\n      \"properties\": {\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"The text of the review.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"commit_id\": {\n      \"description\": \"A commit SHA for the review.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the review\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_request_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dismissed\"\n      ]\n    },\n    \"submitted_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewDismissedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: PullRequestReviewDismissedReviewState,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewDismissedReview> for PullRequestReviewDismissedReview {
    fn from(value: &PullRequestReviewDismissedReview) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewDismissedReviewLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"html\",\n    \"pull_request\"\n  ],\n  \"properties\": {\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewDismissedReviewLinks> for PullRequestReviewDismissedReviewLinks {
    fn from(value: &PullRequestReviewDismissedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewDismissedReviewState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"dismissed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewDismissedReviewState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&PullRequestReviewDismissedReviewState> for PullRequestReviewDismissedReviewState {
    fn from(value: &PullRequestReviewDismissedReviewState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewDismissedReviewState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedReviewState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"pull_request\",\n    \"repository\",\n    \"review\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/simple-pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"review\": {\n      \"description\": \"The review that was affected.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"author_association\",\n        \"body\",\n        \"commit_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"pull_request_url\",\n        \"state\",\n        \"submitted_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"html\",\n            \"pull_request\"\n          ],\n          \"properties\": {\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"pull_request\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"description\": \"The text of the review.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"commit_id\": {\n          \"description\": \"A commit SHA for the review.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"Unique identifier of the review\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_request_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\"\n        },\n        \"submitted_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEdited {
    pub action: PullRequestReviewEditedAction,
    pub changes: PullRequestReviewEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewEditedReview,
    pub sender: User,
}
impl From<&PullRequestReviewEdited> for PullRequestReviewEdited {
    fn from(value: &PullRequestReviewEdited) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestReviewEditedAction> for PullRequestReviewEditedAction {
    fn from(value: &PullRequestReviewEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewEditedChangesBody>,
}
impl From<&PullRequestReviewEditedChanges> for PullRequestReviewEditedChanges {
    fn from(value: &PullRequestReviewEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestReviewEditedChangesBody> for PullRequestReviewEditedChangesBody {
    fn from(value: &PullRequestReviewEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The review that was affected.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"author_association\",\n    \"body\",\n    \"commit_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"pull_request_url\",\n    \"state\",\n    \"submitted_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"html\",\n        \"pull_request\"\n      ],\n      \"properties\": {\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"The text of the review.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"commit_id\": {\n      \"description\": \"A commit SHA for the review.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the review\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_request_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"submitted_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewEditedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewEditedReview> for PullRequestReviewEditedReview {
    fn from(value: &PullRequestReviewEditedReview) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewEditedReviewLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"html\",\n    \"pull_request\"\n  ],\n  \"properties\": {\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewEditedReviewLinks> for PullRequestReviewEditedReviewLinks {
    fn from(value: &PullRequestReviewEditedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/pull_request_review$dismissed\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/pull_request_review$submitted\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewEvent {
    Dismissed(PullRequestReviewDismissed),
    Edited(PullRequestReviewEdited),
    Submitted(PullRequestReviewSubmitted),
}
impl From<&PullRequestReviewEvent> for PullRequestReviewEvent {
    fn from(value: &PullRequestReviewEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestReviewDismissed> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewDismissed) -> Self {
        Self::Dismissed(value)
    }
}
impl From<PullRequestReviewEdited> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<PullRequestReviewSubmitted> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewSubmitted) -> Self {
        Self::Submitted(value)
    }
}
#[doc = "PullRequestReviewRequestRemoved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request review_request_removed event\",\n  \"oneOf\": [\n    {\n      \"type\": \"object\",\n      \"required\": [\n        \"action\",\n        \"number\",\n        \"pull_request\",\n        \"repository\",\n        \"requested_reviewer\",\n        \"sender\"\n      ],\n      \"properties\": {\n        \"action\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"review_request_removed\"\n          ]\n        },\n        \"installation\": {\n          \"$ref\": \"#/definitions/installation-lite\"\n        },\n        \"number\": {\n          \"description\": \"The pull request number.\",\n          \"type\": \"integer\"\n        },\n        \"organization\": {\n          \"$ref\": \"#/definitions/organization\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        \"repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"requested_reviewer\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sender\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    {\n      \"type\": \"object\",\n      \"required\": [\n        \"action\",\n        \"number\",\n        \"pull_request\",\n        \"repository\",\n        \"requested_team\",\n        \"sender\"\n      ],\n      \"properties\": {\n        \"action\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"review_request_removed\"\n          ]\n        },\n        \"installation\": {\n          \"$ref\": \"#/definitions/installation-lite\"\n        },\n        \"number\": {\n          \"description\": \"The pull request number.\",\n          \"type\": \"integer\"\n        },\n        \"organization\": {\n          \"$ref\": \"#/definitions/organization\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        \"repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"requested_team\": {\n          \"$ref\": \"#/definitions/team\"\n        },\n        \"sender\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  ],\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequestRemoved {
    Variant0 {
        action: PullRequestReviewRequestRemovedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestRemovedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl From<&PullRequestReviewRequestRemoved> for PullRequestReviewRequestRemoved {
    fn from(value: &PullRequestReviewRequestRemoved) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewRequestRemovedVariant0Action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"review_request_removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant0Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant0Action>
    for PullRequestReviewRequestRemovedVariant0Action
{
    fn from(value: &PullRequestReviewRequestRemovedVariant0Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestRemovedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewRequestRemovedVariant1Action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"review_request_removed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant1Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant1Action>
    for PullRequestReviewRequestRemovedVariant1Action
{
    fn from(value: &PullRequestReviewRequestRemovedVariant1Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestRemovedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewRequested"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request review_requested event\",\n  \"oneOf\": [\n    {\n      \"type\": \"object\",\n      \"required\": [\n        \"action\",\n        \"number\",\n        \"pull_request\",\n        \"repository\",\n        \"requested_reviewer\",\n        \"sender\"\n      ],\n      \"properties\": {\n        \"action\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"review_requested\"\n          ]\n        },\n        \"installation\": {\n          \"$ref\": \"#/definitions/installation-lite\"\n        },\n        \"number\": {\n          \"description\": \"The pull request number.\",\n          \"type\": \"integer\"\n        },\n        \"organization\": {\n          \"$ref\": \"#/definitions/organization\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        \"repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"requested_reviewer\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sender\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    {\n      \"type\": \"object\",\n      \"required\": [\n        \"action\",\n        \"number\",\n        \"pull_request\",\n        \"repository\",\n        \"requested_team\",\n        \"sender\"\n      ],\n      \"properties\": {\n        \"action\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"review_requested\"\n          ]\n        },\n        \"installation\": {\n          \"$ref\": \"#/definitions/installation-lite\"\n        },\n        \"number\": {\n          \"description\": \"The pull request number.\",\n          \"type\": \"integer\"\n        },\n        \"organization\": {\n          \"$ref\": \"#/definitions/organization\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/pull-request\"\n        },\n        \"repository\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"requested_team\": {\n          \"$ref\": \"#/definitions/team\"\n        },\n        \"sender\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  ],\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequested {
    Variant0 {
        action: PullRequestReviewRequestedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl From<&PullRequestReviewRequested> for PullRequestReviewRequested {
    fn from(value: &PullRequestReviewRequested) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewRequestedVariant0Action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"review_requested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant0Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant0Action> for PullRequestReviewRequestedVariant0Action {
    fn from(value: &PullRequestReviewRequestedVariant0Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewRequestedVariant1Action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"review_requested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant1Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant1Action> for PullRequestReviewRequestedVariant1Action {
    fn from(value: &PullRequestReviewRequestedVariant1Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestReviewSubmitted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request_review submitted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"pull_request\",\n    \"repository\",\n    \"review\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"submitted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/simple-pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"review\": {\n      \"description\": \"The review that was affected.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"_links\",\n        \"author_association\",\n        \"body\",\n        \"commit_id\",\n        \"html_url\",\n        \"id\",\n        \"node_id\",\n        \"pull_request_url\",\n        \"state\",\n        \"submitted_at\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"_links\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"html\",\n            \"pull_request\"\n          ],\n          \"properties\": {\n            \"html\": {\n              \"$ref\": \"#/definitions/link\"\n            },\n            \"pull_request\": {\n              \"$ref\": \"#/definitions/link\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"author_association\": {\n          \"$ref\": \"#/definitions/author_association\"\n        },\n        \"body\": {\n          \"description\": \"The text of the review.\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"commit_id\": {\n          \"description\": \"A commit SHA for the review.\",\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"Unique identifier of the review\",\n          \"type\": \"integer\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"pull_request_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"state\": {\n          \"type\": \"string\"\n        },\n        \"submitted_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmitted {
    pub action: PullRequestReviewSubmittedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewSubmittedReview,
    pub sender: User,
}
impl From<&PullRequestReviewSubmitted> for PullRequestReviewSubmitted {
    fn from(value: &PullRequestReviewSubmitted) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewSubmittedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"submitted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewSubmittedAction {
    #[serde(rename = "submitted")]
    Submitted,
}
impl From<&PullRequestReviewSubmittedAction> for PullRequestReviewSubmittedAction {
    fn from(value: &PullRequestReviewSubmittedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewSubmittedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Submitted => "submitted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewSubmittedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "submitted" => Ok(Self::Submitted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The review that was affected.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"author_association\",\n    \"body\",\n    \"commit_id\",\n    \"html_url\",\n    \"id\",\n    \"node_id\",\n    \"pull_request_url\",\n    \"state\",\n    \"submitted_at\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"html\",\n        \"pull_request\"\n      ],\n      \"properties\": {\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"pull_request\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"body\": {\n      \"description\": \"The text of the review.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"commit_id\": {\n      \"description\": \"A commit SHA for the review.\",\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the review\",\n      \"type\": \"integer\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_request_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"submitted_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewSubmittedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewSubmittedReview> for PullRequestReviewSubmittedReview {
    fn from(value: &PullRequestReviewSubmittedReview) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestReviewSubmittedReviewLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"html\",\n    \"pull_request\"\n  ],\n  \"properties\": {\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewSubmittedReviewLinks> for PullRequestReviewSubmittedReviewLinks {
    fn from(value: &PullRequestReviewSubmittedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of this Pull Request. Either `open` or `closed`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestState> for PullRequestState {
    fn from(value: &PullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestSynchronize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request synchronize event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"after\",\n    \"before\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"synchronize\"\n      ]\n    },\n    \"after\": {\n      \"type\": \"string\"\n    },\n    \"before\": {\n      \"type\": \"string\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestSynchronize {
    pub action: PullRequestSynchronizeAction,
    pub after: String,
    pub before: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestSynchronize> for PullRequestSynchronize {
    fn from(value: &PullRequestSynchronize) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestSynchronizeAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"synchronize\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestSynchronizeAction {
    #[serde(rename = "synchronize")]
    Synchronize,
}
impl From<&PullRequestSynchronizeAction> for PullRequestSynchronizeAction {
    fn from(value: &PullRequestSynchronizeAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestSynchronizeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Synchronize => "synchronize".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestSynchronizeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "synchronize" => Ok(Self::Synchronize),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestUnassigned"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request unassigned event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"assignee\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unassigned\"\n      ]\n    },\n    \"assignee\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnassigned {
    pub action: PullRequestUnassignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnassigned> for PullRequestUnassigned {
    fn from(value: &PullRequestUnassigned) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestUnassignedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unassigned\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl From<&PullRequestUnassignedAction> for PullRequestUnassignedAction {
    fn from(value: &PullRequestUnassignedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestUnlabeled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request unlabeled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"label\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlabeled\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"label\": {\n      \"$ref\": \"#/definitions/label\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlabeled {
    pub action: PullRequestUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnlabeled> for PullRequestUnlabeled {
    fn from(value: &PullRequestUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestUnlabeledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlabeled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&PullRequestUnlabeledAction> for PullRequestUnlabeledAction {
    fn from(value: &PullRequestUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PullRequestUnlocked"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"pull_request unlocked event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"number\",\n    \"pull_request\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unlocked\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"number\": {\n      \"description\": \"The pull request number.\",\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pull_request\": {\n      \"$ref\": \"#/definitions/pull-request\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlocked {
    pub action: PullRequestUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnlocked> for PullRequestUnlocked {
    fn from(value: &PullRequestUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "PullRequestUnlockedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unlocked\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&PullRequestUnlockedAction> for PullRequestUnlockedAction {
    fn from(value: &PullRequestUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "PushEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"push event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"after\",\n    \"base_ref\",\n    \"before\",\n    \"commits\",\n    \"compare\",\n    \"created\",\n    \"deleted\",\n    \"forced\",\n    \"head_commit\",\n    \"pusher\",\n    \"ref\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"after\": {\n      \"description\": \"The SHA of the most recent commit on `ref` after the push.\",\n      \"type\": \"string\"\n    },\n    \"base_ref\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"before\": {\n      \"description\": \"The SHA of the most recent commit on `ref` before the push.\",\n      \"type\": \"string\"\n    },\n    \"commits\": {\n      \"description\": \"An array of commit objects describing the pushed commits.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/commit\"\n      }\n    },\n    \"compare\": {\n      \"type\": \"string\"\n    },\n    \"created\": {\n      \"type\": \"boolean\"\n    },\n    \"deleted\": {\n      \"type\": \"boolean\"\n    },\n    \"forced\": {\n      \"type\": \"boolean\"\n    },\n    \"head_commit\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/commit\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"pusher\": {\n      \"$ref\": \"#/definitions/committer\"\n    },\n    \"ref\": {\n      \"description\": \"The full git ref that was pushed. Example: `refs/heads/main`.\",\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PushEvent {
    #[doc = "The SHA of the most recent commit on `ref` after the push."]
    pub after: String,
    pub base_ref: Option<String>,
    #[doc = "The SHA of the most recent commit on `ref` before the push."]
    pub before: String,
    #[doc = "An array of commit objects describing the pushed commits."]
    pub commits: Vec<Commit>,
    pub compare: String,
    pub created: bool,
    pub deleted: bool,
    pub forced: bool,
    pub head_commit: Option<Commit>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pusher: Committer,
    #[doc = "The full git ref that was pushed. Example: `refs/heads/main`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PushEvent> for PushEvent {
    fn from(value: &PushEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Release\",\n  \"description\": \"The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"assets\",\n    \"assets_url\",\n    \"author\",\n    \"body\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"tarball_url\",\n    \"target_commitish\",\n    \"upload_url\",\n    \"url\",\n    \"zipball_url\"\n  ],\n  \"properties\": {\n    \"assets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/release-asset\"\n      }\n    },\n    \"assets_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"draft\": {\n      \"description\": \"Wether the release is a draft or published\",\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"description\": \"Whether the release is identified as a prerelease or a full release.\",\n      \"type\": \"boolean\"\n    },\n    \"published_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"tag_name\": {\n      \"description\": \"The name of the tag.\",\n      \"type\": \"string\"\n    },\n    \"tarball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"target_commitish\": {\n      \"description\": \"Specifies the commitish value that determines where the Git tag is created from.\",\n      \"type\": \"string\"\n    },\n    \"upload_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"zipball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Release {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
impl From<&Release> for Release {
    fn from(value: &Release) -> Self {
        value.clone()
    }
}
#[doc = "Data related to a release."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Release Asset\",\n  \"description\": \"Data related to a release.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"browser_download_url\",\n    \"content_type\",\n    \"created_at\",\n    \"download_count\",\n    \"id\",\n    \"label\",\n    \"name\",\n    \"node_id\",\n    \"size\",\n    \"state\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"browser_download_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"content_type\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"download_count\": {\n      \"type\": \"integer\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"label\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"name\": {\n      \"description\": \"The file name of the asset.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"state\": {\n      \"description\": \"State of the release asset.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"uploaded\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"uploader\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseAsset {
    pub browser_download_url: String,
    pub content_type: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub download_count: i64,
    pub id: i64,
    pub label: Option<String>,
    #[doc = "The file name of the asset."]
    pub name: String,
    pub node_id: String,
    pub size: i64,
    #[doc = "State of the release asset."]
    pub state: ReleaseAssetState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploader: Option<User>,
    pub url: String,
}
impl From<&ReleaseAsset> for ReleaseAsset {
    fn from(value: &ReleaseAsset) -> Self {
        value.clone()
    }
}
#[doc = "State of the release asset."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"State of the release asset.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"uploaded\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseAssetState {
    #[serde(rename = "uploaded")]
    Uploaded,
}
impl From<&ReleaseAssetState> for ReleaseAssetState {
    fn from(value: &ReleaseAssetState) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseAssetState {
    fn to_string(&self) -> String {
        match *self {
            Self::Uploaded => "uploaded".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseAssetState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "uploaded" => Ok(Self::Uploaded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"$ref\": \"#/definitions/release\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseCreated {
    pub action: ReleaseCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseCreated> for ReleaseCreated {
    fn from(value: &ReleaseCreated) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ReleaseCreatedAction> for ReleaseCreatedAction {
    fn from(value: &ReleaseCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"$ref\": \"#/definitions/release\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseDeleted {
    pub action: ReleaseDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseDeleted> for ReleaseDeleted {
    fn from(value: &ReleaseDeleted) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ReleaseDeletedAction> for ReleaseDeletedAction {
    fn from(value: &ReleaseDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"body\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the body if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the name if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"$ref\": \"#/definitions/release\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEdited {
    pub action: ReleaseEditedAction,
    pub changes: ReleaseEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseEdited> for ReleaseEdited {
    fn from(value: &ReleaseEdited) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ReleaseEditedAction> for ReleaseEditedAction {
    fn from(value: &ReleaseEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"body\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the body if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the name if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ReleaseEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ReleaseEditedChangesName>,
}
impl From<&ReleaseEditedChanges> for ReleaseEditedChanges {
    fn from(value: &ReleaseEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseEditedChangesBody"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the body if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&ReleaseEditedChangesBody> for ReleaseEditedChangesBody {
    fn from(value: &ReleaseEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseEditedChangesName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the name if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&ReleaseEditedChangesName> for ReleaseEditedChangesName {
    fn from(value: &ReleaseEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/release$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$prereleased\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$published\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$released\"\n    },\n    {\n      \"$ref\": \"#/definitions/release$unpublished\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ReleaseEvent {
    Created(ReleaseCreated),
    Deleted(ReleaseDeleted),
    Edited(ReleaseEdited),
    Prereleased(ReleasePrereleased),
    Published(ReleasePublished),
    Released(ReleaseReleased),
    Unpublished(ReleaseUnpublished),
}
impl From<&ReleaseEvent> for ReleaseEvent {
    fn from(value: &ReleaseEvent) -> Self {
        value.clone()
    }
}
impl From<ReleaseCreated> for ReleaseEvent {
    fn from(value: ReleaseCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ReleaseDeleted> for ReleaseEvent {
    fn from(value: ReleaseDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ReleaseEdited> for ReleaseEvent {
    fn from(value: ReleaseEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ReleasePrereleased> for ReleaseEvent {
    fn from(value: ReleasePrereleased) -> Self {
        Self::Prereleased(value)
    }
}
impl From<ReleasePublished> for ReleaseEvent {
    fn from(value: ReleasePublished) -> Self {
        Self::Published(value)
    }
}
impl From<ReleaseReleased> for ReleaseEvent {
    fn from(value: ReleaseReleased) -> Self {
        Self::Released(value)
    }
}
impl From<ReleaseUnpublished> for ReleaseEvent {
    fn from(value: ReleaseUnpublished) -> Self {
        Self::Unpublished(value)
    }
}
#[doc = "ReleasePrereleased"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release prereleased event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"prereleased\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/release\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"prerelease\"\n          ],\n          \"properties\": {\n            \"prerelease\": {\n              \"description\": \"Whether the release is identified as a prerelease or a full release.\",\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleased {
    pub action: ReleasePrereleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: ReleasePrereleasedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleasePrereleased> for ReleasePrereleased {
    fn from(value: &ReleasePrereleased) -> Self {
        value.clone()
    }
}
#[doc = "ReleasePrereleasedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"prereleased\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePrereleasedAction {
    #[serde(rename = "prereleased")]
    Prereleased,
}
impl From<&ReleasePrereleasedAction> for ReleasePrereleasedAction {
    fn from(value: &ReleasePrereleasedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleasePrereleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Prereleased => "prereleased".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePrereleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "prereleased" => Ok(Self::Prereleased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleasePrereleasedRelease"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"assets\",\n    \"assets_url\",\n    \"author\",\n    \"body\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"tarball_url\",\n    \"target_commitish\",\n    \"upload_url\",\n    \"url\",\n    \"zipball_url\"\n  ],\n  \"properties\": {\n    \"assets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/release-asset\"\n      }\n    },\n    \"assets_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"draft\": {\n      \"description\": \"Wether the release is a draft or published\",\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"published_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"tag_name\": {\n      \"description\": \"The name of the tag.\",\n      \"type\": \"string\"\n    },\n    \"tarball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"target_commitish\": {\n      \"description\": \"Specifies the commitish value that determines where the Git tag is created from.\",\n      \"type\": \"string\"\n    },\n    \"upload_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"zipball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleasedRelease {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    pub prerelease: bool,
    pub published_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
impl From<&ReleasePrereleasedRelease> for ReleasePrereleasedRelease {
    fn from(value: &ReleasePrereleasedRelease) -> Self {
        value.clone()
    }
}
#[doc = "ReleasePublished"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release published event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"published\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/release\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"published_at\"\n          ],\n          \"properties\": {\n            \"published_at\": {\n              \"type\": \"string\",\n              \"format\": \"date-time\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublished {
    pub action: ReleasePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: ReleasePublishedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleasePublished> for ReleasePublished {
    fn from(value: &ReleasePublished) -> Self {
        value.clone()
    }
}
#[doc = "ReleasePublishedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"published\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&ReleasePublishedAction> for ReleasePublishedAction {
    fn from(value: &ReleasePublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleasePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleasePublishedRelease"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"assets\",\n    \"assets_url\",\n    \"author\",\n    \"body\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"tarball_url\",\n    \"target_commitish\",\n    \"upload_url\",\n    \"url\",\n    \"zipball_url\"\n  ],\n  \"properties\": {\n    \"assets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/release-asset\"\n      }\n    },\n    \"assets_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"draft\": {\n      \"description\": \"Wether the release is a draft or published\",\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"description\": \"Whether the release is identified as a prerelease or a full release.\",\n      \"type\": \"boolean\"\n    },\n    \"published_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"tag_name\": {\n      \"description\": \"The name of the tag.\",\n      \"type\": \"string\"\n    },\n    \"tarball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"target_commitish\": {\n      \"description\": \"Specifies the commitish value that determines where the Git tag is created from.\",\n      \"type\": \"string\"\n    },\n    \"upload_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"zipball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublishedRelease {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
impl From<&ReleasePublishedRelease> for ReleasePublishedRelease {
    fn from(value: &ReleasePublishedRelease) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseReleased"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release released event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"released\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"$ref\": \"#/definitions/release\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseReleased {
    pub action: ReleaseReleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseReleased> for ReleaseReleased {
    fn from(value: &ReleaseReleased) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseReleasedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"released\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseReleasedAction {
    #[serde(rename = "released")]
    Released,
}
impl From<&ReleaseReleasedAction> for ReleaseReleasedAction {
    fn from(value: &ReleaseReleasedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseReleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Released => "released".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseReleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "released" => Ok(Self::Released),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseUnpublished"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"release unpublished event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"release\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unpublished\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"release\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/release\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"published_at\"\n          ],\n          \"properties\": {\n            \"published_at\": {\n              \"type\": \"null\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublished {
    pub action: ReleaseUnpublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: ReleaseUnpublishedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseUnpublished> for ReleaseUnpublished {
    fn from(value: &ReleaseUnpublished) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseUnpublishedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unpublished\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseUnpublishedAction {
    #[serde(rename = "unpublished")]
    Unpublished,
}
impl From<&ReleaseUnpublishedAction> for ReleaseUnpublishedAction {
    fn from(value: &ReleaseUnpublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseUnpublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpublished => "unpublished".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseUnpublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpublished" => Ok(Self::Unpublished),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "ReleaseUnpublishedRelease"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"assets\",\n    \"assets_url\",\n    \"author\",\n    \"body\",\n    \"created_at\",\n    \"draft\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"prerelease\",\n    \"published_at\",\n    \"tag_name\",\n    \"tarball_url\",\n    \"target_commitish\",\n    \"upload_url\",\n    \"url\",\n    \"zipball_url\"\n  ],\n  \"properties\": {\n    \"assets\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/release-asset\"\n      }\n    },\n    \"assets_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"author\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"date-time\"\n    },\n    \"draft\": {\n      \"description\": \"Wether the release is a draft or published\",\n      \"type\": \"boolean\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"prerelease\": {\n      \"description\": \"Whether the release is identified as a prerelease or a full release.\",\n      \"type\": \"boolean\"\n    },\n    \"published_at\": {\n      \"type\": \"null\",\n      \"format\": \"date-time\"\n    },\n    \"tag_name\": {\n      \"description\": \"The name of the tag.\",\n      \"type\": \"string\"\n    },\n    \"tarball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"target_commitish\": {\n      \"description\": \"Specifies the commitish value that determines where the Git tag is created from.\",\n      \"type\": \"string\"\n    },\n    \"upload_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"zipball_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublishedRelease {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: (),
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
impl From<&ReleaseUnpublishedRelease> for ReleaseUnpublishedRelease {
    fn from(value: &ReleaseUnpublishedRelease) -> Self {
        value.clone()
    }
}
#[doc = "RepoRef"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Repo Ref\",\n  \"type\": \"object\",\n  \"required\": [\n    \"id\",\n    \"name\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepoRef {
    pub id: i64,
    pub name: String,
    pub url: String,
}
impl From<&RepoRef> for RepoRef {
    fn from(value: &RepoRef) -> Self {
        value.clone()
    }
}
#[doc = "A git repository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Repository\",\n  \"description\": \"A git repository\",\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"description\": \"Whether the repository is archived.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Repository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&Repository> for Repository {
    fn from(value: &Repository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryArchived"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository archived event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"archived\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"archived\"\n          ],\n          \"properties\": {\n            \"archived\": {\n              \"description\": \"Whether the repository is archived.\",\n              \"default\": false,\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchived {
    pub action: RepositoryArchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: RepositoryArchivedRepository,
    pub sender: User,
}
impl From<&RepositoryArchived> for RepositoryArchived {
    fn from(value: &RepositoryArchived) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryArchivedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"archived\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryArchivedAction {
    #[serde(rename = "archived")]
    Archived,
}
impl From<&RepositoryArchivedAction> for RepositoryArchivedAction {
    fn from(value: &RepositoryArchivedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryArchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Archived => "archived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryArchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "archived" => Ok(Self::Archived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryArchivedRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchivedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryArchivedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryArchivedRepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryArchivedRepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&RepositoryArchivedRepository> for RepositoryArchivedRepository {
    fn from(value: &RepositoryArchivedRepository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryArchivedRepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryArchivedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryArchivedRepositoryCreatedAt> for RepositoryArchivedRepositoryCreatedAt {
    fn from(value: &RepositoryArchivedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryArchivedRepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryArchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryArchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryArchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryArchivedRepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryArchivedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryArchivedRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryArchivedRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchivedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryArchivedRepositoryPermissions> for RepositoryArchivedRepositoryPermissions {
    fn from(value: &RepositoryArchivedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryArchivedRepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryArchivedRepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryArchivedRepositoryPushedAt> for RepositoryArchivedRepositoryPushedAt {
    fn from(value: &RepositoryArchivedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryArchivedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryArchivedRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryCreated {
    pub action: RepositoryCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryCreated> for RepositoryCreated {
    fn from(value: &RepositoryCreated) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&RepositoryCreatedAction> for RepositoryCreatedAction {
    fn from(value: &RepositoryCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryCreatedAt> for RepositoryCreatedAt {
    fn from(value: &RepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDeleted {
    pub action: RepositoryDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryDeleted> for RepositoryDeleted {
    fn from(value: &RepositoryDeleted) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&RepositoryDeletedAction> for RepositoryDeletedAction {
    fn from(value: &RepositoryDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryDispatchEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/repository_dispatch$on-demand-test\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RepositoryDispatchEvent(pub RepositoryDispatchOnDemandTest);
impl std::ops::Deref for RepositoryDispatchEvent {
    type Target = RepositoryDispatchOnDemandTest;
    fn deref(&self) -> &RepositoryDispatchOnDemandTest {
        &self.0
    }
}
impl From<RepositoryDispatchEvent> for RepositoryDispatchOnDemandTest {
    fn from(value: RepositoryDispatchEvent) -> Self {
        value.0
    }
}
impl From<&RepositoryDispatchEvent> for RepositoryDispatchEvent {
    fn from(value: &RepositoryDispatchEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryDispatchOnDemandTest> for RepositoryDispatchEvent {
    fn from(value: RepositoryDispatchOnDemandTest) -> Self {
        Self(value)
    }
}
#[doc = "RepositoryDispatchOnDemandTest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository_dispatch on-demand-test event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"branch\",\n    \"client_payload\",\n    \"installation\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"on-demand-test\"\n      ]\n    },\n    \"branch\": {\n      \"type\": \"string\"\n    },\n    \"client_payload\": {\n      \"type\": \"object\",\n      \"additionalProperties\": true\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDispatchOnDemandTest {
    pub action: RepositoryDispatchOnDemandTestAction,
    pub branch: String,
    pub client_payload: serde_json::Map<String, serde_json::Value>,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryDispatchOnDemandTest> for RepositoryDispatchOnDemandTest {
    fn from(value: &RepositoryDispatchOnDemandTest) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryDispatchOnDemandTestAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"on-demand-test\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryDispatchOnDemandTestAction {
    #[serde(rename = "on-demand-test")]
    OnDemandTest,
}
impl From<&RepositoryDispatchOnDemandTestAction> for RepositoryDispatchOnDemandTestAction {
    fn from(value: &RepositoryDispatchOnDemandTestAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryDispatchOnDemandTestAction {
    fn to_string(&self) -> String {
        match *self {
            Self::OnDemandTest => "on-demand-test".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDispatchOnDemandTestAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "on-demand-test" => Ok(Self::OnDemandTest),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"default_branch\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"description\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"homepage\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEdited {
    pub action: RepositoryEditedAction,
    pub changes: RepositoryEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryEdited> for RepositoryEdited {
    fn from(value: &RepositoryEdited) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&RepositoryEditedAction> for RepositoryEditedAction {
    fn from(value: &RepositoryEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"default_branch\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"description\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"homepage\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_branch: Option<RepositoryEditedChangesDefaultBranch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<RepositoryEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<RepositoryEditedChangesHomepage>,
}
impl From<&RepositoryEditedChanges> for RepositoryEditedChanges {
    fn from(value: &RepositoryEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryEditedChangesDefaultBranch"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDefaultBranch {
    pub from: String,
}
impl From<&RepositoryEditedChangesDefaultBranch> for RepositoryEditedChangesDefaultBranch {
    fn from(value: &RepositoryEditedChangesDefaultBranch) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryEditedChangesDescription"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDescription {
    pub from: Option<String>,
}
impl From<&RepositoryEditedChangesDescription> for RepositoryEditedChangesDescription {
    fn from(value: &RepositoryEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryEditedChangesHomepage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesHomepage {
    pub from: Option<String>,
}
impl From<&RepositoryEditedChangesHomepage> for RepositoryEditedChangesHomepage {
    fn from(value: &RepositoryEditedChangesHomepage) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/repository$archived\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$privatized\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$publicized\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$renamed\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$transferred\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository$unarchived\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryEvent {
    Archived(RepositoryArchived),
    Created(RepositoryCreated),
    Deleted(RepositoryDeleted),
    Edited(RepositoryEdited),
    Privatized(RepositoryPrivatized),
    Publicized(RepositoryPublicized),
    Renamed(RepositoryRenamed),
    Transferred(RepositoryTransferred),
    Unarchived(RepositoryUnarchived),
}
impl From<&RepositoryEvent> for RepositoryEvent {
    fn from(value: &RepositoryEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryArchived> for RepositoryEvent {
    fn from(value: RepositoryArchived) -> Self {
        Self::Archived(value)
    }
}
impl From<RepositoryCreated> for RepositoryEvent {
    fn from(value: RepositoryCreated) -> Self {
        Self::Created(value)
    }
}
impl From<RepositoryDeleted> for RepositoryEvent {
    fn from(value: RepositoryDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<RepositoryEdited> for RepositoryEvent {
    fn from(value: RepositoryEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<RepositoryPrivatized> for RepositoryEvent {
    fn from(value: RepositoryPrivatized) -> Self {
        Self::Privatized(value)
    }
}
impl From<RepositoryPublicized> for RepositoryEvent {
    fn from(value: RepositoryPublicized) -> Self {
        Self::Publicized(value)
    }
}
impl From<RepositoryRenamed> for RepositoryEvent {
    fn from(value: RepositoryRenamed) -> Self {
        Self::Renamed(value)
    }
}
impl From<RepositoryTransferred> for RepositoryEvent {
    fn from(value: RepositoryTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<RepositoryUnarchived> for RepositoryEvent {
    fn from(value: RepositoryUnarchived) -> Self {
        Self::Unarchived(value)
    }
}
#[doc = "RepositoryImportEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository_import event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"repository\",\n    \"sender\",\n    \"status\"\n  ],\n  \"properties\": {\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"success\",\n        \"cancelled\",\n        \"failure\"\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryImportEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub status: RepositoryImportEventStatus,
}
impl From<&RepositoryImportEvent> for RepositoryImportEvent {
    fn from(value: &RepositoryImportEvent) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryImportEventStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"cancelled\",\n    \"failure\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryImportEventStatus {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "failure")]
    Failure,
}
impl From<&RepositoryImportEventStatus> for RepositoryImportEventStatus {
    fn from(value: &RepositoryImportEventStatus) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryImportEventStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryImportEventStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "cancelled" => Ok(Self::Cancelled),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryLite"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Repository Lite\",\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"languages_url\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"releases_url\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryLite {
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub deployments_url: String,
    pub description: Option<String>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: String,
    pub merges_url: String,
    pub milestones_url: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub owner: User,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub pulls_url: String,
    pub releases_url: String,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub url: String,
}
impl From<&RepositoryLite> for RepositoryLite {
    fn from(value: &RepositoryLite) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryPermissions> for RepositoryPermissions {
    fn from(value: &RepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPrivatized"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository privatized event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"privatized\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"private\"\n          ],\n          \"properties\": {\n            \"private\": {\n              \"description\": \"Whether the repository is private or public.\",\n              \"type\": \"boolean\",\n              \"enum\": [\n                true\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatized {
    pub action: RepositoryPrivatizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: RepositoryPrivatizedRepository,
    pub sender: User,
}
impl From<&RepositoryPrivatized> for RepositoryPrivatized {
    fn from(value: &RepositoryPrivatized) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPrivatizedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"privatized\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPrivatizedAction {
    #[serde(rename = "privatized")]
    Privatized,
}
impl From<&RepositoryPrivatizedAction> for RepositoryPrivatizedAction {
    fn from(value: &RepositoryPrivatizedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryPrivatizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Privatized => "privatized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPrivatizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "privatized" => Ok(Self::Privatized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryPrivatizedRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"description\": \"Whether the repository is archived.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        true\n      ]\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatizedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryPrivatizedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryPrivatizedRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryPrivatizedRepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&RepositoryPrivatizedRepository> for RepositoryPrivatizedRepository {
    fn from(value: &RepositoryPrivatizedRepository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPrivatizedRepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPrivatizedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryPrivatizedRepositoryCreatedAt> for RepositoryPrivatizedRepositoryCreatedAt {
    fn from(value: &RepositoryPrivatizedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryPrivatizedRepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryPrivatizedRepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryPrivatizedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPrivatizedRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryPrivatizedRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatizedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryPrivatizedRepositoryPermissions>
    for RepositoryPrivatizedRepositoryPermissions
{
    fn from(value: &RepositoryPrivatizedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPrivatizedRepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPrivatizedRepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryPrivatizedRepositoryPushedAt> for RepositoryPrivatizedRepositoryPushedAt {
    fn from(value: &RepositoryPrivatizedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryPrivatizedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPrivatizedRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryPublicized"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository publicized event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"publicized\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"private\"\n          ],\n          \"properties\": {\n            \"private\": {\n              \"description\": \"Whether the repository is private or public.\",\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicized {
    pub action: RepositoryPublicizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: RepositoryPublicizedRepository,
    pub sender: User,
}
impl From<&RepositoryPublicized> for RepositoryPublicized {
    fn from(value: &RepositoryPublicized) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPublicizedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"publicized\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPublicizedAction {
    #[serde(rename = "publicized")]
    Publicized,
}
impl From<&RepositoryPublicizedAction> for RepositoryPublicizedAction {
    fn from(value: &RepositoryPublicizedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryPublicizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Publicized => "publicized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPublicizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "publicized" => Ok(Self::Publicized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryPublicizedRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"description\": \"Whether the repository is archived.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicizedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryPublicizedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryPublicizedRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryPublicizedRepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&RepositoryPublicizedRepository> for RepositoryPublicizedRepository {
    fn from(value: &RepositoryPublicizedRepository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPublicizedRepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPublicizedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryPublicizedRepositoryCreatedAt> for RepositoryPublicizedRepositoryCreatedAt {
    fn from(value: &RepositoryPublicizedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryPublicizedRepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryPublicizedRepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryPublicizedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPublicizedRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryPublicizedRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicizedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryPublicizedRepositoryPermissions>
    for RepositoryPublicizedRepositoryPermissions
{
    fn from(value: &RepositoryPublicizedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryPublicizedRepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPublicizedRepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryPublicizedRepositoryPushedAt> for RepositoryPublicizedRepositoryPushedAt {
    fn from(value: &RepositoryPublicizedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryPublicizedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPublicizedRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryPushedAt> for RepositoryPushedAt {
    fn from(value: &RepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryRenamed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository renamed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"renamed\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"repository\"\n      ],\n      \"properties\": {\n        \"repository\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"name\"\n          ],\n          \"properties\": {\n            \"name\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"from\"\n              ],\n              \"properties\": {\n                \"from\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamed {
    pub action: RepositoryRenamedAction,
    pub changes: RepositoryRenamedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryRenamed> for RepositoryRenamed {
    fn from(value: &RepositoryRenamed) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryRenamedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"renamed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl From<&RepositoryRenamedAction> for RepositoryRenamedAction {
    fn from(value: &RepositoryRenamedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryRenamedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"repository\"\n  ],\n  \"properties\": {\n    \"repository\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"name\"\n      ],\n      \"properties\": {\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChanges {
    pub repository: RepositoryRenamedChangesRepository,
}
impl From<&RepositoryRenamedChanges> for RepositoryRenamedChanges {
    fn from(value: &RepositoryRenamedChanges) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryRenamedChangesRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"name\"\n  ],\n  \"properties\": {\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepository {
    pub name: RepositoryRenamedChangesRepositoryName,
}
impl From<&RepositoryRenamedChangesRepository> for RepositoryRenamedChangesRepository {
    fn from(value: &RepositoryRenamedChangesRepository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryRenamedChangesRepositoryName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepositoryName {
    pub from: String,
}
impl From<&RepositoryRenamedChangesRepositoryName> for RepositoryRenamedChangesRepositoryName {
    fn from(value: &RepositoryRenamedChangesRepositoryName) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryTransferred"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository transferred event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"transferred\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"owner\"\n      ],\n      \"properties\": {\n        \"owner\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"user\": {\n                  \"$ref\": \"#/definitions/user\"\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferred {
    pub action: RepositoryTransferredAction,
    pub changes: RepositoryTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryTransferred> for RepositoryTransferred {
    fn from(value: &RepositoryTransferred) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryTransferredAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"transferred\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&RepositoryTransferredAction> for RepositoryTransferredAction {
    fn from(value: &RepositoryTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryTransferredChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"owner\"\n  ],\n  \"properties\": {\n    \"owner\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"user\": {\n              \"$ref\": \"#/definitions/user\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChanges {
    pub owner: RepositoryTransferredChangesOwner,
}
impl From<&RepositoryTransferredChanges> for RepositoryTransferredChanges {
    fn from(value: &RepositoryTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryTransferredChangesOwner"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwner {
    pub from: RepositoryTransferredChangesOwnerFrom,
}
impl From<&RepositoryTransferredChangesOwner> for RepositoryTransferredChangesOwner {
    fn from(value: &RepositoryTransferredChangesOwner) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryTransferredChangesOwnerFrom"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwnerFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<User>,
}
impl From<&RepositoryTransferredChangesOwnerFrom> for RepositoryTransferredChangesOwnerFrom {
    fn from(value: &RepositoryTransferredChangesOwnerFrom) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryUnarchived"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository unarchived event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"unarchived\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"archived\"\n          ],\n          \"properties\": {\n            \"archived\": {\n              \"description\": \"Whether the repository is archived.\",\n              \"default\": false,\n              \"type\": \"boolean\",\n              \"enum\": [\n                false\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchived {
    pub action: RepositoryUnarchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: RepositoryUnarchivedRepository,
    pub sender: User,
}
impl From<&RepositoryUnarchived> for RepositoryUnarchived {
    fn from(value: &RepositoryUnarchived) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryUnarchivedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"unarchived\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryUnarchivedAction {
    #[serde(rename = "unarchived")]
    Unarchived,
}
impl From<&RepositoryUnarchivedAction> for RepositoryUnarchivedAction {
    fn from(value: &RepositoryUnarchivedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryUnarchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unarchived => "unarchived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryUnarchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unarchived" => Ok(Self::Unarchived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "RepositoryUnarchivedRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"archive_url\",\n    \"archived\",\n    \"assignees_url\",\n    \"blobs_url\",\n    \"branches_url\",\n    \"clone_url\",\n    \"collaborators_url\",\n    \"comments_url\",\n    \"commits_url\",\n    \"compare_url\",\n    \"contents_url\",\n    \"contributors_url\",\n    \"created_at\",\n    \"default_branch\",\n    \"deployments_url\",\n    \"description\",\n    \"downloads_url\",\n    \"events_url\",\n    \"fork\",\n    \"forks\",\n    \"forks_count\",\n    \"forks_url\",\n    \"full_name\",\n    \"git_commits_url\",\n    \"git_refs_url\",\n    \"git_tags_url\",\n    \"git_url\",\n    \"has_downloads\",\n    \"has_issues\",\n    \"has_pages\",\n    \"has_projects\",\n    \"has_wiki\",\n    \"homepage\",\n    \"hooks_url\",\n    \"html_url\",\n    \"id\",\n    \"issue_comment_url\",\n    \"issue_events_url\",\n    \"issues_url\",\n    \"keys_url\",\n    \"labels_url\",\n    \"language\",\n    \"languages_url\",\n    \"license\",\n    \"merges_url\",\n    \"milestones_url\",\n    \"mirror_url\",\n    \"name\",\n    \"node_id\",\n    \"notifications_url\",\n    \"open_issues\",\n    \"open_issues_count\",\n    \"owner\",\n    \"private\",\n    \"pulls_url\",\n    \"pushed_at\",\n    \"releases_url\",\n    \"size\",\n    \"ssh_url\",\n    \"stargazers_count\",\n    \"stargazers_url\",\n    \"statuses_url\",\n    \"subscribers_url\",\n    \"subscription_url\",\n    \"svn_url\",\n    \"tags_url\",\n    \"teams_url\",\n    \"trees_url\",\n    \"updated_at\",\n    \"url\",\n    \"watchers\",\n    \"watchers_count\"\n  ],\n  \"properties\": {\n    \"allow_auto_merge\": {\n      \"description\": \"Whether to allow auto-merge for pull requests.\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"allow_forking\": {\n      \"description\": \"Whether to allow private forks\",\n      \"type\": \"boolean\"\n    },\n    \"allow_merge_commit\": {\n      \"description\": \"Whether to allow merge commits for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_rebase_merge\": {\n      \"description\": \"Whether to allow rebase merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"allow_squash_merge\": {\n      \"description\": \"Whether to allow squash merges for pull requests.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"archive_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"archived\": {\n      \"type\": \"boolean\",\n      \"enum\": [\n        false\n      ]\n    },\n    \"assignees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"blobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"branches_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"clone_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"collaborators_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"compare_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contents_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"contributors_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        }\n      ]\n    },\n    \"default_branch\": {\n      \"description\": \"The default branch of the repository.\",\n      \"type\": \"string\"\n    },\n    \"delete_branch_on_merge\": {\n      \"description\": \"Whether to delete head branches when pull requests are merged\",\n      \"default\": false,\n      \"type\": \"boolean\"\n    },\n    \"deployments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"description\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"disabled\": {\n      \"description\": \"Returns whether or not this repository is disabled.\",\n      \"type\": \"boolean\"\n    },\n    \"downloads_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fork\": {\n      \"type\": \"boolean\"\n    },\n    \"forks\": {\n      \"type\": \"integer\"\n    },\n    \"forks_count\": {\n      \"type\": \"integer\"\n    },\n    \"forks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"full_name\": {\n      \"type\": \"string\"\n    },\n    \"git_commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_refs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"git_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"has_downloads\": {\n      \"description\": \"Whether downloads are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_issues\": {\n      \"description\": \"Whether issues are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_pages\": {\n      \"type\": \"boolean\"\n    },\n    \"has_projects\": {\n      \"description\": \"Whether projects are enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"has_wiki\": {\n      \"description\": \"Whether the wiki is enabled.\",\n      \"default\": true,\n      \"type\": \"boolean\"\n    },\n    \"homepage\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"hooks_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the repository\",\n      \"type\": \"integer\"\n    },\n    \"issue_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issue_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"issues_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"keys_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"labels_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"language\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"languages_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"license\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/license\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"master_branch\": {\n      \"type\": \"string\"\n    },\n    \"merges_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"milestones_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"mirror_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"description\": \"The name of the repository.\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"notifications_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"open_issues\": {\n      \"type\": \"integer\"\n    },\n    \"open_issues_count\": {\n      \"type\": \"integer\"\n    },\n    \"organization\": {\n      \"type\": \"string\"\n    },\n    \"owner\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"admin\",\n        \"pull\",\n        \"push\"\n      ],\n      \"properties\": {\n        \"admin\": {\n          \"type\": \"boolean\"\n        },\n        \"maintain\": {\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"type\": \"boolean\"\n        },\n        \"triage\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"private\": {\n      \"description\": \"Whether the repository is private or public.\",\n      \"type\": \"boolean\"\n    },\n    \"public\": {\n      \"type\": \"boolean\"\n    },\n    \"pulls_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"pushed_at\": {\n      \"oneOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"releases_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"size\": {\n      \"type\": \"integer\"\n    },\n    \"ssh_url\": {\n      \"type\": \"string\"\n    },\n    \"stargazers\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_count\": {\n      \"type\": \"integer\"\n    },\n    \"stargazers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscribers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"subscription_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"svn_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"tags_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"teams_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"trees_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"watchers\": {\n      \"type\": \"integer\"\n    },\n    \"watchers_count\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchivedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryUnarchivedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryUnarchivedRepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryUnarchivedRepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&RepositoryUnarchivedRepository> for RepositoryUnarchivedRepository {
    fn from(value: &RepositoryUnarchivedRepository) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryUnarchivedRepositoryCreatedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryUnarchivedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryUnarchivedRepositoryCreatedAt> for RepositoryUnarchivedRepositoryCreatedAt {
    fn from(value: &RepositoryUnarchivedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryUnarchivedRepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryUnarchivedRepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryUnarchivedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryUnarchivedRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryUnarchivedRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"admin\",\n    \"pull\",\n    \"push\"\n  ],\n  \"properties\": {\n    \"admin\": {\n      \"type\": \"boolean\"\n    },\n    \"maintain\": {\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"type\": \"boolean\"\n    },\n    \"triage\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchivedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryUnarchivedRepositoryPermissions>
    for RepositoryUnarchivedRepositoryPermissions
{
    fn from(value: &RepositoryUnarchivedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryUnarchivedRepositoryPushedAt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"type\": \"integer\"\n    },\n    {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    {\n      \"type\": \"null\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryUnarchivedRepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryUnarchivedRepositoryPushedAt> for RepositoryUnarchivedRepositoryPushedAt {
    fn from(value: &RepositoryUnarchivedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryUnarchivedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryUnarchivedRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RepositoryVulnerabilityAlertCreate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository_vulnerability_alert create event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"create\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The security alert of the vulnerable dependency.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"affected_package_name\",\n        \"affected_range\",\n        \"external_identifier\",\n        \"external_reference\",\n        \"fixed_in\",\n        \"id\"\n      ],\n      \"properties\": {\n        \"affected_package_name\": {\n          \"type\": \"string\"\n        },\n        \"affected_range\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"dismiss_reason\": {\n          \"type\": \"string\"\n        },\n        \"dismissed_at\": {\n          \"type\": \"string\"\n        },\n        \"dismisser\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"external_identifier\": {\n          \"type\": \"string\"\n        },\n        \"external_reference\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"fixed_in\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreate {
    pub action: RepositoryVulnerabilityAlertCreateAction,
    pub alert: RepositoryVulnerabilityAlertCreateAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertCreate {
    fn from(value: &RepositoryVulnerabilityAlertCreate) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryVulnerabilityAlertCreateAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"create\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertCreateAction {
    #[serde(rename = "create")]
    Create,
}
impl From<&RepositoryVulnerabilityAlertCreateAction> for RepositoryVulnerabilityAlertCreateAction {
    fn from(value: &RepositoryVulnerabilityAlertCreateAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertCreateAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "create".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertCreateAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "create" => Ok(Self::Create),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The security alert of the vulnerable dependency.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"affected_package_name\",\n    \"affected_range\",\n    \"external_identifier\",\n    \"external_reference\",\n    \"fixed_in\",\n    \"id\"\n  ],\n  \"properties\": {\n    \"affected_package_name\": {\n      \"type\": \"string\"\n    },\n    \"affected_range\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"dismiss_reason\": {\n      \"type\": \"string\"\n    },\n    \"dismissed_at\": {\n      \"type\": \"string\"\n    },\n    \"dismisser\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"external_identifier\": {\n      \"type\": \"string\"\n    },\n    \"external_reference\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fixed_in\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreateAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertCreateAlert> for RepositoryVulnerabilityAlertCreateAlert {
    fn from(value: &RepositoryVulnerabilityAlertCreateAlert) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryVulnerabilityAlertDismiss"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository_vulnerability_alert dismiss event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dismiss\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The security alert of the vulnerable dependency.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"affected_package_name\",\n        \"affected_range\",\n        \"dismiss_reason\",\n        \"dismissed_at\",\n        \"dismisser\",\n        \"external_identifier\",\n        \"external_reference\",\n        \"fixed_in\",\n        \"id\"\n      ],\n      \"properties\": {\n        \"affected_package_name\": {\n          \"type\": \"string\"\n        },\n        \"affected_range\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"dismiss_reason\": {\n          \"type\": \"string\"\n        },\n        \"dismissed_at\": {\n          \"type\": \"string\"\n        },\n        \"dismisser\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"external_identifier\": {\n          \"type\": \"string\"\n        },\n        \"external_reference\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"fixed_in\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismiss {
    pub action: RepositoryVulnerabilityAlertDismissAction,
    pub alert: RepositoryVulnerabilityAlertDismissAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertDismiss {
    fn from(value: &RepositoryVulnerabilityAlertDismiss) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryVulnerabilityAlertDismissAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"dismiss\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertDismissAction {
    #[serde(rename = "dismiss")]
    Dismiss,
}
impl From<&RepositoryVulnerabilityAlertDismissAction>
    for RepositoryVulnerabilityAlertDismissAction
{
    fn from(value: &RepositoryVulnerabilityAlertDismissAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertDismissAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismiss => "dismiss".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertDismissAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismiss" => Ok(Self::Dismiss),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The security alert of the vulnerable dependency.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"affected_package_name\",\n    \"affected_range\",\n    \"dismiss_reason\",\n    \"dismissed_at\",\n    \"dismisser\",\n    \"external_identifier\",\n    \"external_reference\",\n    \"fixed_in\",\n    \"id\"\n  ],\n  \"properties\": {\n    \"affected_package_name\": {\n      \"type\": \"string\"\n    },\n    \"affected_range\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"dismiss_reason\": {\n      \"type\": \"string\"\n    },\n    \"dismissed_at\": {\n      \"type\": \"string\"\n    },\n    \"dismisser\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"external_identifier\": {\n      \"type\": \"string\"\n    },\n    \"external_reference\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fixed_in\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismissAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    pub dismiss_reason: String,
    pub dismissed_at: String,
    pub dismisser: User,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertDismissAlert> for RepositoryVulnerabilityAlertDismissAlert {
    fn from(value: &RepositoryVulnerabilityAlertDismissAlert) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryVulnerabilityAlertEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/repository_vulnerability_alert$create\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_vulnerability_alert$dismiss\"\n    },\n    {\n      \"$ref\": \"#/definitions/repository_vulnerability_alert$resolve\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryVulnerabilityAlertEvent {
    Create(RepositoryVulnerabilityAlertCreate),
    Dismiss(RepositoryVulnerabilityAlertDismiss),
    Resolve(RepositoryVulnerabilityAlertResolve),
}
impl From<&RepositoryVulnerabilityAlertEvent> for RepositoryVulnerabilityAlertEvent {
    fn from(value: &RepositoryVulnerabilityAlertEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertCreate) -> Self {
        Self::Create(value)
    }
}
impl From<RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertDismiss) -> Self {
        Self::Dismiss(value)
    }
}
impl From<RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertResolve) -> Self {
        Self::Resolve(value)
    }
}
#[doc = "RepositoryVulnerabilityAlertResolve"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"repository_vulnerability_alert resolve event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"resolve\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The security alert of the vulnerable dependency.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"affected_package_name\",\n        \"affected_range\",\n        \"external_identifier\",\n        \"external_reference\",\n        \"fixed_in\",\n        \"id\"\n      ],\n      \"properties\": {\n        \"affected_package_name\": {\n          \"type\": \"string\"\n        },\n        \"affected_range\": {\n          \"type\": \"string\"\n        },\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"dismiss_reason\": {\n          \"type\": \"string\"\n        },\n        \"dismissed_at\": {\n          \"type\": \"string\"\n        },\n        \"dismisser\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"external_identifier\": {\n          \"type\": \"string\"\n        },\n        \"external_reference\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"fixed_in\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolve {
    pub action: RepositoryVulnerabilityAlertResolveAction,
    pub alert: RepositoryVulnerabilityAlertResolveAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertResolve {
    fn from(value: &RepositoryVulnerabilityAlertResolve) -> Self {
        value.clone()
    }
}
#[doc = "RepositoryVulnerabilityAlertResolveAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolve\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertResolveAction {
    #[serde(rename = "resolve")]
    Resolve,
}
impl From<&RepositoryVulnerabilityAlertResolveAction>
    for RepositoryVulnerabilityAlertResolveAction
{
    fn from(value: &RepositoryVulnerabilityAlertResolveAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertResolveAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolve => "resolve".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertResolveAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolve" => Ok(Self::Resolve),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The security alert of the vulnerable dependency.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"affected_package_name\",\n    \"affected_range\",\n    \"external_identifier\",\n    \"external_reference\",\n    \"fixed_in\",\n    \"id\"\n  ],\n  \"properties\": {\n    \"affected_package_name\": {\n      \"type\": \"string\"\n    },\n    \"affected_range\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"dismiss_reason\": {\n      \"type\": \"string\"\n    },\n    \"dismissed_at\": {\n      \"type\": \"string\"\n    },\n    \"dismisser\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"external_identifier\": {\n      \"type\": \"string\"\n    },\n    \"external_reference\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"fixed_in\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolveAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertResolveAlert> for RepositoryVulnerabilityAlertResolveAlert {
    fn from(value: &RepositoryVulnerabilityAlertResolveAlert) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"secret_scanning_alert created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The secret scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"number\",\n        \"resolution\",\n        \"resolved_at\",\n        \"resolved_by\",\n        \"secret_type\"\n      ],\n      \"properties\": {\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"resolution\": {\n          \"type\": \"null\"\n        },\n        \"resolved_at\": {\n          \"type\": \"null\"\n        },\n        \"resolved_by\": {\n          \"type\": \"null\"\n        },\n        \"secret_type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreated {
    pub action: SecretScanningAlertCreatedAction,
    pub alert: SecretScanningAlertCreatedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
}
impl From<&SecretScanningAlertCreated> for SecretScanningAlertCreated {
    fn from(value: &SecretScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&SecretScanningAlertCreatedAction> for SecretScanningAlertCreatedAction {
    fn from(value: &SecretScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The secret scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"number\",\n    \"resolution\",\n    \"resolved_at\",\n    \"resolved_by\",\n    \"secret_type\"\n  ],\n  \"properties\": {\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"resolution\": {\n      \"type\": \"null\"\n    },\n    \"resolved_at\": {\n      \"type\": \"null\"\n    },\n    \"resolved_by\": {\n      \"type\": \"null\"\n    },\n    \"secret_type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreatedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
impl From<&SecretScanningAlertCreatedAlert> for SecretScanningAlertCreatedAlert {
    fn from(value: &SecretScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/secret_scanning_alert$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/secret_scanning_alert$reopened\"\n    },\n    {\n      \"$ref\": \"#/definitions/secret_scanning_alert$resolved\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecretScanningAlertEvent {
    Created(SecretScanningAlertCreated),
    Reopened(SecretScanningAlertReopened),
    Resolved(SecretScanningAlertResolved),
}
impl From<&SecretScanningAlertEvent> for SecretScanningAlertEvent {
    fn from(value: &SecretScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl From<SecretScanningAlertCreated> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl From<SecretScanningAlertReopened> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<SecretScanningAlertResolved> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertResolved) -> Self {
        Self::Resolved(value)
    }
}
#[doc = "SecretScanningAlertReopened"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"secret_scanning_alert reopened event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"reopened\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The secret scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"number\",\n        \"resolution\",\n        \"resolved_at\",\n        \"resolved_by\",\n        \"secret_type\"\n      ],\n      \"properties\": {\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"resolution\": {\n          \"type\": \"null\"\n        },\n        \"resolved_at\": {\n          \"type\": \"null\"\n        },\n        \"resolved_by\": {\n          \"type\": \"null\"\n        },\n        \"secret_type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopened {
    pub action: SecretScanningAlertReopenedAction,
    pub alert: SecretScanningAlertReopenedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&SecretScanningAlertReopened> for SecretScanningAlertReopened {
    fn from(value: &SecretScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertReopenedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"reopened\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&SecretScanningAlertReopenedAction> for SecretScanningAlertReopenedAction {
    fn from(value: &SecretScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The secret scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"number\",\n    \"resolution\",\n    \"resolved_at\",\n    \"resolved_by\",\n    \"secret_type\"\n  ],\n  \"properties\": {\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"resolution\": {\n      \"type\": \"null\"\n    },\n    \"resolved_at\": {\n      \"type\": \"null\"\n    },\n    \"resolved_by\": {\n      \"type\": \"null\"\n    },\n    \"secret_type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopenedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
impl From<&SecretScanningAlertReopenedAlert> for SecretScanningAlertReopenedAlert {
    fn from(value: &SecretScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertResolved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"secret_scanning_alert resolved event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"alert\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"resolved\"\n      ]\n    },\n    \"alert\": {\n      \"description\": \"The secret scanning alert involved in the event.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"number\",\n        \"resolution\",\n        \"resolved_at\",\n        \"resolved_by\",\n        \"secret_type\"\n      ],\n      \"properties\": {\n        \"number\": {\n          \"type\": \"integer\"\n        },\n        \"resolution\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"false_positive\",\n            \"wontfix\",\n            \"revoked\",\n            \"used_in_tests\"\n          ]\n        },\n        \"resolved_at\": {\n          \"type\": \"string\"\n        },\n        \"resolved_by\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"secret_type\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolved {
    pub action: SecretScanningAlertResolvedAction,
    pub alert: SecretScanningAlertResolvedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&SecretScanningAlertResolved> for SecretScanningAlertResolved {
    fn from(value: &SecretScanningAlertResolved) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertResolvedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAction {
    #[serde(rename = "resolved")]
    Resolved,
}
impl From<&SecretScanningAlertResolvedAction> for SecretScanningAlertResolvedAction {
    fn from(value: &SecretScanningAlertResolvedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertResolvedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The secret scanning alert involved in the event.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"number\",\n    \"resolution\",\n    \"resolved_at\",\n    \"resolved_by\",\n    \"secret_type\"\n  ],\n  \"properties\": {\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"resolution\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"false_positive\",\n        \"wontfix\",\n        \"revoked\",\n        \"used_in_tests\"\n      ]\n    },\n    \"resolved_at\": {\n      \"type\": \"string\"\n    },\n    \"resolved_by\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"secret_type\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolvedAlert {
    pub number: i64,
    pub resolution: SecretScanningAlertResolvedAlertResolution,
    pub resolved_at: String,
    pub resolved_by: User,
    pub secret_type: String,
}
impl From<&SecretScanningAlertResolvedAlert> for SecretScanningAlertResolvedAlert {
    fn from(value: &SecretScanningAlertResolvedAlert) -> Self {
        value.clone()
    }
}
#[doc = "SecretScanningAlertResolvedAlertResolution"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"false_positive\",\n    \"wontfix\",\n    \"revoked\",\n    \"used_in_tests\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAlertResolution {
    #[serde(rename = "false_positive")]
    FalsePositive,
    #[serde(rename = "wontfix")]
    Wontfix,
    #[serde(rename = "revoked")]
    Revoked,
    #[serde(rename = "used_in_tests")]
    UsedInTests,
}
impl From<&SecretScanningAlertResolvedAlertResolution>
    for SecretScanningAlertResolvedAlertResolution
{
    fn from(value: &SecretScanningAlertResolvedAlertResolution) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertResolvedAlertResolution {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false_positive".to_string(),
            Self::Wontfix => "wontfix".to_string(),
            Self::Revoked => "revoked".to_string(),
            Self::UsedInTests => "used_in_tests".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAlertResolution {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false_positive" => Ok(Self::FalsePositive),
            "wontfix" => Ok(Self::Wontfix),
            "revoked" => Ok(Self::Revoked),
            "used_in_tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SecurityAdvisoryEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/security_advisory$performed\"\n    },\n    {\n      \"$ref\": \"#/definitions/security_advisory$published\"\n    },\n    {\n      \"$ref\": \"#/definitions/security_advisory$updated\"\n    },\n    {\n      \"$ref\": \"#/definitions/security_advisory$withdrawn\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecurityAdvisoryEvent {
    Performed(SecurityAdvisoryPerformed),
    Published(SecurityAdvisoryPublished),
    Updated(SecurityAdvisoryUpdated),
    Withdrawn(SecurityAdvisoryWithdrawn),
}
impl From<&SecurityAdvisoryEvent> for SecurityAdvisoryEvent {
    fn from(value: &SecurityAdvisoryEvent) -> Self {
        value.clone()
    }
}
impl From<SecurityAdvisoryPerformed> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPerformed) -> Self {
        Self::Performed(value)
    }
}
impl From<SecurityAdvisoryPublished> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPublished) -> Self {
        Self::Published(value)
    }
}
impl From<SecurityAdvisoryUpdated> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryUpdated) -> Self {
        Self::Updated(value)
    }
}
impl From<SecurityAdvisoryWithdrawn> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryWithdrawn) -> Self {
        Self::Withdrawn(value)
    }
}
#[doc = "SecurityAdvisoryPerformed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"security_advisory performed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"security_advisory\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"performed\"\n      ]\n    },\n    \"security_advisory\": {\n      \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"cvss\",\n        \"cwes\",\n        \"description\",\n        \"ghsa_id\",\n        \"identifiers\",\n        \"published_at\",\n        \"references\",\n        \"severity\",\n        \"summary\",\n        \"updated_at\",\n        \"vulnerabilities\",\n        \"withdrawn_at\"\n      ],\n      \"properties\": {\n        \"cvss\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"score\",\n            \"vector_string\"\n          ],\n          \"properties\": {\n            \"score\": {\n              \"type\": \"number\"\n            },\n            \"vector_string\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"cwes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"cwe_id\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"cwe_id\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"identifiers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"type\",\n              \"value\"\n            ],\n            \"properties\": {\n              \"type\": {\n                \"type\": \"string\"\n              },\n              \"value\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"references\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"url\"\n            ],\n            \"properties\": {\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"vulnerabilities\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"first_patched_version\",\n              \"package\",\n              \"severity\",\n              \"vulnerable_version_range\"\n            ],\n            \"properties\": {\n              \"first_patched_version\": {\n                \"type\": [\n                  \"object\",\n                  \"null\"\n                ],\n                \"required\": [\n                  \"identifier\"\n                ],\n                \"properties\": {\n                  \"identifier\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"package\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"ecosystem\",\n                  \"name\"\n                ],\n                \"properties\": {\n                  \"ecosystem\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"severity\": {\n                \"type\": \"string\"\n              },\n              \"vulnerable_version_range\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"withdrawn_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformed {
    pub action: SecurityAdvisoryPerformedAction,
    pub security_advisory: SecurityAdvisoryPerformedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPerformed> for SecurityAdvisoryPerformed {
    fn from(value: &SecurityAdvisoryPerformed) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"performed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPerformedAction {
    #[serde(rename = "performed")]
    Performed,
}
impl From<&SecurityAdvisoryPerformedAction> for SecurityAdvisoryPerformedAction {
    fn from(value: &SecurityAdvisoryPerformedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryPerformedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Performed => "performed".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPerformedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "performed" => Ok(Self::Performed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"cvss\",\n    \"cwes\",\n    \"description\",\n    \"ghsa_id\",\n    \"identifiers\",\n    \"published_at\",\n    \"references\",\n    \"severity\",\n    \"summary\",\n    \"updated_at\",\n    \"vulnerabilities\",\n    \"withdrawn_at\"\n  ],\n  \"properties\": {\n    \"cvss\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"score\",\n        \"vector_string\"\n      ],\n      \"properties\": {\n        \"score\": {\n          \"type\": \"number\"\n        },\n        \"vector_string\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"cwes\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"cwe_id\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"cwe_id\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"identifiers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"type\",\n          \"value\"\n        ],\n        \"properties\": {\n          \"type\": {\n            \"type\": \"string\"\n          },\n          \"value\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"references\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"url\"\n        ],\n        \"properties\": {\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"vulnerabilities\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"first_patched_version\",\n          \"package\",\n          \"severity\",\n          \"vulnerable_version_range\"\n        ],\n        \"properties\": {\n          \"first_patched_version\": {\n            \"type\": [\n              \"object\",\n              \"null\"\n            ],\n            \"required\": [\n              \"identifier\"\n            ],\n            \"properties\": {\n              \"identifier\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"package\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ecosystem\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"ecosystem\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"severity\": {\n            \"type\": \"string\"\n          },\n          \"vulnerable_version_range\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"withdrawn_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPerformedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisory>
    for SecurityAdvisoryPerformedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryCvss"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"score\",\n    \"vector_string\"\n  ],\n  \"properties\": {\n    \"score\": {\n      \"type\": \"number\"\n    },\n    \"vector_string\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCvss>
    for SecurityAdvisoryPerformedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryCwesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"cwe_id\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"cwe_id\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"type\",\n    \"value\"\n  ],\n  \"properties\": {\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"value\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"url\"\n  ],\n  \"properties\": {\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"first_patched_version\",\n    \"package\",\n    \"severity\",\n    \"vulnerable_version_range\"\n  ],\n  \"properties\": {\n    \"first_patched_version\": {\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"required\": [\n        \"identifier\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"package\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ecosystem\",\n        \"name\"\n      ],\n      \"properties\": {\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"vulnerable_version_range\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"identifier\"\n  ],\n  \"properties\": {\n    \"identifier\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ecosystem\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublished"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"security_advisory published event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"security_advisory\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"published\"\n      ]\n    },\n    \"security_advisory\": {\n      \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"cvss\",\n        \"cwes\",\n        \"description\",\n        \"ghsa_id\",\n        \"identifiers\",\n        \"published_at\",\n        \"references\",\n        \"severity\",\n        \"summary\",\n        \"updated_at\",\n        \"vulnerabilities\",\n        \"withdrawn_at\"\n      ],\n      \"properties\": {\n        \"cvss\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"score\",\n            \"vector_string\"\n          ],\n          \"properties\": {\n            \"score\": {\n              \"type\": \"number\"\n            },\n            \"vector_string\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"cwes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"cwe_id\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"cwe_id\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"identifiers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"type\",\n              \"value\"\n            ],\n            \"properties\": {\n              \"type\": {\n                \"type\": \"string\"\n              },\n              \"value\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"references\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"url\"\n            ],\n            \"properties\": {\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"vulnerabilities\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"first_patched_version\",\n              \"package\",\n              \"severity\",\n              \"vulnerable_version_range\"\n            ],\n            \"properties\": {\n              \"first_patched_version\": {\n                \"type\": [\n                  \"object\",\n                  \"null\"\n                ],\n                \"required\": [\n                  \"identifier\"\n                ],\n                \"properties\": {\n                  \"identifier\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"package\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"ecosystem\",\n                  \"name\"\n                ],\n                \"properties\": {\n                  \"ecosystem\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"severity\": {\n                \"type\": \"string\"\n              },\n              \"vulnerable_version_range\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"withdrawn_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublished {
    pub action: SecurityAdvisoryPublishedAction,
    pub security_advisory: SecurityAdvisoryPublishedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPublished> for SecurityAdvisoryPublished {
    fn from(value: &SecurityAdvisoryPublished) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"published\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&SecurityAdvisoryPublishedAction> for SecurityAdvisoryPublishedAction {
    fn from(value: &SecurityAdvisoryPublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryPublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"cvss\",\n    \"cwes\",\n    \"description\",\n    \"ghsa_id\",\n    \"identifiers\",\n    \"published_at\",\n    \"references\",\n    \"severity\",\n    \"summary\",\n    \"updated_at\",\n    \"vulnerabilities\",\n    \"withdrawn_at\"\n  ],\n  \"properties\": {\n    \"cvss\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"score\",\n        \"vector_string\"\n      ],\n      \"properties\": {\n        \"score\": {\n          \"type\": \"number\"\n        },\n        \"vector_string\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"cwes\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"cwe_id\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"cwe_id\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"identifiers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"type\",\n          \"value\"\n        ],\n        \"properties\": {\n          \"type\": {\n            \"type\": \"string\"\n          },\n          \"value\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"references\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"url\"\n        ],\n        \"properties\": {\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"vulnerabilities\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"first_patched_version\",\n          \"package\",\n          \"severity\",\n          \"vulnerable_version_range\"\n        ],\n        \"properties\": {\n          \"first_patched_version\": {\n            \"type\": [\n              \"object\",\n              \"null\"\n            ],\n            \"required\": [\n              \"identifier\"\n            ],\n            \"properties\": {\n              \"identifier\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"package\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ecosystem\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"ecosystem\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"severity\": {\n            \"type\": \"string\"\n          },\n          \"vulnerable_version_range\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"withdrawn_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPublishedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisory>
    for SecurityAdvisoryPublishedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryCvss"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"score\",\n    \"vector_string\"\n  ],\n  \"properties\": {\n    \"score\": {\n      \"type\": \"number\"\n    },\n    \"vector_string\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCvss>
    for SecurityAdvisoryPublishedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryCwesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"cwe_id\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"cwe_id\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"type\",\n    \"value\"\n  ],\n  \"properties\": {\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"value\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"url\"\n  ],\n  \"properties\": {\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"first_patched_version\",\n    \"package\",\n    \"severity\",\n    \"vulnerable_version_range\"\n  ],\n  \"properties\": {\n    \"first_patched_version\": {\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"required\": [\n        \"identifier\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"package\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ecosystem\",\n        \"name\"\n      ],\n      \"properties\": {\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"vulnerable_version_range\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"identifier\"\n  ],\n  \"properties\": {\n    \"identifier\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ecosystem\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"security_advisory updated event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"security_advisory\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"updated\"\n      ]\n    },\n    \"security_advisory\": {\n      \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"cvss\",\n        \"cwes\",\n        \"description\",\n        \"ghsa_id\",\n        \"identifiers\",\n        \"published_at\",\n        \"references\",\n        \"severity\",\n        \"summary\",\n        \"updated_at\",\n        \"vulnerabilities\",\n        \"withdrawn_at\"\n      ],\n      \"properties\": {\n        \"cvss\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"score\",\n            \"vector_string\"\n          ],\n          \"properties\": {\n            \"score\": {\n              \"type\": \"number\"\n            },\n            \"vector_string\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"cwes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"cwe_id\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"cwe_id\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"identifiers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"type\",\n              \"value\"\n            ],\n            \"properties\": {\n              \"type\": {\n                \"type\": \"string\"\n              },\n              \"value\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"references\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"url\"\n            ],\n            \"properties\": {\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"vulnerabilities\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"first_patched_version\",\n              \"package\",\n              \"severity\",\n              \"vulnerable_version_range\"\n            ],\n            \"properties\": {\n              \"first_patched_version\": {\n                \"type\": [\n                  \"object\",\n                  \"null\"\n                ],\n                \"required\": [\n                  \"identifier\"\n                ],\n                \"properties\": {\n                  \"identifier\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"package\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"ecosystem\",\n                  \"name\"\n                ],\n                \"properties\": {\n                  \"ecosystem\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"severity\": {\n                \"type\": \"string\"\n              },\n              \"vulnerable_version_range\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"withdrawn_at\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdated {
    pub action: SecurityAdvisoryUpdatedAction,
    pub security_advisory: SecurityAdvisoryUpdatedSecurityAdvisory,
}
impl From<&SecurityAdvisoryUpdated> for SecurityAdvisoryUpdated {
    fn from(value: &SecurityAdvisoryUpdated) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"updated\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl From<&SecurityAdvisoryUpdatedAction> for SecurityAdvisoryUpdatedAction {
    fn from(value: &SecurityAdvisoryUpdatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"cvss\",\n    \"cwes\",\n    \"description\",\n    \"ghsa_id\",\n    \"identifiers\",\n    \"published_at\",\n    \"references\",\n    \"severity\",\n    \"summary\",\n    \"updated_at\",\n    \"vulnerabilities\",\n    \"withdrawn_at\"\n  ],\n  \"properties\": {\n    \"cvss\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"score\",\n        \"vector_string\"\n      ],\n      \"properties\": {\n        \"score\": {\n          \"type\": \"number\"\n        },\n        \"vector_string\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"cwes\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"cwe_id\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"cwe_id\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"identifiers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"type\",\n          \"value\"\n        ],\n        \"properties\": {\n          \"type\": {\n            \"type\": \"string\"\n          },\n          \"value\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"references\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"url\"\n        ],\n        \"properties\": {\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"vulnerabilities\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"first_patched_version\",\n          \"package\",\n          \"severity\",\n          \"vulnerable_version_range\"\n        ],\n        \"properties\": {\n          \"first_patched_version\": {\n            \"type\": [\n              \"object\",\n              \"null\"\n            ],\n            \"required\": [\n              \"identifier\"\n            ],\n            \"properties\": {\n              \"identifier\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"package\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ecosystem\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"ecosystem\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"severity\": {\n            \"type\": \"string\"\n          },\n          \"vulnerable_version_range\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"withdrawn_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisory {
    pub cvss: SecurityAdvisoryUpdatedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisory> for SecurityAdvisoryUpdatedSecurityAdvisory {
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryCvss"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"score\",\n    \"vector_string\"\n  ],\n  \"properties\": {\n    \"score\": {\n      \"type\": \"number\"\n    },\n    \"vector_string\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCvss>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"cwe_id\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"cwe_id\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"type\",\n    \"value\"\n  ],\n  \"properties\": {\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"value\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"url\"\n  ],\n  \"properties\": {\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"first_patched_version\",\n    \"package\",\n    \"severity\",\n    \"vulnerable_version_range\"\n  ],\n  \"properties\": {\n    \"first_patched_version\": {\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"required\": [\n        \"identifier\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"package\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ecosystem\",\n        \"name\"\n      ],\n      \"properties\": {\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"vulnerable_version_range\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"identifier\"\n  ],\n  \"properties\": {\n    \"identifier\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ecosystem\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawn"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"security_advisory withdrawn event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"security_advisory\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"withdrawn\"\n      ]\n    },\n    \"security_advisory\": {\n      \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n      \"type\": \"object\",\n      \"required\": [\n        \"cvss\",\n        \"cwes\",\n        \"description\",\n        \"ghsa_id\",\n        \"identifiers\",\n        \"published_at\",\n        \"references\",\n        \"severity\",\n        \"summary\",\n        \"updated_at\",\n        \"vulnerabilities\",\n        \"withdrawn_at\"\n      ],\n      \"properties\": {\n        \"cvss\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"score\",\n            \"vector_string\"\n          ],\n          \"properties\": {\n            \"score\": {\n              \"type\": \"number\"\n            },\n            \"vector_string\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"cwes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"cwe_id\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"cwe_id\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"ghsa_id\": {\n          \"type\": \"string\"\n        },\n        \"identifiers\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"type\",\n              \"value\"\n            ],\n            \"properties\": {\n              \"type\": {\n                \"type\": \"string\"\n              },\n              \"value\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"published_at\": {\n          \"type\": \"string\"\n        },\n        \"references\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"url\"\n            ],\n            \"properties\": {\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"severity\": {\n          \"type\": \"string\"\n        },\n        \"summary\": {\n          \"type\": \"string\"\n        },\n        \"updated_at\": {\n          \"type\": \"string\"\n        },\n        \"vulnerabilities\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"first_patched_version\",\n              \"package\",\n              \"severity\",\n              \"vulnerable_version_range\"\n            ],\n            \"properties\": {\n              \"first_patched_version\": {\n                \"type\": [\n                  \"object\",\n                  \"null\"\n                ],\n                \"required\": [\n                  \"identifier\"\n                ],\n                \"properties\": {\n                  \"identifier\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"package\": {\n                \"type\": \"object\",\n                \"required\": [\n                  \"ecosystem\",\n                  \"name\"\n                ],\n                \"properties\": {\n                  \"ecosystem\": {\n                    \"type\": \"string\"\n                  },\n                  \"name\": {\n                    \"type\": \"string\"\n                  }\n                },\n                \"additionalProperties\": false\n              },\n              \"severity\": {\n                \"type\": \"string\"\n              },\n              \"vulnerable_version_range\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"withdrawn_at\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawn {
    pub action: SecurityAdvisoryWithdrawnAction,
    pub security_advisory: SecurityAdvisoryWithdrawnSecurityAdvisory,
}
impl From<&SecurityAdvisoryWithdrawn> for SecurityAdvisoryWithdrawn {
    fn from(value: &SecurityAdvisoryWithdrawn) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"withdrawn\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryWithdrawnAction {
    #[serde(rename = "withdrawn")]
    Withdrawn,
}
impl From<&SecurityAdvisoryWithdrawnAction> for SecurityAdvisoryWithdrawnAction {
    fn from(value: &SecurityAdvisoryWithdrawnAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryWithdrawnAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Withdrawn => "withdrawn".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryWithdrawnAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The details of the security advisory, including summary, description, and severity.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"cvss\",\n    \"cwes\",\n    \"description\",\n    \"ghsa_id\",\n    \"identifiers\",\n    \"published_at\",\n    \"references\",\n    \"severity\",\n    \"summary\",\n    \"updated_at\",\n    \"vulnerabilities\",\n    \"withdrawn_at\"\n  ],\n  \"properties\": {\n    \"cvss\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"score\",\n        \"vector_string\"\n      ],\n      \"properties\": {\n        \"score\": {\n          \"type\": \"number\"\n        },\n        \"vector_string\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"cwes\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"cwe_id\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"cwe_id\": {\n            \"type\": \"string\"\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"ghsa_id\": {\n      \"type\": \"string\"\n    },\n    \"identifiers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"type\",\n          \"value\"\n        ],\n        \"properties\": {\n          \"type\": {\n            \"type\": \"string\"\n          },\n          \"value\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"published_at\": {\n      \"type\": \"string\"\n    },\n    \"references\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"url\"\n        ],\n        \"properties\": {\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"summary\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"vulnerabilities\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"first_patched_version\",\n          \"package\",\n          \"severity\",\n          \"vulnerable_version_range\"\n        ],\n        \"properties\": {\n          \"first_patched_version\": {\n            \"type\": [\n              \"object\",\n              \"null\"\n            ],\n            \"required\": [\n              \"identifier\"\n            ],\n            \"properties\": {\n              \"identifier\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"package\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ecosystem\",\n              \"name\"\n            ],\n            \"properties\": {\n              \"ecosystem\": {\n                \"type\": \"string\"\n              },\n              \"name\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"severity\": {\n            \"type\": \"string\"\n          },\n          \"vulnerable_version_range\": {\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"withdrawn_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisory {
    pub cvss: SecurityAdvisoryWithdrawnSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisory>
    for SecurityAdvisoryWithdrawnSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryCvss"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"score\",\n    \"vector_string\"\n  ],\n  \"properties\": {\n    \"score\": {\n      \"type\": \"number\"\n    },\n    \"vector_string\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCvss>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"cwe_id\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"cwe_id\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"type\",\n    \"value\"\n  ],\n  \"properties\": {\n    \"type\": {\n      \"type\": \"string\"\n    },\n    \"value\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"url\"\n  ],\n  \"properties\": {\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"first_patched_version\",\n    \"package\",\n    \"severity\",\n    \"vulnerable_version_range\"\n  ],\n  \"properties\": {\n    \"first_patched_version\": {\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"required\": [\n        \"identifier\"\n      ],\n      \"properties\": {\n        \"identifier\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"package\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ecosystem\",\n        \"name\"\n      ],\n      \"properties\": {\n        \"ecosystem\": {\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"severity\": {\n      \"type\": \"string\"\n    },\n    \"vulnerable_version_range\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"identifier\"\n  ],\n  \"properties\": {\n    \"identifier\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ecosystem\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"ecosystem\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "SimplePullRequest"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Simple Pull Request\",\n  \"type\": \"object\",\n  \"required\": [\n    \"_links\",\n    \"active_lock_reason\",\n    \"assignee\",\n    \"assignees\",\n    \"author_association\",\n    \"auto_merge\",\n    \"base\",\n    \"body\",\n    \"closed_at\",\n    \"comments_url\",\n    \"commits_url\",\n    \"created_at\",\n    \"diff_url\",\n    \"draft\",\n    \"head\",\n    \"html_url\",\n    \"id\",\n    \"issue_url\",\n    \"labels\",\n    \"locked\",\n    \"merge_commit_sha\",\n    \"merged_at\",\n    \"milestone\",\n    \"node_id\",\n    \"number\",\n    \"patch_url\",\n    \"requested_reviewers\",\n    \"requested_teams\",\n    \"review_comment_url\",\n    \"review_comments_url\",\n    \"state\",\n    \"statuses_url\",\n    \"title\",\n    \"updated_at\",\n    \"url\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"_links\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"comments\",\n        \"commits\",\n        \"html\",\n        \"issue\",\n        \"review_comment\",\n        \"review_comments\",\n        \"self\",\n        \"statuses\"\n      ],\n      \"properties\": {\n        \"comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"commits\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"html\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"issue\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comment\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"review_comments\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"self\": {\n          \"$ref\": \"#/definitions/link\"\n        },\n        \"statuses\": {\n          \"$ref\": \"#/definitions/link\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"active_lock_reason\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"resolved\",\n        \"off-topic\",\n        \"too heated\",\n        \"spam\",\n        null\n      ]\n    },\n    \"assignee\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/user\"\n      }\n    },\n    \"author_association\": {\n      \"$ref\": \"#/definitions/author_association\"\n    },\n    \"auto_merge\": {\n      \"type\": \"null\"\n    },\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"body\": {\n      \"type\": \"string\"\n    },\n    \"closed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commits_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"diff_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"draft\": {\n      \"type\": \"boolean\"\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"label\",\n        \"ref\",\n        \"repo\",\n        \"sha\",\n        \"user\"\n      ],\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repository\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"user\": {\n          \"$ref\": \"#/definitions/user\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"issue_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/label\"\n      }\n    },\n    \"locked\": {\n      \"type\": \"boolean\"\n    },\n    \"merge_commit_sha\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"merged_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"milestone\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/milestone\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"patch_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"requested_reviewers\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": [\n          {\n            \"$ref\": \"#/definitions/user\"\n          },\n          {\n            \"$ref\": \"#/definitions/team\"\n          }\n        ]\n      }\n    },\n    \"requested_teams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/team\"\n      }\n    },\n    \"review_comment_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"review_comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"state\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\"\n      ]\n    },\n    \"statuses_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequest {
    pub active_lock_reason: Option<SimplePullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: SimplePullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    pub draft: bool,
    pub head: SimplePullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: SimplePullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<SimplePullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: SimplePullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&SimplePullRequest> for SimplePullRequest {
    fn from(value: &SimplePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "SimplePullRequestActiveLockReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"resolved\",\n    \"off-topic\",\n    \"too heated\",\n    \"spam\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&SimplePullRequestActiveLockReason> for SimplePullRequestActiveLockReason {
    fn from(value: &SimplePullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for SimplePullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SimplePullRequestBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&SimplePullRequestBase> for SimplePullRequestBase {
    fn from(value: &SimplePullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "SimplePullRequestHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"label\",\n    \"ref\",\n    \"repo\",\n    \"sha\",\n    \"user\"\n  ],\n  \"properties\": {\n    \"label\": {\n      \"type\": \"string\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"user\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&SimplePullRequestHead> for SimplePullRequestHead {
    fn from(value: &SimplePullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "SimplePullRequestLinks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"comments\",\n    \"commits\",\n    \"html\",\n    \"issue\",\n    \"review_comment\",\n    \"review_comments\",\n    \"self\",\n    \"statuses\"\n  ],\n  \"properties\": {\n    \"comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"commits\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"html\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"issue\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comment\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"review_comments\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"self\": {\n      \"$ref\": \"#/definitions/link\"\n    },\n    \"statuses\": {\n      \"$ref\": \"#/definitions/link\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&SimplePullRequestLinks> for SimplePullRequestLinks {
    fn from(value: &SimplePullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "SimplePullRequestRequestedReviewersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/user\"\n    },\n    {\n      \"$ref\": \"#/definitions/team\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SimplePullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&SimplePullRequestRequestedReviewersItem> for SimplePullRequestRequestedReviewersItem {
    fn from(value: &SimplePullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for SimplePullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for SimplePullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "SimplePullRequestState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&SimplePullRequestState> for SimplePullRequestState {
    fn from(value: &SimplePullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for SimplePullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipCancelled"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship cancelled event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"cancelled\"\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelled {
    pub action: SponsorshipCancelledAction,
    pub sender: User,
    pub sponsorship: SponsorshipCancelledSponsorship,
}
impl From<&SponsorshipCancelled> for SponsorshipCancelled {
    fn from(value: &SponsorshipCancelled) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipCancelledAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"cancelled\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl From<&SponsorshipCancelledAction> for SponsorshipCancelledAction {
    fn from(value: &SponsorshipCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipCancelledSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelledSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipCancelledSponsorship> for SponsorshipCancelledSponsorship {
    fn from(value: &SponsorshipCancelledSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreated {
    pub action: SponsorshipCreatedAction,
    pub sender: User,
    pub sponsorship: SponsorshipCreatedSponsorship,
}
impl From<&SponsorshipCreated> for SponsorshipCreated {
    fn from(value: &SponsorshipCreated) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&SponsorshipCreatedAction> for SponsorshipCreatedAction {
    fn from(value: &SponsorshipCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipCreatedSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreatedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipCreatedSponsorship> for SponsorshipCreatedSponsorship {
    fn from(value: &SponsorshipCreatedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"privacy_level\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEdited {
    pub action: SponsorshipEditedAction,
    pub changes: SponsorshipEditedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipEditedSponsorship,
}
impl From<&SponsorshipEdited> for SponsorshipEdited {
    fn from(value: &SponsorshipEdited) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&SponsorshipEditedAction> for SponsorshipEditedAction {
    fn from(value: &SponsorshipEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipEditedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"privacy_level\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy_level: Option<SponsorshipEditedChangesPrivacyLevel>,
}
impl From<&SponsorshipEditedChanges> for SponsorshipEditedChanges {
    fn from(value: &SponsorshipEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipEditedChangesPrivacyLevel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChangesPrivacyLevel {
    #[doc = "The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy."]
    pub from: String,
}
impl From<&SponsorshipEditedChangesPrivacyLevel> for SponsorshipEditedChangesPrivacyLevel {
    fn from(value: &SponsorshipEditedChangesPrivacyLevel) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipEditedSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipEditedSponsorship> for SponsorshipEditedSponsorship {
    fn from(value: &SponsorshipEditedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/sponsorship$cancelled\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship$pending_cancellation\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship$pending_tier_change\"\n    },\n    {\n      \"$ref\": \"#/definitions/sponsorship$tier_changed\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SponsorshipEvent {
    Cancelled(SponsorshipCancelled),
    Created(SponsorshipCreated),
    Edited(SponsorshipEdited),
    PendingCancellation(SponsorshipPendingCancellation),
    PendingTierChange(SponsorshipPendingTierChange),
    TierChanged(SponsorshipTierChanged),
}
impl From<&SponsorshipEvent> for SponsorshipEvent {
    fn from(value: &SponsorshipEvent) -> Self {
        value.clone()
    }
}
impl From<SponsorshipCancelled> for SponsorshipEvent {
    fn from(value: SponsorshipCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl From<SponsorshipCreated> for SponsorshipEvent {
    fn from(value: SponsorshipCreated) -> Self {
        Self::Created(value)
    }
}
impl From<SponsorshipEdited> for SponsorshipEvent {
    fn from(value: SponsorshipEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<SponsorshipPendingCancellation> for SponsorshipEvent {
    fn from(value: SponsorshipPendingCancellation) -> Self {
        Self::PendingCancellation(value)
    }
}
impl From<SponsorshipPendingTierChange> for SponsorshipEvent {
    fn from(value: SponsorshipPendingTierChange) -> Self {
        Self::PendingTierChange(value)
    }
}
impl From<SponsorshipTierChanged> for SponsorshipEvent {
    fn from(value: SponsorshipTierChanged) -> Self {
        Self::TierChanged(value)
    }
}
#[doc = "SponsorshipPendingCancellation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship pending_cancellation event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pending_cancellation\"\n      ]\n    },\n    \"effective_date\": {\n      \"description\": \"The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.\",\n      \"type\": \"string\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellation {
    pub action: SponsorshipPendingCancellationAction,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingCancellationSponsorship,
}
impl From<&SponsorshipPendingCancellation> for SponsorshipPendingCancellation {
    fn from(value: &SponsorshipPendingCancellation) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipPendingCancellationAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pending_cancellation\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingCancellationAction {
    #[serde(rename = "pending_cancellation")]
    PendingCancellation,
}
impl From<&SponsorshipPendingCancellationAction> for SponsorshipPendingCancellationAction {
    fn from(value: &SponsorshipPendingCancellationAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipPendingCancellationAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingCancellation => "pending_cancellation".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingCancellationAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_cancellation" => Ok(Self::PendingCancellation),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipPendingCancellationSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellationSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipPendingCancellationSponsorship>
    for SponsorshipPendingCancellationSponsorship
{
    fn from(value: &SponsorshipPendingCancellationSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipPendingTierChange"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship pending_tier_change event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"pending_tier_change\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"tier\"\n      ],\n      \"properties\": {\n        \"tier\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"$ref\": \"#/definitions/sponsorship-tier\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"effective_date\": {\n      \"description\": \"The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.\",\n      \"type\": \"string\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChange {
    pub action: SponsorshipPendingTierChangeAction,
    pub changes: SponsorshipPendingTierChangeChanges,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingTierChangeSponsorship,
}
impl From<&SponsorshipPendingTierChange> for SponsorshipPendingTierChange {
    fn from(value: &SponsorshipPendingTierChange) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipPendingTierChangeAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"pending_tier_change\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingTierChangeAction {
    #[serde(rename = "pending_tier_change")]
    PendingTierChange,
}
impl From<&SponsorshipPendingTierChangeAction> for SponsorshipPendingTierChangeAction {
    fn from(value: &SponsorshipPendingTierChangeAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipPendingTierChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingTierChange => "pending_tier_change".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingTierChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_tier_change" => Ok(Self::PendingTierChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipPendingTierChangeChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"tier\"\n  ],\n  \"properties\": {\n    \"tier\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChanges {
    pub tier: SponsorshipPendingTierChangeChangesTier,
}
impl From<&SponsorshipPendingTierChangeChanges> for SponsorshipPendingTierChangeChanges {
    fn from(value: &SponsorshipPendingTierChangeChanges) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipPendingTierChangeChangesTier"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChangesTier {
    pub from: SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeChangesTier> for SponsorshipPendingTierChangeChangesTier {
    fn from(value: &SponsorshipPendingTierChangeChangesTier) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipPendingTierChangeSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeSponsorship> for SponsorshipPendingTierChangeSponsorship {
    fn from(value: &SponsorshipPendingTierChangeSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Sponsorship Tier\",\n  \"description\": \"The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"description\",\n    \"is_custom_ammount\",\n    \"is_one_time\",\n    \"monthly_price_in_cents\",\n    \"monthly_price_in_dollars\",\n    \"name\",\n    \"node_id\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"is_custom_ammount\": {\n      \"type\": \"boolean\"\n    },\n    \"is_one_time\": {\n      \"type\": \"boolean\"\n    },\n    \"monthly_price_in_cents\": {\n      \"type\": \"integer\"\n    },\n    \"monthly_price_in_dollars\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTier {
    pub created_at: String,
    pub description: String,
    pub is_custom_ammount: bool,
    pub is_one_time: bool,
    pub monthly_price_in_cents: i64,
    pub monthly_price_in_dollars: i64,
    pub name: String,
    pub node_id: String,
}
impl From<&SponsorshipTier> for SponsorshipTier {
    fn from(value: &SponsorshipTier) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipTierChanged"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"sponsorship tier_changed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"sender\",\n    \"sponsorship\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"tier_changed\"\n      ]\n    },\n    \"changes\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"tier\"\n      ],\n      \"properties\": {\n        \"tier\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"$ref\": \"#/definitions/sponsorship-tier\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorship\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"created_at\",\n        \"node_id\",\n        \"privacy_level\",\n        \"sponsor\",\n        \"sponsorable\",\n        \"tier\"\n      ],\n      \"properties\": {\n        \"created_at\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"privacy_level\": {\n          \"type\": \"string\"\n        },\n        \"sponsor\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"sponsorable\": {\n          \"$ref\": \"#/definitions/user\"\n        },\n        \"tier\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChanged {
    pub action: SponsorshipTierChangedAction,
    pub changes: SponsorshipTierChangedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipTierChangedSponsorship,
}
impl From<&SponsorshipTierChanged> for SponsorshipTierChanged {
    fn from(value: &SponsorshipTierChanged) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipTierChangedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"tier_changed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipTierChangedAction {
    #[serde(rename = "tier_changed")]
    TierChanged,
}
impl From<&SponsorshipTierChangedAction> for SponsorshipTierChangedAction {
    fn from(value: &SponsorshipTierChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipTierChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::TierChanged => "tier_changed".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipTierChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tier_changed" => Ok(Self::TierChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "SponsorshipTierChangedChanges"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"tier\"\n  ],\n  \"properties\": {\n    \"tier\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"$ref\": \"#/definitions/sponsorship-tier\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChanges {
    pub tier: SponsorshipTierChangedChangesTier,
}
impl From<&SponsorshipTierChangedChanges> for SponsorshipTierChangedChanges {
    fn from(value: &SponsorshipTierChangedChanges) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipTierChangedChangesTier"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChangesTier {
    pub from: SponsorshipTier,
}
impl From<&SponsorshipTierChangedChangesTier> for SponsorshipTierChangedChangesTier {
    fn from(value: &SponsorshipTierChangedChangesTier) -> Self {
        value.clone()
    }
}
#[doc = "SponsorshipTierChangedSponsorship"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"created_at\",\n    \"node_id\",\n    \"privacy_level\",\n    \"sponsor\",\n    \"sponsorable\",\n    \"tier\"\n  ],\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"privacy_level\": {\n      \"type\": \"string\"\n    },\n    \"sponsor\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sponsorable\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"tier\": {\n      \"$ref\": \"#/definitions/sponsorship-tier\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipTierChangedSponsorship> for SponsorshipTierChangedSponsorship {
    fn from(value: &SponsorshipTierChangedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "StarCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"star created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"starred_at\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"starred_at\": {\n      \"description\": \"The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarCreated {
    pub action: StarCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: String,
}
impl From<&StarCreated> for StarCreated {
    fn from(value: &StarCreated) -> Self {
        value.clone()
    }
}
#[doc = "StarCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&StarCreatedAction> for StarCreatedAction {
    fn from(value: &StarCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for StarCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for StarCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "StarDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"star deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"starred_at\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"starred_at\": {\n      \"description\": \"The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.\",\n      \"type\": \"null\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarDeleted {
    pub action: StarDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: (),
}
impl From<&StarDeleted> for StarDeleted {
    fn from(value: &StarDeleted) -> Self {
        value.clone()
    }
}
#[doc = "StarDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&StarDeletedAction> for StarDeletedAction {
    fn from(value: &StarDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for StarDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for StarDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "StarEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/star$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/star$deleted\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StarEvent {
    Created(StarCreated),
    Deleted(StarDeleted),
}
impl From<&StarEvent> for StarEvent {
    fn from(value: &StarEvent) -> Self {
        value.clone()
    }
}
impl From<StarCreated> for StarEvent {
    fn from(value: StarCreated) -> Self {
        Self::Created(value)
    }
}
impl From<StarDeleted> for StarEvent {
    fn from(value: StarDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[doc = "StatusEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"status event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"branches\",\n    \"commit\",\n    \"context\",\n    \"created_at\",\n    \"description\",\n    \"id\",\n    \"name\",\n    \"repository\",\n    \"sender\",\n    \"sha\",\n    \"state\",\n    \"target_url\",\n    \"updated_at\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"format\": \"uri\"\n    },\n    \"branches\": {\n      \"description\": \"An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches.\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"commit\",\n          \"name\",\n          \"protected\"\n        ],\n        \"properties\": {\n          \"commit\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"sha\",\n              \"url\"\n            ],\n            \"properties\": {\n              \"sha\": {\n                \"type\": \"string\"\n              },\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"protected\": {\n            \"type\": \"boolean\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"commit\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"comments_url\",\n        \"commit\",\n        \"committer\",\n        \"html_url\",\n        \"node_id\",\n        \"parents\",\n        \"sha\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"comments_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"commit\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"author\",\n            \"comment_count\",\n            \"committer\",\n            \"message\",\n            \"tree\",\n            \"url\",\n            \"verification\"\n          ],\n          \"properties\": {\n            \"author\": {\n              \"allOf\": [\n                {\n                  \"$ref\": \"#/definitions/committer\"\n                },\n                {\n                  \"type\": \"object\",\n                  \"required\": [\n                    \"date\"\n                  ],\n                  \"properties\": {\n                    \"date\": {\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"tsAdditionalProperties\": false\n                }\n              ]\n            },\n            \"comment_count\": {\n              \"type\": \"integer\"\n            },\n            \"committer\": {\n              \"allOf\": [\n                {\n                  \"$ref\": \"#/definitions/committer\"\n                },\n                {\n                  \"type\": \"object\",\n                  \"required\": [\n                    \"date\"\n                  ],\n                  \"properties\": {\n                    \"date\": {\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"tsAdditionalProperties\": false\n                }\n              ]\n            },\n            \"message\": {\n              \"type\": \"string\"\n            },\n            \"tree\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"sha\",\n                \"url\"\n              ],\n              \"properties\": {\n                \"sha\": {\n                  \"type\": \"string\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"format\": \"uri\"\n                }\n              },\n              \"additionalProperties\": false\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            },\n            \"verification\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"payload\",\n                \"reason\",\n                \"signature\",\n                \"verified\"\n              ],\n              \"properties\": {\n                \"payload\": {\n                  \"type\": [\n                    \"string\",\n                    \"null\"\n                  ]\n                },\n                \"reason\": {\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"expired_key\",\n                    \"not_signing_key\",\n                    \"gpgverify_error\",\n                    \"gpgverify_unavailable\",\n                    \"unsigned\",\n                    \"unknown_signature_type\",\n                    \"no_user\",\n                    \"unverified_email\",\n                    \"bad_email\",\n                    \"unknown_key\",\n                    \"malformed_signature\",\n                    \"invalid\",\n                    \"valid\"\n                  ]\n                },\n                \"signature\": {\n                  \"type\": [\n                    \"string\",\n                    \"null\"\n                  ]\n                },\n                \"verified\": {\n                  \"type\": \"boolean\"\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"committer\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/definitions/user\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ]\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"parents\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"html_url\",\n              \"sha\",\n              \"url\"\n            ],\n            \"properties\": {\n              \"html_url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              \"sha\": {\n                \"type\": \"string\"\n              },\n              \"url\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            },\n            \"additionalProperties\": false\n          }\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"context\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"description\": \"The optional human-readable description added to the status.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"id\": {\n      \"description\": \"The unique identifier of the status.\",\n      \"type\": \"integer\"\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"sha\": {\n      \"description\": \"The Commit SHA.\",\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"pending\",\n        \"success\",\n        \"failure\",\n        \"error\"\n      ]\n    },\n    \"target_url\": {\n      \"description\": \"The optional link added to the status.\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    #[doc = "An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."]
    pub branches: Vec<StatusEventBranchesItem>,
    pub commit: StatusEventCommit,
    pub context: String,
    pub created_at: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: Option<String>,
    #[doc = "The unique identifier of the status."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The Commit SHA."]
    pub sha: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: StatusEventState,
    #[doc = "The optional link added to the status."]
    pub target_url: Option<String>,
    pub updated_at: String,
}
impl From<&StatusEvent> for StatusEvent {
    fn from(value: &StatusEvent) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventBranchesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"commit\",\n    \"name\",\n    \"protected\"\n  ],\n  \"properties\": {\n    \"commit\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"sha\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"protected\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItem {
    pub commit: StatusEventBranchesItemCommit,
    pub name: String,
    pub protected: bool,
}
impl From<&StatusEventBranchesItem> for StatusEventBranchesItem {
    fn from(value: &StatusEventBranchesItem) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventBranchesItemCommit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"sha\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItemCommit {
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventBranchesItemCommit> for StatusEventBranchesItemCommit {
    fn from(value: &StatusEventBranchesItemCommit) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"comments_url\",\n    \"commit\",\n    \"committer\",\n    \"html_url\",\n    \"node_id\",\n    \"parents\",\n    \"sha\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"comments_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"commit\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"author\",\n        \"comment_count\",\n        \"committer\",\n        \"message\",\n        \"tree\",\n        \"url\",\n        \"verification\"\n      ],\n      \"properties\": {\n        \"author\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/committer\"\n            },\n            {\n              \"type\": \"object\",\n              \"required\": [\n                \"date\"\n              ],\n              \"properties\": {\n                \"date\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"tsAdditionalProperties\": false\n            }\n          ]\n        },\n        \"comment_count\": {\n          \"type\": \"integer\"\n        },\n        \"committer\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/committer\"\n            },\n            {\n              \"type\": \"object\",\n              \"required\": [\n                \"date\"\n              ],\n              \"properties\": {\n                \"date\": {\n                  \"type\": \"string\"\n                }\n              },\n              \"tsAdditionalProperties\": false\n            }\n          ]\n        },\n        \"message\": {\n          \"type\": \"string\"\n        },\n        \"tree\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"sha\",\n            \"url\"\n          ],\n          \"properties\": {\n            \"sha\": {\n              \"type\": \"string\"\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"verification\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"payload\",\n            \"reason\",\n            \"signature\",\n            \"verified\"\n          ],\n          \"properties\": {\n            \"payload\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"reason\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"expired_key\",\n                \"not_signing_key\",\n                \"gpgverify_error\",\n                \"gpgverify_unavailable\",\n                \"unsigned\",\n                \"unknown_signature_type\",\n                \"no_user\",\n                \"unverified_email\",\n                \"bad_email\",\n                \"unknown_key\",\n                \"malformed_signature\",\n                \"invalid\",\n                \"valid\"\n              ]\n            },\n            \"signature\": {\n              \"type\": [\n                \"string\",\n                \"null\"\n              ]\n            },\n            \"verified\": {\n              \"type\": \"boolean\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"committer\": {\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/user\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parents\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"html_url\",\n          \"sha\",\n          \"url\"\n        ],\n        \"properties\": {\n          \"html_url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"sha\": {\n            \"type\": \"string\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommit {
    pub author: Option<User>,
    pub comments_url: String,
    pub commit: StatusEventCommitCommit,
    pub committer: Option<User>,
    pub html_url: String,
    pub node_id: String,
    pub parents: Vec<StatusEventCommitParentsItem>,
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommit> for StatusEventCommit {
    fn from(value: &StatusEventCommit) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"author\",\n    \"comment_count\",\n    \"committer\",\n    \"message\",\n    \"tree\",\n    \"url\",\n    \"verification\"\n  ],\n  \"properties\": {\n    \"author\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/committer\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"date\"\n          ],\n          \"properties\": {\n            \"date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"comment_count\": {\n      \"type\": \"integer\"\n    },\n    \"committer\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/committer\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"date\"\n          ],\n          \"properties\": {\n            \"date\": {\n              \"type\": \"string\"\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    },\n    \"message\": {\n      \"type\": \"string\"\n    },\n    \"tree\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"sha\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"sha\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"verification\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"payload\",\n        \"reason\",\n        \"signature\",\n        \"verified\"\n      ],\n      \"properties\": {\n        \"payload\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"reason\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"expired_key\",\n            \"not_signing_key\",\n            \"gpgverify_error\",\n            \"gpgverify_unavailable\",\n            \"unsigned\",\n            \"unknown_signature_type\",\n            \"no_user\",\n            \"unverified_email\",\n            \"bad_email\",\n            \"unknown_key\",\n            \"malformed_signature\",\n            \"invalid\",\n            \"valid\"\n          ]\n        },\n        \"signature\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"verified\": {\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommit {
    pub author: StatusEventCommitCommitAuthor,
    pub comment_count: i64,
    pub committer: StatusEventCommitCommitCommitter,
    pub message: String,
    pub tree: StatusEventCommitCommitTree,
    pub url: String,
    pub verification: StatusEventCommitCommitVerification,
}
impl From<&StatusEventCommitCommit> for StatusEventCommitCommit {
    fn from(value: &StatusEventCommitCommit) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommitAuthor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"date\",\n    \"email\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"date\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"email\": {\n      \"description\": \"The git author's email address.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"name\": {\n      \"description\": \"The git author's name.\",\n      \"type\": \"string\"\n    },\n    \"username\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitAuthor {
    pub date: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The git author's email address."]
    pub email: Option<String>,
    #[doc = "The git author's name."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}
impl From<&StatusEventCommitCommitAuthor> for StatusEventCommitCommitAuthor {
    fn from(value: &StatusEventCommitCommitAuthor) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommitCommitter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"date\",\n    \"email\",\n    \"name\"\n  ],\n  \"properties\": {\n    \"date\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"email\": {\n      \"description\": \"The git author's email address.\",\n      \"oneOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"name\": {\n      \"description\": \"The git author's name.\",\n      \"type\": \"string\"\n    },\n    \"username\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitCommitter {
    pub date: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The git author's email address."]
    pub email: Option<String>,
    #[doc = "The git author's name."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}
impl From<&StatusEventCommitCommitCommitter> for StatusEventCommitCommitCommitter {
    fn from(value: &StatusEventCommitCommitCommitter) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommitTree"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"sha\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitTree {
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommitCommitTree> for StatusEventCommitCommitTree {
    fn from(value: &StatusEventCommitCommitTree) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommitVerification"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"payload\",\n    \"reason\",\n    \"signature\",\n    \"verified\"\n  ],\n  \"properties\": {\n    \"payload\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"reason\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"expired_key\",\n        \"not_signing_key\",\n        \"gpgverify_error\",\n        \"gpgverify_unavailable\",\n        \"unsigned\",\n        \"unknown_signature_type\",\n        \"no_user\",\n        \"unverified_email\",\n        \"bad_email\",\n        \"unknown_key\",\n        \"malformed_signature\",\n        \"invalid\",\n        \"valid\"\n      ]\n    },\n    \"signature\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"verified\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitVerification {
    pub payload: Option<String>,
    pub reason: StatusEventCommitCommitVerificationReason,
    pub signature: Option<String>,
    pub verified: bool,
}
impl From<&StatusEventCommitCommitVerification> for StatusEventCommitCommitVerification {
    fn from(value: &StatusEventCommitCommitVerification) -> Self {
        value.clone()
    }
}
#[doc = "StatusEventCommitCommitVerificationReason"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"expired_key\",\n    \"not_signing_key\",\n    \"gpgverify_error\",\n    \"gpgverify_unavailable\",\n    \"unsigned\",\n    \"unknown_signature_type\",\n    \"no_user\",\n    \"unverified_email\",\n    \"bad_email\",\n    \"unknown_key\",\n    \"malformed_signature\",\n    \"invalid\",\n    \"valid\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventCommitCommitVerificationReason {
    #[serde(rename = "expired_key")]
    ExpiredKey,
    #[serde(rename = "not_signing_key")]
    NotSigningKey,
    #[serde(rename = "gpgverify_error")]
    GpgverifyError,
    #[serde(rename = "gpgverify_unavailable")]
    GpgverifyUnavailable,
    #[serde(rename = "unsigned")]
    Unsigned,
    #[serde(rename = "unknown_signature_type")]
    UnknownSignatureType,
    #[serde(rename = "no_user")]
    NoUser,
    #[serde(rename = "unverified_email")]
    UnverifiedEmail,
    #[serde(rename = "bad_email")]
    BadEmail,
    #[serde(rename = "unknown_key")]
    UnknownKey,
    #[serde(rename = "malformed_signature")]
    MalformedSignature,
    #[serde(rename = "invalid")]
    Invalid,
    #[serde(rename = "valid")]
    Valid,
}
impl From<&StatusEventCommitCommitVerificationReason>
    for StatusEventCommitCommitVerificationReason
{
    fn from(value: &StatusEventCommitCommitVerificationReason) -> Self {
        value.clone()
    }
}
impl ToString for StatusEventCommitCommitVerificationReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ExpiredKey => "expired_key".to_string(),
            Self::NotSigningKey => "not_signing_key".to_string(),
            Self::GpgverifyError => "gpgverify_error".to_string(),
            Self::GpgverifyUnavailable => "gpgverify_unavailable".to_string(),
            Self::Unsigned => "unsigned".to_string(),
            Self::UnknownSignatureType => "unknown_signature_type".to_string(),
            Self::NoUser => "no_user".to_string(),
            Self::UnverifiedEmail => "unverified_email".to_string(),
            Self::BadEmail => "bad_email".to_string(),
            Self::UnknownKey => "unknown_key".to_string(),
            Self::MalformedSignature => "malformed_signature".to_string(),
            Self::Invalid => "invalid".to_string(),
            Self::Valid => "valid".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventCommitCommitVerificationReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "expired_key" => Ok(Self::ExpiredKey),
            "not_signing_key" => Ok(Self::NotSigningKey),
            "gpgverify_error" => Ok(Self::GpgverifyError),
            "gpgverify_unavailable" => Ok(Self::GpgverifyUnavailable),
            "unsigned" => Ok(Self::Unsigned),
            "unknown_signature_type" => Ok(Self::UnknownSignatureType),
            "no_user" => Ok(Self::NoUser),
            "unverified_email" => Ok(Self::UnverifiedEmail),
            "bad_email" => Ok(Self::BadEmail),
            "unknown_key" => Ok(Self::UnknownKey),
            "malformed_signature" => Ok(Self::MalformedSignature),
            "invalid" => Ok(Self::Invalid),
            "valid" => Ok(Self::Valid),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "StatusEventCommitParentsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"html_url\",\n    \"sha\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitParentsItem {
    pub html_url: String,
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommitParentsItem> for StatusEventCommitParentsItem {
    fn from(value: &StatusEventCommitParentsItem) -> Self {
        value.clone()
    }
}
#[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"pending\",\n    \"success\",\n    \"failure\",\n    \"error\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventState {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "error")]
    Error,
}
impl From<&StatusEventState> for StatusEventState {
    fn from(value: &StatusEventState) -> Self {
        value.clone()
    }
}
impl ToString for StatusEventState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "pending".to_string(),
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending" => Ok(Self::Pending),
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Team\",\n  \"description\": \"Groups of organization members that gives permissions on specified repositories.\",\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"html_url\",\n    \"id\",\n    \"members_url\",\n    \"name\",\n    \"node_id\",\n    \"permission\",\n    \"privacy\",\n    \"repositories_url\",\n    \"slug\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"Description of the team\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the team\",\n      \"type\": \"integer\"\n    },\n    \"members_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"name\": {\n      \"description\": \"Name of the team\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"parent\": {\n      \"type\": [\n        \"object\",\n        \"null\"\n      ],\n      \"required\": [\n        \"description\",\n        \"html_url\",\n        \"id\",\n        \"members_url\",\n        \"name\",\n        \"node_id\",\n        \"permission\",\n        \"privacy\",\n        \"repositories_url\",\n        \"slug\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"description\": {\n          \"description\": \"Description of the team\",\n          \"type\": [\n            \"string\",\n            \"null\"\n          ]\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"description\": \"Unique identifier of the team\",\n          \"type\": \"integer\"\n        },\n        \"members_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri-template\"\n        },\n        \"name\": {\n          \"description\": \"Name of the team\",\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"permission\": {\n          \"description\": \"Permission that the team will have for its repositories\",\n          \"type\": \"string\"\n        },\n        \"privacy\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"open\",\n            \"closed\",\n            \"secret\"\n          ]\n        },\n        \"repositories_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"slug\": {\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"description\": \"URL for the team\",\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"permission\": {\n      \"description\": \"Permission that the team will have for its repositories\",\n      \"type\": \"string\"\n    },\n    \"privacy\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\",\n        \"secret\"\n      ]\n    },\n    \"repositories_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"description\": \"URL for the team\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Team {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<TeamParent>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
impl From<&Team> for Team {
    fn from(value: &Team) -> Self {
        value.clone()
    }
}
#[doc = "TeamAddEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team_add event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"organization\",\n    \"repository\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub repository: Repository,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamAddEvent> for TeamAddEvent {
    fn from(value: &TeamAddEvent) -> Self {
        value.clone()
    }
}
#[doc = "TeamAddedToRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team added_to_repository event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"organization\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"added_to_repository\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddedToRepository {
    pub action: TeamAddedToRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamAddedToRepository> for TeamAddedToRepository {
    fn from(value: &TeamAddedToRepository) -> Self {
        value.clone()
    }
}
#[doc = "TeamAddedToRepositoryAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"added_to_repository\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamAddedToRepositoryAction {
    #[serde(rename = "added_to_repository")]
    AddedToRepository,
}
impl From<&TeamAddedToRepositoryAction> for TeamAddedToRepositoryAction {
    fn from(value: &TeamAddedToRepositoryAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamAddedToRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AddedToRepository => "added_to_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamAddedToRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added_to_repository" => Ok(Self::AddedToRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "TeamCreated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team created event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"organization\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"created\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamCreated {
    pub action: TeamCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamCreated> for TeamCreated {
    fn from(value: &TeamCreated) -> Self {
        value.clone()
    }
}
#[doc = "TeamCreatedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"created\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&TeamCreatedAction> for TeamCreatedAction {
    fn from(value: &TeamCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for TeamCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "TeamDeleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team deleted event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"organization\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"deleted\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamDeleted {
    pub action: TeamDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamDeleted> for TeamDeleted {
    fn from(value: &TeamDeleted) -> Self {
        value.clone()
    }
}
#[doc = "TeamDeletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"deleted\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&TeamDeletedAction> for TeamDeletedAction {
    fn from(value: &TeamDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for TeamDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "TeamEdited"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team edited event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"changes\",\n    \"organization\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"edited\"\n      ]\n    },\n    \"changes\": {\n      \"description\": \"The changes to the team if the action was `edited`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"description\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the description if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"name\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the name if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"privacy\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"description\": \"The previous version of the team's privacy if the action was `edited`.\",\n              \"type\": \"string\"\n            }\n          },\n          \"additionalProperties\": false\n        },\n        \"repository\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"permissions\"\n          ],\n          \"properties\": {\n            \"permissions\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"from\"\n              ],\n              \"properties\": {\n                \"from\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"admin\": {\n                      \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\",\n                      \"type\": \"boolean\"\n                    },\n                    \"pull\": {\n                      \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\",\n                      \"type\": \"boolean\"\n                    },\n                    \"push\": {\n                      \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\",\n                      \"type\": \"boolean\"\n                    }\n                  },\n                  \"additionalProperties\": false\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEdited {
    pub action: TeamEditedAction,
    pub changes: TeamEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamEdited> for TeamEdited {
    fn from(value: &TeamEdited) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"edited\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&TeamEditedAction> for TeamEditedAction {
    fn from(value: &TeamEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for TeamEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the team if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"description\": \"The changes to the team if the action was `edited`.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"description\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the description if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"name\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the name if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"privacy\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"description\": \"The previous version of the team's privacy if the action was `edited`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"repository\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"permissions\"\n      ],\n      \"properties\": {\n        \"permissions\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"from\"\n          ],\n          \"properties\": {\n            \"from\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"admin\": {\n                  \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\",\n                  \"type\": \"boolean\"\n                },\n                \"pull\": {\n                  \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\",\n                  \"type\": \"boolean\"\n                },\n                \"push\": {\n                  \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\",\n                  \"type\": \"boolean\"\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<TeamEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<TeamEditedChangesName>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<TeamEditedChangesPrivacy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TeamEditedChangesRepository>,
}
impl From<&TeamEditedChanges> for TeamEditedChanges {
    fn from(value: &TeamEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesDescription"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the description if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesDescription> for TeamEditedChangesDescription {
    fn from(value: &TeamEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the name if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesName> for TeamEditedChangesName {
    fn from(value: &TeamEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesPrivacy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"description\": \"The previous version of the team's privacy if the action was `edited`.\",\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesPrivacy {
    #[doc = "The previous version of the team's privacy if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesPrivacy> for TeamEditedChangesPrivacy {
    fn from(value: &TeamEditedChangesPrivacy) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"permissions\"\n  ],\n  \"properties\": {\n    \"permissions\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"from\"\n      ],\n      \"properties\": {\n        \"from\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"admin\": {\n              \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\",\n              \"type\": \"boolean\"\n            },\n            \"pull\": {\n              \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\",\n              \"type\": \"boolean\"\n            },\n            \"push\": {\n              \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\",\n              \"type\": \"boolean\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepository {
    pub permissions: TeamEditedChangesRepositoryPermissions,
}
impl From<&TeamEditedChangesRepository> for TeamEditedChangesRepository {
    fn from(value: &TeamEditedChangesRepository) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesRepositoryPermissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"from\"\n  ],\n  \"properties\": {\n    \"from\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"admin\": {\n          \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\",\n          \"type\": \"boolean\"\n        },\n        \"pull\": {\n          \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\",\n          \"type\": \"boolean\"\n        },\n        \"push\": {\n          \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\",\n          \"type\": \"boolean\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissions {
    pub from: TeamEditedChangesRepositoryPermissionsFrom,
}
impl From<&TeamEditedChangesRepositoryPermissions> for TeamEditedChangesRepositoryPermissions {
    fn from(value: &TeamEditedChangesRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "TeamEditedChangesRepositoryPermissionsFrom"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"admin\": {\n      \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\",\n      \"type\": \"boolean\"\n    },\n    \"pull\": {\n      \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\",\n      \"type\": \"boolean\"\n    },\n    \"push\": {\n      \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissionsFrom {
    #[doc = "The previous version of the team member's `admin` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin: Option<bool>,
    #[doc = "The previous version of the team member's `pull` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull: Option<bool>,
    #[doc = "The previous version of the team member's `push` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push: Option<bool>,
}
impl From<&TeamEditedChangesRepositoryPermissionsFrom>
    for TeamEditedChangesRepositoryPermissionsFrom
{
    fn from(value: &TeamEditedChangesRepositoryPermissionsFrom) -> Self {
        value.clone()
    }
}
#[doc = "TeamEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/team$added_to_repository\"\n    },\n    {\n      \"$ref\": \"#/definitions/team$created\"\n    },\n    {\n      \"$ref\": \"#/definitions/team$deleted\"\n    },\n    {\n      \"$ref\": \"#/definitions/team$edited\"\n    },\n    {\n      \"$ref\": \"#/definitions/team$removed_from_repository\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TeamEvent {
    AddedToRepository(TeamAddedToRepository),
    Created(TeamCreated),
    Deleted(TeamDeleted),
    Edited(TeamEdited),
    RemovedFromRepository(TeamRemovedFromRepository),
}
impl From<&TeamEvent> for TeamEvent {
    fn from(value: &TeamEvent) -> Self {
        value.clone()
    }
}
impl From<TeamAddedToRepository> for TeamEvent {
    fn from(value: TeamAddedToRepository) -> Self {
        Self::AddedToRepository(value)
    }
}
impl From<TeamCreated> for TeamEvent {
    fn from(value: TeamCreated) -> Self {
        Self::Created(value)
    }
}
impl From<TeamDeleted> for TeamEvent {
    fn from(value: TeamDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<TeamEdited> for TeamEvent {
    fn from(value: TeamEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<TeamRemovedFromRepository> for TeamEvent {
    fn from(value: TeamRemovedFromRepository) -> Self {
        Self::RemovedFromRepository(value)
    }
}
#[doc = "TeamParent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"description\",\n    \"html_url\",\n    \"id\",\n    \"members_url\",\n    \"name\",\n    \"node_id\",\n    \"permission\",\n    \"privacy\",\n    \"repositories_url\",\n    \"slug\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"description\": {\n      \"description\": \"Description of the team\",\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"description\": \"Unique identifier of the team\",\n      \"type\": \"integer\"\n    },\n    \"members_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"name\": {\n      \"description\": \"Name of the team\",\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"permission\": {\n      \"description\": \"Permission that the team will have for its repositories\",\n      \"type\": \"string\"\n    },\n    \"privacy\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"open\",\n        \"closed\",\n        \"secret\"\n      ]\n    },\n    \"repositories_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"slug\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"description\": \"URL for the team\",\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamParent {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamParentPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
impl From<&TeamParent> for TeamParent {
    fn from(value: &TeamParent) -> Self {
        value.clone()
    }
}
#[doc = "TeamParentPrivacy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\",\n    \"secret\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamParentPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl From<&TeamParentPrivacy> for TeamParentPrivacy {
    fn from(value: &TeamParentPrivacy) -> Self {
        value.clone()
    }
}
impl ToString for TeamParentPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamParentPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "TeamPrivacy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"open\",\n    \"closed\",\n    \"secret\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl From<&TeamPrivacy> for TeamPrivacy {
    fn from(value: &TeamPrivacy) -> Self {
        value.clone()
    }
}
impl ToString for TeamPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "TeamRemovedFromRepository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"team removed_from_repository event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"organization\",\n    \"sender\",\n    \"team\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"removed_from_repository\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"team\": {\n      \"$ref\": \"#/definitions/team\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamRemovedFromRepository {
    pub action: TeamRemovedFromRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamRemovedFromRepository> for TeamRemovedFromRepository {
    fn from(value: &TeamRemovedFromRepository) -> Self {
        value.clone()
    }
}
#[doc = "TeamRemovedFromRepositoryAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"removed_from_repository\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamRemovedFromRepositoryAction {
    #[serde(rename = "removed_from_repository")]
    RemovedFromRepository,
}
impl From<&TeamRemovedFromRepositoryAction> for TeamRemovedFromRepositoryAction {
    fn from(value: &TeamRemovedFromRepositoryAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamRemovedFromRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RemovedFromRepository => "removed_from_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamRemovedFromRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed_from_repository" => Ok(Self::RemovedFromRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "User"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"required\": [\n    \"avatar_url\",\n    \"events_url\",\n    \"followers_url\",\n    \"following_url\",\n    \"gists_url\",\n    \"gravatar_id\",\n    \"html_url\",\n    \"id\",\n    \"login\",\n    \"node_id\",\n    \"organizations_url\",\n    \"received_events_url\",\n    \"repos_url\",\n    \"site_admin\",\n    \"starred_url\",\n    \"subscriptions_url\",\n    \"type\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"avatar_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"email\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"followers_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"following_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gists_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"gravatar_id\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"login\": {\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"organizations_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"received_events_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"repos_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"site_admin\": {\n      \"type\": \"boolean\"\n    },\n    \"starred_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri-template\"\n    },\n    \"subscriptions_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"type\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Bot\",\n        \"User\",\n        \"Organization\"\n      ]\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct User {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: UserType,
    pub url: String,
}
impl From<&User> for User {
    fn from(value: &User) -> Self {
        value.clone()
    }
}
#[doc = "UserType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"Bot\",\n    \"User\",\n    \"Organization\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum UserType {
    Bot,
    User,
    Organization,
}
impl From<&UserType> for UserType {
    fn from(value: &UserType) -> Self {
        value.clone()
    }
}
impl ToString for UserType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for UserType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for UserType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for UserType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for UserType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WatchEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/watch$started\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct WatchEvent(pub WatchStarted);
impl std::ops::Deref for WatchEvent {
    type Target = WatchStarted;
    fn deref(&self) -> &WatchStarted {
        &self.0
    }
}
impl From<WatchEvent> for WatchStarted {
    fn from(value: WatchEvent) -> Self {
        value.0
    }
}
impl From<&WatchEvent> for WatchEvent {
    fn from(value: &WatchEvent) -> Self {
        value.clone()
    }
}
impl From<WatchStarted> for WatchEvent {
    fn from(value: WatchStarted) -> Self {
        Self(value)
    }
}
#[doc = "WatchStarted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"watch started event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"started\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WatchStarted {
    pub action: WatchStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&WatchStarted> for WatchStarted {
    fn from(value: &WatchStarted) -> Self {
        value.clone()
    }
}
#[doc = "WatchStartedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"started\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WatchStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl From<&WatchStartedAction> for WatchStartedAction {
    fn from(value: &WatchStartedAction) -> Self {
        value.clone()
    }
}
impl ToString for WatchStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WatchStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WebhookEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Webhook Events\",\n  \"oneOf\": [\n    {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"check_run\",\n          \"check_suite\",\n          \"code_scanning_alert\",\n          \"commit_comment\",\n          \"content_reference\",\n          \"create\",\n          \"delete\",\n          \"deployment\",\n          \"deployment_review\",\n          \"deployment_status\",\n          \"deploy_key\",\n          \"discussion\",\n          \"discussion_comment\",\n          \"fork\",\n          \"gollum\",\n          \"issues\",\n          \"issue_comment\",\n          \"label\",\n          \"member\",\n          \"membership\",\n          \"meta\",\n          \"milestone\",\n          \"organization\",\n          \"org_block\",\n          \"page_build\",\n          \"project\",\n          \"project_card\",\n          \"project_column\",\n          \"public\",\n          \"pull_request\",\n          \"pull_request_review\",\n          \"pull_request_review_comment\",\n          \"push\",\n          \"registry_package\",\n          \"release\",\n          \"repository\",\n          \"repository_dispatch\",\n          \"repository_import\",\n          \"repository_vulnerability_alert\",\n          \"secret_scanning_alert\",\n          \"star\",\n          \"status\",\n          \"team\",\n          \"team_add\",\n          \"watch\",\n          \"workflow_dispatch\",\n          \"workflow_run\"\n        ]\n      }\n    },\n    {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"const\": \"*\"\n      },\n      \"maxItems\": 1,\n      \"minItems\": 1\n    }\n  ],\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WebhookEvents {
    Variant0(Vec<WebhookEventsVariant0Item>),
    Variant1([String; 1usize]),
}
impl From<&WebhookEvents> for WebhookEvents {
    fn from(value: &WebhookEvents) -> Self {
        value.clone()
    }
}
impl From<Vec<WebhookEventsVariant0Item>> for WebhookEvents {
    fn from(value: Vec<WebhookEventsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<[String; 1usize]> for WebhookEvents {
    fn from(value: [String; 1usize]) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WebhookEventsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"check_run\",\n    \"check_suite\",\n    \"code_scanning_alert\",\n    \"commit_comment\",\n    \"content_reference\",\n    \"create\",\n    \"delete\",\n    \"deployment\",\n    \"deployment_review\",\n    \"deployment_status\",\n    \"deploy_key\",\n    \"discussion\",\n    \"discussion_comment\",\n    \"fork\",\n    \"gollum\",\n    \"issues\",\n    \"issue_comment\",\n    \"label\",\n    \"member\",\n    \"membership\",\n    \"meta\",\n    \"milestone\",\n    \"organization\",\n    \"org_block\",\n    \"page_build\",\n    \"project\",\n    \"project_card\",\n    \"project_column\",\n    \"public\",\n    \"pull_request\",\n    \"pull_request_review\",\n    \"pull_request_review_comment\",\n    \"push\",\n    \"registry_package\",\n    \"release\",\n    \"repository\",\n    \"repository_dispatch\",\n    \"repository_import\",\n    \"repository_vulnerability_alert\",\n    \"secret_scanning_alert\",\n    \"star\",\n    \"status\",\n    \"team\",\n    \"team_add\",\n    \"watch\",\n    \"workflow_dispatch\",\n    \"workflow_run\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WebhookEventsVariant0Item {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "meta")]
    Meta,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "repository_import")]
    RepositoryImport,
    #[serde(rename = "repository_vulnerability_alert")]
    RepositoryVulnerabilityAlert,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&WebhookEventsVariant0Item> for WebhookEventsVariant0Item {
    fn from(value: &WebhookEventsVariant0Item) -> Self {
        value.clone()
    }
}
impl ToString for WebhookEventsVariant0Item {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Meta => "meta".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::RepositoryImport => "repository_import".to_string(),
            Self::RepositoryVulnerabilityAlert => "repository_vulnerability_alert".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for WebhookEventsVariant0Item {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "meta" => Ok(Self::Meta),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "repository_import" => Ok(Self::RepositoryImport),
            "repository_vulnerability_alert" => Ok(Self::RepositoryVulnerabilityAlert),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Workflow"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow\",\n  \"type\": \"object\",\n  \"required\": [\n    \"badge_url\",\n    \"created_at\",\n    \"html_url\",\n    \"id\",\n    \"name\",\n    \"node_id\",\n    \"path\",\n    \"state\",\n    \"updated_at\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"badge_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"created_at\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"path\": {\n      \"type\": \"string\"\n    },\n    \"state\": {\n      \"type\": \"string\"\n    },\n    \"updated_at\": {\n      \"type\": \"string\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Workflow {
    pub badge_url: String,
    pub created_at: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    pub path: String,
    pub state: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&Workflow> for Workflow {
    fn from(value: &Workflow) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowDispatchEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_dispatch event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"inputs\",\n    \"ref\",\n    \"repository\",\n    \"sender\",\n    \"workflow\"\n  ],\n  \"properties\": {\n    \"inputs\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowDispatchEvent {
    pub inputs: Option<serde_json::Map<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
    pub workflow: String,
}
impl From<&WorkflowDispatchEvent> for WorkflowDispatchEvent {
    fn from(value: &WorkflowDispatchEvent) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJob"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow Job\",\n  \"type\": \"object\",\n  \"required\": [\n    \"check_run_url\",\n    \"completed_at\",\n    \"conclusion\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"name\",\n    \"node_id\",\n    \"run_id\",\n    \"run_url\",\n    \"started_at\",\n    \"status\",\n    \"steps\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"check_run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"completed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        null\n      ]\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"run_id\": {\n      \"type\": \"number\"\n    },\n    \"run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"started_at\": {\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"steps\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/workflow-step\"\n      },\n      \"minItems\": 1\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJob {
    pub check_run_url: String,
    pub completed_at: Option<String>,
    pub conclusion: Option<WorkflowJobConclusion>,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: String,
    pub status: WorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
impl From<&WorkflowJob> for WorkflowJob {
    fn from(value: &WorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobCompleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_job completed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"workflow_job\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow_job\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/workflow-job\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"conclusion\"\n          ],\n          \"properties\": {\n            \"conclusion\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"success\",\n                \"failure\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompleted {
    pub action: WorkflowJobCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobCompletedWorkflowJob,
}
impl From<&WorkflowJobCompleted> for WorkflowJobCompleted {
    fn from(value: &WorkflowJobCompleted) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobCompletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobCompletedAction> for WorkflowJobCompletedAction {
    fn from(value: &WorkflowJobCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobCompletedWorkflowJob"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"check_run_url\",\n    \"completed_at\",\n    \"conclusion\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"name\",\n    \"node_id\",\n    \"run_id\",\n    \"run_url\",\n    \"started_at\",\n    \"status\",\n    \"steps\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"check_run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"completed_at\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ]\n    },\n    \"conclusion\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"success\",\n        \"failure\"\n      ]\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"run_id\": {\n      \"type\": \"number\"\n    },\n    \"run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"started_at\": {\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"steps\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/workflow-step\"\n      },\n      \"minItems\": 1\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompletedWorkflowJob {
    pub check_run_url: String,
    pub completed_at: Option<String>,
    pub conclusion: WorkflowJobCompletedWorkflowJobConclusion,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: String,
    pub status: WorkflowJobCompletedWorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
impl From<&WorkflowJobCompletedWorkflowJob> for WorkflowJobCompletedWorkflowJob {
    fn from(value: &WorkflowJobCompletedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobCompletedWorkflowJobConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobCompletedWorkflowJobConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl From<&WorkflowJobCompletedWorkflowJobConclusion>
    for WorkflowJobCompletedWorkflowJobConclusion
{
    fn from(value: &WorkflowJobCompletedWorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobCompletedWorkflowJobConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobCompletedWorkflowJobConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobCompletedWorkflowJobStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobCompletedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobCompletedWorkflowJobStatus> for WorkflowJobCompletedWorkflowJobStatus {
    fn from(value: &WorkflowJobCompletedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobCompletedWorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobCompletedWorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl From<&WorkflowJobConclusion> for WorkflowJobConclusion {
    fn from(value: &WorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/workflow_job$completed\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_job$queued\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_job$started\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowJobEvent {
    Completed(WorkflowJobCompleted),
    Queued(WorkflowJobQueued),
    Started(WorkflowJobStarted),
}
impl From<&WorkflowJobEvent> for WorkflowJobEvent {
    fn from(value: &WorkflowJobEvent) -> Self {
        value.clone()
    }
}
impl From<WorkflowJobCompleted> for WorkflowJobEvent {
    fn from(value: WorkflowJobCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<WorkflowJobQueued> for WorkflowJobEvent {
    fn from(value: WorkflowJobQueued) -> Self {
        Self::Queued(value)
    }
}
impl From<WorkflowJobStarted> for WorkflowJobEvent {
    fn from(value: WorkflowJobStarted) -> Self {
        Self::Started(value)
    }
}
#[doc = "WorkflowJobQueued"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_job queued event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"workflow_job\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow_job\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"check_run_url\",\n        \"completed_at\",\n        \"conclusion\",\n        \"head_sha\",\n        \"html_url\",\n        \"id\",\n        \"labels\",\n        \"name\",\n        \"node_id\",\n        \"run_id\",\n        \"run_url\",\n        \"started_at\",\n        \"status\",\n        \"steps\",\n        \"url\"\n      ],\n      \"properties\": {\n        \"check_run_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"completed_at\": {\n          \"type\": \"null\"\n        },\n        \"conclusion\": {\n          \"type\": \"null\"\n        },\n        \"head_sha\": {\n          \"type\": \"string\"\n        },\n        \"html_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"id\": {\n          \"type\": \"integer\"\n        },\n        \"labels\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"node_id\": {\n          \"type\": \"string\"\n        },\n        \"run_id\": {\n          \"type\": \"number\"\n        },\n        \"run_url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"started_at\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\"\n        },\n        \"status\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"queued\"\n          ]\n        },\n        \"steps\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/workflow-step\"\n          }\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueued {
    pub action: WorkflowJobQueuedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobQueuedWorkflowJob,
}
impl From<&WorkflowJobQueued> for WorkflowJobQueued {
    fn from(value: &WorkflowJobQueued) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobQueuedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobQueuedAction {
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowJobQueuedAction> for WorkflowJobQueuedAction {
    fn from(value: &WorkflowJobQueuedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobQueuedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobQueuedWorkflowJob"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"check_run_url\",\n    \"completed_at\",\n    \"conclusion\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"name\",\n    \"node_id\",\n    \"run_id\",\n    \"run_url\",\n    \"started_at\",\n    \"status\",\n    \"steps\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"check_run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"completed_at\": {\n      \"type\": \"null\"\n    },\n    \"conclusion\": {\n      \"type\": \"null\"\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"run_id\": {\n      \"type\": \"number\"\n    },\n    \"run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"started_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\"\n      ]\n    },\n    \"steps\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/workflow-step\"\n      }\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueuedWorkflowJob {
    pub check_run_url: String,
    pub completed_at: (),
    pub conclusion: (),
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: chrono::DateTime<chrono::offset::Utc>,
    pub status: WorkflowJobQueuedWorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
impl From<&WorkflowJobQueuedWorkflowJob> for WorkflowJobQueuedWorkflowJob {
    fn from(value: &WorkflowJobQueuedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobQueuedWorkflowJobStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobQueuedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowJobQueuedWorkflowJobStatus> for WorkflowJobQueuedWorkflowJobStatus {
    fn from(value: &WorkflowJobQueuedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobQueuedWorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedWorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobStarted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_job started event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"workflow_job\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"started\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow_job\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/workflow-job\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"completed_at\",\n            \"conclusion\",\n            \"steps\"\n          ],\n          \"properties\": {\n            \"completed_at\": {\n              \"type\": \"null\"\n            },\n            \"conclusion\": {\n              \"type\": \"null\"\n            },\n            \"steps\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/workflow-step-in_progress\"\n              },\n              \"maxItems\": 1,\n              \"minItems\": 1\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStarted {
    pub action: WorkflowJobStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobStartedWorkflowJob,
}
impl From<&WorkflowJobStarted> for WorkflowJobStarted {
    fn from(value: &WorkflowJobStarted) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobStartedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"started\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl From<&WorkflowJobStartedAction> for WorkflowJobStartedAction {
    fn from(value: &WorkflowJobStartedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobStartedWorkflowJob"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"check_run_url\",\n    \"completed_at\",\n    \"conclusion\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"labels\",\n    \"name\",\n    \"node_id\",\n    \"run_id\",\n    \"run_url\",\n    \"started_at\",\n    \"status\",\n    \"steps\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"check_run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"completed_at\": {\n      \"type\": \"null\"\n    },\n    \"conclusion\": {\n      \"type\": \"null\",\n      \"enum\": [\n        null\n      ]\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"labels\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"run_id\": {\n      \"type\": \"number\"\n    },\n    \"run_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"started_at\": {\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"queued\",\n        \"in_progress\",\n        \"completed\"\n      ]\n    },\n    \"steps\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/workflow-step-in_progress\"\n      },\n      \"maxItems\": 1,\n      \"minItems\": 1\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStartedWorkflowJob {
    pub check_run_url: String,
    pub completed_at: (),
    pub conclusion: WorkflowJobStartedWorkflowJobConclusion,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: String,
    pub status: WorkflowJobStartedWorkflowJobStatus,
    pub steps: [WorkflowStepInProgress; 1usize],
    pub url: String,
}
impl From<&WorkflowJobStartedWorkflowJob> for WorkflowJobStartedWorkflowJob {
    fn from(value: &WorkflowJobStartedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowJobStartedWorkflowJobConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"null\",\n  \"enum\": [\n    null\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Serialize)]
pub struct WorkflowJobStartedWorkflowJobConclusion(());
impl std::ops::Deref for WorkflowJobStartedWorkflowJobConclusion {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl From<WorkflowJobStartedWorkflowJobConclusion> for () {
    fn from(value: WorkflowJobStartedWorkflowJobConclusion) -> Self {
        value.0
    }
}
impl From<&WorkflowJobStartedWorkflowJobConclusion> for WorkflowJobStartedWorkflowJobConclusion {
    fn from(value: &WorkflowJobStartedWorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<()> for WorkflowJobStartedWorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: ()) -> Result<Self, &'static str> {
        if ![()].contains(&value) {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for WorkflowJobStartedWorkflowJobConclusion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "WorkflowJobStartedWorkflowJobStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStartedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobStartedWorkflowJobStatus> for WorkflowJobStartedWorkflowJobStatus {
    fn from(value: &WorkflowJobStartedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobStartedWorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStartedWorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStartedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStartedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobStartedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowJobStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"queued\",\n    \"in_progress\",\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobStatus> for WorkflowJobStatus {
    fn from(value: &WorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRun"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow Run\",\n  \"type\": \"object\",\n  \"required\": [\n    \"artifacts_url\",\n    \"cancel_url\",\n    \"check_suite_id\",\n    \"check_suite_node_id\",\n    \"check_suite_url\",\n    \"conclusion\",\n    \"created_at\",\n    \"event\",\n    \"head_branch\",\n    \"head_commit\",\n    \"head_repository\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"jobs_url\",\n    \"logs_url\",\n    \"name\",\n    \"node_id\",\n    \"pull_requests\",\n    \"repository\",\n    \"rerun_url\",\n    \"run_number\",\n    \"status\",\n    \"updated_at\",\n    \"url\",\n    \"workflow_id\",\n    \"workflow_url\"\n  ],\n  \"properties\": {\n    \"artifacts_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"cancel_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"check_suite_id\": {\n      \"type\": \"integer\"\n    },\n    \"check_suite_node_id\": {\n      \"type\": \"string\"\n    },\n    \"check_suite_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"conclusion\": {\n      \"type\": [\n        \"string\",\n        \"null\"\n      ],\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\",\n        null\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"event\": {\n      \"type\": \"string\"\n    },\n    \"head_branch\": {\n      \"type\": \"string\"\n    },\n    \"head_commit\": {\n      \"$ref\": \"#/definitions/commit-simple\"\n    },\n    \"head_repository\": {\n      \"$ref\": \"#/definitions/repository-lite\"\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"jobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"logs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"base\",\n          \"head\",\n          \"id\",\n          \"number\",\n          \"url\"\n        ],\n        \"properties\": {\n          \"base\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ref\",\n              \"repo\",\n              \"sha\"\n            ],\n            \"properties\": {\n              \"ref\": {\n                \"type\": \"string\"\n              },\n              \"repo\": {\n                \"$ref\": \"#/definitions/repo-ref\"\n              },\n              \"sha\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"head\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ref\",\n              \"repo\",\n              \"sha\"\n            ],\n            \"properties\": {\n              \"ref\": {\n                \"type\": \"string\"\n              },\n              \"repo\": {\n                \"$ref\": \"#/definitions/repo-ref\"\n              },\n              \"sha\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"id\": {\n            \"type\": \"number\"\n          },\n          \"number\": {\n            \"type\": \"number\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository-lite\"\n    },\n    \"rerun_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"run_number\": {\n      \"type\": \"integer\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"requested\",\n        \"in_progress\",\n        \"completed\",\n        \"queued\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"workflow_id\": {\n      \"type\": \"integer\"\n    },\n    \"workflow_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRun {
    pub artifacts_url: String,
    pub cancel_url: String,
    pub check_suite_id: i64,
    pub check_suite_node_id: String,
    pub check_suite_url: String,
    pub conclusion: Option<WorkflowRunConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub event: String,
    pub head_branch: String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub jobs_url: String,
    pub logs_url: String,
    pub name: String,
    pub node_id: String,
    pub pull_requests: Vec<WorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: String,
    pub run_number: i64,
    pub status: WorkflowRunStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub workflow_id: i64,
    pub workflow_url: String,
}
impl From<&WorkflowRun> for WorkflowRun {
    fn from(value: &WorkflowRun) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_run completed event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"workflow\",\n    \"workflow_run\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow\": {\n      \"$ref\": \"#/definitions/workflow\"\n    },\n    \"workflow_run\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/workflow-run\"\n        },\n        {\n          \"type\": \"object\",\n          \"required\": [\n            \"conclusion\"\n          ],\n          \"properties\": {\n            \"conclusion\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"success\",\n                \"failure\",\n                \"neutral\",\n                \"cancelled\",\n                \"timed_out\",\n                \"action_required\",\n                \"stale\"\n              ]\n            }\n          },\n          \"tsAdditionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompleted {
    pub action: WorkflowRunCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRunCompletedWorkflowRun,
}
impl From<&WorkflowRunCompleted> for WorkflowRunCompleted {
    fn from(value: &WorkflowRunCompleted) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompletedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowRunCompletedAction> for WorkflowRunCompletedAction {
    fn from(value: &WorkflowRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRun"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"artifacts_url\",\n    \"cancel_url\",\n    \"check_suite_id\",\n    \"check_suite_node_id\",\n    \"check_suite_url\",\n    \"conclusion\",\n    \"created_at\",\n    \"event\",\n    \"head_branch\",\n    \"head_commit\",\n    \"head_repository\",\n    \"head_sha\",\n    \"html_url\",\n    \"id\",\n    \"jobs_url\",\n    \"logs_url\",\n    \"name\",\n    \"node_id\",\n    \"pull_requests\",\n    \"repository\",\n    \"rerun_url\",\n    \"run_number\",\n    \"status\",\n    \"updated_at\",\n    \"url\",\n    \"workflow_id\",\n    \"workflow_url\"\n  ],\n  \"properties\": {\n    \"artifacts_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"cancel_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"check_suite_id\": {\n      \"type\": \"integer\"\n    },\n    \"check_suite_node_id\": {\n      \"type\": \"string\"\n    },\n    \"check_suite_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"conclusion\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"success\",\n        \"failure\",\n        \"neutral\",\n        \"cancelled\",\n        \"timed_out\",\n        \"action_required\",\n        \"stale\"\n      ]\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"event\": {\n      \"type\": \"string\"\n    },\n    \"head_branch\": {\n      \"type\": \"string\"\n    },\n    \"head_commit\": {\n      \"$ref\": \"#/definitions/commit-simple\"\n    },\n    \"head_repository\": {\n      \"$ref\": \"#/definitions/repository-lite\"\n    },\n    \"head_sha\": {\n      \"type\": \"string\"\n    },\n    \"html_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"jobs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"logs_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"node_id\": {\n      \"type\": \"string\"\n    },\n    \"pull_requests\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"base\",\n          \"head\",\n          \"id\",\n          \"number\",\n          \"url\"\n        ],\n        \"properties\": {\n          \"base\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ref\",\n              \"repo\",\n              \"sha\"\n            ],\n            \"properties\": {\n              \"ref\": {\n                \"type\": \"string\"\n              },\n              \"repo\": {\n                \"$ref\": \"#/definitions/repo-ref\"\n              },\n              \"sha\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"head\": {\n            \"type\": \"object\",\n            \"required\": [\n              \"ref\",\n              \"repo\",\n              \"sha\"\n            ],\n            \"properties\": {\n              \"ref\": {\n                \"type\": \"string\"\n              },\n              \"repo\": {\n                \"$ref\": \"#/definitions/repo-ref\"\n              },\n              \"sha\": {\n                \"type\": \"string\"\n              }\n            },\n            \"additionalProperties\": false\n          },\n          \"id\": {\n            \"type\": \"number\"\n          },\n          \"number\": {\n            \"type\": \"number\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"additionalProperties\": false\n      }\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository-lite\"\n    },\n    \"rerun_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"run_number\": {\n      \"type\": \"integer\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"requested\",\n        \"in_progress\",\n        \"completed\",\n        \"queued\"\n      ]\n    },\n    \"updated_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"workflow_id\": {\n      \"type\": \"integer\"\n    },\n    \"workflow_url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRun {
    pub artifacts_url: String,
    pub cancel_url: String,
    pub check_suite_id: i64,
    pub check_suite_node_id: String,
    pub check_suite_url: String,
    pub conclusion: WorkflowRunCompletedWorkflowRunConclusion,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub event: String,
    pub head_branch: String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub jobs_url: String,
    pub logs_url: String,
    pub name: String,
    pub node_id: String,
    pub pull_requests: Vec<WorkflowRunCompletedWorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: String,
    pub run_number: i64,
    pub status: WorkflowRunCompletedWorkflowRunStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub workflow_id: i64,
    pub workflow_url: String,
}
impl From<&WorkflowRunCompletedWorkflowRun> for WorkflowRunCompletedWorkflowRun {
    fn from(value: &WorkflowRunCompletedWorkflowRun) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRunConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunCompletedWorkflowRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&WorkflowRunCompletedWorkflowRunConclusion>
    for WorkflowRunCompletedWorkflowRunConclusion
{
    fn from(value: &WorkflowRunCompletedWorkflowRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunCompletedWorkflowRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunCompletedWorkflowRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRunPullRequestsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"base\",\n    \"head\",\n    \"id\",\n    \"number\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"id\": {\n      \"type\": \"number\"\n    },\n    \"number\": {\n      \"type\": \"number\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItem {
    pub base: WorkflowRunCompletedWorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunCompletedWorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: String,
}
impl From<&WorkflowRunCompletedWorkflowRunPullRequestsItem>
    for WorkflowRunCompletedWorkflowRunPullRequestsItem
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItem) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRunPullRequestsItemBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunCompletedWorkflowRunPullRequestsItemBase>
    for WorkflowRunCompletedWorkflowRunPullRequestsItemBase
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItemBase) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRunPullRequestsItemHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunCompletedWorkflowRunPullRequestsItemHead>
    for WorkflowRunCompletedWorkflowRunPullRequestsItemHead
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItemHead) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunCompletedWorkflowRunStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\",\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunCompletedWorkflowRunStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowRunCompletedWorkflowRunStatus> for WorkflowRunCompletedWorkflowRunStatus {
    fn from(value: &WorkflowRunCompletedWorkflowRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunCompletedWorkflowRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunCompletedWorkflowRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRunConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"success\",\n    \"failure\",\n    \"neutral\",\n    \"cancelled\",\n    \"timed_out\",\n    \"action_required\",\n    \"stale\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&WorkflowRunConclusion> for WorkflowRunConclusion {
    fn from(value: &WorkflowRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRunEvent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/workflow_run$completed\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow_run$requested\"\n    }\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowRunEvent {
    Completed(WorkflowRunCompleted),
    Requested(WorkflowRunRequested),
}
impl From<&WorkflowRunEvent> for WorkflowRunEvent {
    fn from(value: &WorkflowRunEvent) -> Self {
        value.clone()
    }
}
impl From<WorkflowRunCompleted> for WorkflowRunEvent {
    fn from(value: WorkflowRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<WorkflowRunRequested> for WorkflowRunEvent {
    fn from(value: WorkflowRunRequested) -> Self {
        Self::Requested(value)
    }
}
#[doc = "WorkflowRunPullRequestsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"base\",\n    \"head\",\n    \"id\",\n    \"number\",\n    \"url\"\n  ],\n  \"properties\": {\n    \"base\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"head\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"ref\",\n        \"repo\",\n        \"sha\"\n      ],\n      \"properties\": {\n        \"ref\": {\n          \"type\": \"string\"\n        },\n        \"repo\": {\n          \"$ref\": \"#/definitions/repo-ref\"\n        },\n        \"sha\": {\n          \"type\": \"string\"\n        }\n      },\n      \"additionalProperties\": false\n    },\n    \"id\": {\n      \"type\": \"number\"\n    },\n    \"number\": {\n      \"type\": \"number\"\n    },\n    \"url\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItem {
    pub base: WorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: String,
}
impl From<&WorkflowRunPullRequestsItem> for WorkflowRunPullRequestsItem {
    fn from(value: &WorkflowRunPullRequestsItem) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunPullRequestsItemBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunPullRequestsItemBase> for WorkflowRunPullRequestsItemBase {
    fn from(value: &WorkflowRunPullRequestsItemBase) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunPullRequestsItemHead"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"object\",\n  \"required\": [\n    \"ref\",\n    \"repo\",\n    \"sha\"\n  ],\n  \"properties\": {\n    \"ref\": {\n      \"type\": \"string\"\n    },\n    \"repo\": {\n      \"$ref\": \"#/definitions/repo-ref\"\n    },\n    \"sha\": {\n      \"type\": \"string\"\n    }\n  },\n  \"additionalProperties\": false\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunPullRequestsItemHead> for WorkflowRunPullRequestsItemHead {
    fn from(value: &WorkflowRunPullRequestsItemHead) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunRequested"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"workflow_run requested event\",\n  \"type\": \"object\",\n  \"required\": [\n    \"action\",\n    \"repository\",\n    \"sender\",\n    \"workflow\",\n    \"workflow_run\"\n  ],\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"requested\"\n      ]\n    },\n    \"installation\": {\n      \"$ref\": \"#/definitions/installation-lite\"\n    },\n    \"organization\": {\n      \"$ref\": \"#/definitions/organization\"\n    },\n    \"repository\": {\n      \"$ref\": \"#/definitions/repository\"\n    },\n    \"sender\": {\n      \"$ref\": \"#/definitions/user\"\n    },\n    \"workflow\": {\n      \"$ref\": \"#/definitions/workflow\"\n    },\n    \"workflow_run\": {\n      \"$ref\": \"#/definitions/workflow-run\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunRequested {
    pub action: WorkflowRunRequestedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunRequested> for WorkflowRunRequested {
    fn from(value: &WorkflowRunRequested) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowRunRequestedAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl From<&WorkflowRunRequestedAction> for WorkflowRunRequestedAction {
    fn from(value: &WorkflowRunRequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowRunStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"requested\",\n    \"in_progress\",\n    \"completed\",\n    \"queued\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowRunStatus> for WorkflowRunStatus {
    fn from(value: &WorkflowRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow Step\",\n  \"type\": \"object\",\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/workflow-step-in_progress\"\n    },\n    {\n      \"$ref\": \"#/definitions/workflow-step-completed\"\n    }\n  ],\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowStep {
    InProgress(WorkflowStepInProgress),
    Completed(WorkflowStepCompleted),
}
impl From<&WorkflowStep> for WorkflowStep {
    fn from(value: &WorkflowStep) -> Self {
        value.clone()
    }
}
impl From<WorkflowStepInProgress> for WorkflowStep {
    fn from(value: WorkflowStepInProgress) -> Self {
        Self::InProgress(value)
    }
}
impl From<WorkflowStepCompleted> for WorkflowStep {
    fn from(value: WorkflowStepCompleted) -> Self {
        Self::Completed(value)
    }
}
#[doc = "WorkflowStepCompleted"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow Step (Completed)\",\n  \"type\": \"object\",\n  \"required\": [\n    \"completed_at\",\n    \"conclusion\",\n    \"name\",\n    \"number\",\n    \"started_at\",\n    \"status\"\n  ],\n  \"properties\": {\n    \"completed_at\": {\n      \"type\": \"string\"\n    },\n    \"conclusion\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"failure\",\n        \"skipped\",\n        \"success\"\n      ]\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"started_at\": {\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"completed\"\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepCompleted {
    pub completed_at: String,
    pub conclusion: WorkflowStepCompletedConclusion,
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepCompletedStatus,
}
impl From<&WorkflowStepCompleted> for WorkflowStepCompleted {
    fn from(value: &WorkflowStepCompleted) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowStepCompletedConclusion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"failure\",\n    \"skipped\",\n    \"success\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedConclusion {
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "skipped")]
    Skipped,
    #[serde(rename = "success")]
    Success,
}
impl From<&WorkflowStepCompletedConclusion> for WorkflowStepCompletedConclusion {
    fn from(value: &WorkflowStepCompletedConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepCompletedConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Failure => "failure".to_string(),
            Self::Skipped => "skipped".to_string(),
            Self::Success => "success".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "failure" => Ok(Self::Failure),
            "skipped" => Ok(Self::Skipped),
            "success" => Ok(Self::Success),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowStepCompletedStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"completed\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowStepCompletedStatus> for WorkflowStepCompletedStatus {
    fn from(value: &WorkflowStepCompletedStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepCompletedStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "WorkflowStepInProgress"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"title\": \"Workflow Step (In Progress)\",\n  \"type\": \"object\",\n  \"required\": [\n    \"completed_at\",\n    \"conclusion\",\n    \"name\",\n    \"number\",\n    \"started_at\",\n    \"status\"\n  ],\n  \"properties\": {\n    \"completed_at\": {\n      \"type\": \"null\"\n    },\n    \"conclusion\": {\n      \"type\": \"null\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"number\": {\n      \"type\": \"integer\"\n    },\n    \"started_at\": {\n      \"type\": \"string\"\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"in_progress\"\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"$schema\": \"http://json-schema.org/draft-07/schema\"\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepInProgress {
    pub completed_at: (),
    pub conclusion: (),
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepInProgressStatus,
}
impl From<&WorkflowStepInProgress> for WorkflowStepInProgress {
    fn from(value: &WorkflowStepInProgress) -> Self {
        value.clone()
    }
}
#[doc = "WorkflowStepInProgressStatus"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{\n  \"type\": \"string\",\n  \"enum\": [\n    \"in_progress\"\n  ]\n}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepInProgressStatus {
    #[serde(rename = "in_progress")]
    InProgress,
}
impl From<&WorkflowStepInProgressStatus> for WorkflowStepInProgressStatus {
    fn from(value: &WorkflowStepInProgressStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepInProgressStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepInProgressStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
}
