#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstance {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<AlertInstanceLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AlertInstanceMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "State of a code scanning alert."]
    pub state: AlertInstanceState,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AlertInstanceState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ToString for AlertInstanceState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for AlertInstanceState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct App {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    #[doc = "The list of events for the GitHub app"]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<AppEventsItem>,
    pub external_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The name of the GitHub app"]
    pub name: String,
    pub node_id: String,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slug: Option<String>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppEventsItem {
    #[educe(Default)]
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ToString for AppEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for AppEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The set of permissions for the GitHub app"]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AppPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<AppPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<AppPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<AppPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<AppPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<AppPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<AppPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<AppPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<AppPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<AppPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<AppPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<AppPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<AppPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<AppPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<AppPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<AppPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<AppPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<AppPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<AppPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners: Option<AppPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<AppPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<AppPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<AppPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<AppPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<AppPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<AppPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<AppPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<AppPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<AppPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<AppPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<AppPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<AppPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<AppPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<AppPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<AppPermissionsWorkflows>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsActions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsAdministration {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsChecks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsContentReferences {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsContents {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsDeployments {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsDiscussions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsEmails {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsEnvironments {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsIssues {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsMembers {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsMetadata {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationAdministration {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationHooks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationPackages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationPlan {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationProjects {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationSecrets {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationSelfHostedRunners {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsOrganizationUserBlocking {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsPackages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsPages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsPullRequests {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsRepositoryHooks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsRepositoryProjects {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsSecretScanningAlerts {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsSecrets {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsSecurityEvents {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsSecurityScanningAlert {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsSingleFile {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsStatuses {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsTeamDiscussions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsVulnerabilityAlerts {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AppPermissionsWorkflows {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for AppPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "How the author is associated with the repository."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AuthorAssociation {
    #[educe(Default)]
    #[serde(rename = "COLLABORATOR")]
    Collaborator,
    #[serde(rename = "CONTRIBUTOR")]
    Contributor,
    #[serde(rename = "FIRST_TIMER")]
    FirstTimer,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    FirstTimeContributor,
    #[serde(rename = "MANNEQUIN")]
    Mannequin,
    #[serde(rename = "MEMBER")]
    Member,
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OWNER")]
    Owner,
}
impl ToString for AuthorAssociation {
    fn to_string(&self) -> String {
        match *self {
            Self::Collaborator => "COLLABORATOR".to_string(),
            Self::Contributor => "CONTRIBUTOR".to_string(),
            Self::FirstTimer => "FIRST_TIMER".to_string(),
            Self::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR".to_string(),
            Self::Mannequin => "MANNEQUIN".to_string(),
            Self::Member => "MEMBER".to_string(),
            Self::None => "NONE".to_string(),
            Self::Owner => "OWNER".to_string(),
        }
    }
}
impl std::str::FromStr for AuthorAssociation {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "COLLABORATOR" => Ok(Self::Collaborator),
            "CONTRIBUTOR" => Ok(Self::Contributor),
            "FIRST_TIMER" => Ok(Self::FirstTimer),
            "FIRST_TIME_CONTRIBUTOR" => Ok(Self::FirstTimeContributor),
            "MANNEQUIN" => Ok(Self::Mannequin),
            "MEMBER" => Ok(Self::Member),
            "NONE" => Ok(Self::None),
            "OWNER" => Ok(Self::Owner),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRule {
    pub admin_enforced: bool,
    pub allow_deletions_enforcement_level: BranchProtectionRuleAllowDeletionsEnforcementLevel,
    pub allow_force_pushes_enforcement_level: BranchProtectionRuleAllowForcePushesEnforcementLevel,
    pub authorized_actor_names: Vec<String>,
    pub authorized_actors_only: bool,
    pub authorized_dismissal_actors_only: bool,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismiss_stale_reviews_on_push: bool,
    pub id: i64,
    pub ignore_approvals_from_contributors: bool,
    pub linear_history_requirement_enforcement_level:
        BranchProtectionRuleLinearHistoryRequirementEnforcementLevel,
    pub merge_queue_enforcement_level: BranchProtectionRuleMergeQueueEnforcementLevel,
    pub name: String,
    pub pull_request_reviews_enforcement_level:
        BranchProtectionRulePullRequestReviewsEnforcementLevel,
    pub repository_id: i64,
    pub require_code_owner_review: bool,
    pub required_approving_review_count: i64,
    pub required_conversation_resolution_level:
        BranchProtectionRuleRequiredConversationResolutionLevel,
    pub required_deployments_enforcement_level:
        BranchProtectionRuleRequiredDeploymentsEnforcementLevel,
    pub required_status_checks: Vec<String>,
    pub required_status_checks_enforcement_level:
        BranchProtectionRuleRequiredStatusChecksEnforcementLevel,
    pub signature_requirement_enforcement_level:
        BranchProtectionRuleSignatureRequirementEnforcementLevel,
    pub strict_required_status_checks_policy: bool,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleAllowDeletionsEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleAllowForcePushesEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleCreated {
    pub action: BranchProtectionRuleCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for BranchProtectionRuleCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleDeleted {
    pub action: BranchProtectionRuleDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for BranchProtectionRuleDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEdited {
    pub action: BranchProtectionRuleEditedAction,
    pub changes: BranchProtectionRuleEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for BranchProtectionRuleEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "If the action was `edited`, the changes to the rule."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actor_names: Option<BranchProtectionRuleEditedChangesAuthorizedActorNames>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actors_only: Option<BranchProtectionRuleEditedChangesAuthorizedActorsOnly>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorNames {
    pub from: Vec<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorsOnly {
    pub from: bool,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum BranchProtectionRuleEvent {
    #[educe(Default)]
    #[doc = "branch protection rule created event\n\nActivity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        rule: BranchProtectionRule,
        sender: User,
    },
    #[doc = "branch protection rule deleted event\n\nActivity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        rule: BranchProtectionRule,
        sender: User,
    },
    #[doc = "branch protection rule edited event\n\nActivity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
    #[serde(rename = "edited")]
    Edited {
        changes: BranchProtectionRuleEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        rule: BranchProtectionRule,
        sender: User,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleMergeQueueEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleMergeQueueEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRulePullRequestReviewsEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleRequiredConversationResolutionLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleRequiredConversationResolutionLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BranchProtectionRuleSignatureRequirementEnforcementLevel {
    #[educe(Default)]
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ToString for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompleted {
    pub action: CheckRunCompletedAction,
    pub check_run: CheckRunCompletedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCompletedRequestedAction>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCompletedAction {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCompletedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCompletedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCompletedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCompletedCheckRunStatus,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCompletedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCompletedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCompletedCheckRunCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCompletedCheckRunCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCompletedCheckRunConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ToString for CheckRunCompletedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCompletedCheckRunStatus {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunCompletedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreated {
    pub action: CheckRunCreatedAction,
    pub check_run: CheckRunCreatedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCreatedRequestedAction>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for CheckRunCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCreatedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCreatedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCreatedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCreatedCheckRunStatus,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCreatedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCreatedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCreatedCheckRunCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCreatedCheckRunCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCreatedCheckRunConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ToString for CheckRunCreatedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunCreatedCheckRunStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunCreatedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
#[doc = "A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunDeployment {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub repository_url: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum CheckRunEvent {
    #[educe(Default)]
    #[doc = "check_run completed event"]
    #[serde(rename = "completed")]
    Completed {
        check_run: CheckRunCompletedCheckRun,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        #[doc = "The action requested by the user."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        requested_action: Option<CheckRunCompletedRequestedAction>,
        sender: User,
    },
    #[doc = "check_run created event"]
    #[serde(rename = "created")]
    Created {
        check_run: CheckRunCreatedCheckRun,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        #[doc = "The action requested by the user."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        requested_action: Option<CheckRunCreatedRequestedAction>,
        sender: User,
    },
    #[doc = "check_run requested_action event"]
    #[serde(rename = "requested_action")]
    RequestedAction {
        check_run: CheckRunRequestedActionCheckRun,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        requested_action: CheckRunRequestedActionRequestedAction,
        sender: User,
    },
    #[doc = "check_run rerequested event"]
    #[serde(rename = "rerequested")]
    Rerequested {
        check_run: CheckRunRerequestedCheckRun,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        #[doc = "The action requested by the user."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        requested_action: Option<CheckRunRerequestedRequestedAction>,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequest {
    pub base: CheckRunPullRequestBase,
    pub head: CheckRunPullRequestHead,
    pub id: i64,
    pub number: i64,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedAction {
    pub action: CheckRunRequestedActionAction,
    pub check_run: CheckRunRequestedActionCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub requested_action: CheckRunRequestedActionRequestedAction,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRequestedActionAction {
    #[educe(Default)]
    #[serde(rename = "requested_action")]
    RequestedAction,
}
impl ToString for CheckRunRequestedActionAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RequestedAction => "requested_action".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested_action" => Ok(Self::RequestedAction),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRun {
    pub app: App,
    pub check_suite: CheckRunRequestedActionCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunRequestedActionCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRequestedActionCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunRequestedActionCheckRunStatus,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunRequestedActionCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRequestedActionCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRequestedActionCheckRunConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ToString for CheckRunRequestedActionCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRequestedActionCheckRunStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunRequestedActionCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequested {
    pub action: CheckRunRerequestedAction,
    pub check_run: CheckRunRerequestedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunRerequestedRequestedAction>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRerequestedAction {
    #[educe(Default)]
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl ToString for CheckRunRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRun {
    pub app: App,
    pub check_suite: CheckRunRerequestedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckRunRerequestedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRerequestedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: CheckRunRerequestedCheckRunStatus,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: CheckRunRerequestedCheckRunCheckSuiteConclusion,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRerequestedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRerequestedCheckRunCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRerequestedCheckRunCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRerequestedCheckRunConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ToString for CheckRunRerequestedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
#[doc = "The phase of the lifecycle that the check is currently in."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckRunRerequestedCheckRunStatus {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckRunRerequestedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompleted {
    pub action: CheckSuiteCompletedAction,
    pub check_suite: CheckSuiteCompletedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteCompletedAction {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for CheckSuiteCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompletedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckSuiteCompletedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteCompletedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteCompletedCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckSuiteCompletedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteCompletedCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for CheckSuiteCompletedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum CheckSuiteEvent {
    #[educe(Default)]
    #[doc = "check_suite completed event"]
    #[serde(rename = "completed")]
    Completed {
        check_suite: CheckSuiteCompletedCheckSuite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "check_suite requested event"]
    #[serde(rename = "requested")]
    Requested {
        check_suite: CheckSuiteRequestedCheckSuite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "check_suite rerequested event"]
    #[serde(rename = "rerequested")]
    Rerequested {
        check_suite: CheckSuiteRerequestedCheckSuite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequested {
    pub action: CheckSuiteRequestedAction,
    pub check_suite: CheckSuiteRequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRequestedAction {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
}
impl ToString for CheckSuiteRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRequestedCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckSuiteRequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRequestedCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for CheckSuiteRequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequested {
    pub action: CheckSuiteRerequestedAction,
    pub check_suite: CheckSuiteRerequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRerequestedAction {
    #[educe(Default)]
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl ToString for CheckSuiteRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRerequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRerequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRerequestedCheckSuiteConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for CheckSuiteRerequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CheckSuiteRerequestedCheckSuiteStatus {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for CheckSuiteRerequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranch {
    pub action: CodeScanningAlertAppearedInBranchAction,
    pub alert: CodeScanningAlertAppearedInBranchAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertAppearedInBranchAction {
    #[educe(Default)]
    #[serde(rename = "appeared_in_branch")]
    AppearedInBranch,
}
impl ToString for CodeScanningAlertAppearedInBranchAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AppearedInBranch => "appeared_in_branch".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "appeared_in_branch" => Ok(Self::AppearedInBranch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertAppearedInBranchAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertAppearedInBranchAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertAppearedInBranchAlertState,
    pub tool: CodeScanningAlertAppearedInBranchAlertTool,
    pub url: String,
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertAppearedInBranchAlertDismissedReason {
    #[educe(Default)]
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ToString for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertAppearedInBranchAlertRuleSeverity>,
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertAppearedInBranchAlertState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ToString for CodeScanningAlertAppearedInBranchAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUser {
    pub action: CodeScanningAlertClosedByUserAction,
    pub alert: CodeScanningAlertClosedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertClosedByUserAction {
    #[educe(Default)]
    #[serde(rename = "closed_by_user")]
    ClosedByUser,
}
impl ToString for CodeScanningAlertClosedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ClosedByUser => "closed_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed_by_user" => Ok(Self::ClosedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismissed_by: User,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertClosedByUserAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertClosedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertClosedByUserAlertState,
    pub tool: CodeScanningAlertClosedByUserAlertTool,
    pub url: String,
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertClosedByUserAlertDismissedReason {
    #[educe(Default)]
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ToString for CodeScanningAlertClosedByUserAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertClosedByUserAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertClosedByUserAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertClosedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertClosedByUserAlertState {
    #[educe(Default)]
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ToString for CodeScanningAlertClosedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreated {
    pub action: CodeScanningAlertCreatedAction,
    pub alert: CodeScanningAlertCreatedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for CodeScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertCreatedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertCreatedAlertState,
    pub tool: CodeScanningAlertCreatedAlertTool,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertCreatedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertCreatedAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertCreatedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertCreatedAlertState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ToString for CodeScanningAlertCreatedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum CodeScanningAlertEvent {
    #[educe(Default)]
    #[doc = "code_scanning_alert appeared_in_branch event"]
    #[serde(rename = "appeared_in_branch")]
    AppearedInBranch {
        alert: CodeScanningAlertAppearedInBranchAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: GithubOrg,
    },
    #[doc = "code_scanning_alert closed_by_user event"]
    #[serde(rename = "closed_by_user")]
    ClosedByUser {
        alert: CodeScanningAlertClosedByUserAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: User,
    },
    #[doc = "code_scanning_alert created event"]
    #[serde(rename = "created")]
    Created {
        alert: CodeScanningAlertCreatedAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: GithubOrg,
    },
    #[doc = "code_scanning_alert fixed event"]
    #[serde(rename = "fixed")]
    Fixed {
        alert: CodeScanningAlertFixedAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: GithubOrg,
    },
    #[doc = "code_scanning_alert reopened event"]
    #[serde(rename = "reopened")]
    Reopened {
        alert: CodeScanningAlertReopenedAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: GithubOrg,
    },
    #[doc = "code_scanning_alert reopened_by_user event"]
    #[serde(rename = "reopened_by_user")]
    ReopenedByUser {
        alert: CodeScanningAlertReopenedByUserAlert,
        #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        commit_oid: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
        #[serde(rename = "ref")]
        ref_: String,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixed {
    pub action: CodeScanningAlertFixedAction,
    pub alert: CodeScanningAlertFixedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertFixedAction {
    #[educe(Default)]
    #[serde(rename = "fixed")]
    Fixed,
}
impl ToString for CodeScanningAlertFixedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertFixedAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertFixedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertFixedAlertState,
    pub tool: CodeScanningAlertFixedAlertTool,
    pub url: String,
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertFixedAlertDismissedReason {
    #[educe(Default)]
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ToString for CodeScanningAlertFixedAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertFixedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertFixedAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertFixedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertFixedAlertState {
    #[educe(Default)]
    #[serde(rename = "fixed")]
    Fixed,
}
impl ToString for CodeScanningAlertFixedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopened {
    pub action: CodeScanningAlertReopenedAction,
    pub alert: CodeScanningAlertReopenedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedAction {
    #[educe(Default)]
    #[serde(rename = "reopened")]
    Reopened,
}
impl ToString for CodeScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedAlertState,
    pub tool: CodeScanningAlertReopenedAlertTool,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertReopenedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedAlertState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ToString for CodeScanningAlertReopenedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUser {
    pub action: CodeScanningAlertReopenedByUserAction,
    pub alert: CodeScanningAlertReopenedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedByUserAction {
    #[educe(Default)]
    #[serde(rename = "reopened_by_user")]
    ReopenedByUser,
}
impl ToString for CodeScanningAlertReopenedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReopenedByUser => "reopened_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened_by_user" => Ok(Self::ReopenedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedByUserAlertState,
    pub tool: CodeScanningAlertReopenedByUserAlertTool,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedByUserAlertRuleSeverity>,
}
#[doc = "The severity of the alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedByUserAlertRuleSeverity {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ToString for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CodeScanningAlertReopenedByUserAlertState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
}
impl ToString for CodeScanningAlertReopenedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Commit {
    #[doc = "An array of files added in the commit."]
    pub added: Vec<String>,
    pub author: Committer,
    pub committer: Committer,
    #[doc = "Whether this commit is distinct from any that have been pushed before."]
    pub distinct: bool,
    pub id: String,
    #[doc = "The commit message."]
    pub message: String,
    #[doc = "An array of files modified by the commit."]
    pub modified: Vec<String>,
    #[doc = "An array of files removed in the commit."]
    pub removed: Vec<String>,
    #[doc = "The ISO 8601 timestamp of the commit."]
    pub timestamp: String,
    pub tree_id: String,
    #[doc = "URL that points to the commit API resource."]
    pub url: String,
}
#[doc = "A commit comment is created. The type of activity is specified in the `action` property. "]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreated {
    #[doc = "The action performed. Can be `created`."]
    pub action: CommitCommentCreatedAction,
    pub comment: CommitCommentCreatedComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The action performed. Can be `created`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CommitCommentCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for CommitCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CommitCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreatedComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: String,
    pub html_url: String,
    #[doc = "The ID of the commit comment."]
    pub id: i64,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[doc = "The node ID of the commit comment."]
    pub node_id: String,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: Option<String>,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum CommitCommentEvent {
    #[educe(Default)]
    #[doc = "commit_comment created event\n\nA commit comment is created. The type of activity is specified in the `action` property. "]
    #[serde(rename = "created")]
    Created {
        comment: CommitCommentCreatedComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitSimple {
    pub author: Committer,
    pub committer: Committer,
    pub id: String,
    pub message: String,
    pub timestamp: String,
    pub tree_id: String,
}
#[doc = "Metaproperties for Git author/committer information."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Committer {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The git author's email address."]
    pub email: Option<String>,
    #[doc = "The git author's name."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreated {
    pub action: ContentReferenceCreatedAction,
    pub content_reference: ContentReferenceCreatedContentReference,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ContentReferenceCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for ContentReferenceCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ContentReferenceCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreatedContentReference {
    pub id: i64,
    pub node_id: String,
    pub reference: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum ContentReferenceEvent {
    #[educe(Default)]
    #[doc = "content_reference created event"]
    #[serde(rename = "created")]
    Created {
        content_reference: ContentReferenceCreatedContentReference,
        installation: InstallationLite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[doc = "A Git branch or tag is created."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CreateEvent {
    #[doc = "The repository's current description."]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The name of the repository's default branch (usually `main`)."]
    pub master_branch: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
    pub ref_type: CreateEventRefType,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CreateEventRefType {
    #[educe(Default)]
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl ToString for CreateEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for CreateEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "A Git branch or tag is deleted."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeleteEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
    pub ref_type: DeleteEventRefType,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DeleteEventRefType {
    #[educe(Default)]
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl ToString for DeleteEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for DeleteEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreated {
    pub action: DeployKeyCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyCreatedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DeployKeyCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for DeployKeyCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreatedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeleted {
    pub action: DeployKeyDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyDeletedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DeployKeyDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for DeployKeyDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeletedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum DeployKeyEvent {
    #[educe(Default)]
    #[doc = "deploy_key created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        key: DeployKeyCreatedKey,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "deploy_key deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        key: DeployKeyDeletedKey,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreated {
    pub action: DeploymentCreatedAction,
    pub deployment: DeploymentCreatedDeployment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: (),
    pub workflow_run: (),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DeploymentCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for DeploymentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentCreatedDeploymentPayload,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeploymentPayload {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum DeploymentEvent {
    #[educe(Default)]
    #[doc = "deployment created event"]
    #[serde(rename = "created")]
    Created {
        deployment: DeploymentCreatedDeployment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow: (),
        workflow_run: (),
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreated {
    pub action: DeploymentStatusCreatedAction,
    pub deployment: DeploymentStatusCreatedDeployment,
    pub deployment_status: DeploymentStatusCreatedDeploymentStatus,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DeploymentStatusCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for DeploymentStatusCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentStatusCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentStatusCreatedDeploymentPayload,
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentPayload {}
#[doc = "The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentStatus {
    pub created_at: String,
    pub creator: User,
    pub deployment_url: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: String,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    pub repository_url: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: String,
    #[doc = "The optional link added to the status."]
    pub target_url: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum DeploymentStatusEvent {
    #[educe(Default)]
    #[doc = "deployment_status created event"]
    #[serde(rename = "created")]
    Created {
        deployment: DeploymentStatusCreatedDeployment,
        deployment_status: DeploymentStatusCreatedDeploymentStatus,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Discussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: Option<String>,
    pub answer_chosen_by: Option<User>,
    pub answer_html_url: Option<String>,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnswered {
    pub action: DiscussionAnsweredAction,
    pub answer: DiscussionAnsweredAnswer,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionAnsweredAction {
    #[educe(Default)]
    #[serde(rename = "answered")]
    Answered,
}
impl ToString for DiscussionAnsweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Answered => "answered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionAnsweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "answered" => Ok(Self::Answered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChanged {
    pub action: DiscussionCategoryChangedAction,
    pub changes: DiscussionCategoryChangedChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionCategoryChangedAction {
    #[educe(Default)]
    #[serde(rename = "category_changed")]
    CategoryChanged,
}
impl ToString for DiscussionCategoryChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::CategoryChanged => "category_changed".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCategoryChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "category_changed" => Ok(Self::CategoryChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChanges {
    pub category: DiscussionCategoryChangedChangesCategory,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategory {
    pub from: DiscussionCategoryChangedChangesCategoryFrom,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategoryFrom {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreated {
    pub action: DiscussionCommentCreatedAction,
    pub comment: DiscussionCommentCreatedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionCommentCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for DiscussionCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreatedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeleted {
    pub action: DiscussionCommentDeletedAction,
    pub comment: DiscussionCommentDeletedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionCommentDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for DiscussionCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeletedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEdited {
    pub action: DiscussionCommentEditedAction,
    pub changes: DiscussionCommentEditedChanges,
    pub comment: DiscussionCommentEditedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionCommentEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for DiscussionCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChanges {
    pub body: DiscussionCommentEditedChangesBody,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChangesBody {
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum DiscussionCommentEvent {
    #[educe(Default)]
    #[doc = "discussion_comment created event"]
    #[serde(rename = "created")]
    Created {
        comment: DiscussionCommentCreatedComment,
        discussion: Discussion,
        installation: InstallationLite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion_comment deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        comment: DiscussionCommentDeletedComment,
        discussion: Discussion,
        installation: InstallationLite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion_comment edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: DiscussionCommentEditedChanges,
        comment: DiscussionCommentEditedComment,
        discussion: Discussion,
        installation: InstallationLite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreated {
    pub action: DiscussionCreatedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for DiscussionCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionDeleted {
    pub action: DiscussionDeletedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for DiscussionDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEdited {
    pub action: DiscussionEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<DiscussionEditedChanges>,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for DiscussionEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<DiscussionEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<DiscussionEditedChangesTitle>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesBody {
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesTitle {
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum DiscussionEvent {
    #[educe(Default)]
    #[doc = "discussion answered event"]
    #[serde(rename = "answered")]
    Answered {
        answer: DiscussionAnsweredAnswer,
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion category changed event"]
    #[serde(rename = "category_changed")]
    CategoryChanged {
        changes: DiscussionCategoryChangedChanges,
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion created event"]
    #[serde(rename = "created")]
    Created {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion edited event"]
    #[serde(rename = "edited")]
    Edited {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        changes: Option<DiscussionEditedChanges>,
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion labeled event"]
    #[serde(rename = "labeled")]
    Labeled {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        label: Label,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion locked event"]
    #[serde(rename = "locked")]
    Locked {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion pinned event"]
    #[serde(rename = "pinned")]
    Pinned {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion transferred event"]
    #[serde(rename = "transferred")]
    Transferred {
        changes: DiscussionTransferredChanges,
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion unanswered event"]
    #[serde(rename = "unanswered")]
    Unanswered {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        old_answer: DiscussionUnansweredOldAnswer,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion unlabeled event"]
    #[serde(rename = "unlabeled")]
    Unlabeled {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        label: Label,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion unlocked event"]
    #[serde(rename = "unlocked")]
    Unlocked {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "discussion unpinned event"]
    #[serde(rename = "unpinned")]
    Unpinned {
        discussion: Discussion,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLabeled {
    pub action: DiscussionLabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionLabeledAction {
    #[educe(Default)]
    #[serde(rename = "labeled")]
    Labeled,
}
impl ToString for DiscussionLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLocked {
    pub action: DiscussionLockedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionLockedAction {
    #[educe(Default)]
    #[serde(rename = "locked")]
    Locked,
}
impl ToString for DiscussionLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionPinned {
    pub action: DiscussionPinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionPinnedAction {
    #[educe(Default)]
    #[serde(rename = "pinned")]
    Pinned,
}
impl ToString for DiscussionPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl ToString for DiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Locked => "locked".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferred {
    pub action: DiscussionTransferredAction,
    pub changes: DiscussionTransferredChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionTransferredAction {
    #[educe(Default)]
    #[serde(rename = "transferred")]
    Transferred,
}
impl ToString for DiscussionTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferredChanges {
    pub new_discussion: Discussion,
    pub new_repository: Repository,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnanswered {
    pub action: DiscussionUnansweredAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub old_answer: DiscussionUnansweredOldAnswer,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionUnansweredAction {
    #[educe(Default)]
    #[serde(rename = "unanswered")]
    Unanswered,
}
impl ToString for DiscussionUnansweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unanswered => "unanswered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnansweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unanswered" => Ok(Self::Unanswered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredOldAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlabeled {
    pub action: DiscussionUnlabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionUnlabeledAction {
    #[educe(Default)]
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ToString for DiscussionUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlocked {
    pub action: DiscussionUnlockedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionUnlockedAction {
    #[educe(Default)]
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ToString for DiscussionUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnpinned {
    pub action: DiscussionUnpinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DiscussionUnpinnedAction {
    #[educe(Default)]
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl ToString for DiscussionUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Everything {
    #[educe(Default)]
    BranchProtectionRuleEvent(BranchProtectionRuleEvent),
    CheckRunEvent(CheckRunEvent),
    CheckSuiteEvent(CheckSuiteEvent),
    CodeScanningAlertEvent(CodeScanningAlertEvent),
    CommitCommentEvent(CommitCommentEvent),
    ContentReferenceEvent(ContentReferenceEvent),
    CreateEvent(CreateEvent),
    DeleteEvent(DeleteEvent),
    DeployKeyEvent(DeployKeyEvent),
    DeploymentEvent(DeploymentEvent),
    DeploymentStatusEvent(DeploymentStatusEvent),
    DiscussionEvent(DiscussionEvent),
    DiscussionCommentEvent(DiscussionCommentEvent),
    ForkEvent(ForkEvent),
    GithubAppAuthorizationEvent(GithubAppAuthorizationEvent),
    GollumEvent(GollumEvent),
    InstallationEvent(InstallationEvent),
    InstallationRepositoriesEvent(InstallationRepositoriesEvent),
    IssueCommentEvent(IssueCommentEvent),
    IssuesEvent(IssuesEvent),
    LabelEvent(LabelEvent),
    MarketplacePurchaseEvent(MarketplacePurchaseEvent),
    MemberEvent(MemberEvent),
    MembershipEvent(MembershipEvent),
    MetaEvent(MetaEvent),
    MilestoneEvent(MilestoneEvent),
    OrgBlockEvent(OrgBlockEvent),
    OrganizationEvent(OrganizationEvent),
    PackageEvent(PackageEvent),
    PageBuildEvent(PageBuildEvent),
    PingEvent(PingEvent),
    ProjectEvent(ProjectEvent),
    ProjectCardEvent(ProjectCardEvent),
    ProjectColumnEvent(ProjectColumnEvent),
    PublicEvent(PublicEvent),
    PullRequestEvent(PullRequestEvent),
    PullRequestReviewEvent(PullRequestReviewEvent),
    PullRequestReviewCommentEvent(PullRequestReviewCommentEvent),
    PushEvent(PushEvent),
    ReleaseEvent(ReleaseEvent),
    RepositoryEvent(RepositoryEvent),
    RepositoryDispatchEvent(RepositoryDispatchEvent),
    RepositoryImportEvent(RepositoryImportEvent),
    RepositoryVulnerabilityAlertEvent(RepositoryVulnerabilityAlertEvent),
    SecretScanningAlertEvent(SecretScanningAlertEvent),
    SecurityAdvisoryEvent(SecurityAdvisoryEvent),
    SponsorshipEvent(SponsorshipEvent),
    StarEvent(StarEvent),
    StatusEvent(StatusEvent),
    TeamEvent(TeamEvent),
    TeamAddEvent(TeamAddEvent),
    WatchEvent(WatchEvent),
    WorkflowDispatchEvent(WorkflowDispatchEvent),
    WorkflowJobEvent(WorkflowJobEvent),
    WorkflowRunEvent(WorkflowRunEvent),
}
#[doc = "A user forks a repository."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEvent {
    #[doc = "The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource."]
    pub forkee: Repository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", content = "sender")]
pub enum GithubAppAuthorizationEvent {
    #[educe(Default)]
    #[doc = "github_app_authorization revoked event"]
    #[serde(rename = "revoked")]
    Revoked(User),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubAppAuthorizationRevoked {
    pub action: GithubAppAuthorizationRevokedAction,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GithubAppAuthorizationRevokedAction {
    #[educe(Default)]
    #[serde(rename = "revoked")]
    Revoked,
}
impl ToString for GithubAppAuthorizationRevokedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Revoked => "revoked".to_string(),
        }
    }
}
impl std::str::FromStr for GithubAppAuthorizationRevokedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "revoked" => Ok(Self::Revoked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubOrg {
    pub avatar_url: String,
    #[serde(default)]
    pub email: (),
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[doc = "A wiki page is created or updated."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pages that were updated."]
    pub pages: Vec<GollumEventPagesItem>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEventPagesItem {
    #[doc = "The action that was performed on the page. Can be `created` or `edited`."]
    pub action: GollumEventPagesItemAction,
    #[doc = "Points to the HTML wiki page."]
    pub html_url: String,
    #[doc = "The name of the page."]
    pub page_name: String,
    #[doc = "The latest commit SHA of the page."]
    pub sha: String,
    pub summary: (),
    #[doc = "The current page title."]
    pub title: String,
}
#[doc = "The action that was performed on the page. Can be `created` or `edited`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GollumEventPagesItemAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for GollumEventPagesItemAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for GollumEventPagesItemAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The GitHub App installation."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Installation {
    pub access_tokens_url: String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_slug: Option<String>,
    pub created_at: InstallationCreatedAt,
    pub events: Vec<InstallationEventsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    pub html_url: String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationPermissions,
    pub repositories_url: String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositorySelection,
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub single_file_paths: Vec<String>,
    pub suspended_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub suspended_by: Option<User>,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationTargetType,
    pub updated_at: InstallationUpdatedAt,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreated {
    pub action: InstallationCreatedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationCreatedRepositoriesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<User>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for InstallationCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum InstallationCreatedAt {
    #[educe(Default)]
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl ToString for InstallationCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreatedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeleted {
    pub action: InstallationDeletedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationDeletedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for InstallationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeletedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum InstallationEvent {
    #[educe(Default)]
    #[doc = "installation created event"]
    #[serde(rename = "created")]
    Created {
        installation: Installation,
        #[doc = "An array of repository objects that the installation can access."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        repositories: Vec<InstallationCreatedRepositoriesItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        requester: Option<User>,
        sender: User,
    },
    #[doc = "installation deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        installation: Installation,
        #[doc = "An array of repository objects that the installation can access."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        repositories: Vec<InstallationDeletedRepositoriesItem>,
        #[serde(default)]
        requester: (),
        sender: User,
    },
    #[doc = "installation new_permissions_accepted event"]
    #[serde(rename = "new_permissions_accepted")]
    NewPermissionsAccepted {
        installation: Installation,
        #[doc = "An array of repository objects that the installation can access."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        repositories: Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
        #[serde(default)]
        requester: (),
        sender: User,
    },
    #[doc = "installation suspend event"]
    #[serde(rename = "suspend")]
    Suspend {
        installation: Installation,
        #[doc = "An array of repository objects that the installation can access."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        repositories: Vec<InstallationSuspendRepositoriesItem>,
        #[serde(default)]
        requester: (),
        sender: User,
    },
    #[doc = "installation unsuspend event"]
    #[serde(rename = "unsuspend")]
    Unsuspend {
        installation: Installation,
        #[doc = "An array of repository objects that the installation can access."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        repositories: Vec<InstallationUnsuspendRepositoriesItem>,
        #[serde(default)]
        requester: (),
        sender: User,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationEventsItem {
    #[educe(Default)]
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ToString for InstallationEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::MergeQueueEntry => "merge_queue_entry".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Installation"]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationLite {
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub node_id: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAccepted {
    pub action: InstallationNewPermissionsAcceptedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationNewPermissionsAcceptedAction {
    #[educe(Default)]
    #[serde(rename = "new_permissions_accepted")]
    NewPermissionsAccepted,
}
impl ToString for InstallationNewPermissionsAcceptedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::NewPermissionsAccepted => "new_permissions_accepted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationNewPermissionsAcceptedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "new_permissions_accepted" => Ok(Self::NewPermissionsAccepted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAcceptedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<InstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<InstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<InstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<InstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<InstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<InstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<InstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<InstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<InstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<InstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<InstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<InstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_events: Option<InstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<InstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<InstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<InstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<InstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<InstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners:
        Option<InstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<InstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<InstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<InstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<InstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<InstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<InstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<InstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<InstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<InstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<InstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<InstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<InstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<InstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<InstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<InstallationPermissionsWorkflows>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsActions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsAdministration {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsChecks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsContentReferences {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsContents {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsDeployments {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsDiscussions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsEmails {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsEnvironments {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsIssues {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsMembers {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsMetadata {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationAdministration {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationEvents {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationHooks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationPackages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationPlan {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationProjects {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationSecrets {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationSelfHostedRunners {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsOrganizationUserBlocking {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsPackages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsPages {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsPullRequests {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsRepositoryHooks {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsRepositoryProjects {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsSecretScanningAlerts {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsSecrets {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsSecurityEvents {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsSecurityScanningAlert {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsSingleFile {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsStatuses {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsTeamDiscussions {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsVulnerabilityAlerts {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationPermissionsWorkflows {
    #[educe(Default)]
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ToString for InstallationPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAdded {
    pub action: InstallationRepositoriesAddedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesAddedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationRepositoriesAddedAction {
    #[educe(Default)]
    #[serde(rename = "added")]
    Added,
}
impl ToString for InstallationRepositoriesAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesRemovedItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_name: Option<String>,
    #[doc = "Unique identifier of the repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "Whether the repository is private or public."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationRepositoriesAddedRepositorySelection {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ToString for InstallationRepositoriesAddedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum InstallationRepositoriesEvent {
    #[educe(Default)]
    #[doc = "installation_repositories added event"]
    #[serde(rename = "added")]
    Added {
        installation: Installation,
        #[doc = "An array of repository objects, which were added to the installation."]
        repositories_added: Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
        #[doc = "An array of repository objects, which were removed from the installation."]
        repositories_removed: Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
        #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
        repository_selection: InstallationRepositoriesAddedRepositorySelection,
        requester: Option<User>,
        sender: User,
    },
    #[doc = "installation_repositories removed event"]
    #[serde(rename = "removed")]
    Removed {
        installation: Installation,
        #[doc = "An array of repository objects, which were added to the installation."]
        repositories_added: Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
        #[doc = "An array of repository objects, which were removed from the installation."]
        repositories_removed: Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
        #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
        repository_selection: InstallationRepositoriesRemovedRepositorySelection,
        requester: Option<User>,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemoved {
    pub action: InstallationRepositoriesRemovedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesRemovedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationRepositoriesRemovedAction {
    #[educe(Default)]
    #[serde(rename = "removed")]
    Removed,
}
impl ToString for InstallationRepositoriesRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesRemovedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationRepositoriesRemovedRepositorySelection {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ToString for InstallationRepositoriesRemovedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationRepositorySelection {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ToString for InstallationRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspend {
    pub action: InstallationSuspendAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationSuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationSuspendAction {
    #[educe(Default)]
    #[serde(rename = "suspend")]
    Suspend,
}
impl ToString for InstallationSuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Suspend => "suspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "suspend" => Ok(Self::Suspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationTargetType {
    #[educe(Default)]
    User,
    Organization,
}
impl ToString for InstallationTargetType {
    fn to_string(&self) -> String {
        match *self {
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationTargetType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspend {
    pub action: InstallationUnsuspendAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationUnsuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum InstallationUnsuspendAction {
    #[educe(Default)]
    #[serde(rename = "unsuspend")]
    Unsuspend,
}
impl ToString for InstallationUnsuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unsuspend => "unsuspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unsuspend" => Ok(Self::Unsuspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum InstallationUpdatedAt {
    #[educe(Default)]
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl ToString for InstallationUpdatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Issue {
    pub active_lock_reason: Option<IssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssueActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for IssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueComment {
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue comment"]
    pub body: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub issue_url: String,
    pub node_id: String,
    pub performed_via_github_app: Option<App>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue comment"]
    pub url: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreated {
    pub action: IssueCommentCreatedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssueCommentCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for IssueCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeleted {
    pub action: IssueCommentDeletedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssueCommentDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for IssueCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEdited {
    pub action: IssueCommentEditedAction,
    pub changes: IssueCommentEditedChanges,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssueCommentEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for IssueCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssueCommentEditedChangesBody>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum IssueCommentEvent {
    #[educe(Default)]
    #[doc = "issue_comment created event"]
    #[serde(rename = "created")]
    Created {
        comment: IssueComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issue_comment deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        comment: IssueComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issue_comment edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: IssueCommentEditedChanges,
        comment: IssueComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssueState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for IssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to an issue. The type of activity is specified in the action property."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesAssigned {
    #[doc = "The action that was performed."]
    pub action: IssuesAssignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The action that was performed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesAssignedAction {
    #[educe(Default)]
    #[serde(rename = "assigned")]
    Assigned,
}
impl ToString for IssuesAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosed {
    #[doc = "The action that was performed."]
    pub action: IssuesClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The action that was performed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesClosedAction {
    #[educe(Default)]
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for IssuesClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDeleted {
    pub action: IssuesDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for IssuesDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestoned {
    pub action: IssuesDemilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesDemilestonedAction {
    #[educe(Default)]
    #[serde(rename = "demilestoned")]
    Demilestoned,
}
impl ToString for IssuesDemilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Demilestoned => "demilestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDemilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "demilestoned" => Ok(Self::Demilestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEdited {
    pub action: IssuesEditedAction,
    pub changes: IssuesEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for IssuesEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the issue."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssuesEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<IssuesEditedChangesTitle>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesTitle {
    #[doc = "The previous version of the title."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum IssuesEvent {
    #[educe(Default)]
    #[doc = "issues assigned event\n\nActivity related to an issue. The type of activity is specified in the action property."]
    #[serde(rename = "assigned")]
    Assigned {
        #[doc = "The optional user who was assigned or unassigned from the issue."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        assignee: Option<User>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues closed event"]
    #[serde(rename = "closed")]
    Closed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues demilestoned event"]
    #[serde(rename = "demilestoned")]
    Demilestoned {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: IssuesEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        label: Option<Label>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues labeled event"]
    #[serde(rename = "labeled")]
    Labeled {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[doc = "The label that was added to the issue."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        label: Option<Label>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues locked event"]
    #[serde(rename = "locked")]
    Locked {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues milestoned event"]
    #[serde(rename = "milestoned")]
    Milestoned {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues opened event"]
    #[serde(rename = "opened")]
    Opened {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        changes: Option<IssuesOpenedChanges>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues pinned event"]
    #[serde(rename = "pinned")]
    Pinned {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues reopened event"]
    #[serde(rename = "reopened")]
    Reopened {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues transferred event"]
    #[serde(rename = "transferred")]
    Transferred {
        changes: IssuesTransferredChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues unassigned event"]
    #[serde(rename = "unassigned")]
    Unassigned {
        #[doc = "The optional user who was assigned or unassigned from the issue."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        assignee: Option<User>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues unlabeled event"]
    #[serde(rename = "unlabeled")]
    Unlabeled {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[doc = "The label that was removed from the issue."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        label: Option<Label>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues unlocked event"]
    #[serde(rename = "unlocked")]
    Unlocked {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "issues unpinned event"]
    #[serde(rename = "unpinned")]
    Unpinned {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        issue: Issue,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLabeled {
    pub action: IssuesLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was added to the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesLabeledAction {
    #[educe(Default)]
    #[serde(rename = "labeled")]
    Labeled,
}
impl ToString for IssuesLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLocked {
    pub action: IssuesLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesLockedAction {
    #[educe(Default)]
    #[serde(rename = "locked")]
    Locked,
}
impl ToString for IssuesLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestoned {
    pub action: IssuesMilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesMilestonedAction {
    #[educe(Default)]
    #[serde(rename = "milestoned")]
    Milestoned,
}
impl ToString for IssuesMilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Milestoned => "milestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "milestoned" => Ok(Self::Milestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpened {
    pub action: IssuesOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<IssuesOpenedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesOpenedAction {
    #[educe(Default)]
    #[serde(rename = "opened")]
    Opened,
}
impl ToString for IssuesOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedChanges {
    pub old_issue: Issue,
    pub old_repository: Repository,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesPinned {
    pub action: IssuesPinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesPinnedAction {
    #[educe(Default)]
    #[serde(rename = "pinned")]
    Pinned,
}
impl ToString for IssuesPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopened {
    pub action: IssuesReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesReopenedAction {
    #[educe(Default)]
    #[serde(rename = "reopened")]
    Reopened,
}
impl ToString for IssuesReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferred {
    pub action: IssuesTransferredAction,
    pub changes: IssuesTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesTransferredAction {
    #[educe(Default)]
    #[serde(rename = "transferred")]
    Transferred,
}
impl ToString for IssuesTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferredChanges {
    pub new_issue: Issue,
    pub new_repository: Repository,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnassigned {
    #[doc = "The action that was performed."]
    pub action: IssuesUnassignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The action that was performed."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesUnassignedAction {
    #[educe(Default)]
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl ToString for IssuesUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlabeled {
    pub action: IssuesUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was removed from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesUnlabeledAction {
    #[educe(Default)]
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ToString for IssuesUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlocked {
    pub action: IssuesUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesUnlockedAction {
    #[educe(Default)]
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ToString for IssuesUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnpinned {
    pub action: IssuesUnpinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IssuesUnpinnedAction {
    #[educe(Default)]
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl ToString for IssuesUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Label {
    #[doc = "6-character hex code, without the leading #, identifying the color"]
    pub color: String,
    pub default: bool,
    pub description: Option<String>,
    pub id: i64,
    #[doc = "The name of the label."]
    pub name: String,
    pub node_id: String,
    #[doc = "URL for the label"]
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelCreated {
    pub action: LabelCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was added."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LabelCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for LabelCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for LabelCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelDeleted {
    pub action: LabelDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was removed."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LabelDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for LabelDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for LabelDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEdited {
    pub action: LabelEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<LabelEditedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was edited."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LabelEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for LabelEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for LabelEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the label if the action was `edited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<LabelEditedChangesColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<LabelEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<LabelEditedChangesName>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesColor {
    #[doc = "The previous version of the color if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum LabelEvent {
    #[educe(Default)]
    #[doc = "label created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The label that was added."]
        label: Label,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "label deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The label that was removed."]
        label: Label,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "label edited event"]
    #[serde(rename = "edited")]
    Edited {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        changes: Option<LabelEditedChanges>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The label that was edited."]
        label: Label,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct License {
    pub key: String,
    pub name: String,
    pub node_id: String,
    pub spdx_id: String,
    pub url: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Link {
    pub href: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchase {
    pub account: MarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_billing_date: Option<String>,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePlan,
    pub unit_count: i64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelled {
    pub action: MarketplacePurchaseCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseCancelledSender,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarketplacePurchaseCancelledAction {
    #[educe(Default)]
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl ToString for MarketplacePurchaseCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChanged {
    pub action: MarketplacePurchaseChangedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseChangedSender,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarketplacePurchaseChangedAction {
    #[educe(Default)]
    #[serde(rename = "changed")]
    Changed,
}
impl ToString for MarketplacePurchaseChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Changed => "changed".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "changed" => Ok(Self::Changed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum MarketplacePurchaseEvent {
    #[educe(Default)]
    #[doc = "marketplace_purchase cancelled event"]
    #[serde(rename = "cancelled")]
    Cancelled {
        effective_date: String,
        marketplace_purchase: MarketplacePurchase,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        previous_marketplace_purchase: Option<MarketplacePurchase>,
        sender: MarketplacePurchaseCancelledSender,
    },
    #[doc = "marketplace_purchase changed event"]
    #[serde(rename = "changed")]
    Changed {
        effective_date: String,
        marketplace_purchase: MarketplacePurchase,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        previous_marketplace_purchase: Option<MarketplacePurchase>,
        sender: MarketplacePurchaseChangedSender,
    },
    #[doc = "marketplace_purchase pending_change event"]
    #[serde(rename = "pending_change")]
    PendingChange {
        effective_date: String,
        marketplace_purchase: MarketplacePurchase,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        previous_marketplace_purchase: Option<MarketplacePurchase>,
        sender: MarketplacePurchasePendingChangeSender,
    },
    #[doc = "marketplace_purchase pending_change_cancelled event"]
    #[serde(rename = "pending_change_cancelled")]
    PendingChangeCancelled {
        effective_date: String,
        marketplace_purchase: MarketplacePurchase,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        previous_marketplace_purchase: Option<MarketplacePurchase>,
        sender: MarketplacePurchasePendingChangeCancelledSender,
    },
    #[doc = "marketplace_purchase purchased event"]
    #[serde(rename = "purchased")]
    Purchased {
        effective_date: String,
        marketplace_purchase: MarketplacePurchase,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        previous_marketplace_purchase: Option<MarketplacePurchase>,
        sender: MarketplacePurchasePurchasedSender,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChange {
    pub action: MarketplacePurchasePendingChangeAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeSender,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarketplacePurchasePendingChangeAction {
    #[educe(Default)]
    #[serde(rename = "pending_change")]
    PendingChange,
}
impl ToString for MarketplacePurchasePendingChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChange => "pending_change".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change" => Ok(Self::PendingChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelled {
    pub action: MarketplacePurchasePendingChangeCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeCancelledSender,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarketplacePurchasePendingChangeCancelledAction {
    #[educe(Default)]
    #[serde(rename = "pending_change_cancelled")]
    PendingChangeCancelled,
}
impl ToString for MarketplacePurchasePendingChangeCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChangeCancelled => "pending_change_cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change_cancelled" => Ok(Self::PendingChangeCancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchased {
    pub action: MarketplacePurchasePurchasedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePurchasedSender,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarketplacePurchasePurchasedAction {
    #[educe(Default)]
    #[serde(rename = "purchased")]
    Purchased,
}
impl ToString for MarketplacePurchasePurchasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Purchased => "purchased".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePurchasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "purchased" => Ok(Self::Purchased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
#[doc = "Activity related to repository collaborators. The type of activity is specified in the action property."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAdded {
    pub action: MemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<MemberAddedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was added."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MemberAddedAction {
    #[educe(Default)]
    #[serde(rename = "added")]
    Added,
}
impl ToString for MemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<MemberAddedChangesPermission>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChangesPermission {
    pub to: MemberAddedChangesPermissionTo,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MemberAddedChangesPermissionTo {
    #[educe(Default)]
    #[serde(rename = "write")]
    Write,
    #[serde(rename = "admin")]
    Admin,
}
impl ToString for MemberAddedChangesPermissionTo {
    fn to_string(&self) -> String {
        match *self {
            Self::Write => "write".to_string(),
            Self::Admin => "admin".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedChangesPermissionTo {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "write" => Ok(Self::Write),
            "admin" => Ok(Self::Admin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEdited {
    pub action: MemberEditedAction,
    pub changes: MemberEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user who's permissions are changed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MemberEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for MemberEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MemberEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the collaborator permissions"]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChanges {
    pub old_permission: MemberEditedChangesOldPermission,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChangesOldPermission {
    #[doc = "The previous permissions of the collaborator if the action was edited."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum MemberEvent {
    #[educe(Default)]
    #[doc = "member added event\n\nActivity related to repository collaborators. The type of activity is specified in the action property."]
    #[serde(rename = "added")]
    Added {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        changes: Option<MemberAddedChanges>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The user that was added."]
        member: User,
        repository: Repository,
        sender: User,
    },
    #[doc = "member edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: MemberEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The user who's permissions are changed."]
        member: User,
        repository: Repository,
        sender: User,
    },
    #[doc = "member removed event"]
    #[serde(rename = "removed")]
    Removed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The user that was removed."]
        member: User,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberRemoved {
    pub action: MemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was removed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MemberRemovedAction {
    #[educe(Default)]
    #[serde(rename = "removed")]
    Removed,
}
impl ToString for MemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Membership {
    pub organization_url: String,
    pub role: String,
    pub state: String,
    pub url: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipAdded {
    pub action: MembershipAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipAddedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MembershipAddedAction {
    #[educe(Default)]
    #[serde(rename = "added")]
    Added,
}
impl ToString for MembershipAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MembershipAddedScope {
    #[educe(Default)]
    #[serde(rename = "team")]
    Team,
}
impl ToString for MembershipAddedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum MembershipEvent {
    #[educe(Default)]
    #[doc = "membership added event"]
    #[serde(rename = "added")]
    Added {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
        member: User,
        organization: Organization,
        #[doc = "The scope of the membership. Currently, can only be `team`."]
        scope: MembershipAddedScope,
        sender: User,
        #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
        team: Team,
    },
    #[doc = "membership removed event"]
    #[serde(rename = "removed")]
    Removed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
        member: User,
        organization: Organization,
        #[doc = "The scope of the membership. Currently, can only be `team`."]
        scope: MembershipRemovedScope,
        sender: User,
        #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
        team: MembershipRemovedTeam,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipRemoved {
    pub action: MembershipRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipRemovedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: MembershipRemovedTeam,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MembershipRemovedAction {
    #[educe(Default)]
    #[serde(rename = "removed")]
    Removed,
}
impl ToString for MembershipRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MembershipRemovedScope {
    #[educe(Default)]
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "organization")]
    Organization,
}
impl ToString for MembershipRemovedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
            Self::Organization => "organization".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            "organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum MembershipRemovedTeam {
    #[educe(Default)]
    Variant0(Team),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        deleted: Option<bool>,
        id: i64,
        name: String,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeleted {
    pub action: MetaDeletedAction,
    pub hook: MetaDeletedHook,
    #[doc = "The id of the modified webhook."]
    pub hook_id: i64,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MetaDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for MetaDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHook {
    pub active: bool,
    pub config: MetaDeletedHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHookConfig {
    pub content_type: MetaDeletedHookConfigContentType,
    pub insecure_ssl: String,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MetaDeletedHookConfigContentType {
    #[educe(Default)]
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl ToString for MetaDeletedHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum MetaEvent {
    #[educe(Default)]
    #[doc = "meta deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        hook: MetaDeletedHook,
        #[doc = "The id of the modified webhook."]
        hook_id: i64,
        repository: Repository,
        sender: User,
    },
}
#[doc = "A collection of related issues and pull requests."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Milestone {
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    #[doc = "The state of the milestone."]
    pub state: MilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosed {
    pub action: MilestoneClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneClosedAction {
    #[educe(Default)]
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for MilestoneClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreated {
    pub action: MilestoneCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for MilestoneCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneDeleted {
    pub action: MilestoneDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for MilestoneDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEdited {
    pub action: MilestoneEditedAction,
    pub changes: MilestoneEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for MilestoneEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the milestone if the action was `edited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<MilestoneEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub due_on: Option<MilestoneEditedChangesDueOn>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<MilestoneEditedChangesTitle>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDueOn {
    #[doc = "The previous version of the due date if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum MilestoneEvent {
    #[educe(Default)]
    #[doc = "milestone closed event"]
    #[serde(rename = "closed")]
    Closed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "milestone created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "milestone deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "milestone edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: MilestoneEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "milestone opened event"]
    #[serde(rename = "opened")]
    Opened {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        milestone: Milestone,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpened {
    pub action: MilestoneOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneOpenedAction {
    #[educe(Default)]
    #[serde(rename = "opened")]
    Opened,
}
impl ToString for MilestoneOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The state of the milestone."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MilestoneState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for MilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockBlocked {
    pub action: OrgBlockBlockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrgBlockBlockedAction {
    #[educe(Default)]
    #[serde(rename = "blocked")]
    Blocked,
}
impl ToString for OrgBlockBlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Blocked => "blocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockBlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "blocked" => Ok(Self::Blocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum OrgBlockEvent {
    #[educe(Default)]
    #[doc = "org_block blocked event"]
    #[serde(rename = "blocked")]
    Blocked {
        #[doc = "Information about the user that was blocked or unblocked."]
        blocked_user: User,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        sender: User,
    },
    #[doc = "org_block unblocked event"]
    #[serde(rename = "unblocked")]
    Unblocked {
        #[doc = "Information about the user that was blocked or unblocked."]
        blocked_user: User,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockUnblocked {
    pub action: OrgBlockUnblockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrgBlockUnblockedAction {
    #[educe(Default)]
    #[serde(rename = "unblocked")]
    Unblocked,
}
impl ToString for OrgBlockUnblockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unblocked => "unblocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockUnblockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unblocked" => Ok(Self::Unblocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Organization {
    pub avatar_url: String,
    pub description: Option<String>,
    pub events_url: String,
    pub hooks_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    pub id: i64,
    pub issues_url: String,
    pub login: String,
    pub members_url: String,
    pub node_id: String,
    pub public_members_url: String,
    pub repos_url: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationDeleted {
    pub action: OrganizationDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrganizationDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for OrganizationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum OrganizationEvent {
    #[educe(Default)]
    #[doc = "organization deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        membership: Membership,
        organization: Organization,
        sender: User,
    },
    #[doc = "organization member_added event"]
    #[serde(rename = "member_added")]
    MemberAdded {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        membership: Membership,
        organization: Organization,
        sender: User,
    },
    #[doc = "organization member_invited event"]
    #[serde(rename = "member_invited")]
    MemberInvited {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        invitation: OrganizationMemberInvitedInvitation,
        organization: Organization,
        sender: User,
        user: User,
    },
    #[doc = "organization member_removed event"]
    #[serde(rename = "member_removed")]
    MemberRemoved {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        membership: Membership,
        organization: Organization,
        sender: User,
    },
    #[doc = "organization renamed event"]
    #[serde(rename = "renamed")]
    Renamed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        membership: Membership,
        organization: Organization,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberAdded {
    pub action: OrganizationMemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrganizationMemberAddedAction {
    #[educe(Default)]
    #[serde(rename = "member_added")]
    MemberAdded,
}
impl ToString for OrganizationMemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberAdded => "member_added".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_added" => Ok(Self::MemberAdded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvited {
    pub action: OrganizationMemberInvitedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub invitation: OrganizationMemberInvitedInvitation,
    pub organization: Organization,
    pub sender: User,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrganizationMemberInvitedAction {
    #[educe(Default)]
    #[serde(rename = "member_invited")]
    MemberInvited,
}
impl ToString for OrganizationMemberInvitedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberInvited => "member_invited".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberInvitedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_invited" => Ok(Self::MemberInvited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The invitation for the user or email if the action is `member_invited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvitedInvitation {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub email: Option<String>,
    pub failed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub failed_reason: Option<String>,
    pub id: f64,
    pub invitation_teams_url: String,
    pub inviter: User,
    pub login: String,
    pub node_id: String,
    pub role: String,
    pub team_count: f64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberRemoved {
    pub action: OrganizationMemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrganizationMemberRemovedAction {
    #[educe(Default)]
    #[serde(rename = "member_removed")]
    MemberRemoved,
}
impl ToString for OrganizationMemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberRemoved => "member_removed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_removed" => Ok(Self::MemberRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamed {
    pub action: OrganizationRenamedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrganizationRenamedAction {
    #[educe(Default)]
    #[serde(rename = "renamed")]
    Renamed,
}
impl ToString for OrganizationRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum PackageEvent {
    #[educe(Default)]
    #[doc = "package published event"]
    #[serde(rename = "published")]
    Published {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        package: PackagePublishedPackage,
        repository: Repository,
        sender: User,
    },
    #[doc = "package updated event"]
    #[serde(rename = "updated")]
    Updated {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        package: PackageUpdatedPackage,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublished {
    pub action: PackagePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackagePublishedPackage,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PackagePublishedAction {
    #[educe(Default)]
    #[serde(rename = "published")]
    Published,
}
impl ToString for PackagePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for PackagePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackagePublishedPackagePackageVersion,
    pub registry: PackagePublishedPackageRegistry,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackagePublishedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackagePublishedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdated {
    pub action: PackageUpdatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackageUpdatedPackage,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PackageUpdatedAction {
    #[educe(Default)]
    #[serde(rename = "updated")]
    Updated,
}
impl ToString for PackageUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for PackageUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackageUpdatedPackagePackageVersion,
    pub registry: PackageUpdatedPackageRegistry,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackageUpdatedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackageUpdatedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
#[doc = "Page Build"]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEvent {
    pub build: PageBuildEventBuild,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuild {
    pub commit: String,
    pub created_at: String,
    pub duration: i64,
    pub error: PageBuildEventBuildError,
    pub pusher: User,
    pub status: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuildError {
    pub message: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEvent {
    pub hook: PingEventHook,
    #[doc = "The ID of the webhook that triggered the ping."]
    pub hook_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<User>,
    pub zen: String,
}
#[doc = "The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook)."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHook {
    pub active: bool,
    #[doc = "When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_id: Option<i64>,
    pub config: PingEventHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_response: Option<PingEventHookLastResponse>,
    pub name: String,
    pub ping_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test_url: Option<String>,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookConfig {
    pub content_type: PingEventHookConfigContentType,
    pub insecure_ssl: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PingEventHookConfigContentType {
    #[educe(Default)]
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl ToString for PingEventHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for PingEventHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookLastResponse {
    pub code: (),
    pub message: (),
    pub status: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Project {
    #[doc = "Body of the project"]
    pub body: Option<String>,
    pub columns_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub html_url: String,
    pub id: i64,
    #[doc = "Name of the project"]
    pub name: String,
    pub node_id: String,
    pub number: i64,
    pub owner_url: String,
    #[doc = "State of the project; either 'open' or 'closed'"]
    pub state: ProjectState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCard {
    #[serde(default)]
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: String,
    pub note: Option<String>,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConverted {
    pub action: ProjectCardConvertedAction,
    pub changes: ProjectCardConvertedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCardConvertedAction {
    #[educe(Default)]
    #[serde(rename = "converted")]
    Converted,
}
impl ToString for ProjectCardConvertedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Converted => "converted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardConvertedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted" => Ok(Self::Converted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChanges {
    pub note: ProjectCardConvertedChangesNote,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChangesNote {
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardCreated {
    pub action: ProjectCardCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCardCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for ProjectCardCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardDeleted {
    pub action: ProjectCardDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCardDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for ProjectCardDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEdited {
    pub action: ProjectCardEditedAction,
    pub changes: ProjectCardEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCardEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for ProjectCardEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChanges {
    pub note: ProjectCardEditedChangesNote,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChangesNote {
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum ProjectCardEvent {
    #[educe(Default)]
    #[doc = "project_card converted event"]
    #[serde(rename = "converted")]
    Converted {
        changes: ProjectCardConvertedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_card: ProjectCard,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_card created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_card: ProjectCard,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_card deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_card: ProjectCard,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_card edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: ProjectCardEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_card: ProjectCard,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_card moved event"]
    #[serde(rename = "moved")]
    Moved {
        changes: ProjectCardMovedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_card: ProjectCard,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMoved {
    pub action: ProjectCardMovedAction,
    pub changes: ProjectCardMovedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCardMovedAction {
    #[educe(Default)]
    #[serde(rename = "moved")]
    Moved,
}
impl ToString for ProjectCardMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChanges {
    pub column_id: ProjectCardMovedChangesColumnId,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChangesColumnId {
    pub from: i64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectClosed {
    pub action: ProjectClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectClosedAction {
    #[educe(Default)]
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for ProjectClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumn {
    pub cards_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The unique identifier of the project column"]
    pub id: i64,
    #[doc = "Name of the project column"]
    pub name: String,
    pub node_id: String,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnCreated {
    pub action: ProjectColumnCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectColumnCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for ProjectColumnCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnDeleted {
    pub action: ProjectColumnDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectColumnDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for ProjectColumnDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEdited {
    pub action: ProjectColumnEditedAction,
    pub changes: ProjectColumnEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectColumnEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for ProjectColumnEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectColumnEditedChangesName>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChangesName {
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum ProjectColumnEvent {
    #[educe(Default)]
    #[doc = "project_column created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_column: ProjectColumn,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_column deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_column: ProjectColumn,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_column edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: ProjectColumnEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_column: ProjectColumn,
        repository: Repository,
        sender: User,
    },
    #[doc = "project_column moved event"]
    #[serde(rename = "moved")]
    Moved {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project_column: ProjectColumn,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnMoved {
    pub action: ProjectColumnMovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectColumnMovedAction {
    #[educe(Default)]
    #[serde(rename = "moved")]
    Moved,
}
impl ToString for ProjectColumnMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCreated {
    pub action: ProjectCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for ProjectCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectDeleted {
    pub action: ProjectDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for ProjectDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEdited {
    pub action: ProjectEditedAction,
    pub changes: ProjectEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for ProjectEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the project if the action was `edited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ProjectEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectEditedChangesName>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesName {
    #[doc = "The changes to the project if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum ProjectEvent {
    #[educe(Default)]
    #[doc = "project closed event"]
    #[serde(rename = "closed")]
    Closed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project: Project,
        repository: Repository,
        sender: User,
    },
    #[doc = "project created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project: Project,
        repository: Repository,
        sender: User,
    },
    #[doc = "project deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project: Project,
        repository: Repository,
        sender: User,
    },
    #[doc = "project edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: ProjectEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project: Project,
        repository: Repository,
        sender: User,
    },
    #[doc = "project reopened event"]
    #[serde(rename = "reopened")]
    Reopened {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        project: Project,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectReopened {
    pub action: ProjectReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectReopenedAction {
    #[educe(Default)]
    #[serde(rename = "reopened")]
    Reopened,
}
impl ToString for ProjectReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of the project; either 'open' or 'closed'"]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for ProjectState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "When a private repository is made public."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequest {
    pub active_lock_reason: Option<PullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: Option<bool>,
    pub merged_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub merged_by: Option<User>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for PullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAssigned {
    pub action: PullRequestAssignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestAssignedAction {
    #[educe(Default)]
    #[serde(rename = "assigned")]
    Assigned,
}
impl ToString for PullRequestAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeDisabled {
    pub action: PullRequestAutoMergeDisabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestAutoMergeDisabledAction {
    #[educe(Default)]
    #[serde(rename = "auto_merge_disabled")]
    AutoMergeDisabled,
}
impl ToString for PullRequestAutoMergeDisabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeDisabled => "auto_merge_disabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeDisabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_disabled" => Ok(Self::AutoMergeDisabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeEnabled {
    pub action: PullRequestAutoMergeEnabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestAutoMergeEnabledAction {
    #[educe(Default)]
    #[serde(rename = "auto_merge_enabled")]
    AutoMergeEnabled,
}
impl ToString for PullRequestAutoMergeEnabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeEnabled => "auto_merge_enabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeEnabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_enabled" => Ok(Self::AutoMergeEnabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosed {
    pub action: PullRequestClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestClosedAction {
    #[educe(Default)]
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for PullRequestClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraft {
    pub action: PullRequestConvertedToDraftAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestConvertedToDraftAction {
    #[educe(Default)]
    #[serde(rename = "converted_to_draft")]
    ConvertedToDraft,
}
impl ToString for PullRequestConvertedToDraftAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ConvertedToDraft => "converted_to_draft".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestConvertedToDraftAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted_to_draft" => Ok(Self::ConvertedToDraft),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEdited {
    pub action: PullRequestEditedAction,
    pub changes: PullRequestEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for PullRequestEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment if the action was `edited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<PullRequestEditedChangesTitle>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PullRequestEvent {
    #[educe(Default)]
    Assigned(PullRequestAssigned),
    AutoMergeDisabled(PullRequestAutoMergeDisabled),
    AutoMergeEnabled(PullRequestAutoMergeEnabled),
    Closed(PullRequestClosed),
    ConvertedToDraft(PullRequestConvertedToDraft),
    Edited(PullRequestEdited),
    Labeled(PullRequestLabeled),
    Locked(PullRequestLocked),
    Opened(PullRequestOpened),
    ReadyForReview(PullRequestReadyForReview),
    Reopened(PullRequestReopened),
    ReviewRequestRemoved(PullRequestReviewRequestRemoved),
    ReviewRequested(PullRequestReviewRequested),
    Synchronize(PullRequestSynchronize),
    Unassigned(PullRequestUnassigned),
    Unlabeled(PullRequestUnlabeled),
    Unlocked(PullRequestUnlocked),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLabeled {
    pub action: PullRequestLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestLabeledAction {
    #[educe(Default)]
    #[serde(rename = "labeled")]
    Labeled,
}
impl ToString for PullRequestLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLocked {
    pub action: PullRequestLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestLockedAction {
    #[educe(Default)]
    #[serde(rename = "locked")]
    Locked,
}
impl ToString for PullRequestLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpened {
    pub action: PullRequestOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestOpenedAction {
    #[educe(Default)]
    #[serde(rename = "opened")]
    Opened,
}
impl ToString for PullRequestOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReview {
    pub action: PullRequestReadyForReviewAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReadyForReviewAction {
    #[educe(Default)]
    #[serde(rename = "ready_for_review")]
    ReadyForReview,
}
impl ToString for PullRequestReadyForReviewAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReadyForReview => "ready_for_review".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReadyForReviewAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ready_for_review" => Ok(Self::ReadyForReview),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopened {
    pub action: PullRequestReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReopenedAction {
    #[educe(Default)]
    #[serde(rename = "reopened")]
    Reopened,
}
impl ToString for PullRequestReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PullRequestRequestedReviewersItem {
    #[educe(Default)]
    User(User),
    Team(Team),
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The diff of the line that the comment refers to."]
    pub diff_hunk: String,
    #[doc = "HTML URL for the pull request review comment."]
    pub html_url: String,
    #[doc = "The ID of the pull request review comment."]
    pub id: i64,
    #[doc = "The comment ID to reply to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentLinks,
    #[doc = "The node ID of the pull request review comment."]
    pub node_id: String,
    #[doc = "The SHA of the original commit to which the comment applies."]
    pub original_commit_id: String,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub original_line: i64,
    #[doc = "The index of the original line in the diff to which the comment applies."]
    pub original_position: i64,
    #[doc = "The first line of the range for a multi-line comment."]
    pub original_start_line: Option<i64>,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: String,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    pub pull_request_review_id: i64,
    #[doc = "URL for the pull request that the review comment belongs to."]
    pub pull_request_url: String,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub side: PullRequestReviewCommentSide,
    #[doc = "The first line of the range for a multi-line comment."]
    pub start_line: Option<i64>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub start_side: Option<PullRequestReviewCommentStartSide>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the pull request review comment"]
    pub url: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreated {
    pub action: PullRequestReviewCommentCreatedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentCreatedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for PullRequestReviewCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentCreatedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentCreatedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentCreatedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentCreatedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentCreatedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    #[educe(Default)]
    User(User),
    Team(Team),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentCreatedPullRequestState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for PullRequestReviewCommentCreatedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeleted {
    pub action: PullRequestReviewCommentDeletedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentDeletedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for PullRequestReviewCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentDeletedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentDeletedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentDeletedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentDeletedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentDeletedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    #[educe(Default)]
    User(User),
    Team(Team),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentDeletedPullRequestState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for PullRequestReviewCommentDeletedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEdited {
    pub action: PullRequestReviewCommentEditedAction,
    pub changes: PullRequestReviewCommentEditedChanges,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentEditedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for PullRequestReviewCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewCommentEditedChangesBody>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentEditedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentEditedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentEditedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentEditedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentEditedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentEditedPullRequestActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    #[educe(Default)]
    User(User),
    Team(Team),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentEditedPullRequestState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for PullRequestReviewCommentEditedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum PullRequestReviewCommentEvent {
    #[educe(Default)]
    #[doc = "pull_request_review_comment created event"]
    #[serde(rename = "created")]
    Created {
        comment: PullRequestReviewComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequestReviewCommentCreatedPullRequest,
        repository: Repository,
        sender: User,
    },
    #[doc = "pull_request_review_comment deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        comment: PullRequestReviewComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequestReviewCommentDeletedPullRequest,
        repository: Repository,
        sender: User,
    },
    #[doc = "pull_request_review_comment edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: PullRequestReviewCommentEditedChanges,
        comment: PullRequestReviewComment,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequestReviewCommentEditedPullRequest,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentLinks {
    pub html: Link,
    pub pull_request: Link,
    #[serde(rename = "self")]
    pub self_: Link,
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentSide {
    #[educe(Default)]
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl ToString for PullRequestReviewCommentSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewCommentStartSide {
    #[educe(Default)]
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl ToString for PullRequestReviewCommentStartSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentStartSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissed {
    pub action: PullRequestReviewDismissedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewDismissedReview,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewDismissedAction {
    #[educe(Default)]
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ToString for PullRequestReviewDismissedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewDismissedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: PullRequestReviewDismissedReviewState,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewDismissedReviewState {
    #[educe(Default)]
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ToString for PullRequestReviewDismissedReviewState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedReviewState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEdited {
    pub action: PullRequestReviewEditedAction,
    pub changes: PullRequestReviewEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewEditedReview,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for PullRequestReviewEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewEditedChangesBody>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewEditedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum PullRequestReviewEvent {
    #[educe(Default)]
    #[doc = "pull_request_review dismissed event"]
    #[serde(rename = "dismissed")]
    Dismissed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: SimplePullRequest,
        repository: Repository,
        review: PullRequestReviewDismissedReview,
        sender: User,
    },
    #[doc = "pull_request_review edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: PullRequestReviewEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: SimplePullRequest,
        repository: Repository,
        review: PullRequestReviewEditedReview,
        sender: User,
    },
    #[doc = "pull_request_review submitted event"]
    #[serde(rename = "submitted")]
    Submitted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: SimplePullRequest,
        repository: Repository,
        review: PullRequestReviewSubmittedReview,
        sender: User,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequestRemoved {
    #[educe(Default)]
    Variant0 {
        action: PullRequestReviewRequestRemovedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestRemovedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewRequestRemovedVariant0Action {
    #[educe(Default)]
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl ToString for PullRequestReviewRequestRemovedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewRequestRemovedVariant1Action {
    #[educe(Default)]
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl ToString for PullRequestReviewRequestRemovedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequested {
    #[educe(Default)]
    Variant0 {
        action: PullRequestReviewRequestedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewRequestedVariant0Action {
    #[educe(Default)]
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl ToString for PullRequestReviewRequestedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewRequestedVariant1Action {
    #[educe(Default)]
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl ToString for PullRequestReviewRequestedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmitted {
    pub action: PullRequestReviewSubmittedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewSubmittedReview,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestReviewSubmittedAction {
    #[educe(Default)]
    #[serde(rename = "submitted")]
    Submitted,
}
impl ToString for PullRequestReviewSubmittedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Submitted => "submitted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewSubmittedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "submitted" => Ok(Self::Submitted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewSubmittedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for PullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestSynchronize {
    pub action: PullRequestSynchronizeAction,
    pub after: String,
    pub before: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestSynchronizeAction {
    #[educe(Default)]
    #[serde(rename = "synchronize")]
    Synchronize,
}
impl ToString for PullRequestSynchronizeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Synchronize => "synchronize".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestSynchronizeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "synchronize" => Ok(Self::Synchronize),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnassigned {
    pub action: PullRequestUnassignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestUnassignedAction {
    #[educe(Default)]
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl ToString for PullRequestUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlabeled {
    pub action: PullRequestUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestUnlabeledAction {
    #[educe(Default)]
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ToString for PullRequestUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlocked {
    pub action: PullRequestUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PullRequestUnlockedAction {
    #[educe(Default)]
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ToString for PullRequestUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PushEvent {
    #[doc = "The SHA of the most recent commit on `ref` after the push."]
    pub after: String,
    pub base_ref: Option<String>,
    #[doc = "The SHA of the most recent commit on `ref` before the push."]
    pub before: String,
    #[doc = "An array of commit objects describing the pushed commits."]
    pub commits: Vec<Commit>,
    pub compare: String,
    pub created: bool,
    pub deleted: bool,
    pub forced: bool,
    pub head_commit: Option<Commit>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pusher: Committer,
    #[doc = "The full git ref that was pushed. Example: `refs/heads/main`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
#[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Release {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
#[doc = "Data related to a release."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseAsset {
    pub browser_download_url: String,
    pub content_type: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub download_count: i64,
    pub id: i64,
    pub label: Option<String>,
    #[doc = "The file name of the asset."]
    pub name: String,
    pub node_id: String,
    pub size: i64,
    #[doc = "State of the release asset."]
    pub state: ReleaseAssetState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploader: Option<User>,
    pub url: String,
}
#[doc = "State of the release asset."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseAssetState {
    #[educe(Default)]
    #[serde(rename = "uploaded")]
    Uploaded,
}
impl ToString for ReleaseAssetState {
    fn to_string(&self) -> String {
        match *self {
            Self::Uploaded => "uploaded".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseAssetState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "uploaded" => Ok(Self::Uploaded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseCreated {
    pub action: ReleaseCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for ReleaseCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseDeleted {
    pub action: ReleaseDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for ReleaseDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEdited {
    pub action: ReleaseEditedAction,
    pub changes: ReleaseEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for ReleaseEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ReleaseEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ReleaseEditedChangesName>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum ReleaseEvent {
    #[educe(Default)]
    #[doc = "release created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: ReleaseEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release prereleased event"]
    #[serde(rename = "prereleased")]
    Prereleased {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release published event"]
    #[serde(rename = "published")]
    Published {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release released event"]
    #[serde(rename = "released")]
    Released {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
    #[doc = "release unpublished event"]
    #[serde(rename = "unpublished")]
    Unpublished {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        release: Release,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleased {
    pub action: ReleasePrereleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleasePrereleasedAction {
    #[educe(Default)]
    #[serde(rename = "prereleased")]
    Prereleased,
}
impl ToString for ReleasePrereleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Prereleased => "prereleased".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePrereleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "prereleased" => Ok(Self::Prereleased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublished {
    pub action: ReleasePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleasePublishedAction {
    #[educe(Default)]
    #[serde(rename = "published")]
    Published,
}
impl ToString for ReleasePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseReleased {
    pub action: ReleaseReleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseReleasedAction {
    #[educe(Default)]
    #[serde(rename = "released")]
    Released,
}
impl ToString for ReleaseReleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Released => "released".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseReleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "released" => Ok(Self::Released),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublished {
    pub action: ReleaseUnpublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ReleaseUnpublishedAction {
    #[educe(Default)]
    #[serde(rename = "unpublished")]
    Unpublished,
}
impl ToString for ReleaseUnpublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpublished => "unpublished".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseUnpublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpublished" => Ok(Self::Unpublished),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepoRef {
    pub id: i64,
    pub name: String,
    pub url: String,
}
#[doc = "A git repository"]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Repository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchived {
    pub action: RepositoryArchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryArchivedAction {
    #[educe(Default)]
    #[serde(rename = "archived")]
    Archived,
}
impl ToString for RepositoryArchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Archived => "archived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryArchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "archived" => Ok(Self::Archived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryCreated {
    pub action: RepositoryCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for RepositoryCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RepositoryCreatedAt {
    #[educe(Default)]
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl ToString for RepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDeleted {
    pub action: RepositoryDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for RepositoryDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum RepositoryDispatchEvent {
    #[educe(Default)]
    #[doc = "repository_dispatch on-demand-test event"]
    #[serde(rename = "on-demand-test")]
    OnDemandTest {
        branch: String,
        client_payload: std::collections::HashMap<String, serde_json::Value>,
        installation: InstallationLite,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDispatchOnDemandTest {
    pub action: RepositoryDispatchOnDemandTestAction,
    pub branch: String,
    pub client_payload: std::collections::HashMap<String, serde_json::Value>,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryDispatchOnDemandTestAction {
    #[educe(Default)]
    #[serde(rename = "on-demand-test")]
    OnDemandTest,
}
impl ToString for RepositoryDispatchOnDemandTestAction {
    fn to_string(&self) -> String {
        match *self {
            Self::OnDemandTest => "on-demand-test".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDispatchOnDemandTestAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "on-demand-test" => Ok(Self::OnDemandTest),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEdited {
    pub action: RepositoryEditedAction,
    pub changes: RepositoryEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for RepositoryEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_branch: Option<RepositoryEditedChangesDefaultBranch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<RepositoryEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<RepositoryEditedChangesHomepage>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDefaultBranch {
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDescription {
    pub from: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesHomepage {
    pub from: Option<String>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum RepositoryEvent {
    #[educe(Default)]
    #[doc = "repository archived event"]
    #[serde(rename = "archived")]
    Archived {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: RepositoryEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository privatized event"]
    #[serde(rename = "privatized")]
    Privatized {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository publicized event"]
    #[serde(rename = "publicized")]
    Publicized {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository renamed event"]
    #[serde(rename = "renamed")]
    Renamed {
        changes: RepositoryRenamedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository transferred event"]
    #[serde(rename = "transferred")]
    Transferred {
        changes: RepositoryTransferredChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository unarchived event"]
    #[serde(rename = "unarchived")]
    Unarchived {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryImportEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub status: RepositoryImportEventStatus,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryImportEventStatus {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "failure")]
    Failure,
}
impl ToString for RepositoryImportEventStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryImportEventStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "cancelled" => Ok(Self::Cancelled),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryLite {
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub deployments_url: String,
    pub description: Option<String>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: String,
    pub merges_url: String,
    pub milestones_url: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub owner: User,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub pulls_url: String,
    pub releases_url: String,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatized {
    pub action: RepositoryPrivatizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryPrivatizedAction {
    #[educe(Default)]
    #[serde(rename = "privatized")]
    Privatized,
}
impl ToString for RepositoryPrivatizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Privatized => "privatized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPrivatizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "privatized" => Ok(Self::Privatized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicized {
    pub action: RepositoryPublicizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryPublicizedAction {
    #[educe(Default)]
    #[serde(rename = "publicized")]
    Publicized,
}
impl ToString for RepositoryPublicizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Publicized => "publicized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPublicizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "publicized" => Ok(Self::Publicized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RepositoryPushedAt {
    #[educe(Default)]
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamed {
    pub action: RepositoryRenamedAction,
    pub changes: RepositoryRenamedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryRenamedAction {
    #[educe(Default)]
    #[serde(rename = "renamed")]
    Renamed,
}
impl ToString for RepositoryRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChanges {
    pub repository: RepositoryRenamedChangesRepository,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepository {
    pub name: RepositoryRenamedChangesRepositoryName,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepositoryName {
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferred {
    pub action: RepositoryTransferredAction,
    pub changes: RepositoryTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryTransferredAction {
    #[educe(Default)]
    #[serde(rename = "transferred")]
    Transferred,
}
impl ToString for RepositoryTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChanges {
    pub owner: RepositoryTransferredChangesOwner,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwner {
    pub from: RepositoryTransferredChangesOwnerFrom,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwnerFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<User>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchived {
    pub action: RepositoryUnarchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryUnarchivedAction {
    #[educe(Default)]
    #[serde(rename = "unarchived")]
    Unarchived,
}
impl ToString for RepositoryUnarchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unarchived => "unarchived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryUnarchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unarchived" => Ok(Self::Unarchived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreate {
    pub action: RepositoryVulnerabilityAlertCreateAction,
    pub alert: RepositoryVulnerabilityAlertCreateAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryVulnerabilityAlertCreateAction {
    #[educe(Default)]
    #[serde(rename = "create")]
    Create,
}
impl ToString for RepositoryVulnerabilityAlertCreateAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "create".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertCreateAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "create" => Ok(Self::Create),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreateAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismiss {
    pub action: RepositoryVulnerabilityAlertDismissAction,
    pub alert: RepositoryVulnerabilityAlertDismissAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryVulnerabilityAlertDismissAction {
    #[educe(Default)]
    #[serde(rename = "dismiss")]
    Dismiss,
}
impl ToString for RepositoryVulnerabilityAlertDismissAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismiss => "dismiss".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertDismissAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismiss" => Ok(Self::Dismiss),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismissAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    pub dismiss_reason: String,
    pub dismissed_at: String,
    pub dismisser: User,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum RepositoryVulnerabilityAlertEvent {
    #[educe(Default)]
    #[doc = "repository_vulnerability_alert create event"]
    #[serde(rename = "create")]
    Create {
        alert: RepositoryVulnerabilityAlertCreateAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository_vulnerability_alert dismiss event"]
    #[serde(rename = "dismiss")]
    Dismiss {
        alert: RepositoryVulnerabilityAlertDismissAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "repository_vulnerability_alert resolve event"]
    #[serde(rename = "resolve")]
    Resolve {
        alert: RepositoryVulnerabilityAlertResolveAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolve {
    pub action: RepositoryVulnerabilityAlertResolveAction,
    pub alert: RepositoryVulnerabilityAlertResolveAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RepositoryVulnerabilityAlertResolveAction {
    #[educe(Default)]
    #[serde(rename = "resolve")]
    Resolve,
}
impl ToString for RepositoryVulnerabilityAlertResolveAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolve => "resolve".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertResolveAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolve" => Ok(Self::Resolve),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolveAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreated {
    pub action: SecretScanningAlertCreatedAction,
    pub alert: SecretScanningAlertCreatedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecretScanningAlertCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for SecretScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreatedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum SecretScanningAlertEvent {
    #[educe(Default)]
    #[doc = "secret_scanning_alert created event"]
    #[serde(rename = "created")]
    Created {
        alert: SecretScanningAlertCreatedAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
    },
    #[doc = "secret_scanning_alert reopened event"]
    #[serde(rename = "reopened")]
    Reopened {
        alert: SecretScanningAlertReopenedAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
    #[doc = "secret_scanning_alert resolved event"]
    #[serde(rename = "resolved")]
    Resolved {
        alert: SecretScanningAlertResolvedAlert,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopened {
    pub action: SecretScanningAlertReopenedAction,
    pub alert: SecretScanningAlertReopenedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecretScanningAlertReopenedAction {
    #[educe(Default)]
    #[serde(rename = "reopened")]
    Reopened,
}
impl ToString for SecretScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopenedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolved {
    pub action: SecretScanningAlertResolvedAction,
    pub alert: SecretScanningAlertResolvedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecretScanningAlertResolvedAction {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
}
impl ToString for SecretScanningAlertResolvedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolvedAlert {
    pub number: i64,
    pub resolution: SecretScanningAlertResolvedAlertResolution,
    pub resolved_at: String,
    pub resolved_by: User,
    pub secret_type: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecretScanningAlertResolvedAlertResolution {
    #[educe(Default)]
    #[serde(rename = "false_positive")]
    FalsePositive,
    #[serde(rename = "wontfix")]
    Wontfix,
    #[serde(rename = "revoked")]
    Revoked,
    #[serde(rename = "used_in_tests")]
    UsedInTests,
}
impl ToString for SecretScanningAlertResolvedAlertResolution {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false_positive".to_string(),
            Self::Wontfix => "wontfix".to_string(),
            Self::Revoked => "revoked".to_string(),
            Self::UsedInTests => "used_in_tests".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAlertResolution {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false_positive" => Ok(Self::FalsePositive),
            "wontfix" => Ok(Self::Wontfix),
            "revoked" => Ok(Self::Revoked),
            "used_in_tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", content = "security_advisory")]
pub enum SecurityAdvisoryEvent {
    #[educe(Default)]
    #[doc = "security_advisory performed event"]
    #[serde(rename = "performed")]
    Performed(SecurityAdvisoryPerformedSecurityAdvisory),
    #[doc = "security_advisory published event"]
    #[serde(rename = "published")]
    Published(SecurityAdvisoryPublishedSecurityAdvisory),
    #[doc = "security_advisory updated event"]
    #[serde(rename = "updated")]
    Updated(SecurityAdvisoryUpdatedSecurityAdvisory),
    #[doc = "security_advisory withdrawn event"]
    #[serde(rename = "withdrawn")]
    Withdrawn(SecurityAdvisoryWithdrawnSecurityAdvisory),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformed {
    pub action: SecurityAdvisoryPerformedAction,
    pub security_advisory: SecurityAdvisoryPerformedSecurityAdvisory,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecurityAdvisoryPerformedAction {
    #[educe(Default)]
    #[serde(rename = "performed")]
    Performed,
}
impl ToString for SecurityAdvisoryPerformedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Performed => "performed".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPerformedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "performed" => Ok(Self::Performed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPerformedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem {
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublished {
    pub action: SecurityAdvisoryPublishedAction,
    pub security_advisory: SecurityAdvisoryPublishedSecurityAdvisory,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecurityAdvisoryPublishedAction {
    #[educe(Default)]
    #[serde(rename = "published")]
    Published,
}
impl ToString for SecurityAdvisoryPublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPublishedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem {
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdated {
    pub action: SecurityAdvisoryUpdatedAction,
    pub security_advisory: SecurityAdvisoryUpdatedSecurityAdvisory,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecurityAdvisoryUpdatedAction {
    #[educe(Default)]
    #[serde(rename = "updated")]
    Updated,
}
impl ToString for SecurityAdvisoryUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisory {
    pub cvss: SecurityAdvisoryUpdatedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem {
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawn {
    pub action: SecurityAdvisoryWithdrawnAction,
    pub security_advisory: SecurityAdvisoryWithdrawnSecurityAdvisory,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SecurityAdvisoryWithdrawnAction {
    #[educe(Default)]
    #[serde(rename = "withdrawn")]
    Withdrawn,
}
impl ToString for SecurityAdvisoryWithdrawnAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Withdrawn => "withdrawn".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryWithdrawnAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisory {
    pub cvss: SecurityAdvisoryWithdrawnSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem {
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequest {
    pub active_lock_reason: Option<SimplePullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: SimplePullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    pub draft: bool,
    pub head: SimplePullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: SimplePullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<SimplePullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: SimplePullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SimplePullRequestActiveLockReason {
    #[educe(Default)]
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ToString for SimplePullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SimplePullRequestRequestedReviewersItem {
    #[educe(Default)]
    User(User),
    Team(Team),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SimplePullRequestState {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ToString for SimplePullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelled {
    pub action: SponsorshipCancelledAction,
    pub sender: User,
    pub sponsorship: SponsorshipCancelledSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipCancelledAction {
    #[educe(Default)]
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl ToString for SponsorshipCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelledSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreated {
    pub action: SponsorshipCreatedAction,
    pub sender: User,
    pub sponsorship: SponsorshipCreatedSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for SponsorshipCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreatedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEdited {
    pub action: SponsorshipEditedAction,
    pub changes: SponsorshipEditedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipEditedSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for SponsorshipEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy_level: Option<SponsorshipEditedChangesPrivacyLevel>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChangesPrivacyLevel {
    #[doc = "The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum SponsorshipEvent {
    #[educe(Default)]
    #[doc = "sponsorship cancelled event"]
    #[serde(rename = "cancelled")]
    Cancelled {
        sender: User,
        sponsorship: SponsorshipCancelledSponsorship,
    },
    #[doc = "sponsorship created event"]
    #[serde(rename = "created")]
    Created {
        sender: User,
        sponsorship: SponsorshipCreatedSponsorship,
    },
    #[doc = "sponsorship edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: SponsorshipEditedChanges,
        sender: User,
        sponsorship: SponsorshipEditedSponsorship,
    },
    #[doc = "sponsorship pending_cancellation event"]
    #[serde(rename = "pending_cancellation")]
    PendingCancellation {
        #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        effective_date: Option<String>,
        sender: User,
        sponsorship: SponsorshipPendingCancellationSponsorship,
    },
    #[doc = "sponsorship pending_tier_change event"]
    #[serde(rename = "pending_tier_change")]
    PendingTierChange {
        changes: SponsorshipPendingTierChangeChanges,
        #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        effective_date: Option<String>,
        sender: User,
        sponsorship: SponsorshipPendingTierChangeSponsorship,
    },
    #[doc = "sponsorship tier_changed event"]
    #[serde(rename = "tier_changed")]
    TierChanged {
        changes: SponsorshipTierChangedChanges,
        sender: User,
        sponsorship: SponsorshipTierChangedSponsorship,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellation {
    pub action: SponsorshipPendingCancellationAction,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingCancellationSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipPendingCancellationAction {
    #[educe(Default)]
    #[serde(rename = "pending_cancellation")]
    PendingCancellation,
}
impl ToString for SponsorshipPendingCancellationAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingCancellation => "pending_cancellation".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingCancellationAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_cancellation" => Ok(Self::PendingCancellation),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellationSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChange {
    pub action: SponsorshipPendingTierChangeAction,
    pub changes: SponsorshipPendingTierChangeChanges,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingTierChangeSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipPendingTierChangeAction {
    #[educe(Default)]
    #[serde(rename = "pending_tier_change")]
    PendingTierChange,
}
impl ToString for SponsorshipPendingTierChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingTierChange => "pending_tier_change".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingTierChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_tier_change" => Ok(Self::PendingTierChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChanges {
    pub tier: SponsorshipPendingTierChangeChangesTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChangesTier {
    pub from: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[doc = "The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTier {
    pub created_at: String,
    pub description: String,
    pub is_custom_ammount: bool,
    pub is_one_time: bool,
    pub monthly_price_in_cents: i64,
    pub monthly_price_in_dollars: i64,
    pub name: String,
    pub node_id: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChanged {
    pub action: SponsorshipTierChangedAction,
    pub changes: SponsorshipTierChangedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipTierChangedSponsorship,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SponsorshipTierChangedAction {
    #[educe(Default)]
    #[serde(rename = "tier_changed")]
    TierChanged,
}
impl ToString for SponsorshipTierChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::TierChanged => "tier_changed".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipTierChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tier_changed" => Ok(Self::TierChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChanges {
    pub tier: SponsorshipTierChangedChangesTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChangesTier {
    pub from: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarCreated {
    pub action: StarCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StarCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for StarCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for StarCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarDeleted {
    pub action: StarDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: (),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StarDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for StarDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for StarDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum StarEvent {
    #[educe(Default)]
    #[doc = "star created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
        starred_at: String,
    },
    #[doc = "star deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
        starred_at: (),
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    #[doc = "An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."]
    pub branches: Vec<StatusEventBranchesItem>,
    pub commit: StatusEventCommit,
    pub context: String,
    pub created_at: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: Option<String>,
    #[doc = "The unique identifier of the status."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The Commit SHA."]
    pub sha: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: StatusEventState,
    #[doc = "The optional link added to the status."]
    pub target_url: Option<String>,
    pub updated_at: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItem {
    pub commit: StatusEventBranchesItemCommit,
    pub name: String,
    pub protected: bool,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItemCommit {
    pub sha: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommit {
    pub author: Option<User>,
    pub comments_url: String,
    pub commit: StatusEventCommitCommit,
    pub committer: Option<User>,
    pub html_url: String,
    pub node_id: String,
    pub parents: Vec<StatusEventCommitParentsItem>,
    pub sha: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommit {
    pub author: Committer,
    pub comment_count: i64,
    pub committer: Committer,
    pub message: String,
    pub tree: StatusEventCommitCommitTree,
    pub url: String,
    pub verification: StatusEventCommitCommitVerification,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitTree {
    pub sha: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitVerification {
    pub payload: Option<String>,
    pub reason: StatusEventCommitCommitVerificationReason,
    pub signature: Option<String>,
    pub verified: bool,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StatusEventCommitCommitVerificationReason {
    #[educe(Default)]
    #[serde(rename = "expired_key")]
    ExpiredKey,
    #[serde(rename = "not_signing_key")]
    NotSigningKey,
    #[serde(rename = "gpgverify_error")]
    GpgverifyError,
    #[serde(rename = "gpgverify_unavailable")]
    GpgverifyUnavailable,
    #[serde(rename = "unsigned")]
    Unsigned,
    #[serde(rename = "unknown_signature_type")]
    UnknownSignatureType,
    #[serde(rename = "no_user")]
    NoUser,
    #[serde(rename = "unverified_email")]
    UnverifiedEmail,
    #[serde(rename = "bad_email")]
    BadEmail,
    #[serde(rename = "unknown_key")]
    UnknownKey,
    #[serde(rename = "malformed_signature")]
    MalformedSignature,
    #[serde(rename = "invalid")]
    Invalid,
    #[serde(rename = "valid")]
    Valid,
}
impl ToString for StatusEventCommitCommitVerificationReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ExpiredKey => "expired_key".to_string(),
            Self::NotSigningKey => "not_signing_key".to_string(),
            Self::GpgverifyError => "gpgverify_error".to_string(),
            Self::GpgverifyUnavailable => "gpgverify_unavailable".to_string(),
            Self::Unsigned => "unsigned".to_string(),
            Self::UnknownSignatureType => "unknown_signature_type".to_string(),
            Self::NoUser => "no_user".to_string(),
            Self::UnverifiedEmail => "unverified_email".to_string(),
            Self::BadEmail => "bad_email".to_string(),
            Self::UnknownKey => "unknown_key".to_string(),
            Self::MalformedSignature => "malformed_signature".to_string(),
            Self::Invalid => "invalid".to_string(),
            Self::Valid => "valid".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventCommitCommitVerificationReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "expired_key" => Ok(Self::ExpiredKey),
            "not_signing_key" => Ok(Self::NotSigningKey),
            "gpgverify_error" => Ok(Self::GpgverifyError),
            "gpgverify_unavailable" => Ok(Self::GpgverifyUnavailable),
            "unsigned" => Ok(Self::Unsigned),
            "unknown_signature_type" => Ok(Self::UnknownSignatureType),
            "no_user" => Ok(Self::NoUser),
            "unverified_email" => Ok(Self::UnverifiedEmail),
            "bad_email" => Ok(Self::BadEmail),
            "unknown_key" => Ok(Self::UnknownKey),
            "malformed_signature" => Ok(Self::MalformedSignature),
            "invalid" => Ok(Self::Invalid),
            "valid" => Ok(Self::Valid),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitParentsItem {
    pub html_url: String,
    pub sha: String,
    pub url: String,
}
#[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StatusEventState {
    #[educe(Default)]
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "error")]
    Error,
}
impl ToString for StatusEventState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "pending".to_string(),
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending" => Ok(Self::Pending),
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Team {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<TeamParent>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub repository: Repository,
    pub sender: User,
    pub team: Team,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddedToRepository {
    pub action: TeamAddedToRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamAddedToRepositoryAction {
    #[educe(Default)]
    #[serde(rename = "added_to_repository")]
    AddedToRepository,
}
impl ToString for TeamAddedToRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AddedToRepository => "added_to_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamAddedToRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added_to_repository" => Ok(Self::AddedToRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamCreated {
    pub action: TeamCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamCreatedAction {
    #[educe(Default)]
    #[serde(rename = "created")]
    Created,
}
impl ToString for TeamCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for TeamCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamDeleted {
    pub action: TeamDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamDeletedAction {
    #[educe(Default)]
    #[serde(rename = "deleted")]
    Deleted,
}
impl ToString for TeamDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for TeamDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEdited {
    pub action: TeamEditedAction,
    pub changes: TeamEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamEditedAction {
    #[educe(Default)]
    #[serde(rename = "edited")]
    Edited,
}
impl ToString for TeamEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for TeamEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the team if the action was `edited`."]
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<TeamEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<TeamEditedChangesName>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<TeamEditedChangesPrivacy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TeamEditedChangesRepository>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesPrivacy {
    #[doc = "The previous version of the team's privacy if the action was `edited`."]
    pub from: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepository {
    pub permissions: TeamEditedChangesRepositoryPermissions,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissions {
    pub from: TeamEditedChangesRepositoryPermissionsFrom,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissionsFrom {
    #[doc = "The previous version of the team member's `admin` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin: Option<bool>,
    #[doc = "The previous version of the team member's `pull` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull: Option<bool>,
    #[doc = "The previous version of the team member's `push` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push: Option<bool>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum TeamEvent {
    #[educe(Default)]
    #[doc = "team added_to_repository event"]
    #[serde(rename = "added_to_repository")]
    AddedToRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        repository: Option<Repository>,
        sender: User,
        team: Team,
    },
    #[doc = "team created event"]
    #[serde(rename = "created")]
    Created {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        repository: Option<Repository>,
        sender: User,
        team: Team,
    },
    #[doc = "team deleted event"]
    #[serde(rename = "deleted")]
    Deleted {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        repository: Option<Repository>,
        sender: User,
        team: Team,
    },
    #[doc = "team edited event"]
    #[serde(rename = "edited")]
    Edited {
        changes: TeamEditedChanges,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        repository: Option<Repository>,
        sender: User,
        team: Team,
    },
    #[doc = "team removed_from_repository event"]
    #[serde(rename = "removed_from_repository")]
    RemovedFromRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        organization: Organization,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        repository: Option<Repository>,
        sender: User,
        team: Team,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamParent {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamParentPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamParentPrivacy {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl ToString for TeamParentPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamParentPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamPrivacy {
    #[educe(Default)]
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl ToString for TeamPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamRemovedFromRepository {
    pub action: TeamRemovedFromRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TeamRemovedFromRepositoryAction {
    #[educe(Default)]
    #[serde(rename = "removed_from_repository")]
    RemovedFromRepository,
}
impl ToString for TeamRemovedFromRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RemovedFromRepository => "removed_from_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamRemovedFromRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed_from_repository" => Ok(Self::RemovedFromRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct User {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: UserType,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum UserType {
    #[educe(Default)]
    Bot,
    User,
    Organization,
}
impl ToString for UserType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for UserType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for UserType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for UserType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum WatchEvent {
    #[educe(Default)]
    #[doc = "watch started event"]
    #[serde(rename = "started")]
    Started {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WatchStarted {
    pub action: WatchStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WatchStartedAction {
    #[educe(Default)]
    #[serde(rename = "started")]
    Started,
}
impl ToString for WatchStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WatchStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WebhookEvents {
    #[educe(Default)]
    Variant0(Vec<WebhookEventsVariant0Item>),
    Variant1(Vec<String>),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WebhookEventsVariant0Item {
    #[educe(Default)]
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "meta")]
    Meta,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "repository_import")]
    RepositoryImport,
    #[serde(rename = "repository_vulnerability_alert")]
    RepositoryVulnerabilityAlert,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ToString for WebhookEventsVariant0Item {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Meta => "meta".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::RepositoryImport => "repository_import".to_string(),
            Self::RepositoryVulnerabilityAlert => "repository_vulnerability_alert".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for WebhookEventsVariant0Item {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "meta" => Ok(Self::Meta),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "repository_import" => Ok(Self::RepositoryImport),
            "repository_vulnerability_alert" => Ok(Self::RepositoryVulnerabilityAlert),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Workflow {
    pub badge_url: String,
    pub created_at: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    pub path: String,
    pub state: String,
    pub updated_at: String,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowDispatchEvent {
    pub inputs: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
    pub workflow: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJob {
    pub check_run_url: String,
    pub completed_at: Option<String>,
    pub conclusion: Option<WorkflowJobConclusion>,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: String,
    pub status: WorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompleted {
    pub action: WorkflowJobCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJob,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobCompletedAction {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for WorkflowJobCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl ToString for WorkflowJobConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum WorkflowJobEvent {
    #[educe(Default)]
    #[doc = "workflow_job completed event"]
    #[serde(rename = "completed")]
    Completed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow_job: WorkflowJob,
    },
    #[doc = "workflow_job queued event"]
    #[serde(rename = "queued")]
    Queued {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow_job: WorkflowJobQueuedWorkflowJob,
    },
    #[doc = "workflow_job started event"]
    #[serde(rename = "started")]
    Started {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow_job: WorkflowJob,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueued {
    pub action: WorkflowJobQueuedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobQueuedWorkflowJob,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobQueuedAction {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for WorkflowJobQueuedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueuedWorkflowJob {
    pub check_run_url: String,
    pub completed_at: (),
    pub conclusion: (),
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: chrono::DateTime<chrono::offset::Utc>,
    pub status: WorkflowJobQueuedWorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobQueuedWorkflowJobStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for WorkflowJobQueuedWorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedWorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStarted {
    pub action: WorkflowJobStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJob,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobStartedAction {
    #[educe(Default)]
    #[serde(rename = "started")]
    Started,
}
impl ToString for WorkflowJobStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowJobStatus {
    #[educe(Default)]
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for WorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRun {
    pub artifacts_url: String,
    pub cancel_url: String,
    pub check_suite_id: i64,
    pub check_suite_node_id: String,
    pub check_suite_url: String,
    pub conclusion: Option<WorkflowRunConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub event: String,
    pub head_branch: String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub jobs_url: String,
    pub logs_url: String,
    pub name: String,
    pub node_id: String,
    pub pull_requests: Vec<WorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: String,
    pub run_number: i64,
    pub status: WorkflowRunStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub workflow_id: i64,
    pub workflow_url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompleted {
    pub action: WorkflowRunCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowRunCompletedAction {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for WorkflowRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowRunConclusion {
    #[educe(Default)]
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ToString for WorkflowRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "action", deny_unknown_fields)]
pub enum WorkflowRunEvent {
    #[educe(Default)]
    #[doc = "workflow_run completed event"]
    #[serde(rename = "completed")]
    Completed {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow: Workflow,
        workflow_run: WorkflowRun,
    },
    #[doc = "workflow_run requested event"]
    #[serde(rename = "requested")]
    Requested {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        repository: Repository,
        sender: User,
        workflow: Workflow,
        workflow_run: WorkflowRun,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItem {
    pub base: WorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunRequested {
    pub action: WorkflowRunRequestedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowRunRequestedAction {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
}
impl ToString for WorkflowRunRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowRunStatus {
    #[educe(Default)]
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ToString for WorkflowRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(tag = "status", deny_unknown_fields)]
pub enum WorkflowStep {
    #[educe(Default)]
    #[doc = "Workflow Step (In Progress)"]
    #[serde(rename = "in_progress")]
    InProgress {
        completed_at: (),
        conclusion: (),
        name: String,
        number: i64,
        started_at: String,
    },
    #[doc = "Workflow Step (Completed)"]
    #[serde(rename = "completed")]
    Completed {
        completed_at: String,
        conclusion: WorkflowStepCompletedConclusion,
        name: String,
        number: i64,
        started_at: String,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepCompleted {
    pub completed_at: String,
    pub conclusion: WorkflowStepCompletedConclusion,
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepCompletedStatus,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowStepCompletedConclusion {
    #[educe(Default)]
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "skipped")]
    Skipped,
    #[serde(rename = "success")]
    Success,
}
impl ToString for WorkflowStepCompletedConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Failure => "failure".to_string(),
            Self::Skipped => "skipped".to_string(),
            Self::Success => "success".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "failure" => Ok(Self::Failure),
            "skipped" => Ok(Self::Skipped),
            "success" => Ok(Self::Success),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowStepCompletedStatus {
    #[educe(Default)]
    #[serde(rename = "completed")]
    Completed,
}
impl ToString for WorkflowStepCompletedStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepInProgress {
    pub completed_at: (),
    pub conclusion: (),
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepInProgressStatus,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WorkflowStepInProgressStatus {
    #[educe(Default)]
    #[serde(rename = "in_progress")]
    InProgress,
}
impl ToString for WorkflowStepInProgressStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepInProgressStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
}
