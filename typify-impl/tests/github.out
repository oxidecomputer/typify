#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstance {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub classifications: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit_sha: Option<String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<AlertInstanceLocation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AlertInstanceMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "State of a code scanning alert."]
    pub state: AlertInstanceState,
}
impl From<&AlertInstance> for AlertInstance {
    fn from(value: &AlertInstance) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceLocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_line: Option<i64>,
}
impl From<&AlertInstanceLocation> for AlertInstanceLocation {
    fn from(value: &AlertInstanceLocation) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}
impl From<&AlertInstanceMessage> for AlertInstanceMessage {
    fn from(value: &AlertInstanceMessage) -> Self {
        value.clone()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlertInstanceState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&AlertInstanceState> for AlertInstanceState {
    fn from(value: &AlertInstanceState) -> Self {
        value.clone()
    }
}
impl ToString for AlertInstanceState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for AlertInstanceState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlertInstanceState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct App {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    #[doc = "The list of events for the GitHub app"]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<AppEventsItem>,
    pub external_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The name of the GitHub app"]
    pub name: String,
    pub node_id: String,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slug: Option<String>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&App> for App {
    fn from(value: &App) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&AppEventsItem> for AppEventsItem {
    fn from(value: &AppEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for AppEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for AppEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The set of permissions for the GitHub app"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AppPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<AppPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<AppPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<AppPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<AppPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<AppPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<AppPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<AppPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<AppPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<AppPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<AppPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<AppPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<AppPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<AppPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<AppPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<AppPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<AppPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<AppPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<AppPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners: Option<AppPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<AppPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<AppPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<AppPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<AppPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<AppPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<AppPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<AppPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<AppPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<AppPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<AppPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<AppPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<AppPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<AppPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<AppPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<AppPermissionsWorkflows>,
}
impl From<&AppPermissions> for AppPermissions {
    fn from(value: &AppPermissions) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsActions> for AppPermissionsActions {
    fn from(value: &AppPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsAdministration> for AppPermissionsAdministration {
    fn from(value: &AppPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsChecks> for AppPermissionsChecks {
    fn from(value: &AppPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsContentReferences> for AppPermissionsContentReferences {
    fn from(value: &AppPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsContents> for AppPermissionsContents {
    fn from(value: &AppPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsDeployments> for AppPermissionsDeployments {
    fn from(value: &AppPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsDiscussions> for AppPermissionsDiscussions {
    fn from(value: &AppPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsEmails> for AppPermissionsEmails {
    fn from(value: &AppPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsEnvironments> for AppPermissionsEnvironments {
    fn from(value: &AppPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsIssues> for AppPermissionsIssues {
    fn from(value: &AppPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsMembers> for AppPermissionsMembers {
    fn from(value: &AppPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsMetadata> for AppPermissionsMetadata {
    fn from(value: &AppPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationAdministration> for AppPermissionsOrganizationAdministration {
    fn from(value: &AppPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationHooks> for AppPermissionsOrganizationHooks {
    fn from(value: &AppPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationPackages> for AppPermissionsOrganizationPackages {
    fn from(value: &AppPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationPlan> for AppPermissionsOrganizationPlan {
    fn from(value: &AppPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationProjects> for AppPermissionsOrganizationProjects {
    fn from(value: &AppPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationSecrets> for AppPermissionsOrganizationSecrets {
    fn from(value: &AppPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationSelfHostedRunners>
    for AppPermissionsOrganizationSelfHostedRunners
{
    fn from(value: &AppPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsOrganizationUserBlocking> for AppPermissionsOrganizationUserBlocking {
    fn from(value: &AppPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPackages> for AppPermissionsPackages {
    fn from(value: &AppPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPages> for AppPermissionsPages {
    fn from(value: &AppPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsPullRequests> for AppPermissionsPullRequests {
    fn from(value: &AppPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsRepositoryHooks> for AppPermissionsRepositoryHooks {
    fn from(value: &AppPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsRepositoryProjects> for AppPermissionsRepositoryProjects {
    fn from(value: &AppPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecretScanningAlerts> for AppPermissionsSecretScanningAlerts {
    fn from(value: &AppPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecrets> for AppPermissionsSecrets {
    fn from(value: &AppPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecurityEvents> for AppPermissionsSecurityEvents {
    fn from(value: &AppPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSecurityScanningAlert> for AppPermissionsSecurityScanningAlert {
    fn from(value: &AppPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsSingleFile> for AppPermissionsSingleFile {
    fn from(value: &AppPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsStatuses> for AppPermissionsStatuses {
    fn from(value: &AppPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsTeamDiscussions> for AppPermissionsTeamDiscussions {
    fn from(value: &AppPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsVulnerabilityAlerts> for AppPermissionsVulnerabilityAlerts {
    fn from(value: &AppPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&AppPermissionsWorkflows> for AppPermissionsWorkflows {
    fn from(value: &AppPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for AppPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for AppPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AppPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "How the author is associated with the repository."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AuthorAssociation {
    #[serde(rename = "COLLABORATOR")]
    Collaborator,
    #[serde(rename = "CONTRIBUTOR")]
    Contributor,
    #[serde(rename = "FIRST_TIMER")]
    FirstTimer,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    FirstTimeContributor,
    #[serde(rename = "MANNEQUIN")]
    Mannequin,
    #[serde(rename = "MEMBER")]
    Member,
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OWNER")]
    Owner,
}
impl From<&AuthorAssociation> for AuthorAssociation {
    fn from(value: &AuthorAssociation) -> Self {
        value.clone()
    }
}
impl ToString for AuthorAssociation {
    fn to_string(&self) -> String {
        match *self {
            Self::Collaborator => "COLLABORATOR".to_string(),
            Self::Contributor => "CONTRIBUTOR".to_string(),
            Self::FirstTimer => "FIRST_TIMER".to_string(),
            Self::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR".to_string(),
            Self::Mannequin => "MANNEQUIN".to_string(),
            Self::Member => "MEMBER".to_string(),
            Self::None => "NONE".to_string(),
            Self::Owner => "OWNER".to_string(),
        }
    }
}
impl std::str::FromStr for AuthorAssociation {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "COLLABORATOR" => Ok(Self::Collaborator),
            "CONTRIBUTOR" => Ok(Self::Contributor),
            "FIRST_TIMER" => Ok(Self::FirstTimer),
            "FIRST_TIME_CONTRIBUTOR" => Ok(Self::FirstTimeContributor),
            "MANNEQUIN" => Ok(Self::Mannequin),
            "MEMBER" => Ok(Self::Member),
            "NONE" => Ok(Self::None),
            "OWNER" => Ok(Self::Owner),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AuthorAssociation {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRule {
    pub admin_enforced: bool,
    pub allow_deletions_enforcement_level: BranchProtectionRuleAllowDeletionsEnforcementLevel,
    pub allow_force_pushes_enforcement_level: BranchProtectionRuleAllowForcePushesEnforcementLevel,
    pub authorized_actor_names: Vec<String>,
    pub authorized_actors_only: bool,
    pub authorized_dismissal_actors_only: bool,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismiss_stale_reviews_on_push: bool,
    pub id: i64,
    pub ignore_approvals_from_contributors: bool,
    pub linear_history_requirement_enforcement_level:
        BranchProtectionRuleLinearHistoryRequirementEnforcementLevel,
    pub merge_queue_enforcement_level: BranchProtectionRuleMergeQueueEnforcementLevel,
    pub name: String,
    pub pull_request_reviews_enforcement_level:
        BranchProtectionRulePullRequestReviewsEnforcementLevel,
    pub repository_id: i64,
    pub require_code_owner_review: bool,
    pub required_approving_review_count: i64,
    pub required_conversation_resolution_level:
        BranchProtectionRuleRequiredConversationResolutionLevel,
    pub required_deployments_enforcement_level:
        BranchProtectionRuleRequiredDeploymentsEnforcementLevel,
    pub required_status_checks: Vec<String>,
    pub required_status_checks_enforcement_level:
        BranchProtectionRuleRequiredStatusChecksEnforcementLevel,
    pub signature_requirement_enforcement_level:
        BranchProtectionRuleSignatureRequirementEnforcementLevel,
    pub strict_required_status_checks_policy: bool,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&BranchProtectionRule> for BranchProtectionRule {
    fn from(value: &BranchProtectionRule) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleAllowDeletionsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleAllowDeletionsEnforcementLevel>
    for BranchProtectionRuleAllowDeletionsEnforcementLevel
{
    fn from(value: &BranchProtectionRuleAllowDeletionsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleAllowForcePushesEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleAllowForcePushesEnforcementLevel>
    for BranchProtectionRuleAllowForcePushesEnforcementLevel
{
    fn from(value: &BranchProtectionRuleAllowForcePushesEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleCreated {
    pub action: BranchProtectionRuleCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleCreated> for BranchProtectionRuleCreated {
    fn from(value: &BranchProtectionRuleCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&BranchProtectionRuleCreatedAction> for BranchProtectionRuleCreatedAction {
    fn from(value: &BranchProtectionRuleCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleDeleted {
    pub action: BranchProtectionRuleDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleDeleted> for BranchProtectionRuleDeleted {
    fn from(value: &BranchProtectionRuleDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&BranchProtectionRuleDeletedAction> for BranchProtectionRuleDeletedAction {
    fn from(value: &BranchProtectionRuleDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEdited {
    pub action: BranchProtectionRuleEditedAction,
    pub changes: BranchProtectionRuleEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl From<&BranchProtectionRuleEdited> for BranchProtectionRuleEdited {
    fn from(value: &BranchProtectionRuleEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&BranchProtectionRuleEditedAction> for BranchProtectionRuleEditedAction {
    fn from(value: &BranchProtectionRuleEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "If the action was `edited`, the changes to the rule."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actor_names: Option<BranchProtectionRuleEditedChangesAuthorizedActorNames>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorized_actors_only: Option<BranchProtectionRuleEditedChangesAuthorizedActorsOnly>,
}
impl From<&BranchProtectionRuleEditedChanges> for BranchProtectionRuleEditedChanges {
    fn from(value: &BranchProtectionRuleEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorNames {
    pub from: Vec<String>,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorNames>
    for BranchProtectionRuleEditedChangesAuthorizedActorNames
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorNames) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorsOnly {
    pub from: bool,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorsOnly>
    for BranchProtectionRuleEditedChangesAuthorizedActorsOnly
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorsOnly) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BranchProtectionRuleEvent {
    Created(BranchProtectionRuleCreated),
    Deleted(BranchProtectionRuleDeleted),
    Edited(BranchProtectionRuleEdited),
}
impl From<&BranchProtectionRuleEvent> for BranchProtectionRuleEvent {
    fn from(value: &BranchProtectionRuleEvent) -> Self {
        value.clone()
    }
}
impl From<BranchProtectionRuleCreated> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleCreated) -> Self {
        Self::Created(value)
    }
}
impl From<BranchProtectionRuleDeleted> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<BranchProtectionRuleEdited> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleEdited) -> Self {
        Self::Edited(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleLinearHistoryRequirementEnforcementLevel>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    fn from(value: &BranchProtectionRuleLinearHistoryRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleMergeQueueEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleMergeQueueEnforcementLevel>
    for BranchProtectionRuleMergeQueueEnforcementLevel
{
    fn from(value: &BranchProtectionRuleMergeQueueEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleMergeQueueEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRulePullRequestReviewsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRulePullRequestReviewsEnforcementLevel>
    for BranchProtectionRulePullRequestReviewsEnforcementLevel
{
    fn from(value: &BranchProtectionRulePullRequestReviewsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredConversationResolutionLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredConversationResolutionLevel>
    for BranchProtectionRuleRequiredConversationResolutionLevel
{
    fn from(value: &BranchProtectionRuleRequiredConversationResolutionLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredConversationResolutionLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredDeploymentsEnforcementLevel>
    for BranchProtectionRuleRequiredDeploymentsEnforcementLevel
{
    fn from(value: &BranchProtectionRuleRequiredDeploymentsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleRequiredStatusChecksEnforcementLevel>
    for BranchProtectionRuleRequiredStatusChecksEnforcementLevel
{
    fn from(value: &BranchProtectionRuleRequiredStatusChecksEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleSignatureRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl From<&BranchProtectionRuleSignatureRequirementEnforcementLevel>
    for BranchProtectionRuleSignatureRequirementEnforcementLevel
{
    fn from(value: &BranchProtectionRuleSignatureRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ToString for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    fn to_string(&self) -> String {
        match *self {
            Self::Off => "off".to_string(),
            Self::NonAdmins => "non_admins".to_string(),
            Self::Everyone => "everyone".to_string(),
        }
    }
}
impl std::str::FromStr for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompleted {
    pub action: CheckRunCompletedAction,
    pub check_run: CheckRunCompletedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCompletedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunCompleted> for CheckRunCompleted {
    fn from(value: &CheckRunCompleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCompletedAction> for CheckRunCompletedAction {
    fn from(value: &CheckRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCompletedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCompletedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCompletedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCompletedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunCompletedCheckRun> for CheckRunCompletedCheckRun {
    fn from(value: &CheckRunCompletedCheckRun) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCompletedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCompletedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunCompletedCheckRunCheckSuite> for CheckRunCompletedCheckRunCheckSuite {
    fn from(value: &CheckRunCompletedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteConclusion>
    for CheckRunCompletedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteStatus {
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteStatus>
    for CheckRunCompletedCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunCompletedCheckRunConclusion> for CheckRunCompletedCheckRunConclusion {
    fn from(value: &CheckRunCompletedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunCompletedCheckRunOutput> for CheckRunCompletedCheckRunOutput {
    fn from(value: &CheckRunCompletedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCompletedCheckRunStatus> for CheckRunCompletedCheckRunStatus {
    fn from(value: &CheckRunCompletedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCompletedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCompletedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunCompletedRequestedAction> for CheckRunCompletedRequestedAction {
    fn from(value: &CheckRunCompletedRequestedAction) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreated {
    pub action: CheckRunCreatedAction,
    pub check_run: CheckRunCreatedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunCreatedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunCreated> for CheckRunCreated {
    fn from(value: &CheckRunCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CheckRunCreatedAction> for CheckRunCreatedAction {
    fn from(value: &CheckRunCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCreatedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunCreatedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunCreatedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCreatedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunCreatedCheckRun> for CheckRunCreatedCheckRun {
    fn from(value: &CheckRunCreatedCheckRun) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunCreatedCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunCreatedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunCreatedCheckRunCheckSuite> for CheckRunCreatedCheckRunCheckSuite {
    fn from(value: &CheckRunCreatedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteConclusion>
    for CheckRunCreatedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteStatus> for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunCreatedCheckRunConclusion> for CheckRunCreatedCheckRunConclusion {
    fn from(value: &CheckRunCreatedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunCreatedCheckRunOutput> for CheckRunCreatedCheckRunOutput {
    fn from(value: &CheckRunCreatedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunCreatedCheckRunStatus> for CheckRunCreatedCheckRunStatus {
    fn from(value: &CheckRunCreatedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunCreatedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunCreatedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunCreatedRequestedAction> for CheckRunCreatedRequestedAction {
    fn from(value: &CheckRunCreatedRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunDeployment {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: Option<String>,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub repository_url: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunDeployment> for CheckRunDeployment {
    fn from(value: &CheckRunDeployment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckRunEvent {
    Completed(CheckRunCompleted),
    Created(CheckRunCreated),
    RequestedAction(CheckRunRequestedAction),
    Rerequested(CheckRunRerequested),
}
impl From<&CheckRunEvent> for CheckRunEvent {
    fn from(value: &CheckRunEvent) -> Self {
        value.clone()
    }
}
impl From<CheckRunCompleted> for CheckRunEvent {
    fn from(value: CheckRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<CheckRunCreated> for CheckRunEvent {
    fn from(value: CheckRunCreated) -> Self {
        Self::Created(value)
    }
}
impl From<CheckRunRequestedAction> for CheckRunEvent {
    fn from(value: CheckRunRequestedAction) -> Self {
        Self::RequestedAction(value)
    }
}
impl From<CheckRunRerequested> for CheckRunEvent {
    fn from(value: CheckRunRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequest {
    pub base: CheckRunPullRequestBase,
    pub head: CheckRunPullRequestHead,
    pub id: i64,
    pub number: i64,
    pub url: String,
}
impl From<&CheckRunPullRequest> for CheckRunPullRequest {
    fn from(value: &CheckRunPullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&CheckRunPullRequestBase> for CheckRunPullRequestBase {
    fn from(value: &CheckRunPullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&CheckRunPullRequestHead> for CheckRunPullRequestHead {
    fn from(value: &CheckRunPullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedAction {
    pub action: CheckRunRequestedActionAction,
    pub check_run: CheckRunRequestedActionCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub requested_action: CheckRunRequestedActionRequestedAction,
    pub sender: User,
}
impl From<&CheckRunRequestedAction> for CheckRunRequestedAction {
    fn from(value: &CheckRunRequestedAction) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionAction {
    #[serde(rename = "requested_action")]
    RequestedAction,
}
impl From<&CheckRunRequestedActionAction> for CheckRunRequestedActionAction {
    fn from(value: &CheckRunRequestedActionAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RequestedAction => "requested_action".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested_action" => Ok(Self::RequestedAction),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRun {
    pub app: App,
    pub check_suite: CheckRunRequestedActionCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: Option<String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckRunRequestedActionCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRequestedActionCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunRequestedActionCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunRequestedActionCheckRun> for CheckRunRequestedActionCheckRun {
    fn from(value: &CheckRunRequestedActionCheckRun) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: Option<CheckRunRequestedActionCheckRunCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRequestedActionCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuite>
    for CheckRunRequestedActionCheckRunCheckSuite
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteConclusion>
    for CheckRunRequestedActionCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteStatus>
    for CheckRunRequestedActionCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunRequestedActionCheckRunConclusion>
    for CheckRunRequestedActionCheckRunConclusion
{
    fn from(value: &CheckRunRequestedActionCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunRequestedActionCheckRunOutput> for CheckRunRequestedActionCheckRunOutput {
    fn from(value: &CheckRunRequestedActionCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRequestedActionCheckRunStatus> for CheckRunRequestedActionCheckRunStatus {
    fn from(value: &CheckRunRequestedActionCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRequestedActionCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunRequestedActionRequestedAction> for CheckRunRequestedActionRequestedAction {
    fn from(value: &CheckRunRequestedActionRequestedAction) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequested {
    pub action: CheckRunRerequestedAction,
    pub check_run: CheckRunRerequestedCheckRun,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requested_action: Option<CheckRunRerequestedRequestedAction>,
    pub sender: User,
}
impl From<&CheckRunRerequested> for CheckRunRerequested {
    fn from(value: &CheckRunRerequested) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl From<&CheckRunRerequestedAction> for CheckRunRerequestedAction {
    fn from(value: &CheckRunRerequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRun {
    pub app: App,
    pub check_suite: CheckRunRerequestedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckRunRerequestedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details_url: Option<String>,
    pub external_id: String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: String,
    pub html_url: String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    pub output: CheckRunRerequestedCheckRunOutput,
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: String,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: CheckRunRerequestedCheckRunStatus,
    pub url: String,
}
impl From<&CheckRunRerequestedCheckRun> for CheckRunRerequestedCheckRun {
    fn from(value: &CheckRunRerequestedCheckRun) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunCheckSuite {
    pub after: Option<String>,
    pub app: App,
    pub before: Option<String>,
    pub conclusion: CheckRunRerequestedCheckRunCheckSuiteConclusion,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<CheckRunDeployment>,
    pub head_branch: Option<String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    pub status: CheckRunRerequestedCheckRunCheckSuiteStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&CheckRunRerequestedCheckRunCheckSuite> for CheckRunRerequestedCheckRunCheckSuite {
    fn from(value: &CheckRunRerequestedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteConclusion>
    for CheckRunRerequestedCheckRunCheckSuiteConclusion
{
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteStatus>
    for CheckRunRerequestedCheckRunCheckSuiteStatus
{
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl From<&CheckRunRerequestedCheckRunConclusion> for CheckRunRerequestedCheckRunConclusion {
    fn from(value: &CheckRunRerequestedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
            Self::Skipped => "skipped".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: String,
    pub summary: Option<String>,
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}
impl From<&CheckRunRerequestedCheckRunOutput> for CheckRunRerequestedCheckRunOutput {
    fn from(value: &CheckRunRerequestedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The phase of the lifecycle that the check is currently in."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckRunRerequestedCheckRunStatus> for CheckRunRerequestedCheckRunStatus {
    fn from(value: &CheckRunRerequestedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckRunRerequestedCheckRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckRunRerequestedCheckRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
}
impl From<&CheckRunRerequestedRequestedAction> for CheckRunRerequestedRequestedAction {
    fn from(value: &CheckRunRerequestedRequestedAction) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompleted {
    pub action: CheckSuiteCompletedAction,
    pub check_suite: CheckSuiteCompletedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteCompleted> for CheckSuiteCompleted {
    fn from(value: &CheckSuiteCompleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&CheckSuiteCompletedAction> for CheckSuiteCompletedAction {
    fn from(value: &CheckSuiteCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompletedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: Option<CheckSuiteCompletedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteCompletedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteCompletedCheckSuite> for CheckSuiteCompletedCheckSuite {
    fn from(value: &CheckSuiteCompletedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteCompletedCheckSuiteConclusion> for CheckSuiteCompletedCheckSuiteConclusion {
    fn from(value: &CheckSuiteCompletedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteCompletedCheckSuiteStatus> for CheckSuiteCompletedCheckSuiteStatus {
    fn from(value: &CheckSuiteCompletedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteCompletedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckSuiteEvent {
    Completed(CheckSuiteCompleted),
    Requested(CheckSuiteRequested),
    Rerequested(CheckSuiteRerequested),
}
impl From<&CheckSuiteEvent> for CheckSuiteEvent {
    fn from(value: &CheckSuiteEvent) -> Self {
        value.clone()
    }
}
impl From<CheckSuiteCompleted> for CheckSuiteEvent {
    fn from(value: CheckSuiteCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<CheckSuiteRequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRequested) -> Self {
        Self::Requested(value)
    }
}
impl From<CheckSuiteRerequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequested {
    pub action: CheckSuiteRequestedAction,
    pub check_suite: CheckSuiteRequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteRequested> for CheckSuiteRequested {
    fn from(value: &CheckSuiteRequested) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl From<&CheckSuiteRequestedAction> for CheckSuiteRequestedAction {
    fn from(value: &CheckSuiteRequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteRequestedCheckSuite> for CheckSuiteRequestedCheckSuite {
    fn from(value: &CheckSuiteRequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteRequestedCheckSuiteConclusion> for CheckSuiteRequestedCheckSuiteConclusion {
    fn from(value: &CheckSuiteRequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteRequestedCheckSuiteStatus> for CheckSuiteRequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequested {
    pub action: CheckSuiteRerequestedAction,
    pub check_suite: CheckSuiteRerequestedCheckSuite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CheckSuiteRerequested> for CheckSuiteRerequested {
    fn from(value: &CheckSuiteRerequested) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl From<&CheckSuiteRerequestedAction> for CheckSuiteRerequestedAction {
    fn from(value: &CheckSuiteRerequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Rerequested => "rerequested".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequestedCheckSuite {
    pub after: String,
    pub app: App,
    pub before: Option<String>,
    pub check_runs_url: String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: Option<CheckSuiteRerequestedCheckSuiteConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: Option<String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: Option<CheckSuiteRerequestedCheckSuiteStatus>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: String,
}
impl From<&CheckSuiteRerequestedCheckSuite> for CheckSuiteRerequestedCheckSuite {
    fn from(value: &CheckSuiteRerequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&CheckSuiteRerequestedCheckSuiteConclusion>
    for CheckSuiteRerequestedCheckSuiteConclusion
{
    fn from(value: &CheckSuiteRerequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedCheckSuiteConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&CheckSuiteRerequestedCheckSuiteStatus> for CheckSuiteRerequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRerequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ToString for CheckSuiteRerequestedCheckSuiteStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranch {
    pub action: CodeScanningAlertAppearedInBranchAction,
    pub alert: CodeScanningAlertAppearedInBranchAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertAppearedInBranch> for CodeScanningAlertAppearedInBranch {
    fn from(value: &CodeScanningAlertAppearedInBranch) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAction {
    #[serde(rename = "appeared_in_branch")]
    AppearedInBranch,
}
impl From<&CodeScanningAlertAppearedInBranchAction> for CodeScanningAlertAppearedInBranchAction {
    fn from(value: &CodeScanningAlertAppearedInBranchAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AppearedInBranch => "appeared_in_branch".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "appeared_in_branch" => Ok(Self::AppearedInBranch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertAppearedInBranchAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertAppearedInBranchAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertAppearedInBranchAlertState,
    pub tool: CodeScanningAlertAppearedInBranchAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertAppearedInBranchAlert> for CodeScanningAlertAppearedInBranchAlert {
    fn from(value: &CodeScanningAlertAppearedInBranchAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertAppearedInBranchAlertDismissedReason>
    for CodeScanningAlertAppearedInBranchAlertDismissedReason
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertAppearedInBranchAlertRuleSeverity>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRule>
    for CodeScanningAlertAppearedInBranchAlertRule
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRuleSeverity>
    for CodeScanningAlertAppearedInBranchAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertAppearedInBranchAlertState>
    for CodeScanningAlertAppearedInBranchAlertState
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertAppearedInBranchAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertTool>
    for CodeScanningAlertAppearedInBranchAlertTool
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUser {
    pub action: CodeScanningAlertClosedByUserAction,
    pub alert: CodeScanningAlertClosedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CodeScanningAlertClosedByUser> for CodeScanningAlertClosedByUser {
    fn from(value: &CodeScanningAlertClosedByUser) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAction {
    #[serde(rename = "closed_by_user")]
    ClosedByUser,
}
impl From<&CodeScanningAlertClosedByUserAction> for CodeScanningAlertClosedByUserAction {
    fn from(value: &CodeScanningAlertClosedByUserAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ClosedByUser => "closed_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed_by_user" => Ok(Self::ClosedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: chrono::DateTime<chrono::offset::Utc>,
    pub dismissed_by: User,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertClosedByUserAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertClosedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertClosedByUserAlertState,
    pub tool: CodeScanningAlertClosedByUserAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertClosedByUserAlert> for CodeScanningAlertClosedByUserAlert {
    fn from(value: &CodeScanningAlertClosedByUserAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertClosedByUserAlertDismissedReason>
    for CodeScanningAlertClosedByUserAlertDismissedReason
{
    fn from(value: &CodeScanningAlertClosedByUserAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertClosedByUserAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertClosedByUserAlertRule> for CodeScanningAlertClosedByUserAlertRule {
    fn from(value: &CodeScanningAlertClosedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertClosedByUserAlertRuleSeverity>
    for CodeScanningAlertClosedByUserAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertClosedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertClosedByUserAlertState> for CodeScanningAlertClosedByUserAlertState {
    fn from(value: &CodeScanningAlertClosedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertClosedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertClosedByUserAlertTool> for CodeScanningAlertClosedByUserAlertTool {
    fn from(value: &CodeScanningAlertClosedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreated {
    pub action: CodeScanningAlertCreatedAction,
    pub alert: CodeScanningAlertCreatedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertCreated> for CodeScanningAlertCreated {
    fn from(value: &CodeScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CodeScanningAlertCreatedAction> for CodeScanningAlertCreatedAction {
    fn from(value: &CodeScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertCreatedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertCreatedAlertState,
    pub tool: CodeScanningAlertCreatedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertCreatedAlert> for CodeScanningAlertCreatedAlert {
    fn from(value: &CodeScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertCreatedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertCreatedAlertRule> for CodeScanningAlertCreatedAlertRule {
    fn from(value: &CodeScanningAlertCreatedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertCreatedAlertRuleSeverity>
    for CodeScanningAlertCreatedAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertCreatedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&CodeScanningAlertCreatedAlertState> for CodeScanningAlertCreatedAlertState {
    fn from(value: &CodeScanningAlertCreatedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertCreatedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertCreatedAlertTool> for CodeScanningAlertCreatedAlertTool {
    fn from(value: &CodeScanningAlertCreatedAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CodeScanningAlertEvent {
    AppearedInBranch(CodeScanningAlertAppearedInBranch),
    ClosedByUser(CodeScanningAlertClosedByUser),
    Created(CodeScanningAlertCreated),
    Fixed(CodeScanningAlertFixed),
    Reopened(CodeScanningAlertReopened),
    ReopenedByUser(CodeScanningAlertReopenedByUser),
}
impl From<&CodeScanningAlertEvent> for CodeScanningAlertEvent {
    fn from(value: &CodeScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl From<CodeScanningAlertAppearedInBranch> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertAppearedInBranch) -> Self {
        Self::AppearedInBranch(value)
    }
}
impl From<CodeScanningAlertClosedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertClosedByUser) -> Self {
        Self::ClosedByUser(value)
    }
}
impl From<CodeScanningAlertCreated> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl From<CodeScanningAlertFixed> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertFixed) -> Self {
        Self::Fixed(value)
    }
}
impl From<CodeScanningAlertReopened> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<CodeScanningAlertReopenedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopenedByUser) -> Self {
        Self::ReopenedByUser(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixed {
    pub action: CodeScanningAlertFixedAction,
    pub alert: CodeScanningAlertFixedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertFixed> for CodeScanningAlertFixed {
    fn from(value: &CodeScanningAlertFixed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAction {
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertFixedAction> for CodeScanningAlertFixedAction {
    fn from(value: &CodeScanningAlertFixedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub dismissed_by: Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: Option<CodeScanningAlertFixedAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertFixedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertFixedAlertState,
    pub tool: CodeScanningAlertFixedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertFixedAlert> for CodeScanningAlertFixedAlert {
    fn from(value: &CodeScanningAlertFixedAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl From<&CodeScanningAlertFixedAlertDismissedReason>
    for CodeScanningAlertFixedAlertDismissedReason
{
    fn from(value: &CodeScanningAlertFixedAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertDismissedReason {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false positive".to_string(),
            Self::WontFix => "won't fix".to_string(),
            Self::UsedInTests => "used in tests".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertDismissedReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertFixedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertFixedAlertRule> for CodeScanningAlertFixedAlertRule {
    fn from(value: &CodeScanningAlertFixedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertFixedAlertRuleSeverity> for CodeScanningAlertFixedAlertRuleSeverity {
    fn from(value: &CodeScanningAlertFixedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertState {
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertFixedAlertState> for CodeScanningAlertFixedAlertState {
    fn from(value: &CodeScanningAlertFixedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertFixedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertFixedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertFixedAlertTool> for CodeScanningAlertFixedAlertTool {
    fn from(value: &CodeScanningAlertFixedAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopened {
    pub action: CodeScanningAlertReopenedAction,
    pub alert: CodeScanningAlertReopenedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl From<&CodeScanningAlertReopened> for CodeScanningAlertReopened {
    fn from(value: &CodeScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&CodeScanningAlertReopenedAction> for CodeScanningAlertReopenedAction {
    fn from(value: &CodeScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedAlertState,
    pub tool: CodeScanningAlertReopenedAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertReopenedAlert> for CodeScanningAlertReopenedAlert {
    fn from(value: &CodeScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_description: Option<String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl From<&CodeScanningAlertReopenedAlertRule> for CodeScanningAlertReopenedAlertRule {
    fn from(value: &CodeScanningAlertReopenedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertReopenedAlertRuleSeverity>
    for CodeScanningAlertReopenedAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertReopenedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl From<&CodeScanningAlertReopenedAlertState> for CodeScanningAlertReopenedAlertState {
    fn from(value: &CodeScanningAlertReopenedAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Dismissed => "dismissed".to_string(),
            Self::Fixed => "fixed".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertTool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guid: Option<String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedAlertTool> for CodeScanningAlertReopenedAlertTool {
    fn from(value: &CodeScanningAlertReopenedAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUser {
    pub action: CodeScanningAlertReopenedByUserAction,
    pub alert: CodeScanningAlertReopenedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CodeScanningAlertReopenedByUser> for CodeScanningAlertReopenedByUser {
    fn from(value: &CodeScanningAlertReopenedByUser) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAction {
    #[serde(rename = "reopened_by_user")]
    ReopenedByUser,
}
impl From<&CodeScanningAlertReopenedByUserAction> for CodeScanningAlertReopenedByUserAction {
    fn from(value: &CodeScanningAlertReopenedByUserAction) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReopenedByUser => "reopened_by_user".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened_by_user" => Ok(Self::ReopenedByUser),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: String,
    pub instances: Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedByUserAlertState,
    pub tool: CodeScanningAlertReopenedByUserAlertTool,
    pub url: String,
}
impl From<&CodeScanningAlertReopenedByUserAlert> for CodeScanningAlertReopenedByUserAlert {
    fn from(value: &CodeScanningAlertReopenedByUserAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: String,
    #[doc = "The severity of the alert."]
    pub severity: Option<CodeScanningAlertReopenedByUserAlertRuleSeverity>,
}
impl From<&CodeScanningAlertReopenedByUserAlertRule> for CodeScanningAlertReopenedByUserAlertRule {
    fn from(value: &CodeScanningAlertReopenedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl From<&CodeScanningAlertReopenedByUserAlertRuleSeverity>
    for CodeScanningAlertReopenedByUserAlertRuleSeverity
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Note => "note".to_string(),
            Self::Warning => "warning".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertState {
    #[serde(rename = "open")]
    Open,
}
impl From<&CodeScanningAlertReopenedByUserAlertState>
    for CodeScanningAlertReopenedByUserAlertState
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ToString for CodeScanningAlertReopenedByUserAlertState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
        }
    }
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedByUserAlertTool> for CodeScanningAlertReopenedByUserAlertTool {
    fn from(value: &CodeScanningAlertReopenedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Commit {
    #[doc = "An array of files added in the commit."]
    pub added: Vec<String>,
    pub author: Committer,
    pub committer: Committer,
    #[doc = "Whether this commit is distinct from any that have been pushed before."]
    pub distinct: bool,
    pub id: String,
    #[doc = "The commit message."]
    pub message: String,
    #[doc = "An array of files modified by the commit."]
    pub modified: Vec<String>,
    #[doc = "An array of files removed in the commit."]
    pub removed: Vec<String>,
    #[doc = "The ISO 8601 timestamp of the commit."]
    pub timestamp: String,
    pub tree_id: String,
    #[doc = "URL that points to the commit API resource."]
    pub url: String,
}
impl From<&Commit> for Commit {
    fn from(value: &Commit) -> Self {
        value.clone()
    }
}
#[doc = "A commit comment is created. The type of activity is specified in the `action` property. "]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreated {
    #[doc = "The action performed. Can be `created`."]
    pub action: CommitCommentCreatedAction,
    pub comment: CommitCommentCreatedComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CommitCommentCreated> for CommitCommentCreated {
    fn from(value: &CommitCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "The action performed. Can be `created`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CommitCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&CommitCommentCreatedAction> for CommitCommentCreatedAction {
    fn from(value: &CommitCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for CommitCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for CommitCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CommitCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreatedComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: String,
    pub html_url: String,
    #[doc = "The ID of the commit comment."]
    pub id: i64,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[doc = "The node ID of the commit comment."]
    pub node_id: String,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: Option<String>,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&CommitCommentCreatedComment> for CommitCommentCreatedComment {
    fn from(value: &CommitCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CommitCommentEvent(pub CommitCommentCreated);
impl std::ops::Deref for CommitCommentEvent {
    type Target = CommitCommentCreated;
    fn deref(&self) -> &CommitCommentCreated {
        &self.0
    }
}
impl From<CommitCommentEvent> for CommitCommentCreated {
    fn from(value: CommitCommentEvent) -> Self {
        value.0
    }
}
impl From<&CommitCommentEvent> for CommitCommentEvent {
    fn from(value: &CommitCommentEvent) -> Self {
        value.clone()
    }
}
impl From<CommitCommentCreated> for CommitCommentEvent {
    fn from(value: CommitCommentCreated) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitSimple {
    pub author: Committer,
    pub committer: Committer,
    pub id: String,
    pub message: String,
    pub timestamp: String,
    pub tree_id: String,
}
impl From<&CommitSimple> for CommitSimple {
    fn from(value: &CommitSimple) -> Self {
        value.clone()
    }
}
#[doc = "Metaproperties for Git author/committer information."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Committer {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The git author's email address."]
    pub email: Option<String>,
    #[doc = "The git author's name."]
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}
impl From<&Committer> for Committer {
    fn from(value: &Committer) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreated {
    pub action: ContentReferenceCreatedAction,
    pub content_reference: ContentReferenceCreatedContentReference,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ContentReferenceCreated> for ContentReferenceCreated {
    fn from(value: &ContentReferenceCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ContentReferenceCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ContentReferenceCreatedAction> for ContentReferenceCreatedAction {
    fn from(value: &ContentReferenceCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ContentReferenceCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ContentReferenceCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ContentReferenceCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreatedContentReference {
    pub id: i64,
    pub node_id: String,
    pub reference: String,
}
impl From<&ContentReferenceCreatedContentReference> for ContentReferenceCreatedContentReference {
    fn from(value: &ContentReferenceCreatedContentReference) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ContentReferenceEvent(pub ContentReferenceCreated);
impl std::ops::Deref for ContentReferenceEvent {
    type Target = ContentReferenceCreated;
    fn deref(&self) -> &ContentReferenceCreated {
        &self.0
    }
}
impl From<ContentReferenceEvent> for ContentReferenceCreated {
    fn from(value: ContentReferenceEvent) -> Self {
        value.0
    }
}
impl From<&ContentReferenceEvent> for ContentReferenceEvent {
    fn from(value: &ContentReferenceEvent) -> Self {
        value.clone()
    }
}
impl From<ContentReferenceCreated> for ContentReferenceEvent {
    fn from(value: ContentReferenceCreated) -> Self {
        Self(value)
    }
}
#[doc = "A Git branch or tag is created."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CreateEvent {
    #[doc = "The repository's current description."]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The name of the repository's default branch (usually `main`)."]
    pub master_branch: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
    pub ref_type: CreateEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl From<&CreateEvent> for CreateEvent {
    fn from(value: &CreateEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CreateEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl From<&CreateEventRefType> for CreateEventRefType {
    fn from(value: &CreateEventRefType) -> Self {
        value.clone()
    }
}
impl ToString for CreateEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for CreateEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CreateEventRefType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "A Git branch or tag is deleted."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeleteEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: String,
    #[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
    pub ref_type: DeleteEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeleteEvent> for DeleteEvent {
    fn from(value: &DeleteEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeleteEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl From<&DeleteEventRefType> for DeleteEventRefType {
    fn from(value: &DeleteEventRefType) -> Self {
        value.clone()
    }
}
impl ToString for DeleteEventRefType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tag => "tag".to_string(),
            Self::Branch => "branch".to_string(),
        }
    }
}
impl std::str::FromStr for DeleteEventRefType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeleteEventRefType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreated {
    pub action: DeployKeyCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyCreatedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeployKeyCreated> for DeployKeyCreated {
    fn from(value: &DeployKeyCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeployKeyCreatedAction> for DeployKeyCreatedAction {
    fn from(value: &DeployKeyCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeployKeyCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeployKeyCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreatedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
impl From<&DeployKeyCreatedKey> for DeployKeyCreatedKey {
    fn from(value: &DeployKeyCreatedKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeleted {
    pub action: DeployKeyDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub key: DeployKeyDeletedKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeployKeyDeleted> for DeployKeyDeleted {
    fn from(value: &DeployKeyDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DeployKeyDeletedAction> for DeployKeyDeletedAction {
    fn from(value: &DeployKeyDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeployKeyDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DeployKeyDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeployKeyDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeletedKey {
    pub created_at: String,
    pub id: i64,
    pub key: String,
    pub read_only: bool,
    pub title: String,
    pub url: String,
    pub verified: bool,
}
impl From<&DeployKeyDeletedKey> for DeployKeyDeletedKey {
    fn from(value: &DeployKeyDeletedKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DeployKeyEvent {
    Created(DeployKeyCreated),
    Deleted(DeployKeyDeleted),
}
impl From<&DeployKeyEvent> for DeployKeyEvent {
    fn from(value: &DeployKeyEvent) -> Self {
        value.clone()
    }
}
impl From<DeployKeyCreated> for DeployKeyEvent {
    fn from(value: DeployKeyCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DeployKeyDeleted> for DeployKeyEvent {
    fn from(value: DeployKeyDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreated {
    pub action: DeploymentCreatedAction,
    pub deployment: DeploymentCreatedDeployment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: (),
    pub workflow_run: (),
}
impl From<&DeploymentCreated> for DeploymentCreated {
    fn from(value: &DeploymentCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeploymentCreatedAction> for DeploymentCreatedAction {
    fn from(value: &DeploymentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeploymentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeploymentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentCreatedDeploymentPayload,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentCreatedDeployment> for DeploymentCreatedDeployment {
    fn from(value: &DeploymentCreatedDeployment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeploymentPayload {}
impl From<&DeploymentCreatedDeploymentPayload> for DeploymentCreatedDeploymentPayload {
    fn from(value: &DeploymentCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentEvent(pub DeploymentCreated);
impl std::ops::Deref for DeploymentEvent {
    type Target = DeploymentCreated;
    fn deref(&self) -> &DeploymentCreated {
        &self.0
    }
}
impl From<DeploymentEvent> for DeploymentCreated {
    fn from(value: DeploymentEvent) -> Self {
        value.0
    }
}
impl From<&DeploymentEvent> for DeploymentEvent {
    fn from(value: &DeploymentEvent) -> Self {
        value.clone()
    }
}
impl From<DeploymentCreated> for DeploymentEvent {
    fn from(value: DeploymentCreated) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreated {
    pub action: DeploymentStatusCreatedAction,
    pub deployment: DeploymentStatusCreatedDeployment,
    pub deployment_status: DeploymentStatusCreatedDeploymentStatus,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DeploymentStatusCreated> for DeploymentStatusCreated {
    fn from(value: &DeploymentStatusCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DeploymentStatusCreatedAction> for DeploymentStatusCreatedAction {
    fn from(value: &DeploymentStatusCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DeploymentStatusCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DeploymentStatusCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeployment {
    pub created_at: String,
    pub creator: User,
    pub description: (),
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    pub original_environment: String,
    pub payload: DeploymentStatusCreatedDeploymentPayload,
    pub performed_via_github_app: Option<App>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository_url: String,
    pub sha: String,
    pub statuses_url: String,
    pub task: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentStatusCreatedDeployment> for DeploymentStatusCreatedDeployment {
    fn from(value: &DeploymentStatusCreatedDeployment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentPayload {}
impl From<&DeploymentStatusCreatedDeploymentPayload> for DeploymentStatusCreatedDeploymentPayload {
    fn from(value: &DeploymentStatusCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
#[doc = "The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentStatus {
    pub created_at: String,
    pub creator: User,
    pub deployment_url: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: String,
    pub environment: String,
    pub id: i64,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    pub repository_url: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: String,
    #[doc = "The optional link added to the status."]
    pub target_url: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&DeploymentStatusCreatedDeploymentStatus> for DeploymentStatusCreatedDeploymentStatus {
    fn from(value: &DeploymentStatusCreatedDeploymentStatus) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentStatusEvent(pub DeploymentStatusCreated);
impl std::ops::Deref for DeploymentStatusEvent {
    type Target = DeploymentStatusCreated;
    fn deref(&self) -> &DeploymentStatusCreated {
        &self.0
    }
}
impl From<DeploymentStatusEvent> for DeploymentStatusCreated {
    fn from(value: DeploymentStatusEvent) -> Self {
        value.0
    }
}
impl From<&DeploymentStatusEvent> for DeploymentStatusEvent {
    fn from(value: &DeploymentStatusEvent) -> Self {
        value.clone()
    }
}
impl From<DeploymentStatusCreated> for DeploymentStatusEvent {
    fn from(value: DeploymentStatusCreated) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Discussion {
    pub active_lock_reason: Option<String>,
    pub answer_chosen_at: Option<String>,
    pub answer_chosen_by: Option<User>,
    pub answer_html_url: Option<String>,
    pub author_association: AuthorAssociation,
    pub body: String,
    pub category: DiscussionCategory,
    pub comments: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    pub id: i64,
    pub locked: bool,
    pub node_id: String,
    pub number: i64,
    pub repository_url: String,
    pub state: DiscussionState,
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&Discussion> for Discussion {
    fn from(value: &Discussion) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnswered {
    pub action: DiscussionAnsweredAction,
    pub answer: DiscussionAnsweredAnswer,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionAnswered> for DiscussionAnswered {
    fn from(value: &DiscussionAnswered) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionAnsweredAction {
    #[serde(rename = "answered")]
    Answered,
}
impl From<&DiscussionAnsweredAction> for DiscussionAnsweredAction {
    fn from(value: &DiscussionAnsweredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionAnsweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Answered => "answered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionAnsweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "answered" => Ok(Self::Answered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionAnsweredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionAnsweredAnswer> for DiscussionAnsweredAnswer {
    fn from(value: &DiscussionAnsweredAnswer) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategory {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionCategory> for DiscussionCategory {
    fn from(value: &DiscussionCategory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChanged {
    pub action: DiscussionCategoryChangedAction,
    pub changes: DiscussionCategoryChangedChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCategoryChanged> for DiscussionCategoryChanged {
    fn from(value: &DiscussionCategoryChanged) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCategoryChangedAction {
    #[serde(rename = "category_changed")]
    CategoryChanged,
}
impl From<&DiscussionCategoryChangedAction> for DiscussionCategoryChangedAction {
    fn from(value: &DiscussionCategoryChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCategoryChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::CategoryChanged => "category_changed".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCategoryChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "category_changed" => Ok(Self::CategoryChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCategoryChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChanges {
    pub category: DiscussionCategoryChangedChangesCategory,
}
impl From<&DiscussionCategoryChangedChanges> for DiscussionCategoryChangedChanges {
    fn from(value: &DiscussionCategoryChangedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategory {
    pub from: DiscussionCategoryChangedChangesCategoryFrom,
}
impl From<&DiscussionCategoryChangedChangesCategory> for DiscussionCategoryChangedChangesCategory {
    fn from(value: &DiscussionCategoryChangedChangesCategory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategoryFrom {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub description: String,
    pub emoji: String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: String,
    pub repository_id: i64,
    pub slug: String,
    pub updated_at: String,
}
impl From<&DiscussionCategoryChangedChangesCategoryFrom>
    for DiscussionCategoryChangedChangesCategoryFrom
{
    fn from(value: &DiscussionCategoryChangedChangesCategoryFrom) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreated {
    pub action: DiscussionCommentCreatedAction,
    pub comment: DiscussionCommentCreatedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentCreated> for DiscussionCommentCreated {
    fn from(value: &DiscussionCommentCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DiscussionCommentCreatedAction> for DiscussionCommentCreatedAction {
    fn from(value: &DiscussionCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreatedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentCreatedComment> for DiscussionCommentCreatedComment {
    fn from(value: &DiscussionCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeleted {
    pub action: DiscussionCommentDeletedAction,
    pub comment: DiscussionCommentDeletedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentDeleted> for DiscussionCommentDeleted {
    fn from(value: &DiscussionCommentDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DiscussionCommentDeletedAction> for DiscussionCommentDeletedAction {
    fn from(value: &DiscussionCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeletedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentDeletedComment> for DiscussionCommentDeletedComment {
    fn from(value: &DiscussionCommentDeletedComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEdited {
    pub action: DiscussionCommentEditedAction,
    pub changes: DiscussionCommentEditedChanges,
    pub comment: DiscussionCommentEditedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCommentEdited> for DiscussionCommentEdited {
    fn from(value: &DiscussionCommentEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&DiscussionCommentEditedAction> for DiscussionCommentEditedAction {
    fn from(value: &DiscussionCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChanges {
    pub body: DiscussionCommentEditedChangesBody,
}
impl From<&DiscussionCommentEditedChanges> for DiscussionCommentEditedChanges {
    fn from(value: &DiscussionCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChangesBody {
    pub from: String,
}
impl From<&DiscussionCommentEditedChangesBody> for DiscussionCommentEditedChangesBody {
    fn from(value: &DiscussionCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedComment {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: String,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: Option<i64>,
    pub repository_url: String,
    pub updated_at: String,
    pub user: User,
}
impl From<&DiscussionCommentEditedComment> for DiscussionCommentEditedComment {
    fn from(value: &DiscussionCommentEditedComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionCommentEvent {
    Created(DiscussionCommentCreated),
    Deleted(DiscussionCommentDeleted),
    Edited(DiscussionCommentEdited),
}
impl From<&DiscussionCommentEvent> for DiscussionCommentEvent {
    fn from(value: &DiscussionCommentEvent) -> Self {
        value.clone()
    }
}
impl From<DiscussionCommentCreated> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DiscussionCommentDeleted> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<DiscussionCommentEdited> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreated {
    pub action: DiscussionCreatedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionCreated> for DiscussionCreated {
    fn from(value: &DiscussionCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&DiscussionCreatedAction> for DiscussionCreatedAction {
    fn from(value: &DiscussionCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionDeleted {
    pub action: DiscussionDeletedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionDeleted> for DiscussionDeleted {
    fn from(value: &DiscussionDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&DiscussionDeletedAction> for DiscussionDeletedAction {
    fn from(value: &DiscussionDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEdited {
    pub action: DiscussionEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<DiscussionEditedChanges>,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionEdited> for DiscussionEdited {
    fn from(value: &DiscussionEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&DiscussionEditedAction> for DiscussionEditedAction {
    fn from(value: &DiscussionEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<DiscussionEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<DiscussionEditedChangesTitle>,
}
impl From<&DiscussionEditedChanges> for DiscussionEditedChanges {
    fn from(value: &DiscussionEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesBody {
    pub from: String,
}
impl From<&DiscussionEditedChangesBody> for DiscussionEditedChangesBody {
    fn from(value: &DiscussionEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesTitle {
    pub from: String,
}
impl From<&DiscussionEditedChangesTitle> for DiscussionEditedChangesTitle {
    fn from(value: &DiscussionEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionEvent {
    Answered(DiscussionAnswered),
    CategoryChanged(DiscussionCategoryChanged),
    Created(DiscussionCreated),
    Deleted(DiscussionDeleted),
    Edited(DiscussionEdited),
    Labeled(DiscussionLabeled),
    Locked(DiscussionLocked),
    Pinned(DiscussionPinned),
    Transferred(DiscussionTransferred),
    Unanswered(DiscussionUnanswered),
    Unlabeled(DiscussionUnlabeled),
    Unlocked(DiscussionUnlocked),
    Unpinned(DiscussionUnpinned),
}
impl From<&DiscussionEvent> for DiscussionEvent {
    fn from(value: &DiscussionEvent) -> Self {
        value.clone()
    }
}
impl From<DiscussionAnswered> for DiscussionEvent {
    fn from(value: DiscussionAnswered) -> Self {
        Self::Answered(value)
    }
}
impl From<DiscussionCategoryChanged> for DiscussionEvent {
    fn from(value: DiscussionCategoryChanged) -> Self {
        Self::CategoryChanged(value)
    }
}
impl From<DiscussionCreated> for DiscussionEvent {
    fn from(value: DiscussionCreated) -> Self {
        Self::Created(value)
    }
}
impl From<DiscussionDeleted> for DiscussionEvent {
    fn from(value: DiscussionDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<DiscussionEdited> for DiscussionEvent {
    fn from(value: DiscussionEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<DiscussionLabeled> for DiscussionEvent {
    fn from(value: DiscussionLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<DiscussionLocked> for DiscussionEvent {
    fn from(value: DiscussionLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<DiscussionPinned> for DiscussionEvent {
    fn from(value: DiscussionPinned) -> Self {
        Self::Pinned(value)
    }
}
impl From<DiscussionTransferred> for DiscussionEvent {
    fn from(value: DiscussionTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<DiscussionUnanswered> for DiscussionEvent {
    fn from(value: DiscussionUnanswered) -> Self {
        Self::Unanswered(value)
    }
}
impl From<DiscussionUnlabeled> for DiscussionEvent {
    fn from(value: DiscussionUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<DiscussionUnlocked> for DiscussionEvent {
    fn from(value: DiscussionUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl From<DiscussionUnpinned> for DiscussionEvent {
    fn from(value: DiscussionUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLabeled {
    pub action: DiscussionLabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionLabeled> for DiscussionLabeled {
    fn from(value: &DiscussionLabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&DiscussionLabeledAction> for DiscussionLabeledAction {
    fn from(value: &DiscussionLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLocked {
    pub action: DiscussionLockedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionLocked> for DiscussionLocked {
    fn from(value: &DiscussionLocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&DiscussionLockedAction> for DiscussionLockedAction {
    fn from(value: &DiscussionLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionPinned {
    pub action: DiscussionPinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionPinned> for DiscussionPinned {
    fn from(value: &DiscussionPinned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl From<&DiscussionPinnedAction> for DiscussionPinnedAction {
    fn from(value: &DiscussionPinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionPinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl From<&DiscussionState> for DiscussionState {
    fn from(value: &DiscussionState) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Locked => "locked".to_string(),
            Self::Converting => "converting".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferred {
    pub action: DiscussionTransferredAction,
    pub changes: DiscussionTransferredChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionTransferred> for DiscussionTransferred {
    fn from(value: &DiscussionTransferred) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&DiscussionTransferredAction> for DiscussionTransferredAction {
    fn from(value: &DiscussionTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferredChanges {
    pub new_discussion: Discussion,
    pub new_repository: Repository,
}
impl From<&DiscussionTransferredChanges> for DiscussionTransferredChanges {
    fn from(value: &DiscussionTransferredChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnanswered {
    pub action: DiscussionUnansweredAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub old_answer: DiscussionUnansweredOldAnswer,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnanswered> for DiscussionUnanswered {
    fn from(value: &DiscussionUnanswered) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnansweredAction {
    #[serde(rename = "unanswered")]
    Unanswered,
}
impl From<&DiscussionUnansweredAction> for DiscussionUnansweredAction {
    fn from(value: &DiscussionUnansweredAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnansweredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unanswered => "unanswered".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnansweredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unanswered" => Ok(Self::Unanswered),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnansweredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredOldAnswer {
    pub author_association: AuthorAssociation,
    pub body: String,
    pub child_comment_count: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: String,
    pub id: i64,
    pub node_id: String,
    pub parent_id: (),
    pub repository_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&DiscussionUnansweredOldAnswer> for DiscussionUnansweredOldAnswer {
    fn from(value: &DiscussionUnansweredOldAnswer) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlabeled {
    pub action: DiscussionUnlabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnlabeled> for DiscussionUnlabeled {
    fn from(value: &DiscussionUnlabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&DiscussionUnlabeledAction> for DiscussionUnlabeledAction {
    fn from(value: &DiscussionUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlocked {
    pub action: DiscussionUnlockedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnlocked> for DiscussionUnlocked {
    fn from(value: &DiscussionUnlocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&DiscussionUnlockedAction> for DiscussionUnlockedAction {
    fn from(value: &DiscussionUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnpinned {
    pub action: DiscussionUnpinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&DiscussionUnpinned> for DiscussionUnpinned {
    fn from(value: &DiscussionUnpinned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl From<&DiscussionUnpinnedAction> for DiscussionUnpinnedAction {
    fn from(value: &DiscussionUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for DiscussionUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for DiscussionUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DiscussionUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Everything {
    BranchProtectionRuleEvent(BranchProtectionRuleEvent),
    CheckRunEvent(CheckRunEvent),
    CheckSuiteEvent(CheckSuiteEvent),
    CodeScanningAlertEvent(CodeScanningAlertEvent),
    CommitCommentEvent(CommitCommentEvent),
    ContentReferenceEvent(ContentReferenceEvent),
    CreateEvent(CreateEvent),
    DeleteEvent(DeleteEvent),
    DeployKeyEvent(DeployKeyEvent),
    DeploymentEvent(DeploymentEvent),
    DeploymentStatusEvent(DeploymentStatusEvent),
    DiscussionEvent(DiscussionEvent),
    DiscussionCommentEvent(DiscussionCommentEvent),
    ForkEvent(ForkEvent),
    GithubAppAuthorizationEvent(GithubAppAuthorizationEvent),
    GollumEvent(GollumEvent),
    InstallationEvent(InstallationEvent),
    InstallationRepositoriesEvent(InstallationRepositoriesEvent),
    IssueCommentEvent(IssueCommentEvent),
    IssuesEvent(IssuesEvent),
    LabelEvent(LabelEvent),
    MarketplacePurchaseEvent(MarketplacePurchaseEvent),
    MemberEvent(MemberEvent),
    MembershipEvent(MembershipEvent),
    MetaEvent(MetaEvent),
    MilestoneEvent(MilestoneEvent),
    OrgBlockEvent(OrgBlockEvent),
    OrganizationEvent(OrganizationEvent),
    PackageEvent(PackageEvent),
    PageBuildEvent(PageBuildEvent),
    PingEvent(PingEvent),
    ProjectEvent(ProjectEvent),
    ProjectCardEvent(ProjectCardEvent),
    ProjectColumnEvent(ProjectColumnEvent),
    PublicEvent(PublicEvent),
    PullRequestEvent(PullRequestEvent),
    PullRequestReviewEvent(PullRequestReviewEvent),
    PullRequestReviewCommentEvent(PullRequestReviewCommentEvent),
    PushEvent(PushEvent),
    ReleaseEvent(ReleaseEvent),
    RepositoryEvent(RepositoryEvent),
    RepositoryDispatchEvent(RepositoryDispatchEvent),
    RepositoryImportEvent(RepositoryImportEvent),
    RepositoryVulnerabilityAlertEvent(RepositoryVulnerabilityAlertEvent),
    SecretScanningAlertEvent(SecretScanningAlertEvent),
    SecurityAdvisoryEvent(SecurityAdvisoryEvent),
    SponsorshipEvent(SponsorshipEvent),
    StarEvent(StarEvent),
    StatusEvent(StatusEvent),
    TeamEvent(TeamEvent),
    TeamAddEvent(TeamAddEvent),
    WatchEvent(WatchEvent),
    WorkflowDispatchEvent(WorkflowDispatchEvent),
    WorkflowJobEvent(WorkflowJobEvent),
    WorkflowRunEvent(WorkflowRunEvent),
}
impl From<&Everything> for Everything {
    fn from(value: &Everything) -> Self {
        value.clone()
    }
}
impl From<BranchProtectionRuleEvent> for Everything {
    fn from(value: BranchProtectionRuleEvent) -> Self {
        Self::BranchProtectionRuleEvent(value)
    }
}
impl From<CheckRunEvent> for Everything {
    fn from(value: CheckRunEvent) -> Self {
        Self::CheckRunEvent(value)
    }
}
impl From<CheckSuiteEvent> for Everything {
    fn from(value: CheckSuiteEvent) -> Self {
        Self::CheckSuiteEvent(value)
    }
}
impl From<CodeScanningAlertEvent> for Everything {
    fn from(value: CodeScanningAlertEvent) -> Self {
        Self::CodeScanningAlertEvent(value)
    }
}
impl From<CommitCommentEvent> for Everything {
    fn from(value: CommitCommentEvent) -> Self {
        Self::CommitCommentEvent(value)
    }
}
impl From<ContentReferenceEvent> for Everything {
    fn from(value: ContentReferenceEvent) -> Self {
        Self::ContentReferenceEvent(value)
    }
}
impl From<CreateEvent> for Everything {
    fn from(value: CreateEvent) -> Self {
        Self::CreateEvent(value)
    }
}
impl From<DeleteEvent> for Everything {
    fn from(value: DeleteEvent) -> Self {
        Self::DeleteEvent(value)
    }
}
impl From<DeployKeyEvent> for Everything {
    fn from(value: DeployKeyEvent) -> Self {
        Self::DeployKeyEvent(value)
    }
}
impl From<DeploymentEvent> for Everything {
    fn from(value: DeploymentEvent) -> Self {
        Self::DeploymentEvent(value)
    }
}
impl From<DeploymentStatusEvent> for Everything {
    fn from(value: DeploymentStatusEvent) -> Self {
        Self::DeploymentStatusEvent(value)
    }
}
impl From<DiscussionEvent> for Everything {
    fn from(value: DiscussionEvent) -> Self {
        Self::DiscussionEvent(value)
    }
}
impl From<DiscussionCommentEvent> for Everything {
    fn from(value: DiscussionCommentEvent) -> Self {
        Self::DiscussionCommentEvent(value)
    }
}
impl From<ForkEvent> for Everything {
    fn from(value: ForkEvent) -> Self {
        Self::ForkEvent(value)
    }
}
impl From<GithubAppAuthorizationEvent> for Everything {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        Self::GithubAppAuthorizationEvent(value)
    }
}
impl From<GollumEvent> for Everything {
    fn from(value: GollumEvent) -> Self {
        Self::GollumEvent(value)
    }
}
impl From<InstallationEvent> for Everything {
    fn from(value: InstallationEvent) -> Self {
        Self::InstallationEvent(value)
    }
}
impl From<InstallationRepositoriesEvent> for Everything {
    fn from(value: InstallationRepositoriesEvent) -> Self {
        Self::InstallationRepositoriesEvent(value)
    }
}
impl From<IssueCommentEvent> for Everything {
    fn from(value: IssueCommentEvent) -> Self {
        Self::IssueCommentEvent(value)
    }
}
impl From<IssuesEvent> for Everything {
    fn from(value: IssuesEvent) -> Self {
        Self::IssuesEvent(value)
    }
}
impl From<LabelEvent> for Everything {
    fn from(value: LabelEvent) -> Self {
        Self::LabelEvent(value)
    }
}
impl From<MarketplacePurchaseEvent> for Everything {
    fn from(value: MarketplacePurchaseEvent) -> Self {
        Self::MarketplacePurchaseEvent(value)
    }
}
impl From<MemberEvent> for Everything {
    fn from(value: MemberEvent) -> Self {
        Self::MemberEvent(value)
    }
}
impl From<MembershipEvent> for Everything {
    fn from(value: MembershipEvent) -> Self {
        Self::MembershipEvent(value)
    }
}
impl From<MetaEvent> for Everything {
    fn from(value: MetaEvent) -> Self {
        Self::MetaEvent(value)
    }
}
impl From<MilestoneEvent> for Everything {
    fn from(value: MilestoneEvent) -> Self {
        Self::MilestoneEvent(value)
    }
}
impl From<OrgBlockEvent> for Everything {
    fn from(value: OrgBlockEvent) -> Self {
        Self::OrgBlockEvent(value)
    }
}
impl From<OrganizationEvent> for Everything {
    fn from(value: OrganizationEvent) -> Self {
        Self::OrganizationEvent(value)
    }
}
impl From<PackageEvent> for Everything {
    fn from(value: PackageEvent) -> Self {
        Self::PackageEvent(value)
    }
}
impl From<PageBuildEvent> for Everything {
    fn from(value: PageBuildEvent) -> Self {
        Self::PageBuildEvent(value)
    }
}
impl From<PingEvent> for Everything {
    fn from(value: PingEvent) -> Self {
        Self::PingEvent(value)
    }
}
impl From<ProjectEvent> for Everything {
    fn from(value: ProjectEvent) -> Self {
        Self::ProjectEvent(value)
    }
}
impl From<ProjectCardEvent> for Everything {
    fn from(value: ProjectCardEvent) -> Self {
        Self::ProjectCardEvent(value)
    }
}
impl From<ProjectColumnEvent> for Everything {
    fn from(value: ProjectColumnEvent) -> Self {
        Self::ProjectColumnEvent(value)
    }
}
impl From<PublicEvent> for Everything {
    fn from(value: PublicEvent) -> Self {
        Self::PublicEvent(value)
    }
}
impl From<PullRequestEvent> for Everything {
    fn from(value: PullRequestEvent) -> Self {
        Self::PullRequestEvent(value)
    }
}
impl From<PullRequestReviewEvent> for Everything {
    fn from(value: PullRequestReviewEvent) -> Self {
        Self::PullRequestReviewEvent(value)
    }
}
impl From<PullRequestReviewCommentEvent> for Everything {
    fn from(value: PullRequestReviewCommentEvent) -> Self {
        Self::PullRequestReviewCommentEvent(value)
    }
}
impl From<PushEvent> for Everything {
    fn from(value: PushEvent) -> Self {
        Self::PushEvent(value)
    }
}
impl From<ReleaseEvent> for Everything {
    fn from(value: ReleaseEvent) -> Self {
        Self::ReleaseEvent(value)
    }
}
impl From<RepositoryEvent> for Everything {
    fn from(value: RepositoryEvent) -> Self {
        Self::RepositoryEvent(value)
    }
}
impl From<RepositoryDispatchEvent> for Everything {
    fn from(value: RepositoryDispatchEvent) -> Self {
        Self::RepositoryDispatchEvent(value)
    }
}
impl From<RepositoryImportEvent> for Everything {
    fn from(value: RepositoryImportEvent) -> Self {
        Self::RepositoryImportEvent(value)
    }
}
impl From<RepositoryVulnerabilityAlertEvent> for Everything {
    fn from(value: RepositoryVulnerabilityAlertEvent) -> Self {
        Self::RepositoryVulnerabilityAlertEvent(value)
    }
}
impl From<SecretScanningAlertEvent> for Everything {
    fn from(value: SecretScanningAlertEvent) -> Self {
        Self::SecretScanningAlertEvent(value)
    }
}
impl From<SecurityAdvisoryEvent> for Everything {
    fn from(value: SecurityAdvisoryEvent) -> Self {
        Self::SecurityAdvisoryEvent(value)
    }
}
impl From<SponsorshipEvent> for Everything {
    fn from(value: SponsorshipEvent) -> Self {
        Self::SponsorshipEvent(value)
    }
}
impl From<StarEvent> for Everything {
    fn from(value: StarEvent) -> Self {
        Self::StarEvent(value)
    }
}
impl From<StatusEvent> for Everything {
    fn from(value: StatusEvent) -> Self {
        Self::StatusEvent(value)
    }
}
impl From<TeamEvent> for Everything {
    fn from(value: TeamEvent) -> Self {
        Self::TeamEvent(value)
    }
}
impl From<TeamAddEvent> for Everything {
    fn from(value: TeamAddEvent) -> Self {
        Self::TeamAddEvent(value)
    }
}
impl From<WatchEvent> for Everything {
    fn from(value: WatchEvent) -> Self {
        Self::WatchEvent(value)
    }
}
impl From<WorkflowDispatchEvent> for Everything {
    fn from(value: WorkflowDispatchEvent) -> Self {
        Self::WorkflowDispatchEvent(value)
    }
}
impl From<WorkflowJobEvent> for Everything {
    fn from(value: WorkflowJobEvent) -> Self {
        Self::WorkflowJobEvent(value)
    }
}
impl From<WorkflowRunEvent> for Everything {
    fn from(value: WorkflowRunEvent) -> Self {
        Self::WorkflowRunEvent(value)
    }
}
#[doc = "A user forks a repository."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEvent {
    #[doc = "The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource."]
    pub forkee: Repository,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ForkEvent> for ForkEvent {
    fn from(value: &ForkEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GithubAppAuthorizationEvent(pub GithubAppAuthorizationRevoked);
impl std::ops::Deref for GithubAppAuthorizationEvent {
    type Target = GithubAppAuthorizationRevoked;
    fn deref(&self) -> &GithubAppAuthorizationRevoked {
        &self.0
    }
}
impl From<GithubAppAuthorizationEvent> for GithubAppAuthorizationRevoked {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        value.0
    }
}
impl From<&GithubAppAuthorizationEvent> for GithubAppAuthorizationEvent {
    fn from(value: &GithubAppAuthorizationEvent) -> Self {
        value.clone()
    }
}
impl From<GithubAppAuthorizationRevoked> for GithubAppAuthorizationEvent {
    fn from(value: GithubAppAuthorizationRevoked) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubAppAuthorizationRevoked {
    pub action: GithubAppAuthorizationRevokedAction,
    pub sender: User,
}
impl From<&GithubAppAuthorizationRevoked> for GithubAppAuthorizationRevoked {
    fn from(value: &GithubAppAuthorizationRevoked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GithubAppAuthorizationRevokedAction {
    #[serde(rename = "revoked")]
    Revoked,
}
impl From<&GithubAppAuthorizationRevokedAction> for GithubAppAuthorizationRevokedAction {
    fn from(value: &GithubAppAuthorizationRevokedAction) -> Self {
        value.clone()
    }
}
impl ToString for GithubAppAuthorizationRevokedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Revoked => "revoked".to_string(),
        }
    }
}
impl std::str::FromStr for GithubAppAuthorizationRevokedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "revoked" => Ok(Self::Revoked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GithubAppAuthorizationRevokedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubOrg {
    pub avatar_url: String,
    #[serde(default)]
    pub email: (),
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&GithubOrg> for GithubOrg {
    fn from(value: &GithubOrg) -> Self {
        value.clone()
    }
}
#[doc = "A wiki page is created or updated."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[doc = "The pages that were updated."]
    pub pages: Vec<GollumEventPagesItem>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&GollumEvent> for GollumEvent {
    fn from(value: &GollumEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEventPagesItem {
    #[doc = "The action that was performed on the page. Can be `created` or `edited`."]
    pub action: GollumEventPagesItemAction,
    #[doc = "Points to the HTML wiki page."]
    pub html_url: String,
    #[doc = "The name of the page."]
    pub page_name: String,
    #[doc = "The latest commit SHA of the page."]
    pub sha: String,
    pub summary: (),
    #[doc = "The current page title."]
    pub title: String,
}
impl From<&GollumEventPagesItem> for GollumEventPagesItem {
    fn from(value: &GollumEventPagesItem) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed on the page. Can be `created` or `edited`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GollumEventPagesItemAction {
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "edited")]
    Edited,
}
impl From<&GollumEventPagesItemAction> for GollumEventPagesItemAction {
    fn from(value: &GollumEventPagesItemAction) -> Self {
        value.clone()
    }
}
impl ToString for GollumEventPagesItemAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for GollumEventPagesItemAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GollumEventPagesItemAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The GitHub App installation."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Installation {
    pub access_tokens_url: String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_slug: Option<String>,
    pub created_at: InstallationCreatedAt,
    pub events: Vec<InstallationEventsItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    pub html_url: String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationPermissions,
    pub repositories_url: String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositorySelection,
    pub single_file_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub single_file_paths: Vec<String>,
    pub suspended_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub suspended_by: Option<User>,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationTargetType,
    pub updated_at: InstallationUpdatedAt,
}
impl From<&Installation> for Installation {
    fn from(value: &Installation) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreated {
    pub action: InstallationCreatedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationCreatedRepositoriesItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationCreated> for InstallationCreated {
    fn from(value: &InstallationCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&InstallationCreatedAction> for InstallationCreatedAction {
    fn from(value: &InstallationCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationCreatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationCreatedAt> for InstallationCreatedAt {
    fn from(value: &InstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreatedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationCreatedRepositoriesItem> for InstallationCreatedRepositoriesItem {
    fn from(value: &InstallationCreatedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeleted {
    pub action: InstallationDeletedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationDeletedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationDeleted> for InstallationDeleted {
    fn from(value: &InstallationDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&InstallationDeletedAction> for InstallationDeletedAction {
    fn from(value: &InstallationDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeletedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationDeletedRepositoriesItem> for InstallationDeletedRepositoriesItem {
    fn from(value: &InstallationDeletedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationEvent {
    Created(InstallationCreated),
    Deleted(InstallationDeleted),
    NewPermissionsAccepted(InstallationNewPermissionsAccepted),
    Suspend(InstallationSuspend),
    Unsuspend(InstallationUnsuspend),
}
impl From<&InstallationEvent> for InstallationEvent {
    fn from(value: &InstallationEvent) -> Self {
        value.clone()
    }
}
impl From<InstallationCreated> for InstallationEvent {
    fn from(value: InstallationCreated) -> Self {
        Self::Created(value)
    }
}
impl From<InstallationDeleted> for InstallationEvent {
    fn from(value: InstallationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<InstallationNewPermissionsAccepted> for InstallationEvent {
    fn from(value: InstallationNewPermissionsAccepted) -> Self {
        Self::NewPermissionsAccepted(value)
    }
}
impl From<InstallationSuspend> for InstallationEvent {
    fn from(value: InstallationSuspend) -> Self {
        Self::Suspend(value)
    }
}
impl From<InstallationUnsuspend> for InstallationEvent {
    fn from(value: InstallationUnsuspend) -> Self {
        Self::Unsuspend(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&InstallationEventsItem> for InstallationEventsItem {
    fn from(value: &InstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ToString for InstallationEventsItem {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::MergeQueueEntry => "merge_queue_entry".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationEventsItem {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationEventsItem {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Installation"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationLite {
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub node_id: String,
}
impl From<&InstallationLite> for InstallationLite {
    fn from(value: &InstallationLite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAccepted {
    pub action: InstallationNewPermissionsAcceptedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationNewPermissionsAccepted> for InstallationNewPermissionsAccepted {
    fn from(value: &InstallationNewPermissionsAccepted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationNewPermissionsAcceptedAction {
    #[serde(rename = "new_permissions_accepted")]
    NewPermissionsAccepted,
}
impl From<&InstallationNewPermissionsAcceptedAction> for InstallationNewPermissionsAcceptedAction {
    fn from(value: &InstallationNewPermissionsAcceptedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationNewPermissionsAcceptedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::NewPermissionsAccepted => "new_permissions_accepted".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationNewPermissionsAcceptedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "new_permissions_accepted" => Ok(Self::NewPermissionsAccepted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationNewPermissionsAcceptedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAcceptedRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationNewPermissionsAcceptedRepositoriesItem>
    for InstallationNewPermissionsAcceptedRepositoriesItem
{
    fn from(value: &InstallationNewPermissionsAcceptedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationPermissions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<InstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub administration: Option<InstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<InstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_references: Option<InstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contents: Option<InstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployments: Option<InstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discussions: Option<InstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emails: Option<InstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environments: Option<InstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<InstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<InstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<InstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_administration: Option<InstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_events: Option<InstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_hooks: Option<InstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_packages: Option<InstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_plan: Option<InstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_projects: Option<InstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_secrets: Option<InstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_self_hosted_runners:
        Option<InstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization_user_blocking: Option<InstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<InstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pages: Option<InstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_requests: Option<InstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_hooks: Option<InstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository_projects: Option<InstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_scanning_alerts: Option<InstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<InstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_events: Option<InstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_scanning_alert: Option<InstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_file: Option<InstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statuses: Option<InstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub team_discussions: Option<InstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vulnerability_alerts: Option<InstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workflows: Option<InstallationPermissionsWorkflows>,
}
impl From<&InstallationPermissions> for InstallationPermissions {
    fn from(value: &InstallationPermissions) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsActions> for InstallationPermissionsActions {
    fn from(value: &InstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsActions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsActions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsActions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsAdministration> for InstallationPermissionsAdministration {
    fn from(value: &InstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsChecks> for InstallationPermissionsChecks {
    fn from(value: &InstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsChecks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsChecks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsChecks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsContentReferences> for InstallationPermissionsContentReferences {
    fn from(value: &InstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsContentReferences {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContentReferences {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsContentReferences {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsContents> for InstallationPermissionsContents {
    fn from(value: &InstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsContents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsContents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsContents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsDeployments> for InstallationPermissionsDeployments {
    fn from(value: &InstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsDeployments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDeployments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsDeployments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsDiscussions> for InstallationPermissionsDiscussions {
    fn from(value: &InstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsEmails> for InstallationPermissionsEmails {
    fn from(value: &InstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsEmails {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEmails {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsEmails {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsEnvironments> for InstallationPermissionsEnvironments {
    fn from(value: &InstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsEnvironments {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsEnvironments {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsEnvironments {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsIssues> for InstallationPermissionsIssues {
    fn from(value: &InstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsIssues {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsIssues {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsIssues {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsMembers> for InstallationPermissionsMembers {
    fn from(value: &InstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsMembers {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMembers {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsMembers {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsMetadata> for InstallationPermissionsMetadata {
    fn from(value: &InstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsMetadata {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsMetadata {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsMetadata {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationAdministration>
    for InstallationPermissionsOrganizationAdministration
{
    fn from(value: &InstallationPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationAdministration {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationAdministration {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationAdministration {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationEvents>
    for InstallationPermissionsOrganizationEvents
{
    fn from(value: &InstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationHooks> for InstallationPermissionsOrganizationHooks {
    fn from(value: &InstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationPackages>
    for InstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationPlan> for InstallationPermissionsOrganizationPlan {
    fn from(value: &InstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationPlan {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationPlan {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPlan {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationProjects>
    for InstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationSecrets>
    for InstallationPermissionsOrganizationSecrets
{
    fn from(value: &InstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationSelfHostedRunners>
    for InstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(value: &InstallationPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationSelfHostedRunners {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationSelfHostedRunners {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsOrganizationUserBlocking>
    for InstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsOrganizationUserBlocking {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsOrganizationUserBlocking {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationUserBlocking {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPackages> for InstallationPermissionsPackages {
    fn from(value: &InstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPackages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPackages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPackages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPages> for InstallationPermissionsPages {
    fn from(value: &InstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPages {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPages {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPages {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsPullRequests> for InstallationPermissionsPullRequests {
    fn from(value: &InstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsPullRequests {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsPullRequests {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsPullRequests {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsRepositoryHooks> for InstallationPermissionsRepositoryHooks {
    fn from(value: &InstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsRepositoryHooks {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryHooks {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryHooks {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsRepositoryProjects>
    for InstallationPermissionsRepositoryProjects
{
    fn from(value: &InstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsRepositoryProjects {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsRepositoryProjects {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryProjects {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecretScanningAlerts>
    for InstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecretScanningAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecretScanningAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecretScanningAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecrets> for InstallationPermissionsSecrets {
    fn from(value: &InstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecrets {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecrets {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecrets {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecurityEvents> for InstallationPermissionsSecurityEvents {
    fn from(value: &InstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecurityEvents {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityEvents {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityEvents {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSecurityScanningAlert>
    for InstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSecurityScanningAlert {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSecurityScanningAlert {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityScanningAlert {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsSingleFile> for InstallationPermissionsSingleFile {
    fn from(value: &InstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsSingleFile {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsSingleFile {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsSingleFile {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsStatuses> for InstallationPermissionsStatuses {
    fn from(value: &InstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsStatuses {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsStatuses {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsStatuses {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsTeamDiscussions> for InstallationPermissionsTeamDiscussions {
    fn from(value: &InstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsTeamDiscussions {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsTeamDiscussions {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsTeamDiscussions {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsVulnerabilityAlerts>
    for InstallationPermissionsVulnerabilityAlerts
{
    fn from(value: &InstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsVulnerabilityAlerts {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsVulnerabilityAlerts {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl From<&InstallationPermissionsWorkflows> for InstallationPermissionsWorkflows {
    fn from(value: &InstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ToString for InstallationPermissionsWorkflows {
    fn to_string(&self) -> String {
        match *self {
            Self::Read => "read".to_string(),
            Self::Write => "write".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationPermissionsWorkflows {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationPermissionsWorkflows {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAdded {
    pub action: InstallationRepositoriesAddedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesAddedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationRepositoriesAdded> for InstallationRepositoriesAdded {
    fn from(value: &InstallationRepositoriesAdded) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&InstallationRepositoriesAddedAction> for InstallationRepositoriesAddedAction {
    fn from(value: &InstallationRepositoriesAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesAddedRepositoriesAddedItem>
    for InstallationRepositoriesAddedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesRemovedItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full_name: Option<String>,
    #[doc = "Unique identifier of the repository"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    #[doc = "Whether the repository is private or public."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
}
impl From<&InstallationRepositoriesAddedRepositoriesRemovedItem>
    for InstallationRepositoriesAddedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositoriesAddedRepositorySelection>
    for InstallationRepositoriesAddedRepositorySelection
{
    fn from(value: &InstallationRepositoriesAddedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesAddedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesAddedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationRepositoriesEvent {
    Added(InstallationRepositoriesAdded),
    Removed(InstallationRepositoriesRemoved),
}
impl From<&InstallationRepositoriesEvent> for InstallationRepositoriesEvent {
    fn from(value: &InstallationRepositoriesEvent) -> Self {
        value.clone()
    }
}
impl From<InstallationRepositoriesAdded> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesAdded) -> Self {
        Self::Added(value)
    }
}
impl From<InstallationRepositoriesRemoved> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesRemoved) -> Self {
        Self::Removed(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemoved {
    pub action: InstallationRepositoriesRemovedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesRemovedRepositorySelection,
    pub requester: Option<User>,
    pub sender: User,
}
impl From<&InstallationRepositoriesRemoved> for InstallationRepositoriesRemoved {
    fn from(value: &InstallationRepositoriesRemoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&InstallationRepositoriesRemovedAction> for InstallationRepositoriesRemovedAction {
    fn from(value: &InstallationRepositoriesRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesAddedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesAddedItem>
    for InstallationRepositoriesRemovedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesRemovedItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesRemovedItem>
    for InstallationRepositoriesRemovedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositoriesRemovedRepositorySelection>
    for InstallationRepositoriesRemovedRepositorySelection
{
    fn from(value: &InstallationRepositoriesRemovedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositoriesRemovedRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositoriesRemovedRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl From<&InstallationRepositorySelection> for InstallationRepositorySelection {
    fn from(value: &InstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ToString for InstallationRepositorySelection {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Selected => "selected".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationRepositorySelection {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationRepositorySelection {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspend {
    pub action: InstallationSuspendAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationSuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationSuspend> for InstallationSuspend {
    fn from(value: &InstallationSuspend) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendAction {
    #[serde(rename = "suspend")]
    Suspend,
}
impl From<&InstallationSuspendAction> for InstallationSuspendAction {
    fn from(value: &InstallationSuspendAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationSuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Suspend => "suspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationSuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "suspend" => Ok(Self::Suspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationSuspendAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationSuspendRepositoriesItem> for InstallationSuspendRepositoriesItem {
    fn from(value: &InstallationSuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationTargetType {
    User,
    Organization,
}
impl From<&InstallationTargetType> for InstallationTargetType {
    fn from(value: &InstallationTargetType) -> Self {
        value.clone()
    }
}
impl ToString for InstallationTargetType {
    fn to_string(&self) -> String {
        match *self {
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationTargetType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationTargetType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspend {
    pub action: InstallationUnsuspendAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub repositories: Vec<InstallationUnsuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl From<&InstallationUnsuspend> for InstallationUnsuspend {
    fn from(value: &InstallationUnsuspend) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendAction {
    #[serde(rename = "unsuspend")]
    Unsuspend,
}
impl From<&InstallationUnsuspendAction> for InstallationUnsuspendAction {
    fn from(value: &InstallationUnsuspendAction) -> Self {
        value.clone()
    }
}
impl ToString for InstallationUnsuspendAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unsuspend => "unsuspend".to_string(),
        }
    }
}
impl std::str::FromStr for InstallationUnsuspendAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unsuspend" => Ok(Self::Unsuspend),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUnsuspendAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendRepositoriesItem {
    pub full_name: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl From<&InstallationUnsuspendRepositoriesItem> for InstallationUnsuspendRepositoriesItem {
    fn from(value: &InstallationUnsuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationUpdatedAt {
    Variant0(chrono::DateTime<chrono::offset::Utc>),
    Variant1(i64),
}
impl From<&InstallationUpdatedAt> for InstallationUpdatedAt {
    fn from(value: &InstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for InstallationUpdatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for InstallationUpdatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for InstallationUpdatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationUpdatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl From<i64> for InstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Issue {
    pub active_lock_reason: Option<IssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: Option<String>,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub events_url: String,
    pub html_url: String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<Label>,
    pub labels_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub locked: Option<bool>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull_request: Option<IssuePullRequest>,
    pub repository_url: String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<IssueState>,
    #[doc = "Title of the issue"]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: String,
    pub user: User,
}
impl From<&Issue> for Issue {
    fn from(value: &Issue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&IssueActiveLockReason> for IssueActiveLockReason {
    fn from(value: &IssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for IssueActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for IssueActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueComment {
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue comment"]
    pub body: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub html_url: String,
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub issue_url: String,
    pub node_id: String,
    pub performed_via_github_app: Option<App>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the issue comment"]
    pub url: String,
    pub user: User,
}
impl From<&IssueComment> for IssueComment {
    fn from(value: &IssueComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreated {
    pub action: IssueCommentCreatedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentCreated> for IssueCommentCreated {
    fn from(value: &IssueCommentCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&IssueCommentCreatedAction> for IssueCommentCreatedAction {
    fn from(value: &IssueCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeleted {
    pub action: IssueCommentDeletedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentDeleted> for IssueCommentDeleted {
    fn from(value: &IssueCommentDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&IssueCommentDeletedAction> for IssueCommentDeletedAction {
    fn from(value: &IssueCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEdited {
    pub action: IssueCommentEditedAction,
    pub changes: IssueCommentEditedChanges,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssueCommentEdited> for IssueCommentEdited {
    fn from(value: &IssueCommentEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&IssueCommentEditedAction> for IssueCommentEditedAction {
    fn from(value: &IssueCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssueCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssueCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssueCommentEditedChangesBody>,
}
impl From<&IssueCommentEditedChanges> for IssueCommentEditedChanges {
    fn from(value: &IssueCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&IssueCommentEditedChangesBody> for IssueCommentEditedChangesBody {
    fn from(value: &IssueCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssueCommentEvent {
    Created(IssueCommentCreated),
    Deleted(IssueCommentDeleted),
    Edited(IssueCommentEdited),
}
impl From<&IssueCommentEvent> for IssueCommentEvent {
    fn from(value: &IssueCommentEvent) -> Self {
        value.clone()
    }
}
impl From<IssueCommentCreated> for IssueCommentEvent {
    fn from(value: IssueCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<IssueCommentDeleted> for IssueCommentEvent {
    fn from(value: IssueCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<IssueCommentEdited> for IssueCommentEvent {
    fn from(value: IssueCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuePullRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl From<&IssuePullRequest> for IssuePullRequest {
    fn from(value: &IssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssueState> for IssueState {
    fn from(value: &IssueState) -> Self {
        value.clone()
    }
}
impl ToString for IssueState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssueState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssueState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssueState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssueState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Activity related to an issue. The type of activity is specified in the action property."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesAssigned {
    #[doc = "The action that was performed."]
    pub action: IssuesAssignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesAssigned> for IssuesAssigned {
    fn from(value: &IssuesAssigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl From<&IssuesAssignedAction> for IssuesAssignedAction {
    fn from(value: &IssuesAssignedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesAssignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosed {
    #[doc = "The action that was performed."]
    pub action: IssuesClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesClosed> for IssuesClosed {
    fn from(value: &IssuesClosed) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&IssuesClosedAction> for IssuesClosedAction {
    fn from(value: &IssuesClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDeleted {
    pub action: IssuesDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesDeleted> for IssuesDeleted {
    fn from(value: &IssuesDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&IssuesDeletedAction> for IssuesDeletedAction {
    fn from(value: &IssuesDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestoned {
    pub action: IssuesDemilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesDemilestoned> for IssuesDemilestoned {
    fn from(value: &IssuesDemilestoned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDemilestonedAction {
    #[serde(rename = "demilestoned")]
    Demilestoned,
}
impl From<&IssuesDemilestonedAction> for IssuesDemilestonedAction {
    fn from(value: &IssuesDemilestonedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesDemilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Demilestoned => "demilestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesDemilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "demilestoned" => Ok(Self::Demilestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesDemilestonedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEdited {
    pub action: IssuesEditedAction,
    pub changes: IssuesEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesEdited> for IssuesEdited {
    fn from(value: &IssuesEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&IssuesEditedAction> for IssuesEditedAction {
    fn from(value: &IssuesEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the issue."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<IssuesEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<IssuesEditedChangesTitle>,
}
impl From<&IssuesEditedChanges> for IssuesEditedChanges {
    fn from(value: &IssuesEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&IssuesEditedChangesBody> for IssuesEditedChangesBody {
    fn from(value: &IssuesEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesTitle {
    #[doc = "The previous version of the title."]
    pub from: String,
}
impl From<&IssuesEditedChangesTitle> for IssuesEditedChangesTitle {
    fn from(value: &IssuesEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssuesEvent {
    Assigned(IssuesAssigned),
    Closed(IssuesClosed),
    Deleted(IssuesDeleted),
    Demilestoned(IssuesDemilestoned),
    Edited(IssuesEdited),
    Labeled(IssuesLabeled),
    Locked(IssuesLocked),
    Milestoned(IssuesMilestoned),
    Opened(IssuesOpened),
    Pinned(IssuesPinned),
    Reopened(IssuesReopened),
    Transferred(IssuesTransferred),
    Unassigned(IssuesUnassigned),
    Unlabeled(IssuesUnlabeled),
    Unlocked(IssuesUnlocked),
    Unpinned(IssuesUnpinned),
}
impl From<&IssuesEvent> for IssuesEvent {
    fn from(value: &IssuesEvent) -> Self {
        value.clone()
    }
}
impl From<IssuesAssigned> for IssuesEvent {
    fn from(value: IssuesAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl From<IssuesClosed> for IssuesEvent {
    fn from(value: IssuesClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<IssuesDeleted> for IssuesEvent {
    fn from(value: IssuesDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<IssuesDemilestoned> for IssuesEvent {
    fn from(value: IssuesDemilestoned) -> Self {
        Self::Demilestoned(value)
    }
}
impl From<IssuesEdited> for IssuesEvent {
    fn from(value: IssuesEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<IssuesLabeled> for IssuesEvent {
    fn from(value: IssuesLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<IssuesLocked> for IssuesEvent {
    fn from(value: IssuesLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<IssuesMilestoned> for IssuesEvent {
    fn from(value: IssuesMilestoned) -> Self {
        Self::Milestoned(value)
    }
}
impl From<IssuesOpened> for IssuesEvent {
    fn from(value: IssuesOpened) -> Self {
        Self::Opened(value)
    }
}
impl From<IssuesPinned> for IssuesEvent {
    fn from(value: IssuesPinned) -> Self {
        Self::Pinned(value)
    }
}
impl From<IssuesReopened> for IssuesEvent {
    fn from(value: IssuesReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<IssuesTransferred> for IssuesEvent {
    fn from(value: IssuesTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<IssuesUnassigned> for IssuesEvent {
    fn from(value: IssuesUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl From<IssuesUnlabeled> for IssuesEvent {
    fn from(value: IssuesUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<IssuesUnlocked> for IssuesEvent {
    fn from(value: IssuesUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl From<IssuesUnpinned> for IssuesEvent {
    fn from(value: IssuesUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLabeled {
    pub action: IssuesLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was added to the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesLabeled> for IssuesLabeled {
    fn from(value: &IssuesLabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&IssuesLabeledAction> for IssuesLabeledAction {
    fn from(value: &IssuesLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLocked {
    pub action: IssuesLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesLocked> for IssuesLocked {
    fn from(value: &IssuesLocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&IssuesLockedAction> for IssuesLockedAction {
    fn from(value: &IssuesLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestoned {
    pub action: IssuesMilestonedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesMilestoned> for IssuesMilestoned {
    fn from(value: &IssuesMilestoned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedAction {
    #[serde(rename = "milestoned")]
    Milestoned,
}
impl From<&IssuesMilestonedAction> for IssuesMilestonedAction {
    fn from(value: &IssuesMilestonedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesMilestonedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Milestoned => "milestoned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesMilestonedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "milestoned" => Ok(Self::Milestoned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesMilestonedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpened {
    pub action: IssuesOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<IssuesOpenedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesOpened> for IssuesOpened {
    fn from(value: &IssuesOpened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&IssuesOpenedAction> for IssuesOpenedAction {
    fn from(value: &IssuesOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedChanges {
    pub old_issue: Issue,
    pub old_repository: Repository,
}
impl From<&IssuesOpenedChanges> for IssuesOpenedChanges {
    fn from(value: &IssuesOpenedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesPinned {
    pub action: IssuesPinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesPinned> for IssuesPinned {
    fn from(value: &IssuesPinned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl From<&IssuesPinnedAction> for IssuesPinnedAction {
    fn from(value: &IssuesPinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesPinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Pinned => "pinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesPinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesPinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopened {
    pub action: IssuesReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesReopened> for IssuesReopened {
    fn from(value: &IssuesReopened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&IssuesReopenedAction> for IssuesReopenedAction {
    fn from(value: &IssuesReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferred {
    pub action: IssuesTransferredAction,
    pub changes: IssuesTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesTransferred> for IssuesTransferred {
    fn from(value: &IssuesTransferred) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&IssuesTransferredAction> for IssuesTransferredAction {
    fn from(value: &IssuesTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferredChanges {
    pub new_issue: Issue,
    pub new_repository: Repository,
}
impl From<&IssuesTransferredChanges> for IssuesTransferredChanges {
    fn from(value: &IssuesTransferredChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnassigned {
    #[doc = "The action that was performed."]
    pub action: IssuesUnassignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assignee: Option<User>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnassigned> for IssuesUnassigned {
    fn from(value: &IssuesUnassigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl From<&IssuesUnassignedAction> for IssuesUnassignedAction {
    fn from(value: &IssuesUnassignedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnassignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlabeled {
    pub action: IssuesUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was removed from the issue."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<Label>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnlabeled> for IssuesUnlabeled {
    fn from(value: &IssuesUnlabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&IssuesUnlabeledAction> for IssuesUnlabeledAction {
    fn from(value: &IssuesUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlocked {
    pub action: IssuesUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnlocked> for IssuesUnlocked {
    fn from(value: &IssuesUnlocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&IssuesUnlockedAction> for IssuesUnlockedAction {
    fn from(value: &IssuesUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnpinned {
    pub action: IssuesUnpinnedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&IssuesUnpinned> for IssuesUnpinned {
    fn from(value: &IssuesUnpinned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl From<&IssuesUnpinnedAction> for IssuesUnpinnedAction {
    fn from(value: &IssuesUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ToString for IssuesUnpinnedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpinned => "unpinned".to_string(),
        }
    }
}
impl std::str::FromStr for IssuesUnpinnedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IssuesUnpinnedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Label {
    #[doc = "6-character hex code, without the leading #, identifying the color"]
    pub color: String,
    pub default: bool,
    pub description: Option<String>,
    pub id: i64,
    #[doc = "The name of the label."]
    pub name: String,
    pub node_id: String,
    #[doc = "URL for the label"]
    pub url: String,
}
impl From<&Label> for Label {
    fn from(value: &Label) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelCreated {
    pub action: LabelCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was added."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelCreated> for LabelCreated {
    fn from(value: &LabelCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&LabelCreatedAction> for LabelCreatedAction {
    fn from(value: &LabelCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for LabelCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelDeleted {
    pub action: LabelDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was removed."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelDeleted> for LabelDeleted {
    fn from(value: &LabelDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&LabelDeletedAction> for LabelDeletedAction {
    fn from(value: &LabelDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for LabelDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEdited {
    pub action: LabelEditedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<LabelEditedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The label that was edited."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&LabelEdited> for LabelEdited {
    fn from(value: &LabelEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&LabelEditedAction> for LabelEditedAction {
    fn from(value: &LabelEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for LabelEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for LabelEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the label if the action was `edited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<LabelEditedChangesColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<LabelEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<LabelEditedChangesName>,
}
impl From<&LabelEditedChanges> for LabelEditedChanges {
    fn from(value: &LabelEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesColor {
    #[doc = "The previous version of the color if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesColor> for LabelEditedChangesColor {
    fn from(value: &LabelEditedChangesColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesDescription> for LabelEditedChangesDescription {
    fn from(value: &LabelEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&LabelEditedChangesName> for LabelEditedChangesName {
    fn from(value: &LabelEditedChangesName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelEvent {
    Created(LabelCreated),
    Deleted(LabelDeleted),
    Edited(LabelEdited),
}
impl From<&LabelEvent> for LabelEvent {
    fn from(value: &LabelEvent) -> Self {
        value.clone()
    }
}
impl From<LabelCreated> for LabelEvent {
    fn from(value: LabelCreated) -> Self {
        Self::Created(value)
    }
}
impl From<LabelDeleted> for LabelEvent {
    fn from(value: LabelDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<LabelEdited> for LabelEvent {
    fn from(value: LabelEdited) -> Self {
        Self::Edited(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct License {
    pub key: String,
    pub name: String,
    pub node_id: String,
    pub spdx_id: String,
    pub url: Option<String>,
}
impl From<&License> for License {
    fn from(value: &License) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Link {
    pub href: String,
}
impl From<&Link> for Link {
    fn from(value: &Link) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchase {
    pub account: MarketplacePurchaseAccount,
    pub billing_cycle: String,
    pub free_trial_ends_on: (),
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub next_billing_date: Option<String>,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePlan,
    pub unit_count: i64,
}
impl From<&MarketplacePurchase> for MarketplacePurchase {
    fn from(value: &MarketplacePurchase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseAccount {
    pub id: i64,
    pub login: String,
    pub node_id: String,
    pub organization_billing_email: String,
    #[serde(rename = "type")]
    pub type_: String,
}
impl From<&MarketplacePurchaseAccount> for MarketplacePurchaseAccount {
    fn from(value: &MarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelled {
    pub action: MarketplacePurchaseCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseCancelledSender,
}
impl From<&MarketplacePurchaseCancelled> for MarketplacePurchaseCancelled {
    fn from(value: &MarketplacePurchaseCancelled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl From<&MarketplacePurchaseCancelledAction> for MarketplacePurchaseCancelledAction {
    fn from(value: &MarketplacePurchaseCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchaseCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchaseCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchaseCancelledSender> for MarketplacePurchaseCancelledSender {
    fn from(value: &MarketplacePurchaseCancelledSender) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChanged {
    pub action: MarketplacePurchaseChangedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseChangedSender,
}
impl From<&MarketplacePurchaseChanged> for MarketplacePurchaseChanged {
    fn from(value: &MarketplacePurchaseChanged) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseChangedAction {
    #[serde(rename = "changed")]
    Changed,
}
impl From<&MarketplacePurchaseChangedAction> for MarketplacePurchaseChangedAction {
    fn from(value: &MarketplacePurchaseChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchaseChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Changed => "changed".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchaseChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "changed" => Ok(Self::Changed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchaseChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchaseChangedSender> for MarketplacePurchaseChangedSender {
    fn from(value: &MarketplacePurchaseChangedSender) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarketplacePurchaseEvent {
    Cancelled(MarketplacePurchaseCancelled),
    Changed(MarketplacePurchaseChanged),
    PendingChange(MarketplacePurchasePendingChange),
    PendingChangeCancelled(MarketplacePurchasePendingChangeCancelled),
    Purchased(MarketplacePurchasePurchased),
}
impl From<&MarketplacePurchaseEvent> for MarketplacePurchaseEvent {
    fn from(value: &MarketplacePurchaseEvent) -> Self {
        value.clone()
    }
}
impl From<MarketplacePurchaseCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl From<MarketplacePurchaseChanged> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseChanged) -> Self {
        Self::Changed(value)
    }
}
impl From<MarketplacePurchasePendingChange> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChange) -> Self {
        Self::PendingChange(value)
    }
}
impl From<MarketplacePurchasePendingChangeCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChangeCancelled) -> Self {
        Self::PendingChangeCancelled(value)
    }
}
impl From<MarketplacePurchasePurchased> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePurchased) -> Self {
        Self::Purchased(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChange {
    pub action: MarketplacePurchasePendingChangeAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeSender,
}
impl From<&MarketplacePurchasePendingChange> for MarketplacePurchasePendingChange {
    fn from(value: &MarketplacePurchasePendingChange) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeAction {
    #[serde(rename = "pending_change")]
    PendingChange,
}
impl From<&MarketplacePurchasePendingChangeAction> for MarketplacePurchasePendingChangeAction {
    fn from(value: &MarketplacePurchasePendingChangeAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePendingChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChange => "pending_change".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change" => Ok(Self::PendingChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelled {
    pub action: MarketplacePurchasePendingChangeCancelledAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeCancelledSender,
}
impl From<&MarketplacePurchasePendingChangeCancelled>
    for MarketplacePurchasePendingChangeCancelled
{
    fn from(value: &MarketplacePurchasePendingChangeCancelled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeCancelledAction {
    #[serde(rename = "pending_change_cancelled")]
    PendingChangeCancelled,
}
impl From<&MarketplacePurchasePendingChangeCancelledAction>
    for MarketplacePurchasePendingChangeCancelledAction
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePendingChangeCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingChangeCancelled => "pending_change_cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePendingChangeCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_change_cancelled" => Ok(Self::PendingChangeCancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePendingChangeCancelledSender>
    for MarketplacePurchasePendingChangeCancelledSender
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledSender) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePendingChangeSender> for MarketplacePurchasePendingChangeSender {
    fn from(value: &MarketplacePurchasePendingChangeSender) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePlan {
    pub bullets: Vec<String>,
    pub description: String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: String,
    pub price_model: String,
    pub unit_name: Option<String>,
    pub yearly_price_in_cents: i64,
}
impl From<&MarketplacePurchasePlan> for MarketplacePurchasePlan {
    fn from(value: &MarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchased {
    pub action: MarketplacePurchasePurchasedAction,
    pub effective_date: String,
    pub marketplace_purchase: MarketplacePurchase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePurchasedSender,
}
impl From<&MarketplacePurchasePurchased> for MarketplacePurchasePurchased {
    fn from(value: &MarketplacePurchasePurchased) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePurchasedAction {
    #[serde(rename = "purchased")]
    Purchased,
}
impl From<&MarketplacePurchasePurchasedAction> for MarketplacePurchasePurchasedAction {
    fn from(value: &MarketplacePurchasePurchasedAction) -> Self {
        value.clone()
    }
}
impl ToString for MarketplacePurchasePurchasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Purchased => "purchased".to_string(),
        }
    }
}
impl std::str::FromStr for MarketplacePurchasePurchasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "purchased" => Ok(Self::Purchased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarketplacePurchasePurchasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedSender {
    pub avatar_url: String,
    pub email: String,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
}
impl From<&MarketplacePurchasePurchasedSender> for MarketplacePurchasePurchasedSender {
    fn from(value: &MarketplacePurchasePurchasedSender) -> Self {
        value.clone()
    }
}
#[doc = "Activity related to repository collaborators. The type of activity is specified in the action property."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAdded {
    pub action: MemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<MemberAddedChanges>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was added."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberAdded> for MemberAdded {
    fn from(value: &MemberAdded) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&MemberAddedAction> for MemberAddedAction {
    fn from(value: &MemberAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<MemberAddedChangesPermission>,
}
impl From<&MemberAddedChanges> for MemberAddedChanges {
    fn from(value: &MemberAddedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChangesPermission {
    pub to: MemberAddedChangesPermissionTo,
}
impl From<&MemberAddedChangesPermission> for MemberAddedChangesPermission {
    fn from(value: &MemberAddedChangesPermission) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedChangesPermissionTo {
    #[serde(rename = "write")]
    Write,
    #[serde(rename = "admin")]
    Admin,
}
impl From<&MemberAddedChangesPermissionTo> for MemberAddedChangesPermissionTo {
    fn from(value: &MemberAddedChangesPermissionTo) -> Self {
        value.clone()
    }
}
impl ToString for MemberAddedChangesPermissionTo {
    fn to_string(&self) -> String {
        match *self {
            Self::Write => "write".to_string(),
            Self::Admin => "admin".to_string(),
        }
    }
}
impl std::str::FromStr for MemberAddedChangesPermissionTo {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "write" => Ok(Self::Write),
            "admin" => Ok(Self::Admin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberAddedChangesPermissionTo {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEdited {
    pub action: MemberEditedAction,
    pub changes: MemberEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user who's permissions are changed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberEdited> for MemberEdited {
    fn from(value: &MemberEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&MemberEditedAction> for MemberEditedAction {
    fn from(value: &MemberEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MemberEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the collaborator permissions"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChanges {
    pub old_permission: MemberEditedChangesOldPermission,
}
impl From<&MemberEditedChanges> for MemberEditedChanges {
    fn from(value: &MemberEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChangesOldPermission {
    #[doc = "The previous permissions of the collaborator if the action was edited."]
    pub from: String,
}
impl From<&MemberEditedChangesOldPermission> for MemberEditedChangesOldPermission {
    fn from(value: &MemberEditedChangesOldPermission) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MemberEvent {
    Added(MemberAdded),
    Edited(MemberEdited),
    Removed(MemberRemoved),
}
impl From<&MemberEvent> for MemberEvent {
    fn from(value: &MemberEvent) -> Self {
        value.clone()
    }
}
impl From<MemberAdded> for MemberEvent {
    fn from(value: MemberAdded) -> Self {
        Self::Added(value)
    }
}
impl From<MemberEdited> for MemberEvent {
    fn from(value: MemberEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<MemberRemoved> for MemberEvent {
    fn from(value: MemberRemoved) -> Self {
        Self::Removed(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberRemoved {
    pub action: MemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The user that was removed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MemberRemoved> for MemberRemoved {
    fn from(value: &MemberRemoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&MemberRemovedAction> for MemberRemovedAction {
    fn from(value: &MemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for MemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Membership {
    pub organization_url: String,
    pub role: String,
    pub state: String,
    pub url: String,
    pub user: User,
}
impl From<&Membership> for Membership {
    fn from(value: &Membership) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipAdded {
    pub action: MembershipAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipAddedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: Team,
}
impl From<&MembershipAdded> for MembershipAdded {
    fn from(value: &MembershipAdded) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl From<&MembershipAddedAction> for MembershipAddedAction {
    fn from(value: &MembershipAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for MembershipAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Added => "added".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedScope {
    #[serde(rename = "team")]
    Team,
}
impl From<&MembershipAddedScope> for MembershipAddedScope {
    fn from(value: &MembershipAddedScope) -> Self {
        value.clone()
    }
}
impl ToString for MembershipAddedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipAddedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipAddedScope {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MembershipEvent {
    Added(MembershipAdded),
    Removed(MembershipRemoved),
}
impl From<&MembershipEvent> for MembershipEvent {
    fn from(value: &MembershipEvent) -> Self {
        value.clone()
    }
}
impl From<MembershipAdded> for MembershipEvent {
    fn from(value: MembershipAdded) -> Self {
        Self::Added(value)
    }
}
impl From<MembershipRemoved> for MembershipEvent {
    fn from(value: MembershipRemoved) -> Self {
        Self::Removed(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipRemoved {
    pub action: MembershipRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipRemovedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: MembershipRemovedTeam,
}
impl From<&MembershipRemoved> for MembershipRemoved {
    fn from(value: &MembershipRemoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl From<&MembershipRemovedAction> for MembershipRemovedAction {
    fn from(value: &MembershipRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for MembershipRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Removed => "removed".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedScope {
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "organization")]
    Organization,
}
impl From<&MembershipRemovedScope> for MembershipRemovedScope {
    fn from(value: &MembershipRemovedScope) -> Self {
        value.clone()
    }
}
impl ToString for MembershipRemovedScope {
    fn to_string(&self) -> String {
        match *self {
            Self::Team => "team".to_string(),
            Self::Organization => "organization".to_string(),
        }
    }
}
impl std::str::FromStr for MembershipRemovedScope {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "team" => Ok(Self::Team),
            "organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MembershipRemovedScope {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum MembershipRemovedTeam {
    Variant0(Team),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        deleted: Option<bool>,
        id: i64,
        name: String,
    },
}
impl From<&MembershipRemovedTeam> for MembershipRemovedTeam {
    fn from(value: &MembershipRemovedTeam) -> Self {
        value.clone()
    }
}
impl From<Team> for MembershipRemovedTeam {
    fn from(value: Team) -> Self {
        Self::Variant0(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeleted {
    pub action: MetaDeletedAction,
    pub hook: MetaDeletedHook,
    #[doc = "The id of the modified webhook."]
    pub hook_id: i64,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MetaDeleted> for MetaDeleted {
    fn from(value: &MetaDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&MetaDeletedAction> for MetaDeletedAction {
    fn from(value: &MetaDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for MetaDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MetaDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHook {
    pub active: bool,
    pub config: MetaDeletedHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
}
impl From<&MetaDeletedHook> for MetaDeletedHook {
    fn from(value: &MetaDeletedHook) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHookConfig {
    pub content_type: MetaDeletedHookConfigContentType,
    pub insecure_ssl: String,
    pub url: String,
}
impl From<&MetaDeletedHookConfig> for MetaDeletedHookConfig {
    fn from(value: &MetaDeletedHookConfig) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl From<&MetaDeletedHookConfigContentType> for MetaDeletedHookConfigContentType {
    fn from(value: &MetaDeletedHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ToString for MetaDeletedHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for MetaDeletedHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MetaDeletedHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MetaEvent(pub MetaDeleted);
impl std::ops::Deref for MetaEvent {
    type Target = MetaDeleted;
    fn deref(&self) -> &MetaDeleted {
        &self.0
    }
}
impl From<MetaEvent> for MetaDeleted {
    fn from(value: MetaEvent) -> Self {
        value.0
    }
}
impl From<&MetaEvent> for MetaEvent {
    fn from(value: &MetaEvent) -> Self {
        value.clone()
    }
}
impl From<MetaDeleted> for MetaEvent {
    fn from(value: MetaDeleted) -> Self {
        Self(value)
    }
}
#[doc = "A collection of related issues and pull requests."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Milestone {
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub description: Option<String>,
    pub due_on: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub html_url: String,
    pub id: i64,
    pub labels_url: String,
    pub node_id: String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    #[doc = "The state of the milestone."]
    pub state: MilestoneState,
    #[doc = "The title of the milestone."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&Milestone> for Milestone {
    fn from(value: &Milestone) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosed {
    pub action: MilestoneClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneClosed> for MilestoneClosed {
    fn from(value: &MilestoneClosed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&MilestoneClosedAction> for MilestoneClosedAction {
    fn from(value: &MilestoneClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreated {
    pub action: MilestoneCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneCreated> for MilestoneCreated {
    fn from(value: &MilestoneCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&MilestoneCreatedAction> for MilestoneCreatedAction {
    fn from(value: &MilestoneCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneDeleted {
    pub action: MilestoneDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneDeleted> for MilestoneDeleted {
    fn from(value: &MilestoneDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&MilestoneDeletedAction> for MilestoneDeletedAction {
    fn from(value: &MilestoneDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEdited {
    pub action: MilestoneEditedAction,
    pub changes: MilestoneEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneEdited> for MilestoneEdited {
    fn from(value: &MilestoneEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&MilestoneEditedAction> for MilestoneEditedAction {
    fn from(value: &MilestoneEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the milestone if the action was `edited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<MilestoneEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub due_on: Option<MilestoneEditedChangesDueOn>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<MilestoneEditedChangesTitle>,
}
impl From<&MilestoneEditedChanges> for MilestoneEditedChanges {
    fn from(value: &MilestoneEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesDescription> for MilestoneEditedChangesDescription {
    fn from(value: &MilestoneEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDueOn {
    #[doc = "The previous version of the due date if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesDueOn> for MilestoneEditedChangesDueOn {
    fn from(value: &MilestoneEditedChangesDueOn) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
impl From<&MilestoneEditedChangesTitle> for MilestoneEditedChangesTitle {
    fn from(value: &MilestoneEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MilestoneEvent {
    Closed(MilestoneClosed),
    Created(MilestoneCreated),
    Deleted(MilestoneDeleted),
    Edited(MilestoneEdited),
    Opened(MilestoneOpened),
}
impl From<&MilestoneEvent> for MilestoneEvent {
    fn from(value: &MilestoneEvent) -> Self {
        value.clone()
    }
}
impl From<MilestoneClosed> for MilestoneEvent {
    fn from(value: MilestoneClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<MilestoneCreated> for MilestoneEvent {
    fn from(value: MilestoneCreated) -> Self {
        Self::Created(value)
    }
}
impl From<MilestoneDeleted> for MilestoneEvent {
    fn from(value: MilestoneDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<MilestoneEdited> for MilestoneEvent {
    fn from(value: MilestoneEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<MilestoneOpened> for MilestoneEvent {
    fn from(value: MilestoneOpened) -> Self {
        Self::Opened(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpened {
    pub action: MilestoneOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&MilestoneOpened> for MilestoneOpened {
    fn from(value: &MilestoneOpened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&MilestoneOpenedAction> for MilestoneOpenedAction {
    fn from(value: &MilestoneOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The state of the milestone."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&MilestoneState> for MilestoneState {
    fn from(value: &MilestoneState) -> Self {
        value.clone()
    }
}
impl ToString for MilestoneState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for MilestoneState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MilestoneState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockBlocked {
    pub action: OrgBlockBlockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrgBlockBlocked> for OrgBlockBlocked {
    fn from(value: &OrgBlockBlocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockBlockedAction {
    #[serde(rename = "blocked")]
    Blocked,
}
impl From<&OrgBlockBlockedAction> for OrgBlockBlockedAction {
    fn from(value: &OrgBlockBlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrgBlockBlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Blocked => "blocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockBlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "blocked" => Ok(Self::Blocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrgBlockBlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrgBlockEvent {
    Blocked(OrgBlockBlocked),
    Unblocked(OrgBlockUnblocked),
}
impl From<&OrgBlockEvent> for OrgBlockEvent {
    fn from(value: &OrgBlockEvent) -> Self {
        value.clone()
    }
}
impl From<OrgBlockBlocked> for OrgBlockEvent {
    fn from(value: OrgBlockBlocked) -> Self {
        Self::Blocked(value)
    }
}
impl From<OrgBlockUnblocked> for OrgBlockEvent {
    fn from(value: OrgBlockUnblocked) -> Self {
        Self::Unblocked(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockUnblocked {
    pub action: OrgBlockUnblockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrgBlockUnblocked> for OrgBlockUnblocked {
    fn from(value: &OrgBlockUnblocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockUnblockedAction {
    #[serde(rename = "unblocked")]
    Unblocked,
}
impl From<&OrgBlockUnblockedAction> for OrgBlockUnblockedAction {
    fn from(value: &OrgBlockUnblockedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrgBlockUnblockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unblocked => "unblocked".to_string(),
        }
    }
}
impl std::str::FromStr for OrgBlockUnblockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unblocked" => Ok(Self::Unblocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrgBlockUnblockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Organization {
    pub avatar_url: String,
    pub description: Option<String>,
    pub events_url: String,
    pub hooks_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    pub id: i64,
    pub issues_url: String,
    pub login: String,
    pub members_url: String,
    pub node_id: String,
    pub public_members_url: String,
    pub repos_url: String,
    pub url: String,
}
impl From<&Organization> for Organization {
    fn from(value: &Organization) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationDeleted {
    pub action: OrganizationDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationDeleted> for OrganizationDeleted {
    fn from(value: &OrganizationDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&OrganizationDeletedAction> for OrganizationDeletedAction {
    fn from(value: &OrganizationDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrganizationEvent {
    Deleted(OrganizationDeleted),
    MemberAdded(OrganizationMemberAdded),
    MemberInvited(OrganizationMemberInvited),
    MemberRemoved(OrganizationMemberRemoved),
    Renamed(OrganizationRenamed),
}
impl From<&OrganizationEvent> for OrganizationEvent {
    fn from(value: &OrganizationEvent) -> Self {
        value.clone()
    }
}
impl From<OrganizationDeleted> for OrganizationEvent {
    fn from(value: OrganizationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<OrganizationMemberAdded> for OrganizationEvent {
    fn from(value: OrganizationMemberAdded) -> Self {
        Self::MemberAdded(value)
    }
}
impl From<OrganizationMemberInvited> for OrganizationEvent {
    fn from(value: OrganizationMemberInvited) -> Self {
        Self::MemberInvited(value)
    }
}
impl From<OrganizationMemberRemoved> for OrganizationEvent {
    fn from(value: OrganizationMemberRemoved) -> Self {
        Self::MemberRemoved(value)
    }
}
impl From<OrganizationRenamed> for OrganizationEvent {
    fn from(value: OrganizationRenamed) -> Self {
        Self::Renamed(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberAdded {
    pub action: OrganizationMemberAddedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationMemberAdded> for OrganizationMemberAdded {
    fn from(value: &OrganizationMemberAdded) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberAddedAction {
    #[serde(rename = "member_added")]
    MemberAdded,
}
impl From<&OrganizationMemberAddedAction> for OrganizationMemberAddedAction {
    fn from(value: &OrganizationMemberAddedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberAddedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberAdded => "member_added".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberAddedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_added" => Ok(Self::MemberAdded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberAddedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvited {
    pub action: OrganizationMemberInvitedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub invitation: OrganizationMemberInvitedInvitation,
    pub organization: Organization,
    pub sender: User,
    pub user: User,
}
impl From<&OrganizationMemberInvited> for OrganizationMemberInvited {
    fn from(value: &OrganizationMemberInvited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberInvitedAction {
    #[serde(rename = "member_invited")]
    MemberInvited,
}
impl From<&OrganizationMemberInvitedAction> for OrganizationMemberInvitedAction {
    fn from(value: &OrganizationMemberInvitedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberInvitedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberInvited => "member_invited".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberInvitedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_invited" => Ok(Self::MemberInvited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberInvitedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The invitation for the user or email if the action is `member_invited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvitedInvitation {
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub email: Option<String>,
    pub failed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub failed_reason: Option<String>,
    pub id: f64,
    pub invitation_teams_url: String,
    pub inviter: User,
    pub login: String,
    pub node_id: String,
    pub role: String,
    pub team_count: f64,
}
impl From<&OrganizationMemberInvitedInvitation> for OrganizationMemberInvitedInvitation {
    fn from(value: &OrganizationMemberInvitedInvitation) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberRemoved {
    pub action: OrganizationMemberRemovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationMemberRemoved> for OrganizationMemberRemoved {
    fn from(value: &OrganizationMemberRemoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberRemovedAction {
    #[serde(rename = "member_removed")]
    MemberRemoved,
}
impl From<&OrganizationMemberRemovedAction> for OrganizationMemberRemovedAction {
    fn from(value: &OrganizationMemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationMemberRemovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::MemberRemoved => "member_removed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationMemberRemovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "member_removed" => Ok(Self::MemberRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationMemberRemovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamed {
    pub action: OrganizationRenamedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl From<&OrganizationRenamed> for OrganizationRenamed {
    fn from(value: &OrganizationRenamed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl From<&OrganizationRenamedAction> for OrganizationRenamedAction {
    fn from(value: &OrganizationRenamedAction) -> Self {
        value.clone()
    }
}
impl ToString for OrganizationRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for OrganizationRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrganizationRenamedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackageEvent {
    Published(PackagePublished),
    Updated(PackageUpdated),
}
impl From<&PackageEvent> for PackageEvent {
    fn from(value: &PackageEvent) -> Self {
        value.clone()
    }
}
impl From<PackagePublished> for PackageEvent {
    fn from(value: PackagePublished) -> Self {
        Self::Published(value)
    }
}
impl From<PackageUpdated> for PackageEvent {
    fn from(value: PackageUpdated) -> Self {
        Self::Updated(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublished {
    pub action: PackagePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackagePublishedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PackagePublished> for PackagePublished {
    fn from(value: &PackagePublished) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackagePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&PackagePublishedAction> for PackagePublishedAction {
    fn from(value: &PackagePublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for PackagePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for PackagePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackagePublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackagePublishedPackagePackageVersion,
    pub registry: PackagePublishedPackageRegistry,
    pub updated_at: String,
}
impl From<&PackagePublishedPackage> for PackagePublishedPackage {
    fn from(value: &PackagePublishedPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackagePublishedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackagePublishedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
impl From<&PackagePublishedPackagePackageVersion> for PackagePublishedPackagePackageVersion {
    fn from(value: &PackagePublishedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
impl From<&PackagePublishedPackagePackageVersionPackageFilesItem>
    for PackagePublishedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackagePublishedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
impl From<&PackagePublishedPackagePackageVersionRelease>
    for PackagePublishedPackagePackageVersionRelease
{
    fn from(value: &PackagePublishedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
impl From<&PackagePublishedPackageRegistry> for PackagePublishedPackageRegistry {
    fn from(value: &PackagePublishedPackageRegistry) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdated {
    pub action: PackageUpdatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub package: PackageUpdatedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PackageUpdated> for PackageUpdated {
    fn from(value: &PackageUpdated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackageUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl From<&PackageUpdatedAction> for PackageUpdatedAction {
    fn from(value: &PackageUpdatedAction) -> Self {
        value.clone()
    }
}
impl ToString for PackageUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for PackageUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackageUpdatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackage {
    pub created_at: String,
    pub description: Option<String>,
    pub ecosystem: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub namespace: String,
    pub owner: User,
    pub package_type: String,
    pub package_version: PackageUpdatedPackagePackageVersion,
    pub registry: PackageUpdatedPackageRegistry,
    pub updated_at: String,
}
impl From<&PackageUpdatedPackage> for PackageUpdatedPackage {
    fn from(value: &PackageUpdatedPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersion {
    pub author: User,
    pub body: String,
    pub body_html: String,
    pub created_at: String,
    pub description: String,
    pub docker_metadata: Vec<serde_json::Value>,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub installation_command: String,
    pub manifest: String,
    pub metadata: Vec<serde_json::Value>,
    pub name: String,
    pub package_files: Vec<PackageUpdatedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackageUpdatedPackagePackageVersionRelease,
    pub source_url: String,
    pub summary: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub target_oid: String,
    pub updated_at: String,
    pub version: String,
}
impl From<&PackageUpdatedPackagePackageVersion> for PackageUpdatedPackagePackageVersion {
    fn from(value: &PackageUpdatedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionPackageFilesItem {
    pub content_type: String,
    pub created_at: String,
    pub download_url: String,
    pub id: i64,
    pub md5: String,
    pub name: String,
    pub sha1: String,
    pub sha256: String,
    pub size: i64,
    pub state: String,
    pub updated_at: String,
}
impl From<&PackageUpdatedPackagePackageVersionPackageFilesItem>
    for PackageUpdatedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackageUpdatedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: String,
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub prerelease: bool,
    pub published_at: String,
    pub tag_name: String,
    pub target_commitish: String,
    pub url: String,
}
impl From<&PackageUpdatedPackagePackageVersionRelease>
    for PackageUpdatedPackagePackageVersionRelease
{
    fn from(value: &PackageUpdatedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackageRegistry {
    pub about_url: String,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    pub url: String,
    pub vendor: String,
}
impl From<&PackageUpdatedPackageRegistry> for PackageUpdatedPackageRegistry {
    fn from(value: &PackageUpdatedPackageRegistry) -> Self {
        value.clone()
    }
}
#[doc = "Page Build"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEvent {
    pub build: PageBuildEventBuild,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PageBuildEvent> for PageBuildEvent {
    fn from(value: &PageBuildEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuild {
    pub commit: String,
    pub created_at: String,
    pub duration: i64,
    pub error: PageBuildEventBuildError,
    pub pusher: User,
    pub status: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&PageBuildEventBuild> for PageBuildEventBuild {
    fn from(value: &PageBuildEventBuild) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuildError {
    pub message: Option<String>,
}
impl From<&PageBuildEventBuildError> for PageBuildEventBuildError {
    fn from(value: &PageBuildEventBuildError) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEvent {
    pub hook: PingEventHook,
    #[doc = "The ID of the webhook that triggered the ping."]
    pub hook_id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sender: Option<User>,
    pub zen: String,
}
impl From<&PingEvent> for PingEvent {
    fn from(value: &PingEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook)."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHook {
    pub active: bool,
    #[doc = "When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_id: Option<i64>,
    pub config: PingEventHookConfig,
    pub created_at: String,
    pub events: WebhookEvents,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_response: Option<PingEventHookLastResponse>,
    pub name: String,
    pub ping_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test_url: Option<String>,
    #[serde(rename = "type")]
    pub type_: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&PingEventHook> for PingEventHook {
    fn from(value: &PingEventHook) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookConfig {
    pub content_type: PingEventHookConfigContentType,
    pub insecure_ssl: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    pub url: String,
}
impl From<&PingEventHookConfig> for PingEventHookConfig {
    fn from(value: &PingEventHookConfig) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PingEventHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl From<&PingEventHookConfigContentType> for PingEventHookConfigContentType {
    fn from(value: &PingEventHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ToString for PingEventHookConfigContentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
            Self::Form => "form".to_string(),
        }
    }
}
impl std::str::FromStr for PingEventHookConfigContentType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PingEventHookConfigContentType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookLastResponse {
    pub code: (),
    pub message: (),
    pub status: String,
}
impl From<&PingEventHookLastResponse> for PingEventHookLastResponse {
    fn from(value: &PingEventHookLastResponse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Project {
    #[doc = "Body of the project"]
    pub body: Option<String>,
    pub columns_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    pub html_url: String,
    pub id: i64,
    #[doc = "Name of the project"]
    pub name: String,
    pub node_id: String,
    pub number: i64,
    pub owner_url: String,
    #[doc = "State of the project; either 'open' or 'closed'"]
    pub state: ProjectState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&Project> for Project {
    fn from(value: &Project) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCard {
    #[serde(default)]
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: String,
    pub note: Option<String>,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&ProjectCard> for ProjectCard {
    fn from(value: &ProjectCard) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConverted {
    pub action: ProjectCardConvertedAction,
    pub changes: ProjectCardConvertedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardConverted> for ProjectCardConverted {
    fn from(value: &ProjectCardConverted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardConvertedAction {
    #[serde(rename = "converted")]
    Converted,
}
impl From<&ProjectCardConvertedAction> for ProjectCardConvertedAction {
    fn from(value: &ProjectCardConvertedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardConvertedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Converted => "converted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardConvertedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted" => Ok(Self::Converted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardConvertedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChanges {
    pub note: ProjectCardConvertedChangesNote,
}
impl From<&ProjectCardConvertedChanges> for ProjectCardConvertedChanges {
    fn from(value: &ProjectCardConvertedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChangesNote {
    pub from: String,
}
impl From<&ProjectCardConvertedChangesNote> for ProjectCardConvertedChangesNote {
    fn from(value: &ProjectCardConvertedChangesNote) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardCreated {
    pub action: ProjectCardCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardCreated> for ProjectCardCreated {
    fn from(value: &ProjectCardCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectCardCreatedAction> for ProjectCardCreatedAction {
    fn from(value: &ProjectCardCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardDeleted {
    pub action: ProjectCardDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardDeleted> for ProjectCardDeleted {
    fn from(value: &ProjectCardDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectCardDeletedAction> for ProjectCardDeletedAction {
    fn from(value: &ProjectCardDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEdited {
    pub action: ProjectCardEditedAction,
    pub changes: ProjectCardEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardEdited> for ProjectCardEdited {
    fn from(value: &ProjectCardEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectCardEditedAction> for ProjectCardEditedAction {
    fn from(value: &ProjectCardEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChanges {
    pub note: ProjectCardEditedChangesNote,
}
impl From<&ProjectCardEditedChanges> for ProjectCardEditedChanges {
    fn from(value: &ProjectCardEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChangesNote {
    pub from: String,
}
impl From<&ProjectCardEditedChangesNote> for ProjectCardEditedChangesNote {
    fn from(value: &ProjectCardEditedChangesNote) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectCardEvent {
    Converted(ProjectCardConverted),
    Created(ProjectCardCreated),
    Deleted(ProjectCardDeleted),
    Edited(ProjectCardEdited),
    Moved(ProjectCardMoved),
}
impl From<&ProjectCardEvent> for ProjectCardEvent {
    fn from(value: &ProjectCardEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectCardConverted> for ProjectCardEvent {
    fn from(value: ProjectCardConverted) -> Self {
        Self::Converted(value)
    }
}
impl From<ProjectCardCreated> for ProjectCardEvent {
    fn from(value: ProjectCardCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectCardDeleted> for ProjectCardEvent {
    fn from(value: ProjectCardDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectCardEdited> for ProjectCardEvent {
    fn from(value: ProjectCardEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectCardMoved> for ProjectCardEvent {
    fn from(value: ProjectCardMoved) -> Self {
        Self::Moved(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMoved {
    pub action: ProjectCardMovedAction,
    pub changes: ProjectCardMovedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCardMoved> for ProjectCardMoved {
    fn from(value: &ProjectCardMoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl From<&ProjectCardMovedAction> for ProjectCardMovedAction {
    fn from(value: &ProjectCardMovedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCardMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCardMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCardMovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChanges {
    pub column_id: ProjectCardMovedChangesColumnId,
}
impl From<&ProjectCardMovedChanges> for ProjectCardMovedChanges {
    fn from(value: &ProjectCardMovedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChangesColumnId {
    pub from: i64,
}
impl From<&ProjectCardMovedChangesColumnId> for ProjectCardMovedChangesColumnId {
    fn from(value: &ProjectCardMovedChangesColumnId) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectClosed {
    pub action: ProjectClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectClosed> for ProjectClosed {
    fn from(value: &ProjectClosed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&ProjectClosedAction> for ProjectClosedAction {
    fn from(value: &ProjectClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumn {
    pub cards_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The unique identifier of the project column"]
    pub id: i64,
    #[doc = "Name of the project column"]
    pub name: String,
    pub node_id: String,
    pub project_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
}
impl From<&ProjectColumn> for ProjectColumn {
    fn from(value: &ProjectColumn) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnCreated {
    pub action: ProjectColumnCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnCreated> for ProjectColumnCreated {
    fn from(value: &ProjectColumnCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectColumnCreatedAction> for ProjectColumnCreatedAction {
    fn from(value: &ProjectColumnCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnDeleted {
    pub action: ProjectColumnDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnDeleted> for ProjectColumnDeleted {
    fn from(value: &ProjectColumnDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectColumnDeletedAction> for ProjectColumnDeletedAction {
    fn from(value: &ProjectColumnDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEdited {
    pub action: ProjectColumnEditedAction,
    pub changes: ProjectColumnEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnEdited> for ProjectColumnEdited {
    fn from(value: &ProjectColumnEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectColumnEditedAction> for ProjectColumnEditedAction {
    fn from(value: &ProjectColumnEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectColumnEditedChangesName>,
}
impl From<&ProjectColumnEditedChanges> for ProjectColumnEditedChanges {
    fn from(value: &ProjectColumnEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChangesName {
    pub from: String,
}
impl From<&ProjectColumnEditedChangesName> for ProjectColumnEditedChangesName {
    fn from(value: &ProjectColumnEditedChangesName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectColumnEvent {
    Created(ProjectColumnCreated),
    Deleted(ProjectColumnDeleted),
    Edited(ProjectColumnEdited),
    Moved(ProjectColumnMoved),
}
impl From<&ProjectColumnEvent> for ProjectColumnEvent {
    fn from(value: &ProjectColumnEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectColumnCreated> for ProjectColumnEvent {
    fn from(value: ProjectColumnCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectColumnDeleted> for ProjectColumnEvent {
    fn from(value: ProjectColumnDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectColumnEdited> for ProjectColumnEvent {
    fn from(value: ProjectColumnEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectColumnMoved> for ProjectColumnEvent {
    fn from(value: ProjectColumnMoved) -> Self {
        Self::Moved(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnMoved {
    pub action: ProjectColumnMovedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectColumnMoved> for ProjectColumnMoved {
    fn from(value: &ProjectColumnMoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl From<&ProjectColumnMovedAction> for ProjectColumnMovedAction {
    fn from(value: &ProjectColumnMovedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectColumnMovedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Moved => "moved".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectColumnMovedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectColumnMovedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCreated {
    pub action: ProjectCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectCreated> for ProjectCreated {
    fn from(value: &ProjectCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ProjectCreatedAction> for ProjectCreatedAction {
    fn from(value: &ProjectCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectDeleted {
    pub action: ProjectDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectDeleted> for ProjectDeleted {
    fn from(value: &ProjectDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ProjectDeletedAction> for ProjectDeletedAction {
    fn from(value: &ProjectDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEdited {
    pub action: ProjectEditedAction,
    pub changes: ProjectEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectEdited> for ProjectEdited {
    fn from(value: &ProjectEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ProjectEditedAction> for ProjectEditedAction {
    fn from(value: &ProjectEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the project if the action was `edited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ProjectEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ProjectEditedChangesName>,
}
impl From<&ProjectEditedChanges> for ProjectEditedChanges {
    fn from(value: &ProjectEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&ProjectEditedChangesBody> for ProjectEditedChangesBody {
    fn from(value: &ProjectEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesName {
    #[doc = "The changes to the project if the action was `edited`."]
    pub from: String,
}
impl From<&ProjectEditedChangesName> for ProjectEditedChangesName {
    fn from(value: &ProjectEditedChangesName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectEvent {
    Closed(ProjectClosed),
    Created(ProjectCreated),
    Deleted(ProjectDeleted),
    Edited(ProjectEdited),
    Reopened(ProjectReopened),
}
impl From<&ProjectEvent> for ProjectEvent {
    fn from(value: &ProjectEvent) -> Self {
        value.clone()
    }
}
impl From<ProjectClosed> for ProjectEvent {
    fn from(value: ProjectClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<ProjectCreated> for ProjectEvent {
    fn from(value: ProjectCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ProjectDeleted> for ProjectEvent {
    fn from(value: ProjectDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ProjectEdited> for ProjectEvent {
    fn from(value: ProjectEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ProjectReopened> for ProjectEvent {
    fn from(value: ProjectReopened) -> Self {
        Self::Reopened(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectReopened {
    pub action: ProjectReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ProjectReopened> for ProjectReopened {
    fn from(value: &ProjectReopened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&ProjectReopenedAction> for ProjectReopenedAction {
    fn from(value: &ProjectReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for ProjectReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "State of the project; either 'open' or 'closed'"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&ProjectState> for ProjectState {
    fn from(value: &ProjectState) -> Self {
        value.clone()
    }
}
impl ToString for ProjectState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "When a private repository is made public."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PublicEvent> for PublicEvent {
    fn from(value: &PublicEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequest {
    pub active_lock_reason: Option<PullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestBase,
    pub body: Option<String>,
    pub changed_files: i64,
    pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: String,
    pub commits: i64,
    pub commits_url: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: Option<String>,
    pub mergeable: Option<bool>,
    pub mergeable_state: String,
    pub merged: Option<bool>,
    pub merged_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    pub merged_by: Option<User>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: String,
    pub rebaseable: Option<bool>,
    pub requested_reviewers: Vec<PullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments: i64,
    pub review_comments_url: String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestState,
    pub statuses_url: String,
    #[doc = "The title of the pull request."]
    pub title: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub user: User,
}
impl From<&PullRequest> for PullRequest {
    fn from(value: &PullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestActiveLockReason> for PullRequestActiveLockReason {
    fn from(value: &PullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAssigned {
    pub action: PullRequestAssignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAssigned> for PullRequestAssigned {
    fn from(value: &PullRequestAssigned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl From<&PullRequestAssignedAction> for PullRequestAssignedAction {
    fn from(value: &PullRequestAssignedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAssignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Assigned => "assigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAssignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAssignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeDisabled {
    pub action: PullRequestAutoMergeDisabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAutoMergeDisabled> for PullRequestAutoMergeDisabled {
    fn from(value: &PullRequestAutoMergeDisabled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeDisabledAction {
    #[serde(rename = "auto_merge_disabled")]
    AutoMergeDisabled,
}
impl From<&PullRequestAutoMergeDisabledAction> for PullRequestAutoMergeDisabledAction {
    fn from(value: &PullRequestAutoMergeDisabledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAutoMergeDisabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeDisabled => "auto_merge_disabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeDisabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_disabled" => Ok(Self::AutoMergeDisabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeDisabledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeEnabled {
    pub action: PullRequestAutoMergeEnabledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestAutoMergeEnabled> for PullRequestAutoMergeEnabled {
    fn from(value: &PullRequestAutoMergeEnabled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeEnabledAction {
    #[serde(rename = "auto_merge_enabled")]
    AutoMergeEnabled,
}
impl From<&PullRequestAutoMergeEnabledAction> for PullRequestAutoMergeEnabledAction {
    fn from(value: &PullRequestAutoMergeEnabledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestAutoMergeEnabledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AutoMergeEnabled => "auto_merge_enabled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestAutoMergeEnabledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto_merge_enabled" => Ok(Self::AutoMergeEnabled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeEnabledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestBase> for PullRequestBase {
    fn from(value: &PullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosed {
    pub action: PullRequestClosedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestClosed> for PullRequestClosed {
    fn from(value: &PullRequestClosed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestClosedAction> for PullRequestClosedAction {
    fn from(value: &PullRequestClosedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestClosedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestClosedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestClosedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraft {
    pub action: PullRequestConvertedToDraftAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestConvertedToDraft> for PullRequestConvertedToDraft {
    fn from(value: &PullRequestConvertedToDraft) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestConvertedToDraftAction {
    #[serde(rename = "converted_to_draft")]
    ConvertedToDraft,
}
impl From<&PullRequestConvertedToDraftAction> for PullRequestConvertedToDraftAction {
    fn from(value: &PullRequestConvertedToDraftAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestConvertedToDraftAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ConvertedToDraft => "converted_to_draft".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestConvertedToDraftAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "converted_to_draft" => Ok(Self::ConvertedToDraft),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestConvertedToDraftAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEdited {
    pub action: PullRequestEditedAction,
    pub changes: PullRequestEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestEdited> for PullRequestEdited {
    fn from(value: &PullRequestEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestEditedAction> for PullRequestEditedAction {
    fn from(value: &PullRequestEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment if the action was `edited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<PullRequestEditedChangesTitle>,
}
impl From<&PullRequestEditedChanges> for PullRequestEditedChanges {
    fn from(value: &PullRequestEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestEditedChangesBody> for PullRequestEditedChangesBody {
    fn from(value: &PullRequestEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestEditedChangesTitle> for PullRequestEditedChangesTitle {
    fn from(value: &PullRequestEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestEvent {
    Assigned(PullRequestAssigned),
    AutoMergeDisabled(PullRequestAutoMergeDisabled),
    AutoMergeEnabled(PullRequestAutoMergeEnabled),
    Closed(PullRequestClosed),
    ConvertedToDraft(PullRequestConvertedToDraft),
    Edited(PullRequestEdited),
    Labeled(PullRequestLabeled),
    Locked(PullRequestLocked),
    Opened(PullRequestOpened),
    ReadyForReview(PullRequestReadyForReview),
    Reopened(PullRequestReopened),
    ReviewRequestRemoved(PullRequestReviewRequestRemoved),
    ReviewRequested(PullRequestReviewRequested),
    Synchronize(PullRequestSynchronize),
    Unassigned(PullRequestUnassigned),
    Unlabeled(PullRequestUnlabeled),
    Unlocked(PullRequestUnlocked),
}
impl From<&PullRequestEvent> for PullRequestEvent {
    fn from(value: &PullRequestEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestAssigned> for PullRequestEvent {
    fn from(value: PullRequestAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl From<PullRequestAutoMergeDisabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeDisabled) -> Self {
        Self::AutoMergeDisabled(value)
    }
}
impl From<PullRequestAutoMergeEnabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeEnabled) -> Self {
        Self::AutoMergeEnabled(value)
    }
}
impl From<PullRequestClosed> for PullRequestEvent {
    fn from(value: PullRequestClosed) -> Self {
        Self::Closed(value)
    }
}
impl From<PullRequestConvertedToDraft> for PullRequestEvent {
    fn from(value: PullRequestConvertedToDraft) -> Self {
        Self::ConvertedToDraft(value)
    }
}
impl From<PullRequestEdited> for PullRequestEvent {
    fn from(value: PullRequestEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<PullRequestLabeled> for PullRequestEvent {
    fn from(value: PullRequestLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl From<PullRequestLocked> for PullRequestEvent {
    fn from(value: PullRequestLocked) -> Self {
        Self::Locked(value)
    }
}
impl From<PullRequestOpened> for PullRequestEvent {
    fn from(value: PullRequestOpened) -> Self {
        Self::Opened(value)
    }
}
impl From<PullRequestReadyForReview> for PullRequestEvent {
    fn from(value: PullRequestReadyForReview) -> Self {
        Self::ReadyForReview(value)
    }
}
impl From<PullRequestReopened> for PullRequestEvent {
    fn from(value: PullRequestReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<PullRequestReviewRequestRemoved> for PullRequestEvent {
    fn from(value: PullRequestReviewRequestRemoved) -> Self {
        Self::ReviewRequestRemoved(value)
    }
}
impl From<PullRequestReviewRequested> for PullRequestEvent {
    fn from(value: PullRequestReviewRequested) -> Self {
        Self::ReviewRequested(value)
    }
}
impl From<PullRequestSynchronize> for PullRequestEvent {
    fn from(value: PullRequestSynchronize) -> Self {
        Self::Synchronize(value)
    }
}
impl From<PullRequestUnassigned> for PullRequestEvent {
    fn from(value: PullRequestUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl From<PullRequestUnlabeled> for PullRequestEvent {
    fn from(value: PullRequestUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl From<PullRequestUnlocked> for PullRequestEvent {
    fn from(value: PullRequestUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestHead> for PullRequestHead {
    fn from(value: &PullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLabeled {
    pub action: PullRequestLabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestLabeled> for PullRequestLabeled {
    fn from(value: &PullRequestLabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl From<&PullRequestLabeledAction> for PullRequestLabeledAction {
    fn from(value: &PullRequestLabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestLabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Labeled => "labeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestLabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestLinks> for PullRequestLinks {
    fn from(value: &PullRequestLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLocked {
    pub action: PullRequestLockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestLocked> for PullRequestLocked {
    fn from(value: &PullRequestLocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl From<&PullRequestLockedAction> for PullRequestLockedAction {
    fn from(value: &PullRequestLockedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestLockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Locked => "locked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestLockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestLockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpened {
    pub action: PullRequestOpenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestOpened> for PullRequestOpened {
    fn from(value: &PullRequestOpened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl From<&PullRequestOpenedAction> for PullRequestOpenedAction {
    fn from(value: &PullRequestOpenedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestOpenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Opened => "opened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestOpenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestOpenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReview {
    pub action: PullRequestReadyForReviewAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReadyForReview> for PullRequestReadyForReview {
    fn from(value: &PullRequestReadyForReview) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReadyForReviewAction {
    #[serde(rename = "ready_for_review")]
    ReadyForReview,
}
impl From<&PullRequestReadyForReviewAction> for PullRequestReadyForReviewAction {
    fn from(value: &PullRequestReadyForReviewAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReadyForReviewAction {
    fn to_string(&self) -> String {
        match *self {
            Self::ReadyForReview => "ready_for_review".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReadyForReviewAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ready_for_review" => Ok(Self::ReadyForReview),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReadyForReviewAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopened {
    pub action: PullRequestReopenedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReopened> for PullRequestReopened {
    fn from(value: &PullRequestReopened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&PullRequestReopenedAction> for PullRequestReopenedAction {
    fn from(value: &PullRequestReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestRequestedReviewersItem> for PullRequestRequestedReviewersItem {
    fn from(value: &PullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "The diff of the line that the comment refers to."]
    pub diff_hunk: String,
    #[doc = "HTML URL for the pull request review comment."]
    pub html_url: String,
    #[doc = "The ID of the pull request review comment."]
    pub id: i64,
    #[doc = "The comment ID to reply to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: Option<i64>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentLinks,
    #[doc = "The node ID of the pull request review comment."]
    pub node_id: String,
    #[doc = "The SHA of the original commit to which the comment applies."]
    pub original_commit_id: String,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub original_line: i64,
    #[doc = "The index of the original line in the diff to which the comment applies."]
    pub original_position: i64,
    #[doc = "The first line of the range for a multi-line comment."]
    pub original_start_line: Option<i64>,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: String,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: Option<i64>,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    pub pull_request_review_id: i64,
    #[doc = "URL for the pull request that the review comment belongs to."]
    pub pull_request_url: String,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub side: PullRequestReviewCommentSide,
    #[doc = "The first line of the range for a multi-line comment."]
    pub start_line: Option<i64>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub start_side: Option<PullRequestReviewCommentStartSide>,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[doc = "URL for the pull request review comment"]
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewComment> for PullRequestReviewComment {
    fn from(value: &PullRequestReviewComment) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreated {
    pub action: PullRequestReviewCommentCreatedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentCreatedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentCreated> for PullRequestReviewCommentCreated {
    fn from(value: &PullRequestReviewCommentCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&PullRequestReviewCommentCreatedAction> for PullRequestReviewCommentCreatedAction {
    fn from(value: &PullRequestReviewCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentCreatedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentCreatedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentCreatedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentCreatedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentCreatedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequest>
    for PullRequestReviewCommentCreatedPullRequest
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentCreatedPullRequestActiveLockReason>
    for PullRequestReviewCommentCreatedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestBase>
    for PullRequestReviewCommentCreatedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestHead>
    for PullRequestReviewCommentCreatedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentCreatedPullRequestLinks>
    for PullRequestReviewCommentCreatedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentCreatedPullRequestState>
    for PullRequestReviewCommentCreatedPullRequestState
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentCreatedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeleted {
    pub action: PullRequestReviewCommentDeletedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentDeletedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentDeleted> for PullRequestReviewCommentDeleted {
    fn from(value: &PullRequestReviewCommentDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&PullRequestReviewCommentDeletedAction> for PullRequestReviewCommentDeletedAction {
    fn from(value: &PullRequestReviewCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentDeletedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentDeletedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentDeletedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentDeletedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentDeletedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequest>
    for PullRequestReviewCommentDeletedPullRequest
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentDeletedPullRequestActiveLockReason>
    for PullRequestReviewCommentDeletedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestBase>
    for PullRequestReviewCommentDeletedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestHead>
    for PullRequestReviewCommentDeletedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentDeletedPullRequestLinks>
    for PullRequestReviewCommentDeletedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentDeletedPullRequestState>
    for PullRequestReviewCommentDeletedPullRequestState
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentDeletedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEdited {
    pub action: PullRequestReviewCommentEditedAction,
    pub changes: PullRequestReviewCommentEditedChanges,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequestReviewCommentEditedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestReviewCommentEdited> for PullRequestReviewCommentEdited {
    fn from(value: &PullRequestReviewCommentEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestReviewCommentEditedAction> for PullRequestReviewCommentEditedAction {
    fn from(value: &PullRequestReviewCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewCommentEditedChangesBody>,
}
impl From<&PullRequestReviewCommentEditedChanges> for PullRequestReviewCommentEditedChanges {
    fn from(value: &PullRequestReviewCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: String,
}
impl From<&PullRequestReviewCommentEditedChangesBody>
    for PullRequestReviewCommentEditedChangesBody
{
    fn from(value: &PullRequestReviewCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequest {
    pub active_lock_reason: Option<PullRequestReviewCommentEditedPullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentEditedPullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub draft: Option<bool>,
    pub head: PullRequestReviewCommentEditedPullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentEditedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: PullRequestReviewCommentEditedPullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequest>
    for PullRequestReviewCommentEditedPullRequest
{
    fn from(value: &PullRequestReviewCommentEditedPullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&PullRequestReviewCommentEditedPullRequestActiveLockReason>
    for PullRequestReviewCommentEditedPullRequestActiveLockReason
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequestBase>
    for PullRequestReviewCommentEditedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&PullRequestReviewCommentEditedPullRequestHead>
    for PullRequestReviewCommentEditedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&PullRequestReviewCommentEditedPullRequestLinks>
    for PullRequestReviewCommentEditedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>
    for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestReviewCommentEditedPullRequestState>
    for PullRequestReviewCommentEditedPullRequestState
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentEditedPullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEvent {
    Created(PullRequestReviewCommentCreated),
    Deleted(PullRequestReviewCommentDeleted),
    Edited(PullRequestReviewCommentEdited),
}
impl From<&PullRequestReviewCommentEvent> for PullRequestReviewCommentEvent {
    fn from(value: &PullRequestReviewCommentEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestReviewCommentCreated> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl From<PullRequestReviewCommentDeleted> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<PullRequestReviewCommentEdited> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentLinks {
    pub html: Link,
    pub pull_request: Link,
    #[serde(rename = "self")]
    pub self_: Link,
}
impl From<&PullRequestReviewCommentLinks> for PullRequestReviewCommentLinks {
    fn from(value: &PullRequestReviewCommentLinks) -> Self {
        value.clone()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl From<&PullRequestReviewCommentSide> for PullRequestReviewCommentSide {
    fn from(value: &PullRequestReviewCommentSide) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentSide {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentStartSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl From<&PullRequestReviewCommentStartSide> for PullRequestReviewCommentStartSide {
    fn from(value: &PullRequestReviewCommentStartSide) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewCommentStartSide {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "LEFT".to_string(),
            Self::Right => "RIGHT".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewCommentStartSide {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentStartSide {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissed {
    pub action: PullRequestReviewDismissedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewDismissedReview,
    pub sender: User,
}
impl From<&PullRequestReviewDismissed> for PullRequestReviewDismissed {
    fn from(value: &PullRequestReviewDismissed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewDismissedAction {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&PullRequestReviewDismissedAction> for PullRequestReviewDismissedAction {
    fn from(value: &PullRequestReviewDismissedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewDismissedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewDismissedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewDismissedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: PullRequestReviewDismissedReviewState,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewDismissedReview> for PullRequestReviewDismissedReview {
    fn from(value: &PullRequestReviewDismissedReview) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewDismissedReviewLinks> for PullRequestReviewDismissedReviewLinks {
    fn from(value: &PullRequestReviewDismissedReviewLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewDismissedReviewState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl From<&PullRequestReviewDismissedReviewState> for PullRequestReviewDismissedReviewState {
    fn from(value: &PullRequestReviewDismissedReviewState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewDismissedReviewState {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismissed => "dismissed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewDismissedReviewState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewDismissedReviewState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEdited {
    pub action: PullRequestReviewEditedAction,
    pub changes: PullRequestReviewEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewEditedReview,
    pub sender: User,
}
impl From<&PullRequestReviewEdited> for PullRequestReviewEdited {
    fn from(value: &PullRequestReviewEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&PullRequestReviewEditedAction> for PullRequestReviewEditedAction {
    fn from(value: &PullRequestReviewEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<PullRequestReviewEditedChangesBody>,
}
impl From<&PullRequestReviewEditedChanges> for PullRequestReviewEditedChanges {
    fn from(value: &PullRequestReviewEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&PullRequestReviewEditedChangesBody> for PullRequestReviewEditedChangesBody {
    fn from(value: &PullRequestReviewEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewEditedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewEditedReview> for PullRequestReviewEditedReview {
    fn from(value: &PullRequestReviewEditedReview) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewEditedReviewLinks> for PullRequestReviewEditedReviewLinks {
    fn from(value: &PullRequestReviewEditedReviewLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewEvent {
    Dismissed(PullRequestReviewDismissed),
    Edited(PullRequestReviewEdited),
    Submitted(PullRequestReviewSubmitted),
}
impl From<&PullRequestReviewEvent> for PullRequestReviewEvent {
    fn from(value: &PullRequestReviewEvent) -> Self {
        value.clone()
    }
}
impl From<PullRequestReviewDismissed> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewDismissed) -> Self {
        Self::Dismissed(value)
    }
}
impl From<PullRequestReviewEdited> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<PullRequestReviewSubmitted> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewSubmitted) -> Self {
        Self::Submitted(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequestRemoved {
    Variant0 {
        action: PullRequestReviewRequestRemovedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestRemovedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl From<&PullRequestReviewRequestRemoved> for PullRequestReviewRequestRemoved {
    fn from(value: &PullRequestReviewRequestRemoved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant0Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant0Action>
    for PullRequestReviewRequestRemovedVariant0Action
{
    fn from(value: &PullRequestReviewRequestRemovedVariant0Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestRemovedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant1Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant1Action>
    for PullRequestReviewRequestRemovedVariant1Action
{
    fn from(value: &PullRequestReviewRequestRemovedVariant1Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestRemovedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequestRemoved => "review_request_removed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequested {
    Variant0 {
        action: PullRequestReviewRequestedVariant0Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestedVariant1Action,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        installation: Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        organization: Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl From<&PullRequestReviewRequested> for PullRequestReviewRequested {
    fn from(value: &PullRequestReviewRequested) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant0Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant0Action> for PullRequestReviewRequestedVariant0Action {
    fn from(value: &PullRequestReviewRequestedVariant0Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestedVariant0Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant0Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant0Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant1Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant1Action> for PullRequestReviewRequestedVariant1Action {
    fn from(value: &PullRequestReviewRequestedVariant1Action) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewRequestedVariant1Action {
    fn to_string(&self) -> String {
        match *self {
            Self::ReviewRequested => "review_requested".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewRequestedVariant1Action {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant1Action {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmitted {
    pub action: PullRequestReviewSubmittedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewSubmittedReview,
    pub sender: User,
}
impl From<&PullRequestReviewSubmitted> for PullRequestReviewSubmitted {
    fn from(value: &PullRequestReviewSubmitted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewSubmittedAction {
    #[serde(rename = "submitted")]
    Submitted,
}
impl From<&PullRequestReviewSubmittedAction> for PullRequestReviewSubmittedAction {
    fn from(value: &PullRequestReviewSubmittedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestReviewSubmittedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Submitted => "submitted".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestReviewSubmittedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "submitted" => Ok(Self::Submitted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestReviewSubmittedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: Option<String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: String,
    pub html_url: String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewSubmittedReviewLinks,
    pub node_id: String,
    pub pull_request_url: String,
    pub state: String,
    pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    pub user: User,
}
impl From<&PullRequestReviewSubmittedReview> for PullRequestReviewSubmittedReview {
    fn from(value: &PullRequestReviewSubmittedReview) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl From<&PullRequestReviewSubmittedReviewLinks> for PullRequestReviewSubmittedReviewLinks {
    fn from(value: &PullRequestReviewSubmittedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&PullRequestState> for PullRequestState {
    fn from(value: &PullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestSynchronize {
    pub action: PullRequestSynchronizeAction,
    pub after: String,
    pub before: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestSynchronize> for PullRequestSynchronize {
    fn from(value: &PullRequestSynchronize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestSynchronizeAction {
    #[serde(rename = "synchronize")]
    Synchronize,
}
impl From<&PullRequestSynchronizeAction> for PullRequestSynchronizeAction {
    fn from(value: &PullRequestSynchronizeAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestSynchronizeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Synchronize => "synchronize".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestSynchronizeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "synchronize" => Ok(Self::Synchronize),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestSynchronizeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnassigned {
    pub action: PullRequestUnassignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnassigned> for PullRequestUnassigned {
    fn from(value: &PullRequestUnassigned) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl From<&PullRequestUnassignedAction> for PullRequestUnassignedAction {
    fn from(value: &PullRequestUnassignedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnassignedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unassigned => "unassigned".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnassignedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnassignedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlabeled {
    pub action: PullRequestUnlabeledAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnlabeled> for PullRequestUnlabeled {
    fn from(value: &PullRequestUnlabeled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl From<&PullRequestUnlabeledAction> for PullRequestUnlabeledAction {
    fn from(value: &PullRequestUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnlabeledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlabeled => "unlabeled".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlabeledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnlabeledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlocked {
    pub action: PullRequestUnlockedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PullRequestUnlocked> for PullRequestUnlocked {
    fn from(value: &PullRequestUnlocked) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl From<&PullRequestUnlockedAction> for PullRequestUnlockedAction {
    fn from(value: &PullRequestUnlockedAction) -> Self {
        value.clone()
    }
}
impl ToString for PullRequestUnlockedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unlocked => "unlocked".to_string(),
        }
    }
}
impl std::str::FromStr for PullRequestUnlockedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PullRequestUnlockedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PushEvent {
    #[doc = "The SHA of the most recent commit on `ref` after the push."]
    pub after: String,
    pub base_ref: Option<String>,
    #[doc = "The SHA of the most recent commit on `ref` before the push."]
    pub before: String,
    #[doc = "An array of commit objects describing the pushed commits."]
    pub commits: Vec<Commit>,
    pub compare: String,
    pub created: bool,
    pub deleted: bool,
    pub forced: bool,
    pub head_commit: Option<Commit>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub pusher: Committer,
    #[doc = "The full git ref that was pushed. Example: `refs/heads/main`."]
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
}
impl From<&PushEvent> for PushEvent {
    fn from(value: &PushEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Release {
    pub assets: Vec<ReleaseAsset>,
    pub assets_url: String,
    pub author: User,
    pub body: String,
    pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: String,
    pub tarball_url: Option<String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: String,
    pub upload_url: String,
    pub url: String,
    pub zipball_url: Option<String>,
}
impl From<&Release> for Release {
    fn from(value: &Release) -> Self {
        value.clone()
    }
}
#[doc = "Data related to a release."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseAsset {
    pub browser_download_url: String,
    pub content_type: String,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub download_count: i64,
    pub id: i64,
    pub label: Option<String>,
    #[doc = "The file name of the asset."]
    pub name: String,
    pub node_id: String,
    pub size: i64,
    #[doc = "State of the release asset."]
    pub state: ReleaseAssetState,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploader: Option<User>,
    pub url: String,
}
impl From<&ReleaseAsset> for ReleaseAsset {
    fn from(value: &ReleaseAsset) -> Self {
        value.clone()
    }
}
#[doc = "State of the release asset."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseAssetState {
    #[serde(rename = "uploaded")]
    Uploaded,
}
impl From<&ReleaseAssetState> for ReleaseAssetState {
    fn from(value: &ReleaseAssetState) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseAssetState {
    fn to_string(&self) -> String {
        match *self {
            Self::Uploaded => "uploaded".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseAssetState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "uploaded" => Ok(Self::Uploaded),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseAssetState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseCreated {
    pub action: ReleaseCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseCreated> for ReleaseCreated {
    fn from(value: &ReleaseCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&ReleaseCreatedAction> for ReleaseCreatedAction {
    fn from(value: &ReleaseCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseDeleted {
    pub action: ReleaseDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseDeleted> for ReleaseDeleted {
    fn from(value: &ReleaseDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&ReleaseDeletedAction> for ReleaseDeletedAction {
    fn from(value: &ReleaseDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEdited {
    pub action: ReleaseEditedAction,
    pub changes: ReleaseEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseEdited> for ReleaseEdited {
    fn from(value: &ReleaseEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&ReleaseEditedAction> for ReleaseEditedAction {
    fn from(value: &ReleaseEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<ReleaseEditedChangesBody>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<ReleaseEditedChangesName>,
}
impl From<&ReleaseEditedChanges> for ReleaseEditedChanges {
    fn from(value: &ReleaseEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: String,
}
impl From<&ReleaseEditedChangesBody> for ReleaseEditedChangesBody {
    fn from(value: &ReleaseEditedChangesBody) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&ReleaseEditedChangesName> for ReleaseEditedChangesName {
    fn from(value: &ReleaseEditedChangesName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ReleaseEvent {
    Created(ReleaseCreated),
    Deleted(ReleaseDeleted),
    Edited(ReleaseEdited),
    Prereleased(ReleasePrereleased),
    Published(ReleasePublished),
    Released(ReleaseReleased),
    Unpublished(ReleaseUnpublished),
}
impl From<&ReleaseEvent> for ReleaseEvent {
    fn from(value: &ReleaseEvent) -> Self {
        value.clone()
    }
}
impl From<ReleaseCreated> for ReleaseEvent {
    fn from(value: ReleaseCreated) -> Self {
        Self::Created(value)
    }
}
impl From<ReleaseDeleted> for ReleaseEvent {
    fn from(value: ReleaseDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<ReleaseEdited> for ReleaseEvent {
    fn from(value: ReleaseEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<ReleasePrereleased> for ReleaseEvent {
    fn from(value: ReleasePrereleased) -> Self {
        Self::Prereleased(value)
    }
}
impl From<ReleasePublished> for ReleaseEvent {
    fn from(value: ReleasePublished) -> Self {
        Self::Published(value)
    }
}
impl From<ReleaseReleased> for ReleaseEvent {
    fn from(value: ReleaseReleased) -> Self {
        Self::Released(value)
    }
}
impl From<ReleaseUnpublished> for ReleaseEvent {
    fn from(value: ReleaseUnpublished) -> Self {
        Self::Unpublished(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleased {
    pub action: ReleasePrereleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleasePrereleased> for ReleasePrereleased {
    fn from(value: &ReleasePrereleased) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePrereleasedAction {
    #[serde(rename = "prereleased")]
    Prereleased,
}
impl From<&ReleasePrereleasedAction> for ReleasePrereleasedAction {
    fn from(value: &ReleasePrereleasedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleasePrereleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Prereleased => "prereleased".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePrereleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "prereleased" => Ok(Self::Prereleased),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleasePrereleasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublished {
    pub action: ReleasePublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleasePublished> for ReleasePublished {
    fn from(value: &ReleasePublished) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&ReleasePublishedAction> for ReleasePublishedAction {
    fn from(value: &ReleasePublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleasePublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for ReleasePublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleasePublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseReleased {
    pub action: ReleaseReleasedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseReleased> for ReleaseReleased {
    fn from(value: &ReleaseReleased) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseReleasedAction {
    #[serde(rename = "released")]
    Released,
}
impl From<&ReleaseReleasedAction> for ReleaseReleasedAction {
    fn from(value: &ReleaseReleasedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseReleasedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Released => "released".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseReleasedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "released" => Ok(Self::Released),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseReleasedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublished {
    pub action: ReleaseUnpublishedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl From<&ReleaseUnpublished> for ReleaseUnpublished {
    fn from(value: &ReleaseUnpublished) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseUnpublishedAction {
    #[serde(rename = "unpublished")]
    Unpublished,
}
impl From<&ReleaseUnpublishedAction> for ReleaseUnpublishedAction {
    fn from(value: &ReleaseUnpublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for ReleaseUnpublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unpublished => "unpublished".to_string(),
        }
    }
}
impl std::str::FromStr for ReleaseUnpublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unpublished" => Ok(Self::Unpublished),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ReleaseUnpublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepoRef {
    pub id: i64,
    pub name: String,
    pub url: String,
}
impl From<&RepoRef> for RepoRef {
    fn from(value: &RepoRef) -> Self {
        value.clone()
    }
}
#[doc = "A git repository"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Repository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_forking: Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub clone_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub created_at: RepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: String,
    pub description: Option<String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub git_url: String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: Option<String>,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub language: Option<String>,
    pub languages_url: String,
    pub license: Option<License>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub master_branch: Option<String>,
    pub merges_url: String,
    pub milestones_url: String,
    pub mirror_url: Option<String>,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    pub pulls_url: String,
    pub pushed_at: RepositoryPushedAt,
    pub releases_url: String,
    pub size: i64,
    pub ssh_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stargazers: Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub svn_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl From<&Repository> for Repository {
    fn from(value: &Repository) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchived {
    pub action: RepositoryArchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryArchived> for RepositoryArchived {
    fn from(value: &RepositoryArchived) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryArchivedAction {
    #[serde(rename = "archived")]
    Archived,
}
impl From<&RepositoryArchivedAction> for RepositoryArchivedAction {
    fn from(value: &RepositoryArchivedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryArchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Archived => "archived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryArchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "archived" => Ok(Self::Archived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryArchivedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryCreated {
    pub action: RepositoryCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryCreated> for RepositoryCreated {
    fn from(value: &RepositoryCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&RepositoryCreatedAction> for RepositoryCreatedAction {
    fn from(value: &RepositoryCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryCreatedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryCreatedAt> for RepositoryCreatedAt {
    fn from(value: &RepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for RepositoryCreatedAt {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryCreatedAt {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for RepositoryCreatedAt {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<i64> for RepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDeleted {
    pub action: RepositoryDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryDeleted> for RepositoryDeleted {
    fn from(value: &RepositoryDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&RepositoryDeletedAction> for RepositoryDeletedAction {
    fn from(value: &RepositoryDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RepositoryDispatchEvent(pub RepositoryDispatchOnDemandTest);
impl std::ops::Deref for RepositoryDispatchEvent {
    type Target = RepositoryDispatchOnDemandTest;
    fn deref(&self) -> &RepositoryDispatchOnDemandTest {
        &self.0
    }
}
impl From<RepositoryDispatchEvent> for RepositoryDispatchOnDemandTest {
    fn from(value: RepositoryDispatchEvent) -> Self {
        value.0
    }
}
impl From<&RepositoryDispatchEvent> for RepositoryDispatchEvent {
    fn from(value: &RepositoryDispatchEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryDispatchOnDemandTest> for RepositoryDispatchEvent {
    fn from(value: RepositoryDispatchOnDemandTest) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDispatchOnDemandTest {
    pub action: RepositoryDispatchOnDemandTestAction,
    pub branch: String,
    pub client_payload: std::collections::HashMap<String, serde_json::Value>,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryDispatchOnDemandTest> for RepositoryDispatchOnDemandTest {
    fn from(value: &RepositoryDispatchOnDemandTest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryDispatchOnDemandTestAction {
    #[serde(rename = "on-demand-test")]
    OnDemandTest,
}
impl From<&RepositoryDispatchOnDemandTestAction> for RepositoryDispatchOnDemandTestAction {
    fn from(value: &RepositoryDispatchOnDemandTestAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryDispatchOnDemandTestAction {
    fn to_string(&self) -> String {
        match *self {
            Self::OnDemandTest => "on-demand-test".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryDispatchOnDemandTestAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "on-demand-test" => Ok(Self::OnDemandTest),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryDispatchOnDemandTestAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEdited {
    pub action: RepositoryEditedAction,
    pub changes: RepositoryEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryEdited> for RepositoryEdited {
    fn from(value: &RepositoryEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&RepositoryEditedAction> for RepositoryEditedAction {
    fn from(value: &RepositoryEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_branch: Option<RepositoryEditedChangesDefaultBranch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<RepositoryEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub homepage: Option<RepositoryEditedChangesHomepage>,
}
impl From<&RepositoryEditedChanges> for RepositoryEditedChanges {
    fn from(value: &RepositoryEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDefaultBranch {
    pub from: String,
}
impl From<&RepositoryEditedChangesDefaultBranch> for RepositoryEditedChangesDefaultBranch {
    fn from(value: &RepositoryEditedChangesDefaultBranch) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDescription {
    pub from: Option<String>,
}
impl From<&RepositoryEditedChangesDescription> for RepositoryEditedChangesDescription {
    fn from(value: &RepositoryEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesHomepage {
    pub from: Option<String>,
}
impl From<&RepositoryEditedChangesHomepage> for RepositoryEditedChangesHomepage {
    fn from(value: &RepositoryEditedChangesHomepage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryEvent {
    Archived(RepositoryArchived),
    Created(RepositoryCreated),
    Deleted(RepositoryDeleted),
    Edited(RepositoryEdited),
    Privatized(RepositoryPrivatized),
    Publicized(RepositoryPublicized),
    Renamed(RepositoryRenamed),
    Transferred(RepositoryTransferred),
    Unarchived(RepositoryUnarchived),
}
impl From<&RepositoryEvent> for RepositoryEvent {
    fn from(value: &RepositoryEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryArchived> for RepositoryEvent {
    fn from(value: RepositoryArchived) -> Self {
        Self::Archived(value)
    }
}
impl From<RepositoryCreated> for RepositoryEvent {
    fn from(value: RepositoryCreated) -> Self {
        Self::Created(value)
    }
}
impl From<RepositoryDeleted> for RepositoryEvent {
    fn from(value: RepositoryDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<RepositoryEdited> for RepositoryEvent {
    fn from(value: RepositoryEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<RepositoryPrivatized> for RepositoryEvent {
    fn from(value: RepositoryPrivatized) -> Self {
        Self::Privatized(value)
    }
}
impl From<RepositoryPublicized> for RepositoryEvent {
    fn from(value: RepositoryPublicized) -> Self {
        Self::Publicized(value)
    }
}
impl From<RepositoryRenamed> for RepositoryEvent {
    fn from(value: RepositoryRenamed) -> Self {
        Self::Renamed(value)
    }
}
impl From<RepositoryTransferred> for RepositoryEvent {
    fn from(value: RepositoryTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl From<RepositoryUnarchived> for RepositoryEvent {
    fn from(value: RepositoryUnarchived) -> Self {
        Self::Unarchived(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryImportEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub status: RepositoryImportEventStatus,
}
impl From<&RepositoryImportEvent> for RepositoryImportEvent {
    fn from(value: &RepositoryImportEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryImportEventStatus {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "failure")]
    Failure,
}
impl From<&RepositoryImportEventStatus> for RepositoryImportEventStatus {
    fn from(value: &RepositoryImportEventStatus) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryImportEventStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryImportEventStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "cancelled" => Ok(Self::Cancelled),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryImportEventStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryLite {
    pub archive_url: String,
    pub assignees_url: String,
    pub blobs_url: String,
    pub branches_url: String,
    pub collaborators_url: String,
    pub comments_url: String,
    pub commits_url: String,
    pub compare_url: String,
    pub contents_url: String,
    pub contributors_url: String,
    pub deployments_url: String,
    pub description: Option<String>,
    pub downloads_url: String,
    pub events_url: String,
    pub fork: bool,
    pub forks_url: String,
    pub full_name: String,
    pub git_commits_url: String,
    pub git_refs_url: String,
    pub git_tags_url: String,
    pub hooks_url: String,
    pub html_url: String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: String,
    pub issue_events_url: String,
    pub issues_url: String,
    pub keys_url: String,
    pub labels_url: String,
    pub languages_url: String,
    pub merges_url: String,
    pub milestones_url: String,
    #[doc = "The name of the repository."]
    pub name: String,
    pub node_id: String,
    pub notifications_url: String,
    pub owner: User,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub pulls_url: String,
    pub releases_url: String,
    pub stargazers_url: String,
    pub statuses_url: String,
    pub subscribers_url: String,
    pub subscription_url: String,
    pub tags_url: String,
    pub teams_url: String,
    pub trees_url: String,
    pub url: String,
}
impl From<&RepositoryLite> for RepositoryLite {
    fn from(value: &RepositoryLite) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maintain: Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub triage: Option<bool>,
}
impl From<&RepositoryPermissions> for RepositoryPermissions {
    fn from(value: &RepositoryPermissions) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatized {
    pub action: RepositoryPrivatizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryPrivatized> for RepositoryPrivatized {
    fn from(value: &RepositoryPrivatized) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPrivatizedAction {
    #[serde(rename = "privatized")]
    Privatized,
}
impl From<&RepositoryPrivatizedAction> for RepositoryPrivatizedAction {
    fn from(value: &RepositoryPrivatizedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryPrivatizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Privatized => "privatized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPrivatizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "privatized" => Ok(Self::Privatized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPrivatizedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicized {
    pub action: RepositoryPublicizedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryPublicized> for RepositoryPublicized {
    fn from(value: &RepositoryPublicized) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPublicizedAction {
    #[serde(rename = "publicized")]
    Publicized,
}
impl From<&RepositoryPublicizedAction> for RepositoryPublicizedAction {
    fn from(value: &RepositoryPublicizedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryPublicizedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Publicized => "publicized".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryPublicizedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "publicized" => Ok(Self::Publicized),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryPublicizedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPushedAt {
    Variant0(i64),
    Variant1(chrono::DateTime<chrono::offset::Utc>),
    Variant2,
}
impl From<&RepositoryPushedAt> for RepositoryPushedAt {
    fn from(value: &RepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl From<i64> for RepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamed {
    pub action: RepositoryRenamedAction,
    pub changes: RepositoryRenamedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryRenamed> for RepositoryRenamed {
    fn from(value: &RepositoryRenamed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl From<&RepositoryRenamedAction> for RepositoryRenamedAction {
    fn from(value: &RepositoryRenamedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryRenamedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Renamed => "renamed".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryRenamedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryRenamedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChanges {
    pub repository: RepositoryRenamedChangesRepository,
}
impl From<&RepositoryRenamedChanges> for RepositoryRenamedChanges {
    fn from(value: &RepositoryRenamedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepository {
    pub name: RepositoryRenamedChangesRepositoryName,
}
impl From<&RepositoryRenamedChangesRepository> for RepositoryRenamedChangesRepository {
    fn from(value: &RepositoryRenamedChangesRepository) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepositoryName {
    pub from: String,
}
impl From<&RepositoryRenamedChangesRepositoryName> for RepositoryRenamedChangesRepositoryName {
    fn from(value: &RepositoryRenamedChangesRepositoryName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferred {
    pub action: RepositoryTransferredAction,
    pub changes: RepositoryTransferredChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryTransferred> for RepositoryTransferred {
    fn from(value: &RepositoryTransferred) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl From<&RepositoryTransferredAction> for RepositoryTransferredAction {
    fn from(value: &RepositoryTransferredAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryTransferredAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Transferred => "transferred".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryTransferredAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryTransferredAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChanges {
    pub owner: RepositoryTransferredChangesOwner,
}
impl From<&RepositoryTransferredChanges> for RepositoryTransferredChanges {
    fn from(value: &RepositoryTransferredChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwner {
    pub from: RepositoryTransferredChangesOwnerFrom,
}
impl From<&RepositoryTransferredChangesOwner> for RepositoryTransferredChangesOwner {
    fn from(value: &RepositoryTransferredChangesOwner) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwnerFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<User>,
}
impl From<&RepositoryTransferredChangesOwnerFrom> for RepositoryTransferredChangesOwnerFrom {
    fn from(value: &RepositoryTransferredChangesOwnerFrom) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchived {
    pub action: RepositoryUnarchivedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryUnarchived> for RepositoryUnarchived {
    fn from(value: &RepositoryUnarchived) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryUnarchivedAction {
    #[serde(rename = "unarchived")]
    Unarchived,
}
impl From<&RepositoryUnarchivedAction> for RepositoryUnarchivedAction {
    fn from(value: &RepositoryUnarchivedAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryUnarchivedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Unarchived => "unarchived".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryUnarchivedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "unarchived" => Ok(Self::Unarchived),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryUnarchivedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreate {
    pub action: RepositoryVulnerabilityAlertCreateAction,
    pub alert: RepositoryVulnerabilityAlertCreateAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertCreate {
    fn from(value: &RepositoryVulnerabilityAlertCreate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertCreateAction {
    #[serde(rename = "create")]
    Create,
}
impl From<&RepositoryVulnerabilityAlertCreateAction> for RepositoryVulnerabilityAlertCreateAction {
    fn from(value: &RepositoryVulnerabilityAlertCreateAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertCreateAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "create".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertCreateAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "create" => Ok(Self::Create),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreateAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertCreateAlert> for RepositoryVulnerabilityAlertCreateAlert {
    fn from(value: &RepositoryVulnerabilityAlertCreateAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismiss {
    pub action: RepositoryVulnerabilityAlertDismissAction,
    pub alert: RepositoryVulnerabilityAlertDismissAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertDismiss {
    fn from(value: &RepositoryVulnerabilityAlertDismiss) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertDismissAction {
    #[serde(rename = "dismiss")]
    Dismiss,
}
impl From<&RepositoryVulnerabilityAlertDismissAction>
    for RepositoryVulnerabilityAlertDismissAction
{
    fn from(value: &RepositoryVulnerabilityAlertDismissAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertDismissAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Dismiss => "dismiss".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertDismissAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dismiss" => Ok(Self::Dismiss),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismissAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    pub dismiss_reason: String,
    pub dismissed_at: String,
    pub dismisser: User,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertDismissAlert> for RepositoryVulnerabilityAlertDismissAlert {
    fn from(value: &RepositoryVulnerabilityAlertDismissAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryVulnerabilityAlertEvent {
    Create(RepositoryVulnerabilityAlertCreate),
    Dismiss(RepositoryVulnerabilityAlertDismiss),
    Resolve(RepositoryVulnerabilityAlertResolve),
}
impl From<&RepositoryVulnerabilityAlertEvent> for RepositoryVulnerabilityAlertEvent {
    fn from(value: &RepositoryVulnerabilityAlertEvent) -> Self {
        value.clone()
    }
}
impl From<RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertCreate) -> Self {
        Self::Create(value)
    }
}
impl From<RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertDismiss) -> Self {
        Self::Dismiss(value)
    }
}
impl From<RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertEvent {
    fn from(value: RepositoryVulnerabilityAlertResolve) -> Self {
        Self::Resolve(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolve {
    pub action: RepositoryVulnerabilityAlertResolveAction,
    pub alert: RepositoryVulnerabilityAlertResolveAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertResolve {
    fn from(value: &RepositoryVulnerabilityAlertResolve) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertResolveAction {
    #[serde(rename = "resolve")]
    Resolve,
}
impl From<&RepositoryVulnerabilityAlertResolveAction>
    for RepositoryVulnerabilityAlertResolveAction
{
    fn from(value: &RepositoryVulnerabilityAlertResolveAction) -> Self {
        value.clone()
    }
}
impl ToString for RepositoryVulnerabilityAlertResolveAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolve => "resolve".to_string(),
        }
    }
}
impl std::str::FromStr for RepositoryVulnerabilityAlertResolveAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolve" => Ok(Self::Resolve),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolveAlert {
    pub affected_package_name: String,
    pub affected_range: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismisser: Option<User>,
    pub external_identifier: String,
    pub external_reference: String,
    pub fixed_in: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ghsa_id: Option<String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}
impl From<&RepositoryVulnerabilityAlertResolveAlert> for RepositoryVulnerabilityAlertResolveAlert {
    fn from(value: &RepositoryVulnerabilityAlertResolveAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreated {
    pub action: SecretScanningAlertCreatedAction,
    pub alert: SecretScanningAlertCreatedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
}
impl From<&SecretScanningAlertCreated> for SecretScanningAlertCreated {
    fn from(value: &SecretScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&SecretScanningAlertCreatedAction> for SecretScanningAlertCreatedAction {
    fn from(value: &SecretScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreatedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
impl From<&SecretScanningAlertCreatedAlert> for SecretScanningAlertCreatedAlert {
    fn from(value: &SecretScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecretScanningAlertEvent {
    Created(SecretScanningAlertCreated),
    Reopened(SecretScanningAlertReopened),
    Resolved(SecretScanningAlertResolved),
}
impl From<&SecretScanningAlertEvent> for SecretScanningAlertEvent {
    fn from(value: &SecretScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl From<SecretScanningAlertCreated> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl From<SecretScanningAlertReopened> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl From<SecretScanningAlertResolved> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertResolved) -> Self {
        Self::Resolved(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopened {
    pub action: SecretScanningAlertReopenedAction,
    pub alert: SecretScanningAlertReopenedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&SecretScanningAlertReopened> for SecretScanningAlertReopened {
    fn from(value: &SecretScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl From<&SecretScanningAlertReopenedAction> for SecretScanningAlertReopenedAction {
    fn from(value: &SecretScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertReopenedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Reopened => "reopened".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertReopenedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertReopenedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopenedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: String,
}
impl From<&SecretScanningAlertReopenedAlert> for SecretScanningAlertReopenedAlert {
    fn from(value: &SecretScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolved {
    pub action: SecretScanningAlertResolvedAction,
    pub alert: SecretScanningAlertResolvedAlert,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&SecretScanningAlertResolved> for SecretScanningAlertResolved {
    fn from(value: &SecretScanningAlertResolved) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAction {
    #[serde(rename = "resolved")]
    Resolved,
}
impl From<&SecretScanningAlertResolvedAction> for SecretScanningAlertResolvedAction {
    fn from(value: &SecretScanningAlertResolvedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertResolvedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolvedAlert {
    pub number: i64,
    pub resolution: SecretScanningAlertResolvedAlertResolution,
    pub resolved_at: String,
    pub resolved_by: User,
    pub secret_type: String,
}
impl From<&SecretScanningAlertResolvedAlert> for SecretScanningAlertResolvedAlert {
    fn from(value: &SecretScanningAlertResolvedAlert) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAlertResolution {
    #[serde(rename = "false_positive")]
    FalsePositive,
    #[serde(rename = "wontfix")]
    Wontfix,
    #[serde(rename = "revoked")]
    Revoked,
    #[serde(rename = "used_in_tests")]
    UsedInTests,
}
impl From<&SecretScanningAlertResolvedAlertResolution>
    for SecretScanningAlertResolvedAlertResolution
{
    fn from(value: &SecretScanningAlertResolvedAlertResolution) -> Self {
        value.clone()
    }
}
impl ToString for SecretScanningAlertResolvedAlertResolution {
    fn to_string(&self) -> String {
        match *self {
            Self::FalsePositive => "false_positive".to_string(),
            Self::Wontfix => "wontfix".to_string(),
            Self::Revoked => "revoked".to_string(),
            Self::UsedInTests => "used_in_tests".to_string(),
        }
    }
}
impl std::str::FromStr for SecretScanningAlertResolvedAlertResolution {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "false_positive" => Ok(Self::FalsePositive),
            "wontfix" => Ok(Self::Wontfix),
            "revoked" => Ok(Self::Revoked),
            "used_in_tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAlertResolution {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecurityAdvisoryEvent {
    Performed(SecurityAdvisoryPerformed),
    Published(SecurityAdvisoryPublished),
    Updated(SecurityAdvisoryUpdated),
    Withdrawn(SecurityAdvisoryWithdrawn),
}
impl From<&SecurityAdvisoryEvent> for SecurityAdvisoryEvent {
    fn from(value: &SecurityAdvisoryEvent) -> Self {
        value.clone()
    }
}
impl From<SecurityAdvisoryPerformed> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPerformed) -> Self {
        Self::Performed(value)
    }
}
impl From<SecurityAdvisoryPublished> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPublished) -> Self {
        Self::Published(value)
    }
}
impl From<SecurityAdvisoryUpdated> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryUpdated) -> Self {
        Self::Updated(value)
    }
}
impl From<SecurityAdvisoryWithdrawn> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryWithdrawn) -> Self {
        Self::Withdrawn(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformed {
    pub action: SecurityAdvisoryPerformedAction,
    pub security_advisory: SecurityAdvisoryPerformedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPerformed> for SecurityAdvisoryPerformed {
    fn from(value: &SecurityAdvisoryPerformed) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPerformedAction {
    #[serde(rename = "performed")]
    Performed,
}
impl From<&SecurityAdvisoryPerformedAction> for SecurityAdvisoryPerformedAction {
    fn from(value: &SecurityAdvisoryPerformedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryPerformedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Performed => "performed".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPerformedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "performed" => Ok(Self::Performed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPerformedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPerformedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisory>
    for SecurityAdvisoryPerformedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCvss>
    for SecurityAdvisoryPerformedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublished {
    pub action: SecurityAdvisoryPublishedAction,
    pub security_advisory: SecurityAdvisoryPublishedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPublished> for SecurityAdvisoryPublished {
    fn from(value: &SecurityAdvisoryPublished) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl From<&SecurityAdvisoryPublishedAction> for SecurityAdvisoryPublishedAction {
    fn from(value: &SecurityAdvisoryPublishedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryPublishedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Published => "published".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryPublishedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPublishedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPublishedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisory>
    for SecurityAdvisoryPublishedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCvss>
    for SecurityAdvisoryPublishedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdated {
    pub action: SecurityAdvisoryUpdatedAction,
    pub security_advisory: SecurityAdvisoryUpdatedSecurityAdvisory,
}
impl From<&SecurityAdvisoryUpdated> for SecurityAdvisoryUpdated {
    fn from(value: &SecurityAdvisoryUpdated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl From<&SecurityAdvisoryUpdatedAction> for SecurityAdvisoryUpdatedAction {
    fn from(value: &SecurityAdvisoryUpdatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryUpdatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Updated => "updated".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryUpdatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryUpdatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisory {
    pub cvss: SecurityAdvisoryUpdatedSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: Option<String>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisory> for SecurityAdvisoryUpdatedSecurityAdvisory {
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCvss>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawn {
    pub action: SecurityAdvisoryWithdrawnAction,
    pub security_advisory: SecurityAdvisoryWithdrawnSecurityAdvisory,
}
impl From<&SecurityAdvisoryWithdrawn> for SecurityAdvisoryWithdrawn {
    fn from(value: &SecurityAdvisoryWithdrawn) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryWithdrawnAction {
    #[serde(rename = "withdrawn")]
    Withdrawn,
}
impl From<&SecurityAdvisoryWithdrawnAction> for SecurityAdvisoryWithdrawnAction {
    fn from(value: &SecurityAdvisoryWithdrawnAction) -> Self {
        value.clone()
    }
}
impl ToString for SecurityAdvisoryWithdrawnAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Withdrawn => "withdrawn".to_string(),
        }
    }
}
impl std::str::FromStr for SecurityAdvisoryWithdrawnAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SecurityAdvisoryWithdrawnAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisory {
    pub cvss: SecurityAdvisoryWithdrawnSecurityAdvisoryCvss,
    pub cwes: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>,
    pub description: String,
    pub ghsa_id: String,
    pub identifiers: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>,
    pub published_at: String,
    pub references: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>,
    pub severity: String,
    pub summary: String,
    pub updated_at: String,
    pub vulnerabilities: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisory>
    for SecurityAdvisoryWithdrawnSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCvss>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem {
    pub cwe_id: String,
    pub name: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: String,
    pub value: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem {
    pub url: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version:
        Option<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
    pub package: SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: String,
    pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: String,
    pub name: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequest {
    pub active_lock_reason: Option<SimplePullRequestActiveLockReason>,
    pub assignee: Option<User>,
    pub assignees: Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: SimplePullRequestBase,
    pub body: String,
    pub closed_at: Option<String>,
    pub comments_url: String,
    pub commits_url: String,
    pub created_at: String,
    pub diff_url: String,
    pub draft: bool,
    pub head: SimplePullRequestHead,
    pub html_url: String,
    pub id: i64,
    pub issue_url: String,
    pub labels: Vec<Label>,
    #[serde(rename = "_links")]
    pub links: SimplePullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: Option<String>,
    pub merged_at: Option<String>,
    pub milestone: Option<Milestone>,
    pub node_id: String,
    pub number: i64,
    pub patch_url: String,
    pub requested_reviewers: Vec<SimplePullRequestRequestedReviewersItem>,
    pub requested_teams: Vec<Team>,
    pub review_comment_url: String,
    pub review_comments_url: String,
    pub state: SimplePullRequestState,
    pub statuses_url: String,
    pub title: String,
    pub updated_at: String,
    pub url: String,
    pub user: User,
}
impl From<&SimplePullRequest> for SimplePullRequest {
    fn from(value: &SimplePullRequest) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl From<&SimplePullRequestActiveLockReason> for SimplePullRequestActiveLockReason {
    fn from(value: &SimplePullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ToString for SimplePullRequestActiveLockReason {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolved => "resolved".to_string(),
            Self::OffTopic => "off-topic".to_string(),
            Self::TooHeated => "too heated".to_string(),
            Self::Spam => "spam".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestActiveLockReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SimplePullRequestActiveLockReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestBase {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&SimplePullRequestBase> for SimplePullRequestBase {
    fn from(value: &SimplePullRequestBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestHead {
    pub label: String,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: Repository,
    pub sha: String,
    pub user: User,
}
impl From<&SimplePullRequestHead> for SimplePullRequestHead {
    fn from(value: &SimplePullRequestHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl From<&SimplePullRequestLinks> for SimplePullRequestLinks {
    fn from(value: &SimplePullRequestLinks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SimplePullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl From<&SimplePullRequestRequestedReviewersItem> for SimplePullRequestRequestedReviewersItem {
    fn from(value: &SimplePullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl From<User> for SimplePullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl From<Team> for SimplePullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl From<&SimplePullRequestState> for SimplePullRequestState {
    fn from(value: &SimplePullRequestState) -> Self {
        value.clone()
    }
}
impl ToString for SimplePullRequestState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
        }
    }
}
impl std::str::FromStr for SimplePullRequestState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SimplePullRequestState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelled {
    pub action: SponsorshipCancelledAction,
    pub sender: User,
    pub sponsorship: SponsorshipCancelledSponsorship,
}
impl From<&SponsorshipCancelled> for SponsorshipCancelled {
    fn from(value: &SponsorshipCancelled) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl From<&SponsorshipCancelledAction> for SponsorshipCancelledAction {
    fn from(value: &SponsorshipCancelledAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipCancelledAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Cancelled => "cancelled".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCancelledAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipCancelledAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelledSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipCancelledSponsorship> for SponsorshipCancelledSponsorship {
    fn from(value: &SponsorshipCancelledSponsorship) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreated {
    pub action: SponsorshipCreatedAction,
    pub sender: User,
    pub sponsorship: SponsorshipCreatedSponsorship,
}
impl From<&SponsorshipCreated> for SponsorshipCreated {
    fn from(value: &SponsorshipCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&SponsorshipCreatedAction> for SponsorshipCreatedAction {
    fn from(value: &SponsorshipCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreatedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipCreatedSponsorship> for SponsorshipCreatedSponsorship {
    fn from(value: &SponsorshipCreatedSponsorship) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEdited {
    pub action: SponsorshipEditedAction,
    pub changes: SponsorshipEditedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipEditedSponsorship,
}
impl From<&SponsorshipEdited> for SponsorshipEdited {
    fn from(value: &SponsorshipEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&SponsorshipEditedAction> for SponsorshipEditedAction {
    fn from(value: &SponsorshipEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy_level: Option<SponsorshipEditedChangesPrivacyLevel>,
}
impl From<&SponsorshipEditedChanges> for SponsorshipEditedChanges {
    fn from(value: &SponsorshipEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChangesPrivacyLevel {
    #[doc = "The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy."]
    pub from: String,
}
impl From<&SponsorshipEditedChangesPrivacyLevel> for SponsorshipEditedChangesPrivacyLevel {
    fn from(value: &SponsorshipEditedChangesPrivacyLevel) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipEditedSponsorship> for SponsorshipEditedSponsorship {
    fn from(value: &SponsorshipEditedSponsorship) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SponsorshipEvent {
    Cancelled(SponsorshipCancelled),
    Created(SponsorshipCreated),
    Edited(SponsorshipEdited),
    PendingCancellation(SponsorshipPendingCancellation),
    PendingTierChange(SponsorshipPendingTierChange),
    TierChanged(SponsorshipTierChanged),
}
impl From<&SponsorshipEvent> for SponsorshipEvent {
    fn from(value: &SponsorshipEvent) -> Self {
        value.clone()
    }
}
impl From<SponsorshipCancelled> for SponsorshipEvent {
    fn from(value: SponsorshipCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl From<SponsorshipCreated> for SponsorshipEvent {
    fn from(value: SponsorshipCreated) -> Self {
        Self::Created(value)
    }
}
impl From<SponsorshipEdited> for SponsorshipEvent {
    fn from(value: SponsorshipEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<SponsorshipPendingCancellation> for SponsorshipEvent {
    fn from(value: SponsorshipPendingCancellation) -> Self {
        Self::PendingCancellation(value)
    }
}
impl From<SponsorshipPendingTierChange> for SponsorshipEvent {
    fn from(value: SponsorshipPendingTierChange) -> Self {
        Self::PendingTierChange(value)
    }
}
impl From<SponsorshipTierChanged> for SponsorshipEvent {
    fn from(value: SponsorshipTierChanged) -> Self {
        Self::TierChanged(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellation {
    pub action: SponsorshipPendingCancellationAction,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingCancellationSponsorship,
}
impl From<&SponsorshipPendingCancellation> for SponsorshipPendingCancellation {
    fn from(value: &SponsorshipPendingCancellation) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingCancellationAction {
    #[serde(rename = "pending_cancellation")]
    PendingCancellation,
}
impl From<&SponsorshipPendingCancellationAction> for SponsorshipPendingCancellationAction {
    fn from(value: &SponsorshipPendingCancellationAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipPendingCancellationAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingCancellation => "pending_cancellation".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingCancellationAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_cancellation" => Ok(Self::PendingCancellation),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipPendingCancellationAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellationSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipPendingCancellationSponsorship>
    for SponsorshipPendingCancellationSponsorship
{
    fn from(value: &SponsorshipPendingCancellationSponsorship) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChange {
    pub action: SponsorshipPendingTierChangeAction,
    pub changes: SponsorshipPendingTierChangeChanges,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effective_date: Option<String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingTierChangeSponsorship,
}
impl From<&SponsorshipPendingTierChange> for SponsorshipPendingTierChange {
    fn from(value: &SponsorshipPendingTierChange) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingTierChangeAction {
    #[serde(rename = "pending_tier_change")]
    PendingTierChange,
}
impl From<&SponsorshipPendingTierChangeAction> for SponsorshipPendingTierChangeAction {
    fn from(value: &SponsorshipPendingTierChangeAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipPendingTierChangeAction {
    fn to_string(&self) -> String {
        match *self {
            Self::PendingTierChange => "pending_tier_change".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipPendingTierChangeAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending_tier_change" => Ok(Self::PendingTierChange),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipPendingTierChangeAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChanges {
    pub tier: SponsorshipPendingTierChangeChangesTier,
}
impl From<&SponsorshipPendingTierChangeChanges> for SponsorshipPendingTierChangeChanges {
    fn from(value: &SponsorshipPendingTierChangeChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChangesTier {
    pub from: SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeChangesTier> for SponsorshipPendingTierChangeChangesTier {
    fn from(value: &SponsorshipPendingTierChangeChangesTier) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeSponsorship> for SponsorshipPendingTierChangeSponsorship {
    fn from(value: &SponsorshipPendingTierChangeSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTier {
    pub created_at: String,
    pub description: String,
    pub is_custom_ammount: bool,
    pub is_one_time: bool,
    pub monthly_price_in_cents: i64,
    pub monthly_price_in_dollars: i64,
    pub name: String,
    pub node_id: String,
}
impl From<&SponsorshipTier> for SponsorshipTier {
    fn from(value: &SponsorshipTier) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChanged {
    pub action: SponsorshipTierChangedAction,
    pub changes: SponsorshipTierChangedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipTierChangedSponsorship,
}
impl From<&SponsorshipTierChanged> for SponsorshipTierChanged {
    fn from(value: &SponsorshipTierChanged) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipTierChangedAction {
    #[serde(rename = "tier_changed")]
    TierChanged,
}
impl From<&SponsorshipTierChangedAction> for SponsorshipTierChangedAction {
    fn from(value: &SponsorshipTierChangedAction) -> Self {
        value.clone()
    }
}
impl ToString for SponsorshipTierChangedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::TierChanged => "tier_changed".to_string(),
        }
    }
}
impl std::str::FromStr for SponsorshipTierChangedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tier_changed" => Ok(Self::TierChanged),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SponsorshipTierChangedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChanges {
    pub tier: SponsorshipTierChangedChangesTier,
}
impl From<&SponsorshipTierChangedChanges> for SponsorshipTierChangedChanges {
    fn from(value: &SponsorshipTierChangedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChangesTier {
    pub from: SponsorshipTier,
}
impl From<&SponsorshipTierChangedChangesTier> for SponsorshipTierChangedChangesTier {
    fn from(value: &SponsorshipTierChangedChangesTier) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedSponsorship {
    pub created_at: String,
    pub node_id: String,
    pub privacy_level: String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl From<&SponsorshipTierChangedSponsorship> for SponsorshipTierChangedSponsorship {
    fn from(value: &SponsorshipTierChangedSponsorship) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarCreated {
    pub action: StarCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: String,
}
impl From<&StarCreated> for StarCreated {
    fn from(value: &StarCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&StarCreatedAction> for StarCreatedAction {
    fn from(value: &StarCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for StarCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for StarCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StarCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarDeleted {
    pub action: StarDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: (),
}
impl From<&StarDeleted> for StarDeleted {
    fn from(value: &StarDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&StarDeletedAction> for StarDeletedAction {
    fn from(value: &StarDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for StarDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for StarDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StarDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StarEvent {
    Created(StarCreated),
    Deleted(StarDeleted),
}
impl From<&StarEvent> for StarEvent {
    fn from(value: &StarEvent) -> Self {
        value.clone()
    }
}
impl From<StarCreated> for StarEvent {
    fn from(value: StarCreated) -> Self {
        Self::Created(value)
    }
}
impl From<StarDeleted> for StarEvent {
    fn from(value: StarDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    #[doc = "An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."]
    pub branches: Vec<StatusEventBranchesItem>,
    pub commit: StatusEventCommit,
    pub context: String,
    pub created_at: String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: Option<String>,
    #[doc = "The unique identifier of the status."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The Commit SHA."]
    pub sha: String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: StatusEventState,
    #[doc = "The optional link added to the status."]
    pub target_url: Option<String>,
    pub updated_at: String,
}
impl From<&StatusEvent> for StatusEvent {
    fn from(value: &StatusEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItem {
    pub commit: StatusEventBranchesItemCommit,
    pub name: String,
    pub protected: bool,
}
impl From<&StatusEventBranchesItem> for StatusEventBranchesItem {
    fn from(value: &StatusEventBranchesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItemCommit {
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventBranchesItemCommit> for StatusEventBranchesItemCommit {
    fn from(value: &StatusEventBranchesItemCommit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommit {
    pub author: Option<User>,
    pub comments_url: String,
    pub commit: StatusEventCommitCommit,
    pub committer: Option<User>,
    pub html_url: String,
    pub node_id: String,
    pub parents: Vec<StatusEventCommitParentsItem>,
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommit> for StatusEventCommit {
    fn from(value: &StatusEventCommit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommit {
    pub author: Committer,
    pub comment_count: i64,
    pub committer: Committer,
    pub message: String,
    pub tree: StatusEventCommitCommitTree,
    pub url: String,
    pub verification: StatusEventCommitCommitVerification,
}
impl From<&StatusEventCommitCommit> for StatusEventCommitCommit {
    fn from(value: &StatusEventCommitCommit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitTree {
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommitCommitTree> for StatusEventCommitCommitTree {
    fn from(value: &StatusEventCommitCommitTree) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitVerification {
    pub payload: Option<String>,
    pub reason: StatusEventCommitCommitVerificationReason,
    pub signature: Option<String>,
    pub verified: bool,
}
impl From<&StatusEventCommitCommitVerification> for StatusEventCommitCommitVerification {
    fn from(value: &StatusEventCommitCommitVerification) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventCommitCommitVerificationReason {
    #[serde(rename = "expired_key")]
    ExpiredKey,
    #[serde(rename = "not_signing_key")]
    NotSigningKey,
    #[serde(rename = "gpgverify_error")]
    GpgverifyError,
    #[serde(rename = "gpgverify_unavailable")]
    GpgverifyUnavailable,
    #[serde(rename = "unsigned")]
    Unsigned,
    #[serde(rename = "unknown_signature_type")]
    UnknownSignatureType,
    #[serde(rename = "no_user")]
    NoUser,
    #[serde(rename = "unverified_email")]
    UnverifiedEmail,
    #[serde(rename = "bad_email")]
    BadEmail,
    #[serde(rename = "unknown_key")]
    UnknownKey,
    #[serde(rename = "malformed_signature")]
    MalformedSignature,
    #[serde(rename = "invalid")]
    Invalid,
    #[serde(rename = "valid")]
    Valid,
}
impl From<&StatusEventCommitCommitVerificationReason>
    for StatusEventCommitCommitVerificationReason
{
    fn from(value: &StatusEventCommitCommitVerificationReason) -> Self {
        value.clone()
    }
}
impl ToString for StatusEventCommitCommitVerificationReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ExpiredKey => "expired_key".to_string(),
            Self::NotSigningKey => "not_signing_key".to_string(),
            Self::GpgverifyError => "gpgverify_error".to_string(),
            Self::GpgverifyUnavailable => "gpgverify_unavailable".to_string(),
            Self::Unsigned => "unsigned".to_string(),
            Self::UnknownSignatureType => "unknown_signature_type".to_string(),
            Self::NoUser => "no_user".to_string(),
            Self::UnverifiedEmail => "unverified_email".to_string(),
            Self::BadEmail => "bad_email".to_string(),
            Self::UnknownKey => "unknown_key".to_string(),
            Self::MalformedSignature => "malformed_signature".to_string(),
            Self::Invalid => "invalid".to_string(),
            Self::Valid => "valid".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventCommitCommitVerificationReason {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "expired_key" => Ok(Self::ExpiredKey),
            "not_signing_key" => Ok(Self::NotSigningKey),
            "gpgverify_error" => Ok(Self::GpgverifyError),
            "gpgverify_unavailable" => Ok(Self::GpgverifyUnavailable),
            "unsigned" => Ok(Self::Unsigned),
            "unknown_signature_type" => Ok(Self::UnknownSignatureType),
            "no_user" => Ok(Self::NoUser),
            "unverified_email" => Ok(Self::UnverifiedEmail),
            "bad_email" => Ok(Self::BadEmail),
            "unknown_key" => Ok(Self::UnknownKey),
            "malformed_signature" => Ok(Self::MalformedSignature),
            "invalid" => Ok(Self::Invalid),
            "valid" => Ok(Self::Valid),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StatusEventCommitCommitVerificationReason {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitParentsItem {
    pub html_url: String,
    pub sha: String,
    pub url: String,
}
impl From<&StatusEventCommitParentsItem> for StatusEventCommitParentsItem {
    fn from(value: &StatusEventCommitParentsItem) -> Self {
        value.clone()
    }
}
#[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventState {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "error")]
    Error,
}
impl From<&StatusEventState> for StatusEventState {
    fn from(value: &StatusEventState) -> Self {
        value.clone()
    }
}
impl ToString for StatusEventState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "pending".to_string(),
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Error => "error".to_string(),
        }
    }
}
impl std::str::FromStr for StatusEventState {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pending" => Ok(Self::Pending),
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "error" => Ok(Self::Error),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StatusEventState {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Team {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<TeamParent>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
impl From<&Team> for Team {
    fn from(value: &Team) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    pub repository: Repository,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamAddEvent> for TeamAddEvent {
    fn from(value: &TeamAddEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddedToRepository {
    pub action: TeamAddedToRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamAddedToRepository> for TeamAddedToRepository {
    fn from(value: &TeamAddedToRepository) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamAddedToRepositoryAction {
    #[serde(rename = "added_to_repository")]
    AddedToRepository,
}
impl From<&TeamAddedToRepositoryAction> for TeamAddedToRepositoryAction {
    fn from(value: &TeamAddedToRepositoryAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamAddedToRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::AddedToRepository => "added_to_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamAddedToRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "added_to_repository" => Ok(Self::AddedToRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamAddedToRepositoryAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamCreated {
    pub action: TeamCreatedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamCreated> for TeamCreated {
    fn from(value: &TeamCreated) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl From<&TeamCreatedAction> for TeamCreatedAction {
    fn from(value: &TeamCreatedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamCreatedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Created => "created".to_string(),
        }
    }
}
impl std::str::FromStr for TeamCreatedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamCreatedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamDeleted {
    pub action: TeamDeletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamDeleted> for TeamDeleted {
    fn from(value: &TeamDeleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl From<&TeamDeletedAction> for TeamDeletedAction {
    fn from(value: &TeamDeletedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamDeletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Deleted => "deleted".to_string(),
        }
    }
}
impl std::str::FromStr for TeamDeletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamDeletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEdited {
    pub action: TeamEditedAction,
    pub changes: TeamEditedChanges,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamEdited> for TeamEdited {
    fn from(value: &TeamEdited) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl From<&TeamEditedAction> for TeamEditedAction {
    fn from(value: &TeamEditedAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamEditedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Edited => "edited".to_string(),
        }
    }
}
impl std::str::FromStr for TeamEditedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamEditedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[doc = "The changes to the team if the action was `edited`."]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChanges {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<TeamEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<TeamEditedChangesName>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privacy: Option<TeamEditedChangesPrivacy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TeamEditedChangesRepository>,
}
impl From<&TeamEditedChanges> for TeamEditedChanges {
    fn from(value: &TeamEditedChanges) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesDescription> for TeamEditedChangesDescription {
    fn from(value: &TeamEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesName> for TeamEditedChangesName {
    fn from(value: &TeamEditedChangesName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesPrivacy {
    #[doc = "The previous version of the team's privacy if the action was `edited`."]
    pub from: String,
}
impl From<&TeamEditedChangesPrivacy> for TeamEditedChangesPrivacy {
    fn from(value: &TeamEditedChangesPrivacy) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepository {
    pub permissions: TeamEditedChangesRepositoryPermissions,
}
impl From<&TeamEditedChangesRepository> for TeamEditedChangesRepository {
    fn from(value: &TeamEditedChangesRepository) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissions {
    pub from: TeamEditedChangesRepositoryPermissionsFrom,
}
impl From<&TeamEditedChangesRepositoryPermissions> for TeamEditedChangesRepositoryPermissions {
    fn from(value: &TeamEditedChangesRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissionsFrom {
    #[doc = "The previous version of the team member's `admin` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin: Option<bool>,
    #[doc = "The previous version of the team member's `pull` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pull: Option<bool>,
    #[doc = "The previous version of the team member's `push` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub push: Option<bool>,
}
impl From<&TeamEditedChangesRepositoryPermissionsFrom>
    for TeamEditedChangesRepositoryPermissionsFrom
{
    fn from(value: &TeamEditedChangesRepositoryPermissionsFrom) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TeamEvent {
    AddedToRepository(TeamAddedToRepository),
    Created(TeamCreated),
    Deleted(TeamDeleted),
    Edited(TeamEdited),
    RemovedFromRepository(TeamRemovedFromRepository),
}
impl From<&TeamEvent> for TeamEvent {
    fn from(value: &TeamEvent) -> Self {
        value.clone()
    }
}
impl From<TeamAddedToRepository> for TeamEvent {
    fn from(value: TeamAddedToRepository) -> Self {
        Self::AddedToRepository(value)
    }
}
impl From<TeamCreated> for TeamEvent {
    fn from(value: TeamCreated) -> Self {
        Self::Created(value)
    }
}
impl From<TeamDeleted> for TeamEvent {
    fn from(value: TeamDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl From<TeamEdited> for TeamEvent {
    fn from(value: TeamEdited) -> Self {
        Self::Edited(value)
    }
}
impl From<TeamRemovedFromRepository> for TeamEvent {
    fn from(value: TeamRemovedFromRepository) -> Self {
        Self::RemovedFromRepository(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamParent {
    #[doc = "Description of the team"]
    pub description: Option<String>,
    pub html_url: String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: String,
    #[doc = "Name of the team"]
    pub name: String,
    pub node_id: String,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: String,
    pub privacy: TeamParentPrivacy,
    pub repositories_url: String,
    pub slug: String,
    #[doc = "URL for the team"]
    pub url: String,
}
impl From<&TeamParent> for TeamParent {
    fn from(value: &TeamParent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamParentPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl From<&TeamParentPrivacy> for TeamParentPrivacy {
    fn from(value: &TeamParentPrivacy) -> Self {
        value.clone()
    }
}
impl ToString for TeamParentPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamParentPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamParentPrivacy {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl From<&TeamPrivacy> for TeamPrivacy {
    fn from(value: &TeamPrivacy) -> Self {
        value.clone()
    }
}
impl ToString for TeamPrivacy {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "open".to_string(),
            Self::Closed => "closed".to_string(),
            Self::Secret => "secret".to_string(),
        }
    }
}
impl std::str::FromStr for TeamPrivacy {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamPrivacy {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamRemovedFromRepository {
    pub action: TeamRemovedFromRepositoryAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl From<&TeamRemovedFromRepository> for TeamRemovedFromRepository {
    fn from(value: &TeamRemovedFromRepository) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamRemovedFromRepositoryAction {
    #[serde(rename = "removed_from_repository")]
    RemovedFromRepository,
}
impl From<&TeamRemovedFromRepositoryAction> for TeamRemovedFromRepositoryAction {
    fn from(value: &TeamRemovedFromRepositoryAction) -> Self {
        value.clone()
    }
}
impl ToString for TeamRemovedFromRepositoryAction {
    fn to_string(&self) -> String {
        match *self {
            Self::RemovedFromRepository => "removed_from_repository".to_string(),
        }
    }
}
impl std::str::FromStr for TeamRemovedFromRepositoryAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "removed_from_repository" => Ok(Self::RemovedFromRepository),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TeamRemovedFromRepositoryAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct User {
    pub avatar_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    pub events_url: String,
    pub followers_url: String,
    pub following_url: String,
    pub gists_url: String,
    pub gravatar_id: String,
    pub html_url: String,
    pub id: i64,
    pub login: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub node_id: String,
    pub organizations_url: String,
    pub received_events_url: String,
    pub repos_url: String,
    pub site_admin: bool,
    pub starred_url: String,
    pub subscriptions_url: String,
    #[serde(rename = "type")]
    pub type_: UserType,
    pub url: String,
}
impl From<&User> for User {
    fn from(value: &User) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum UserType {
    Bot,
    User,
    Organization,
}
impl From<&UserType> for UserType {
    fn from(value: &UserType) -> Self {
        value.clone()
    }
}
impl ToString for UserType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bot => "Bot".to_string(),
            Self::User => "User".to_string(),
            Self::Organization => "Organization".to_string(),
        }
    }
}
impl std::str::FromStr for UserType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for UserType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for UserType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for UserType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct WatchEvent(pub WatchStarted);
impl std::ops::Deref for WatchEvent {
    type Target = WatchStarted;
    fn deref(&self) -> &WatchStarted {
        &self.0
    }
}
impl From<WatchEvent> for WatchStarted {
    fn from(value: WatchEvent) -> Self {
        value.0
    }
}
impl From<&WatchEvent> for WatchEvent {
    fn from(value: &WatchEvent) -> Self {
        value.clone()
    }
}
impl From<WatchStarted> for WatchEvent {
    fn from(value: WatchStarted) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WatchStarted {
    pub action: WatchStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl From<&WatchStarted> for WatchStarted {
    fn from(value: &WatchStarted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WatchStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl From<&WatchStartedAction> for WatchStartedAction {
    fn from(value: &WatchStartedAction) -> Self {
        value.clone()
    }
}
impl ToString for WatchStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WatchStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WatchStartedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WebhookEvents {
    Variant0(Vec<WebhookEventsVariant0Item>),
    Variant1(Vec<String>),
}
impl From<&WebhookEvents> for WebhookEvents {
    fn from(value: &WebhookEvents) -> Self {
        value.clone()
    }
}
impl From<Vec<WebhookEventsVariant0Item>> for WebhookEvents {
    fn from(value: Vec<WebhookEventsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<String>> for WebhookEvents {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WebhookEventsVariant0Item {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "meta")]
    Meta,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "repository_import")]
    RepositoryImport,
    #[serde(rename = "repository_vulnerability_alert")]
    RepositoryVulnerabilityAlert,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl From<&WebhookEventsVariant0Item> for WebhookEventsVariant0Item {
    fn from(value: &WebhookEventsVariant0Item) -> Self {
        value.clone()
    }
}
impl ToString for WebhookEventsVariant0Item {
    fn to_string(&self) -> String {
        match *self {
            Self::CheckRun => "check_run".to_string(),
            Self::CheckSuite => "check_suite".to_string(),
            Self::CodeScanningAlert => "code_scanning_alert".to_string(),
            Self::CommitComment => "commit_comment".to_string(),
            Self::ContentReference => "content_reference".to_string(),
            Self::Create => "create".to_string(),
            Self::Delete => "delete".to_string(),
            Self::Deployment => "deployment".to_string(),
            Self::DeploymentReview => "deployment_review".to_string(),
            Self::DeploymentStatus => "deployment_status".to_string(),
            Self::DeployKey => "deploy_key".to_string(),
            Self::Discussion => "discussion".to_string(),
            Self::DiscussionComment => "discussion_comment".to_string(),
            Self::Fork => "fork".to_string(),
            Self::Gollum => "gollum".to_string(),
            Self::Issues => "issues".to_string(),
            Self::IssueComment => "issue_comment".to_string(),
            Self::Label => "label".to_string(),
            Self::Member => "member".to_string(),
            Self::Membership => "membership".to_string(),
            Self::Meta => "meta".to_string(),
            Self::Milestone => "milestone".to_string(),
            Self::Organization => "organization".to_string(),
            Self::OrgBlock => "org_block".to_string(),
            Self::PageBuild => "page_build".to_string(),
            Self::Project => "project".to_string(),
            Self::ProjectCard => "project_card".to_string(),
            Self::ProjectColumn => "project_column".to_string(),
            Self::Public => "public".to_string(),
            Self::PullRequest => "pull_request".to_string(),
            Self::PullRequestReview => "pull_request_review".to_string(),
            Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
            Self::Push => "push".to_string(),
            Self::RegistryPackage => "registry_package".to_string(),
            Self::Release => "release".to_string(),
            Self::Repository => "repository".to_string(),
            Self::RepositoryDispatch => "repository_dispatch".to_string(),
            Self::RepositoryImport => "repository_import".to_string(),
            Self::RepositoryVulnerabilityAlert => "repository_vulnerability_alert".to_string(),
            Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
            Self::Star => "star".to_string(),
            Self::Status => "status".to_string(),
            Self::Team => "team".to_string(),
            Self::TeamAdd => "team_add".to_string(),
            Self::Watch => "watch".to_string(),
            Self::WorkflowDispatch => "workflow_dispatch".to_string(),
            Self::WorkflowRun => "workflow_run".to_string(),
        }
    }
}
impl std::str::FromStr for WebhookEventsVariant0Item {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "meta" => Ok(Self::Meta),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "repository_import" => Ok(Self::RepositoryImport),
            "repository_vulnerability_alert" => Ok(Self::RepositoryVulnerabilityAlert),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WebhookEventsVariant0Item {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Workflow {
    pub badge_url: String,
    pub created_at: String,
    pub html_url: String,
    pub id: i64,
    pub name: String,
    pub node_id: String,
    pub path: String,
    pub state: String,
    pub updated_at: String,
    pub url: String,
}
impl From<&Workflow> for Workflow {
    fn from(value: &Workflow) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowDispatchEvent {
    pub inputs: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repository: Repository,
    pub sender: User,
    pub workflow: String,
}
impl From<&WorkflowDispatchEvent> for WorkflowDispatchEvent {
    fn from(value: &WorkflowDispatchEvent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJob {
    pub check_run_url: String,
    pub completed_at: Option<String>,
    pub conclusion: Option<WorkflowJobConclusion>,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: String,
    pub status: WorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
impl From<&WorkflowJob> for WorkflowJob {
    fn from(value: &WorkflowJob) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompleted {
    pub action: WorkflowJobCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJob,
}
impl From<&WorkflowJobCompleted> for WorkflowJobCompleted {
    fn from(value: &WorkflowJobCompleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobCompletedAction> for WorkflowJobCompletedAction {
    fn from(value: &WorkflowJobCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl From<&WorkflowJobConclusion> for WorkflowJobConclusion {
    fn from(value: &WorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowJobEvent {
    Completed(WorkflowJobCompleted),
    Queued(WorkflowJobQueued),
    Started(WorkflowJobStarted),
}
impl From<&WorkflowJobEvent> for WorkflowJobEvent {
    fn from(value: &WorkflowJobEvent) -> Self {
        value.clone()
    }
}
impl From<WorkflowJobCompleted> for WorkflowJobEvent {
    fn from(value: WorkflowJobCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<WorkflowJobQueued> for WorkflowJobEvent {
    fn from(value: WorkflowJobQueued) -> Self {
        Self::Queued(value)
    }
}
impl From<WorkflowJobStarted> for WorkflowJobEvent {
    fn from(value: WorkflowJobStarted) -> Self {
        Self::Started(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueued {
    pub action: WorkflowJobQueuedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobQueuedWorkflowJob,
}
impl From<&WorkflowJobQueued> for WorkflowJobQueued {
    fn from(value: &WorkflowJobQueued) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobQueuedAction {
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowJobQueuedAction> for WorkflowJobQueuedAction {
    fn from(value: &WorkflowJobQueuedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobQueuedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobQueuedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueuedWorkflowJob {
    pub check_run_url: String,
    pub completed_at: (),
    pub conclusion: (),
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub labels: Vec<String>,
    pub name: String,
    pub node_id: String,
    pub run_id: f64,
    pub run_url: String,
    pub started_at: chrono::DateTime<chrono::offset::Utc>,
    pub status: WorkflowJobQueuedWorkflowJobStatus,
    pub steps: Vec<WorkflowStep>,
    pub url: String,
}
impl From<&WorkflowJobQueuedWorkflowJob> for WorkflowJobQueuedWorkflowJob {
    fn from(value: &WorkflowJobQueuedWorkflowJob) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobQueuedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowJobQueuedWorkflowJobStatus> for WorkflowJobQueuedWorkflowJobStatus {
    fn from(value: &WorkflowJobQueuedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobQueuedWorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobQueuedWorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStarted {
    pub action: WorkflowJobStartedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJob,
}
impl From<&WorkflowJobStarted> for WorkflowJobStarted {
    fn from(value: &WorkflowJobStarted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl From<&WorkflowJobStartedAction> for WorkflowJobStartedAction {
    fn from(value: &WorkflowJobStartedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobStartedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Started => "started".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStartedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobStartedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowJobStatus> for WorkflowJobStatus {
    fn from(value: &WorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowJobStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Queued => "queued".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowJobStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowJobStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRun {
    pub artifacts_url: String,
    pub cancel_url: String,
    pub check_suite_id: i64,
    pub check_suite_node_id: String,
    pub check_suite_url: String,
    pub conclusion: Option<WorkflowRunConclusion>,
    pub created_at: chrono::DateTime<chrono::offset::Utc>,
    pub event: String,
    pub head_branch: String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: String,
    pub html_url: String,
    pub id: i64,
    pub jobs_url: String,
    pub logs_url: String,
    pub name: String,
    pub node_id: String,
    pub pull_requests: Vec<WorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: String,
    pub run_number: i64,
    pub status: WorkflowRunStatus,
    pub updated_at: chrono::DateTime<chrono::offset::Utc>,
    pub url: String,
    pub workflow_id: i64,
    pub workflow_url: String,
}
impl From<&WorkflowRun> for WorkflowRun {
    fn from(value: &WorkflowRun) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompleted {
    pub action: WorkflowRunCompletedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunCompleted> for WorkflowRunCompleted {
    fn from(value: &WorkflowRunCompleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowRunCompletedAction> for WorkflowRunCompletedAction {
    fn from(value: &WorkflowRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunCompletedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunCompletedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunCompletedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl From<&WorkflowRunConclusion> for WorkflowRunConclusion {
    fn from(value: &WorkflowRunConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Success => "success".to_string(),
            Self::Failure => "failure".to_string(),
            Self::Neutral => "neutral".to_string(),
            Self::Cancelled => "cancelled".to_string(),
            Self::TimedOut => "timed_out".to_string(),
            Self::ActionRequired => "action_required".to_string(),
            Self::Stale => "stale".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowRunEvent {
    Completed(WorkflowRunCompleted),
    Requested(WorkflowRunRequested),
}
impl From<&WorkflowRunEvent> for WorkflowRunEvent {
    fn from(value: &WorkflowRunEvent) -> Self {
        value.clone()
    }
}
impl From<WorkflowRunCompleted> for WorkflowRunEvent {
    fn from(value: WorkflowRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl From<WorkflowRunRequested> for WorkflowRunEvent {
    fn from(value: WorkflowRunRequested) -> Self {
        Self::Requested(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItem {
    pub base: WorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: String,
}
impl From<&WorkflowRunPullRequestsItem> for WorkflowRunPullRequestsItem {
    fn from(value: &WorkflowRunPullRequestsItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunPullRequestsItemBase> for WorkflowRunPullRequestsItemBase {
    fn from(value: &WorkflowRunPullRequestsItemBase) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: String,
    pub repo: RepoRef,
    pub sha: String,
}
impl From<&WorkflowRunPullRequestsItemHead> for WorkflowRunPullRequestsItemHead {
    fn from(value: &WorkflowRunPullRequestsItemHead) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunRequested {
    pub action: WorkflowRunRequestedAction,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation: Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub organization: Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunRequested> for WorkflowRunRequested {
    fn from(value: &WorkflowRunRequested) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl From<&WorkflowRunRequestedAction> for WorkflowRunRequestedAction {
    fn from(value: &WorkflowRunRequestedAction) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunRequestedAction {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunRequestedAction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunRequestedAction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl From<&WorkflowRunStatus> for WorkflowRunStatus {
    fn from(value: &WorkflowRunStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowRunStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Requested => "requested".to_string(),
            Self::InProgress => "in_progress".to_string(),
            Self::Completed => "completed".to_string(),
            Self::Queued => "queued".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowRunStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowRunStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowStep {
    InProgress(WorkflowStepInProgress),
    Completed(WorkflowStepCompleted),
}
impl From<&WorkflowStep> for WorkflowStep {
    fn from(value: &WorkflowStep) -> Self {
        value.clone()
    }
}
impl From<WorkflowStepInProgress> for WorkflowStep {
    fn from(value: WorkflowStepInProgress) -> Self {
        Self::InProgress(value)
    }
}
impl From<WorkflowStepCompleted> for WorkflowStep {
    fn from(value: WorkflowStepCompleted) -> Self {
        Self::Completed(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepCompleted {
    pub completed_at: String,
    pub conclusion: WorkflowStepCompletedConclusion,
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepCompletedStatus,
}
impl From<&WorkflowStepCompleted> for WorkflowStepCompleted {
    fn from(value: &WorkflowStepCompleted) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedConclusion {
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "skipped")]
    Skipped,
    #[serde(rename = "success")]
    Success,
}
impl From<&WorkflowStepCompletedConclusion> for WorkflowStepCompletedConclusion {
    fn from(value: &WorkflowStepCompletedConclusion) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepCompletedConclusion {
    fn to_string(&self) -> String {
        match *self {
            Self::Failure => "failure".to_string(),
            Self::Skipped => "skipped".to_string(),
            Self::Success => "success".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedConclusion {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "failure" => Ok(Self::Failure),
            "skipped" => Ok(Self::Skipped),
            "success" => Ok(Self::Success),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedConclusion {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl From<&WorkflowStepCompletedStatus> for WorkflowStepCompletedStatus {
    fn from(value: &WorkflowStepCompletedStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepCompletedStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Completed => "completed".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepCompletedStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepInProgress {
    pub completed_at: (),
    pub conclusion: (),
    pub name: String,
    pub number: i64,
    pub started_at: String,
    pub status: WorkflowStepInProgressStatus,
}
impl From<&WorkflowStepInProgress> for WorkflowStepInProgress {
    fn from(value: &WorkflowStepInProgress) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepInProgressStatus {
    #[serde(rename = "in_progress")]
    InProgress,
}
impl From<&WorkflowStepInProgressStatus> for WorkflowStepInProgressStatus {
    fn from(value: &WorkflowStepInProgressStatus) -> Self {
        value.clone()
    }
}
impl ToString for WorkflowStepInProgressStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::InProgress => "in_progress".to_string(),
        }
    }
}
impl std::str::FromStr for WorkflowStepInProgressStatus {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WorkflowStepInProgressStatus {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
}
