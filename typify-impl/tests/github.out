#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "`AlertInstance`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Alert Instance\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"analysis_key\","]
#[doc = "    \"environment\","]
#[doc = "    \"ref\","]
#[doc = "    \"state\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"analysis_key\": {"]
#[doc = "      \"description\": \"Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"classifications\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"commit_sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"description\": \"Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"location\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"end_column\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"end_line\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"path\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"start_column\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"start_line\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"text\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The full Git reference, formatted as `refs/heads/<branch name>`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"dismissed\","]
#[doc = "        \"fixed\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AlertInstance {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<AlertInstanceLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<AlertInstanceMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    #[doc = "State of a code scanning alert."]
    pub state: AlertInstanceState,
}
impl ::std::convert::From<&AlertInstance> for AlertInstance {
    fn from(value: &AlertInstance) -> Self {
        value.clone()
    }
}
#[doc = "`AlertInstanceLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&AlertInstanceLocation> for AlertInstanceLocation {
    fn from(value: &AlertInstanceLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AlertInstanceLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`AlertInstanceMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&AlertInstanceMessage> for AlertInstanceMessage {
    fn from(value: &AlertInstanceMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AlertInstanceMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"dismissed\","]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AlertInstanceState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for AlertInstanceState {
    fn from(value: &AlertInstanceState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AlertInstanceState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Dismissed => write!(f, "dismissed"),
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for AlertInstanceState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AlertInstanceState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AlertInstanceState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AlertInstanceState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"App\","]
#[doc = "  \"description\": \"GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"external_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"owner\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"events\": {"]
#[doc = "      \"description\": \"The list of events for the GitHub app\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\","]
#[doc = "        \"enum\": ["]
#[doc = "          \"check_run\","]
#[doc = "          \"check_suite\","]
#[doc = "          \"code_scanning_alert\","]
#[doc = "          \"commit_comment\","]
#[doc = "          \"content_reference\","]
#[doc = "          \"create\","]
#[doc = "          \"delete\","]
#[doc = "          \"deployment\","]
#[doc = "          \"deployment_review\","]
#[doc = "          \"deployment_status\","]
#[doc = "          \"deploy_key\","]
#[doc = "          \"discussion\","]
#[doc = "          \"discussion_comment\","]
#[doc = "          \"fork\","]
#[doc = "          \"gollum\","]
#[doc = "          \"issues\","]
#[doc = "          \"issue_comment\","]
#[doc = "          \"label\","]
#[doc = "          \"member\","]
#[doc = "          \"membership\","]
#[doc = "          \"milestone\","]
#[doc = "          \"organization\","]
#[doc = "          \"org_block\","]
#[doc = "          \"page_build\","]
#[doc = "          \"project\","]
#[doc = "          \"project_card\","]
#[doc = "          \"project_column\","]
#[doc = "          \"public\","]
#[doc = "          \"pull_request\","]
#[doc = "          \"pull_request_review\","]
#[doc = "          \"pull_request_review_comment\","]
#[doc = "          \"push\","]
#[doc = "          \"registry_package\","]
#[doc = "          \"release\","]
#[doc = "          \"repository\","]
#[doc = "          \"repository_dispatch\","]
#[doc = "          \"secret_scanning_alert\","]
#[doc = "          \"star\","]
#[doc = "          \"status\","]
#[doc = "          \"team\","]
#[doc = "          \"team_add\","]
#[doc = "          \"watch\","]
#[doc = "          \"workflow_dispatch\","]
#[doc = "          \"workflow_run\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"external_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the GitHub app\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the GitHub app\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"owner\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"permissions\": {"]
#[doc = "      \"description\": \"The set of permissions for the GitHub app\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"actions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"administration\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"checks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"content_references\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"contents\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"deployments\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"discussions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"emails\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"environments\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"issues\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"members\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_administration\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_hooks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_packages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_plan\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_projects\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_secrets\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_self_hosted_runners\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_user_blocking\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"packages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"pages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_hooks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_projects\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"secret_scanning_alerts\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"secrets\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"security_events\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"security_scanning_alert\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"single_file\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"team_discussions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"vulnerability_alerts\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"workflows\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"description\": \"The slug name of the GitHub app\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct App {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "The list of events for the GitHub app"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub events: ::std::vec::Vec<AppEventsItem>,
    pub external_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the GitHub app"]
    pub id: i64,
    #[doc = "The name of the GitHub app"]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<AppPermissions>,
    #[doc = "The slug name of the GitHub app"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub slug: ::std::option::Option<::std::string::String>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
}
impl ::std::convert::From<&App> for App {
    fn from(value: &App) -> Self {
        value.clone()
    }
}
#[doc = "`AppEventsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"check_run\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"code_scanning_alert\","]
#[doc = "    \"commit_comment\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"create\","]
#[doc = "    \"delete\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_review\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"deploy_key\","]
#[doc = "    \"discussion\","]
#[doc = "    \"discussion_comment\","]
#[doc = "    \"fork\","]
#[doc = "    \"gollum\","]
#[doc = "    \"issues\","]
#[doc = "    \"issue_comment\","]
#[doc = "    \"label\","]
#[doc = "    \"member\","]
#[doc = "    \"membership\","]
#[doc = "    \"milestone\","]
#[doc = "    \"organization\","]
#[doc = "    \"org_block\","]
#[doc = "    \"page_build\","]
#[doc = "    \"project\","]
#[doc = "    \"project_card\","]
#[doc = "    \"project_column\","]
#[doc = "    \"public\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"pull_request_review\","]
#[doc = "    \"pull_request_review_comment\","]
#[doc = "    \"push\","]
#[doc = "    \"registry_package\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"repository_dispatch\","]
#[doc = "    \"secret_scanning_alert\","]
#[doc = "    \"star\","]
#[doc = "    \"status\","]
#[doc = "    \"team\","]
#[doc = "    \"team_add\","]
#[doc = "    \"watch\","]
#[doc = "    \"workflow_dispatch\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ::std::convert::From<&Self> for AppEventsItem {
    fn from(value: &AppEventsItem) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppEventsItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CheckRun => write!(f, "check_run"),
            Self::CheckSuite => write!(f, "check_suite"),
            Self::CodeScanningAlert => write!(f, "code_scanning_alert"),
            Self::CommitComment => write!(f, "commit_comment"),
            Self::ContentReference => write!(f, "content_reference"),
            Self::Create => write!(f, "create"),
            Self::Delete => write!(f, "delete"),
            Self::Deployment => write!(f, "deployment"),
            Self::DeploymentReview => write!(f, "deployment_review"),
            Self::DeploymentStatus => write!(f, "deployment_status"),
            Self::DeployKey => write!(f, "deploy_key"),
            Self::Discussion => write!(f, "discussion"),
            Self::DiscussionComment => write!(f, "discussion_comment"),
            Self::Fork => write!(f, "fork"),
            Self::Gollum => write!(f, "gollum"),
            Self::Issues => write!(f, "issues"),
            Self::IssueComment => write!(f, "issue_comment"),
            Self::Label => write!(f, "label"),
            Self::Member => write!(f, "member"),
            Self::Membership => write!(f, "membership"),
            Self::Milestone => write!(f, "milestone"),
            Self::Organization => write!(f, "organization"),
            Self::OrgBlock => write!(f, "org_block"),
            Self::PageBuild => write!(f, "page_build"),
            Self::Project => write!(f, "project"),
            Self::ProjectCard => write!(f, "project_card"),
            Self::ProjectColumn => write!(f, "project_column"),
            Self::Public => write!(f, "public"),
            Self::PullRequest => write!(f, "pull_request"),
            Self::PullRequestReview => write!(f, "pull_request_review"),
            Self::PullRequestReviewComment => write!(f, "pull_request_review_comment"),
            Self::Push => write!(f, "push"),
            Self::RegistryPackage => write!(f, "registry_package"),
            Self::Release => write!(f, "release"),
            Self::Repository => write!(f, "repository"),
            Self::RepositoryDispatch => write!(f, "repository_dispatch"),
            Self::SecretScanningAlert => write!(f, "secret_scanning_alert"),
            Self::Star => write!(f, "star"),
            Self::Status => write!(f, "status"),
            Self::Team => write!(f, "team"),
            Self::TeamAdd => write!(f, "team_add"),
            Self::Watch => write!(f, "watch"),
            Self::WorkflowDispatch => write!(f, "workflow_dispatch"),
            Self::WorkflowRun => write!(f, "workflow_run"),
        }
    }
}
impl ::std::str::FromStr for AppEventsItem {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The set of permissions for the GitHub app"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The set of permissions for the GitHub app\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"checks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content_references\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"contents\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"emails\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"environments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"issues\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_plan\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_self_hosted_runners\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_user_blocking\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secret_scanning_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_scanning_alert\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"team_discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"vulnerability_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"workflows\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AppPermissions {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub actions: ::std::option::Option<AppPermissionsActions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub administration: ::std::option::Option<AppPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub checks: ::std::option::Option<AppPermissionsChecks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_references: ::std::option::Option<AppPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub contents: ::std::option::Option<AppPermissionsContents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployments: ::std::option::Option<AppPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub discussions: ::std::option::Option<AppPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub emails: ::std::option::Option<AppPermissionsEmails>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub environments: ::std::option::Option<AppPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub issues: ::std::option::Option<AppPermissionsIssues>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub members: ::std::option::Option<AppPermissionsMembers>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<AppPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_administration:
        ::std::option::Option<AppPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_hooks: ::std::option::Option<AppPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_packages: ::std::option::Option<AppPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_plan: ::std::option::Option<AppPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_projects: ::std::option::Option<AppPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_secrets: ::std::option::Option<AppPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_self_hosted_runners:
        ::std::option::Option<AppPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_user_blocking: ::std::option::Option<AppPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub packages: ::std::option::Option<AppPermissionsPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pages: ::std::option::Option<AppPermissionsPages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_requests: ::std::option::Option<AppPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_hooks: ::std::option::Option<AppPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_projects: ::std::option::Option<AppPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret_scanning_alerts: ::std::option::Option<AppPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secrets: ::std::option::Option<AppPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_events: ::std::option::Option<AppPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_scanning_alert: ::std::option::Option<AppPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub single_file: ::std::option::Option<AppPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub statuses: ::std::option::Option<AppPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub team_discussions: ::std::option::Option<AppPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub vulnerability_alerts: ::std::option::Option<AppPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub workflows: ::std::option::Option<AppPermissionsWorkflows>,
}
impl ::std::convert::From<&AppPermissions> for AppPermissions {
    fn from(value: &AppPermissions) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AppPermissions {
    fn default() -> Self {
        Self {
            actions: Default::default(),
            administration: Default::default(),
            checks: Default::default(),
            content_references: Default::default(),
            contents: Default::default(),
            deployments: Default::default(),
            discussions: Default::default(),
            emails: Default::default(),
            environments: Default::default(),
            issues: Default::default(),
            members: Default::default(),
            metadata: Default::default(),
            organization_administration: Default::default(),
            organization_hooks: Default::default(),
            organization_packages: Default::default(),
            organization_plan: Default::default(),
            organization_projects: Default::default(),
            organization_secrets: Default::default(),
            organization_self_hosted_runners: Default::default(),
            organization_user_blocking: Default::default(),
            packages: Default::default(),
            pages: Default::default(),
            pull_requests: Default::default(),
            repository_hooks: Default::default(),
            repository_projects: Default::default(),
            secret_scanning_alerts: Default::default(),
            secrets: Default::default(),
            security_events: Default::default(),
            security_scanning_alert: Default::default(),
            single_file: Default::default(),
            statuses: Default::default(),
            team_discussions: Default::default(),
            vulnerability_alerts: Default::default(),
            workflows: Default::default(),
        }
    }
}
#[doc = "`AppPermissionsActions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsActions {
    fn from(value: &AppPermissionsActions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsActions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsAdministration {
    fn from(value: &AppPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsChecks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsChecks {
    fn from(value: &AppPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsChecks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsChecks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsContentReferences`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsContentReferences {
    fn from(value: &AppPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsContentReferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsContentReferences {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsContents {
    fn from(value: &AppPermissionsContents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsContents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsDeployments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsDeployments {
    fn from(value: &AppPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsDeployments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsDeployments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsDiscussions {
    fn from(value: &AppPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsEmails`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsEmails {
    fn from(value: &AppPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsEmails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsEmails {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsEnvironments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsEnvironments {
    fn from(value: &AppPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsEnvironments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsEnvironments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsIssues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsIssues {
    fn from(value: &AppPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsIssues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsIssues {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsMembers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsMembers {
    fn from(value: &AppPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsMembers {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsMetadata`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsMetadata {
    fn from(value: &AppPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsMetadata {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationAdministration {
    fn from(value: &AppPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationHooks {
    fn from(value: &AppPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationPackages {
    fn from(value: &AppPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationPlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationPlan {
    fn from(value: &AppPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationPlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationPlan {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationProjects {
    fn from(value: &AppPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationProjects {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationSecrets {
    fn from(value: &AppPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationSelfHostedRunners`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationSelfHostedRunners {
    fn from(value: &AppPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationSelfHostedRunners {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationSelfHostedRunners {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationSelfHostedRunners {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AppPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AppPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsOrganizationUserBlocking`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsOrganizationUserBlocking {
    fn from(value: &AppPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsOrganizationUserBlocking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsOrganizationUserBlocking {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsOrganizationUserBlocking {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsOrganizationUserBlocking {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsOrganizationUserBlocking {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsPackages {
    fn from(value: &AppPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsPages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsPages {
    fn from(value: &AppPermissionsPages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsPages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsPages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsPullRequests`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsPullRequests {
    fn from(value: &AppPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsPullRequests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsPullRequests {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsRepositoryHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsRepositoryHooks {
    fn from(value: &AppPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsRepositoryHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsRepositoryHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsRepositoryProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsRepositoryProjects {
    fn from(value: &AppPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsRepositoryProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsRepositoryProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsSecretScanningAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsSecretScanningAlerts {
    fn from(value: &AppPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsSecretScanningAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsSecretScanningAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsSecretScanningAlerts {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsSecretScanningAlerts {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsSecretScanningAlerts {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsSecrets {
    fn from(value: &AppPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsSecurityEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsSecurityEvents {
    fn from(value: &AppPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsSecurityEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsSecurityEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsSecurityScanningAlert`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsSecurityScanningAlert {
    fn from(value: &AppPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsSecurityScanningAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsSecurityScanningAlert {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsSecurityScanningAlert {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsSecurityScanningAlert {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsSecurityScanningAlert {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsSingleFile`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsSingleFile {
    fn from(value: &AppPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsSingleFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsSingleFile {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsStatuses`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsStatuses {
    fn from(value: &AppPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsStatuses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsStatuses {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsTeamDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsTeamDiscussions {
    fn from(value: &AppPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsTeamDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsTeamDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsVulnerabilityAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsVulnerabilityAlerts {
    fn from(value: &AppPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsVulnerabilityAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsVulnerabilityAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsVulnerabilityAlerts {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsVulnerabilityAlerts {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsVulnerabilityAlerts {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AppPermissionsWorkflows`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AppPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for AppPermissionsWorkflows {
    fn from(value: &AppPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AppPermissionsWorkflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for AppPermissionsWorkflows {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AppPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AppPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AppPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "How the author is associated with the repository."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AuthorAssociation\","]
#[doc = "  \"description\": \"How the author is associated with the repository.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"COLLABORATOR\","]
#[doc = "    \"CONTRIBUTOR\","]
#[doc = "    \"FIRST_TIMER\","]
#[doc = "    \"FIRST_TIME_CONTRIBUTOR\","]
#[doc = "    \"MANNEQUIN\","]
#[doc = "    \"MEMBER\","]
#[doc = "    \"NONE\","]
#[doc = "    \"OWNER\""]
#[doc = "  ],"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AuthorAssociation {
    #[serde(rename = "COLLABORATOR")]
    Collaborator,
    #[serde(rename = "CONTRIBUTOR")]
    Contributor,
    #[serde(rename = "FIRST_TIMER")]
    FirstTimer,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    FirstTimeContributor,
    #[serde(rename = "MANNEQUIN")]
    Mannequin,
    #[serde(rename = "MEMBER")]
    Member,
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OWNER")]
    Owner,
}
impl ::std::convert::From<&Self> for AuthorAssociation {
    fn from(value: &AuthorAssociation) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AuthorAssociation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Collaborator => write!(f, "COLLABORATOR"),
            Self::Contributor => write!(f, "CONTRIBUTOR"),
            Self::FirstTimer => write!(f, "FIRST_TIMER"),
            Self::FirstTimeContributor => write!(f, "FIRST_TIME_CONTRIBUTOR"),
            Self::Mannequin => write!(f, "MANNEQUIN"),
            Self::Member => write!(f, "MEMBER"),
            Self::None => write!(f, "NONE"),
            Self::Owner => write!(f, "OWNER"),
        }
    }
}
impl ::std::str::FromStr for AuthorAssociation {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "COLLABORATOR" => Ok(Self::Collaborator),
            "CONTRIBUTOR" => Ok(Self::Contributor),
            "FIRST_TIMER" => Ok(Self::FirstTimer),
            "FIRST_TIME_CONTRIBUTOR" => Ok(Self::FirstTimeContributor),
            "MANNEQUIN" => Ok(Self::Mannequin),
            "MEMBER" => Ok(Self::Member),
            "NONE" => Ok(Self::None),
            "OWNER" => Ok(Self::Owner),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AuthorAssociation {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AuthorAssociation {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AuthorAssociation {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"branch protection rule\","]
#[doc = "  \"description\": \"The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin_enforced\","]
#[doc = "    \"allow_deletions_enforcement_level\","]
#[doc = "    \"allow_force_pushes_enforcement_level\","]
#[doc = "    \"authorized_actor_names\","]
#[doc = "    \"authorized_actors_only\","]
#[doc = "    \"authorized_dismissal_actors_only\","]
#[doc = "    \"created_at\","]
#[doc = "    \"dismiss_stale_reviews_on_push\","]
#[doc = "    \"id\","]
#[doc = "    \"ignore_approvals_from_contributors\","]
#[doc = "    \"linear_history_requirement_enforcement_level\","]
#[doc = "    \"merge_queue_enforcement_level\","]
#[doc = "    \"name\","]
#[doc = "    \"pull_request_reviews_enforcement_level\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"require_code_owner_review\","]
#[doc = "    \"required_approving_review_count\","]
#[doc = "    \"required_conversation_resolution_level\","]
#[doc = "    \"required_deployments_enforcement_level\","]
#[doc = "    \"required_status_checks\","]
#[doc = "    \"required_status_checks_enforcement_level\","]
#[doc = "    \"signature_requirement_enforcement_level\","]
#[doc = "    \"strict_required_status_checks_policy\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin_enforced\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"allow_deletions_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"allow_force_pushes_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"authorized_actor_names\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"authorized_actors_only\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"authorized_dismissal_actors_only\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismiss_stale_reviews_on_push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"ignore_approvals_from_contributors\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"linear_history_requirement_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merge_queue_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_request_reviews_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"require_code_owner_review\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"required_approving_review_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"required_conversation_resolution_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"required_deployments_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"required_status_checks\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"required_status_checks_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signature_requirement_enforcement_level\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"off\","]
#[doc = "        \"non_admins\","]
#[doc = "        \"everyone\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"strict_required_status_checks_policy\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRule {
    pub admin_enforced: bool,
    pub allow_deletions_enforcement_level: BranchProtectionRuleAllowDeletionsEnforcementLevel,
    pub allow_force_pushes_enforcement_level: BranchProtectionRuleAllowForcePushesEnforcementLevel,
    pub authorized_actor_names: ::std::vec::Vec<::std::string::String>,
    pub authorized_actors_only: bool,
    pub authorized_dismissal_actors_only: bool,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub dismiss_stale_reviews_on_push: bool,
    pub id: i64,
    pub ignore_approvals_from_contributors: bool,
    pub linear_history_requirement_enforcement_level:
        BranchProtectionRuleLinearHistoryRequirementEnforcementLevel,
    pub merge_queue_enforcement_level: BranchProtectionRuleMergeQueueEnforcementLevel,
    pub name: ::std::string::String,
    pub pull_request_reviews_enforcement_level:
        BranchProtectionRulePullRequestReviewsEnforcementLevel,
    pub repository_id: i64,
    pub require_code_owner_review: bool,
    pub required_approving_review_count: i64,
    pub required_conversation_resolution_level:
        BranchProtectionRuleRequiredConversationResolutionLevel,
    pub required_deployments_enforcement_level:
        BranchProtectionRuleRequiredDeploymentsEnforcementLevel,
    pub required_status_checks: ::std::vec::Vec<::std::string::String>,
    pub required_status_checks_enforcement_level:
        BranchProtectionRuleRequiredStatusChecksEnforcementLevel,
    pub signature_requirement_enforcement_level:
        BranchProtectionRuleSignatureRequirementEnforcementLevel,
    pub strict_required_status_checks_policy: bool,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
}
impl ::std::convert::From<&BranchProtectionRule> for BranchProtectionRule {
    fn from(value: &BranchProtectionRule) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleAllowDeletionsEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleAllowDeletionsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    fn from(value: &BranchProtectionRuleAllowDeletionsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleAllowDeletionsEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleAllowDeletionsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleAllowDeletionsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleAllowForcePushesEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleAllowForcePushesEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    fn from(value: &BranchProtectionRuleAllowForcePushesEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleAllowForcePushesEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleAllowForcePushesEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleAllowForcePushesEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"branch protection rule created event\","]
#[doc = "  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"rule\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"$ref\": \"#/definitions/branch-protection-rule\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleCreated {
    pub action: BranchProtectionRuleCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl ::std::convert::From<&BranchProtectionRuleCreated> for BranchProtectionRuleCreated {
    fn from(value: &BranchProtectionRuleCreated) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleCreatedAction {
    fn from(value: &BranchProtectionRuleCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BranchProtectionRuleCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BranchProtectionRuleCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"branch protection rule deleted event\","]
#[doc = "  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"rule\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"$ref\": \"#/definitions/branch-protection-rule\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleDeleted {
    pub action: BranchProtectionRuleDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl ::std::convert::From<&BranchProtectionRuleDeleted> for BranchProtectionRuleDeleted {
    fn from(value: &BranchProtectionRuleDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleDeletedAction {
    fn from(value: &BranchProtectionRuleDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BranchProtectionRuleDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BranchProtectionRuleDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Activity related to a branch protection rule. For more information, see \"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"branch protection rule edited event\","]
#[doc = "  \"description\": \"Activity related to a branch protection rule. For more information, see \\\"[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules).\\\"\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"repository\","]
#[doc = "    \"rule\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"If the action was `edited`, the changes to the rule.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"authorized_actor_names\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"authorized_actors_only\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"$ref\": \"#/definitions/branch-protection-rule\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEdited {
    pub action: BranchProtectionRuleEditedAction,
    pub changes: BranchProtectionRuleEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub rule: BranchProtectionRule,
    pub sender: User,
}
impl ::std::convert::From<&BranchProtectionRuleEdited> for BranchProtectionRuleEdited {
    fn from(value: &BranchProtectionRuleEdited) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleEditedAction {
    fn from(value: &BranchProtectionRuleEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BranchProtectionRuleEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BranchProtectionRuleEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "If the action was `edited`, the changes to the rule."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"If the action was `edited`, the changes to the rule.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"authorized_actor_names\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"authorized_actors_only\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authorized_actor_names:
        ::std::option::Option<BranchProtectionRuleEditedChangesAuthorizedActorNames>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authorized_actors_only:
        ::std::option::Option<BranchProtectionRuleEditedChangesAuthorizedActorsOnly>,
}
impl ::std::convert::From<&BranchProtectionRuleEditedChanges>
    for BranchProtectionRuleEditedChanges
{
    fn from(value: &BranchProtectionRuleEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BranchProtectionRuleEditedChanges {
    fn default() -> Self {
        Self {
            authorized_actor_names: Default::default(),
            authorized_actors_only: Default::default(),
        }
    }
}
#[doc = "`BranchProtectionRuleEditedChangesAuthorizedActorNames`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorNames {
    pub from: ::std::vec::Vec<::std::string::String>,
}
impl ::std::convert::From<&BranchProtectionRuleEditedChangesAuthorizedActorNames>
    for BranchProtectionRuleEditedChangesAuthorizedActorNames
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorNames) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleEditedChangesAuthorizedActorsOnly`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorsOnly {
    pub from: bool,
}
impl ::std::convert::From<&BranchProtectionRuleEditedChangesAuthorizedActorsOnly>
    for BranchProtectionRuleEditedChangesAuthorizedActorsOnly
{
    fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorsOnly) -> Self {
        value.clone()
    }
}
#[doc = "`BranchProtectionRuleEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/branch_protection_rule$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/branch_protection_rule$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/branch_protection_rule$edited\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BranchProtectionRuleEvent {
    Created(BranchProtectionRuleCreated),
    Deleted(BranchProtectionRuleDeleted),
    Edited(BranchProtectionRuleEdited),
}
impl ::std::convert::From<&Self> for BranchProtectionRuleEvent {
    fn from(value: &BranchProtectionRuleEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BranchProtectionRuleCreated> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<BranchProtectionRuleDeleted> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<BranchProtectionRuleEdited> for BranchProtectionRuleEvent {
    fn from(value: BranchProtectionRuleEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "`BranchProtectionRuleLinearHistoryRequirementEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    fn from(value: &BranchProtectionRuleLinearHistoryRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleLinearHistoryRequirementEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleMergeQueueEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleMergeQueueEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleMergeQueueEnforcementLevel {
    fn from(value: &BranchProtectionRuleMergeQueueEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleMergeQueueEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleMergeQueueEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleMergeQueueEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleMergeQueueEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRulePullRequestReviewsEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRulePullRequestReviewsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    fn from(value: &BranchProtectionRulePullRequestReviewsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRulePullRequestReviewsEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRulePullRequestReviewsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRulePullRequestReviewsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleRequiredConversationResolutionLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleRequiredConversationResolutionLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleRequiredConversationResolutionLevel {
    fn from(value: &BranchProtectionRuleRequiredConversationResolutionLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleRequiredConversationResolutionLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleRequiredConversationResolutionLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleRequiredConversationResolutionLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleRequiredConversationResolutionLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleRequiredDeploymentsEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    fn from(value: &BranchProtectionRuleRequiredDeploymentsEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleRequiredDeploymentsEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleRequiredDeploymentsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleRequiredDeploymentsEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleRequiredStatusChecksEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    fn from(value: &BranchProtectionRuleRequiredStatusChecksEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleRequiredStatusChecksEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleRequiredStatusChecksEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleRequiredStatusChecksEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BranchProtectionRuleSignatureRequirementEnforcementLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"off\","]
#[doc = "    \"non_admins\","]
#[doc = "    \"everyone\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BranchProtectionRuleSignatureRequirementEnforcementLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "non_admins")]
    NonAdmins,
    #[serde(rename = "everyone")]
    Everyone,
}
impl ::std::convert::From<&Self> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    fn from(value: &BranchProtectionRuleSignatureRequirementEnforcementLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Off => write!(f, "off"),
            Self::NonAdmins => write!(f, "non_admins"),
            Self::Everyone => write!(f, "everyone"),
        }
    }
}
impl ::std::str::FromStr for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "off" => Ok(Self::Off),
            "non_admins" => Ok(Self::NonAdmins),
            "everyone" => Ok(Self::Everyone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BranchProtectionRuleSignatureRequirementEnforcementLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BranchProtectionRuleSignatureRequirementEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BranchProtectionRuleSignatureRequirementEnforcementLevel
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunCompleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_run completed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_run\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_run\": {"]
#[doc = "      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"app\","]
#[doc = "        \"check_suite\","]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"external_id\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"output\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"started_at\","]
#[doc = "        \"status\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"check_suite\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"after\","]
#[doc = "            \"app\","]
#[doc = "            \"before\","]
#[doc = "            \"conclusion\","]
#[doc = "            \"created_at\","]
#[doc = "            \"head_branch\","]
#[doc = "            \"head_sha\","]
#[doc = "            \"id\","]
#[doc = "            \"pull_requests\","]
#[doc = "            \"status\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"after\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"app\": {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            \"before\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\","]
#[doc = "                \"neutral\","]
#[doc = "                \"cancelled\","]
#[doc = "                \"timed_out\","]
#[doc = "                \"action_required\","]
#[doc = "                \"stale\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"deployment\": {"]
#[doc = "              \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "            },"]
#[doc = "            \"head_branch\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"head_sha\": {"]
#[doc = "              \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"node_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"pull_requests\": {"]
#[doc = "              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"status\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"in_progress\","]
#[doc = "                \"completed\","]
#[doc = "                \"queued\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            \"skipped\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"details_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"external_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the check run.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"output\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"annotations_count\","]
#[doc = "            \"annotations_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"text\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"annotations_count\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"annotations_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"text\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"started_at\": {"]
#[doc = "          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"requested_action\": {"]
#[doc = "      \"description\": \"The action requested by the user.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompleted {
    pub action: CheckRunCompletedAction,
    pub check_run: CheckRunCompletedCheckRun,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requested_action: ::std::option::Option<CheckRunCompletedRequestedAction>,
    pub sender: User,
}
impl ::std::convert::From<&CheckRunCompleted> for CheckRunCompleted {
    fn from(value: &CheckRunCompleted) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCompletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunCompletedAction {
    fn from(value: &CheckRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCompletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCompletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"app\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"external_id\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"output\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"deployment\": {"]
#[doc = "          \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\","]
#[doc = "            \"queued\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        \"skipped\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"details_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"external_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the check run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"annotations_count\","]
#[doc = "        \"annotations_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"text\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"annotations_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"annotations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCompletedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: ::std::string::String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: ::std::option::Option<CheckRunCompletedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub details_url: ::std::option::Option<::std::string::String>,
    pub external_id: ::std::string::String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    pub output: CheckRunCompletedCheckRunOutput,
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: ::std::string::String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCompletedCheckRunStatus,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunCompletedCheckRun> for CheckRunCompletedCheckRun {
    fn from(value: &CheckRunCompletedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCompletedCheckRunCheckSuite`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\","]
#[doc = "        \"queued\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunCheckSuite {
    pub after: ::std::option::Option<::std::string::String>,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub conclusion: ::std::option::Option<CheckRunCompletedCheckRunCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployment: ::std::option::Option<CheckRunDeployment>,
    pub head_branch: ::std::option::Option<::std::string::String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    pub status: CheckRunCompletedCheckRunCheckSuiteStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunCompletedCheckRunCheckSuite>
    for CheckRunCompletedCheckRunCheckSuite
{
    fn from(value: &CheckRunCompletedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCompletedCheckRunCheckSuiteConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCompletedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCompletedCheckRunCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunCompletedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunCompletedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunCompletedCheckRunCheckSuiteStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCompletedCheckRunCheckSuiteStatus {
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for CheckRunCompletedCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunCompletedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCompletedCheckRunCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCompletedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\","]
#[doc = "    \"skipped\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCompletedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ::std::convert::From<&Self> for CheckRunCompletedCheckRunConclusion {
    fn from(value: &CheckRunCompletedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCompletedCheckRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
            Self::Skipped => write!(f, "skipped"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCompletedCheckRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCompletedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCompletedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCompletedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunCompletedCheckRunOutput`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"annotations_count\","]
#[doc = "    \"annotations_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"text\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"annotations_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"annotations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: ::std::string::String,
    pub summary: ::std::option::Option<::std::string::String>,
    pub text: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunCompletedCheckRunOutput> for CheckRunCompletedCheckRunOutput {
    fn from(value: &CheckRunCompletedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCompletedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunCompletedCheckRunStatus {
    fn from(value: &CheckRunCompletedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCompletedCheckRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCompletedCheckRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCompletedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCompletedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCompletedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action requested by the user.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub identifier: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunCompletedRequestedAction> for CheckRunCompletedRequestedAction {
    fn from(value: &CheckRunCompletedRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CheckRunCompletedRequestedAction {
    fn default() -> Self {
        Self {
            identifier: Default::default(),
        }
    }
}
#[doc = "`CheckRunCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_run created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_run\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_run\": {"]
#[doc = "      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"app\","]
#[doc = "        \"check_suite\","]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"external_id\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"output\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"started_at\","]
#[doc = "        \"status\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"check_suite\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"after\","]
#[doc = "            \"app\","]
#[doc = "            \"before\","]
#[doc = "            \"conclusion\","]
#[doc = "            \"created_at\","]
#[doc = "            \"head_branch\","]
#[doc = "            \"head_sha\","]
#[doc = "            \"id\","]
#[doc = "            \"pull_requests\","]
#[doc = "            \"status\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"after\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"app\": {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            \"before\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\","]
#[doc = "                \"neutral\","]
#[doc = "                \"cancelled\","]
#[doc = "                \"timed_out\","]
#[doc = "                \"action_required\","]
#[doc = "                \"stale\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"deployment\": {"]
#[doc = "              \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "            },"]
#[doc = "            \"head_branch\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"head_sha\": {"]
#[doc = "              \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"node_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"pull_requests\": {"]
#[doc = "              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"status\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queued\","]
#[doc = "                \"in_progress\","]
#[doc = "                \"completed\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            \"skipped\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"details_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"external_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the check run.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"output\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"annotations_count\","]
#[doc = "            \"annotations_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"text\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"annotations_count\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"annotations_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"text\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"started_at\": {"]
#[doc = "          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queued\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"requested_action\": {"]
#[doc = "      \"description\": \"The action requested by the user.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreated {
    pub action: CheckRunCreatedAction,
    pub check_run: CheckRunCreatedCheckRun,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requested_action: ::std::option::Option<CheckRunCreatedRequestedAction>,
    pub sender: User,
}
impl ::std::convert::From<&CheckRunCreated> for CheckRunCreated {
    fn from(value: &CheckRunCreated) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for CheckRunCreatedAction {
    fn from(value: &CheckRunCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"app\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"external_id\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"output\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"deployment\": {"]
#[doc = "          \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queued\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        \"skipped\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"details_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"external_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the check run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"annotations_count\","]
#[doc = "        \"annotations_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"text\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"annotations_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"annotations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRun {
    pub app: App,
    pub check_suite: CheckRunCreatedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: ::std::option::Option<::std::string::String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: ::std::option::Option<CheckRunCreatedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub details_url: ::std::option::Option<::std::string::String>,
    pub external_id: ::std::string::String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    pub output: CheckRunCreatedCheckRunOutput,
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: ::std::string::String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunCreatedCheckRunStatus,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunCreatedCheckRun> for CheckRunCreatedCheckRun {
    fn from(value: &CheckRunCreatedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCreatedCheckRunCheckSuite`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunCheckSuite {
    pub after: ::std::option::Option<::std::string::String>,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub conclusion: ::std::option::Option<CheckRunCreatedCheckRunCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployment: ::std::option::Option<CheckRunDeployment>,
    pub head_branch: ::std::option::Option<::std::string::String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    pub status: CheckRunCreatedCheckRunCheckSuiteStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunCreatedCheckRunCheckSuite>
    for CheckRunCreatedCheckRunCheckSuite
{
    fn from(value: &CheckRunCreatedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunCreatedCheckRunCheckSuiteConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCreatedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCreatedCheckRunCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunCreatedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunCreatedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunCreatedCheckRunCheckSuiteStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCreatedCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunCreatedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCreatedCheckRunCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCreatedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\","]
#[doc = "    \"skipped\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCreatedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ::std::convert::From<&Self> for CheckRunCreatedCheckRunConclusion {
    fn from(value: &CheckRunCreatedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCreatedCheckRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
            Self::Skipped => write!(f, "skipped"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCreatedCheckRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCreatedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCreatedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCreatedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunCreatedCheckRunOutput`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"annotations_count\","]
#[doc = "    \"annotations_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"text\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"annotations_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"annotations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: ::std::string::String,
    pub summary: ::std::option::Option<::std::string::String>,
    pub text: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunCreatedCheckRunOutput> for CheckRunCreatedCheckRunOutput {
    fn from(value: &CheckRunCreatedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunCreatedCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunCreatedCheckRunStatus {
    fn from(value: &CheckRunCreatedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunCreatedCheckRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunCreatedCheckRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunCreatedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunCreatedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunCreatedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action requested by the user.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub identifier: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunCreatedRequestedAction> for CheckRunCreatedRequestedAction {
    fn from(value: &CheckRunCreatedRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CheckRunCreatedRequestedAction {
    fn default() -> Self {
        Self {
            identifier: Default::default(),
        }
    }
}
#[doc = "A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Check Run Deployment\","]
#[doc = "  \"description\": \"A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"environment\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"original_environment\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"task\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"original_environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunDeployment {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::option::Option<::std::string::String>,
    pub environment: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub original_environment: ::std::string::String,
    pub repository_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub task: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunDeployment> for CheckRunDeployment {
    fn from(value: &CheckRunDeployment) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_run$completed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_run$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_run$requested_action\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_run$rerequested\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CheckRunEvent {
    Completed(CheckRunCompleted),
    Created(CheckRunCreated),
    RequestedAction(CheckRunRequestedAction),
    Rerequested(CheckRunRerequested),
}
impl ::std::convert::From<&Self> for CheckRunEvent {
    fn from(value: &CheckRunEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CheckRunCompleted> for CheckRunEvent {
    fn from(value: CheckRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl ::std::convert::From<CheckRunCreated> for CheckRunEvent {
    fn from(value: CheckRunCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<CheckRunRequestedAction> for CheckRunEvent {
    fn from(value: CheckRunRequestedAction) -> Self {
        Self::RequestedAction(value)
    }
}
impl ::std::convert::From<CheckRunRerequested> for CheckRunEvent {
    fn from(value: CheckRunRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[doc = "`CheckRunPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Check Run Pull Request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base\","]
#[doc = "    \"head\","]
#[doc = "    \"id\","]
#[doc = "    \"number\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequest {
    pub base: CheckRunPullRequestBase,
    pub head: CheckRunPullRequestHead,
    pub id: i64,
    pub number: i64,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunPullRequest> for CheckRunPullRequest {
    fn from(value: &CheckRunPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestBase {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&CheckRunPullRequestBase> for CheckRunPullRequestBase {
    fn from(value: &CheckRunPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestHead {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&CheckRunPullRequestHead> for CheckRunPullRequestHead {
    fn from(value: &CheckRunPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRequestedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_run requested_action event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_run\","]
#[doc = "    \"repository\","]
#[doc = "    \"requested_action\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested_action\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_run\": {"]
#[doc = "      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"app\","]
#[doc = "        \"check_suite\","]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"external_id\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"output\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"started_at\","]
#[doc = "        \"status\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"check_suite\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"after\","]
#[doc = "            \"app\","]
#[doc = "            \"before\","]
#[doc = "            \"conclusion\","]
#[doc = "            \"created_at\","]
#[doc = "            \"head_branch\","]
#[doc = "            \"head_sha\","]
#[doc = "            \"id\","]
#[doc = "            \"pull_requests\","]
#[doc = "            \"status\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"after\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"app\": {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            \"before\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\","]
#[doc = "                \"neutral\","]
#[doc = "                \"cancelled\","]
#[doc = "                \"timed_out\","]
#[doc = "                \"action_required\","]
#[doc = "                \"stale\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"deployment\": {"]
#[doc = "              \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "            },"]
#[doc = "            \"head_branch\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"head_sha\": {"]
#[doc = "              \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"node_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"pull_requests\": {"]
#[doc = "              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"status\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queued\","]
#[doc = "                \"in_progress\","]
#[doc = "                \"completed\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            \"skipped\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"details_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"external_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the check run.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"output\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"annotations_count\","]
#[doc = "            \"annotations_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"text\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"annotations_count\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"annotations_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"text\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"started_at\": {"]
#[doc = "          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queued\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"requested_action\": {"]
#[doc = "      \"description\": \"The action requested by the user.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedAction {
    pub action: CheckRunRequestedActionAction,
    pub check_run: CheckRunRequestedActionCheckRun,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub requested_action: CheckRunRequestedActionRequestedAction,
    pub sender: User,
}
impl ::std::convert::From<&CheckRunRequestedAction> for CheckRunRequestedAction {
    fn from(value: &CheckRunRequestedAction) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRequestedActionAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested_action\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRequestedActionAction {
    #[serde(rename = "requested_action")]
    RequestedAction,
}
impl ::std::convert::From<&Self> for CheckRunRequestedActionAction {
    fn from(value: &CheckRunRequestedActionAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRequestedActionAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RequestedAction => write!(f, "requested_action"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRequestedActionAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested_action" => Ok(Self::RequestedAction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRequestedActionAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRequestedActionAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRequestedActionAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"app\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"external_id\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"output\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"deployment\": {"]
#[doc = "          \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queued\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        \"skipped\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"details_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"external_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the check run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"annotations_count\","]
#[doc = "        \"annotations_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"text\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"annotations_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"annotations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRun {
    pub app: App,
    pub check_suite: CheckRunRequestedActionCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: ::std::option::Option<::std::string::String>,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: ::std::option::Option<CheckRunRequestedActionCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub details_url: ::std::option::Option<::std::string::String>,
    pub external_id: ::std::string::String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check run."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    pub output: CheckRunRequestedActionCheckRunOutput,
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: ::std::string::String,
    #[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
    pub status: CheckRunRequestedActionCheckRunStatus,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunRequestedActionCheckRun> for CheckRunRequestedActionCheckRun {
    fn from(value: &CheckRunRequestedActionCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRequestedActionCheckRunCheckSuite`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunCheckSuite {
    pub after: ::std::option::Option<::std::string::String>,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub conclusion: ::std::option::Option<CheckRunRequestedActionCheckRunCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployment: ::std::option::Option<CheckRunDeployment>,
    pub head_branch: ::std::option::Option<::std::string::String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    pub status: CheckRunRequestedActionCheckRunCheckSuiteStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunRequestedActionCheckRunCheckSuite>
    for CheckRunRequestedActionCheckRunCheckSuite
{
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRequestedActionCheckRunCheckSuiteConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunRequestedActionCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunRequestedActionCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunRequestedActionCheckRunCheckSuiteStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunRequestedActionCheckRunCheckSuiteStatus
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunRequestedActionCheckRunCheckSuiteStatus
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\","]
#[doc = "    \"skipped\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRequestedActionCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ::std::convert::From<&Self> for CheckRunRequestedActionCheckRunConclusion {
    fn from(value: &CheckRunRequestedActionCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRequestedActionCheckRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
            Self::Skipped => write!(f, "skipped"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRequestedActionCheckRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRequestedActionCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunRequestedActionCheckRunOutput`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"annotations_count\","]
#[doc = "    \"annotations_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"text\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"annotations_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"annotations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: ::std::string::String,
    pub summary: ::std::option::Option<::std::string::String>,
    pub text: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunRequestedActionCheckRunOutput>
    for CheckRunRequestedActionCheckRunOutput
{
    fn from(value: &CheckRunRequestedActionCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The current status of the check run. Can be `queued`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The current status of the check run. Can be `queued`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRequestedActionCheckRunStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunRequestedActionCheckRunStatus {
    fn from(value: &CheckRunRequestedActionCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRequestedActionCheckRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRequestedActionCheckRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRequestedActionCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRequestedActionCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action requested by the user.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub identifier: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunRequestedActionRequestedAction>
    for CheckRunRequestedActionRequestedAction
{
    fn from(value: &CheckRunRequestedActionRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CheckRunRequestedActionRequestedAction {
    fn default() -> Self {
        Self {
            identifier: Default::default(),
        }
    }
}
#[doc = "`CheckRunRerequested`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_run rerequested event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_run\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"rerequested\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_run\": {"]
#[doc = "      \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"app\","]
#[doc = "        \"check_suite\","]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"external_id\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"output\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"started_at\","]
#[doc = "        \"status\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"check_suite\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"after\","]
#[doc = "            \"app\","]
#[doc = "            \"before\","]
#[doc = "            \"conclusion\","]
#[doc = "            \"created_at\","]
#[doc = "            \"head_branch\","]
#[doc = "            \"head_sha\","]
#[doc = "            \"id\","]
#[doc = "            \"pull_requests\","]
#[doc = "            \"status\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"after\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"app\": {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            \"before\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\","]
#[doc = "                \"neutral\","]
#[doc = "                \"cancelled\","]
#[doc = "                \"timed_out\","]
#[doc = "                \"action_required\","]
#[doc = "                \"stale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"deployment\": {"]
#[doc = "              \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "            },"]
#[doc = "            \"head_branch\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"head_sha\": {"]
#[doc = "              \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"node_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"pull_requests\": {"]
#[doc = "              \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"status\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"completed\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            \"skipped\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"details_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"external_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the check.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"output\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"annotations_count\","]
#[doc = "            \"annotations_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"text\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"annotations_count\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"annotations_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"text\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"started_at\": {"]
#[doc = "          \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The phase of the lifecycle that the check is currently in.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"requested_action\": {"]
#[doc = "      \"description\": \"The action requested by the user.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequested {
    pub action: CheckRunRerequestedAction,
    pub check_run: CheckRunRerequestedCheckRun,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    #[doc = "The action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requested_action: ::std::option::Option<CheckRunRerequestedRequestedAction>,
    pub sender: User,
}
impl ::std::convert::From<&CheckRunRerequested> for CheckRunRerequested {
    fn from(value: &CheckRunRerequested) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRerequestedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"rerequested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl ::std::convert::From<&Self> for CheckRunRerequestedAction {
    fn from(value: &CheckRunRerequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRerequestedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Rerequested => write!(f, "rerequested"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRerequestedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"app\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"external_id\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"output\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"deployment\": {"]
#[doc = "          \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"completed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"description\": \"The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        \"skipped\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"details_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"external_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the check.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"annotations_count\","]
#[doc = "        \"annotations_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"text\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"annotations_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"annotations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"description\": \"The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The phase of the lifecycle that the check is currently in.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRun {
    pub app: App,
    pub check_suite: CheckRunRerequestedCheckRunCheckSuite,
    #[doc = "The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub completed_at: ::std::string::String,
    #[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: ::std::option::Option<CheckRunRerequestedCheckRunConclusion>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub details_url: ::std::option::Option<::std::string::String>,
    pub external_id: ::std::string::String,
    #[doc = "The SHA of the commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "The id of the check."]
    pub id: i64,
    #[doc = "The name of the check."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    pub output: CheckRunRerequestedCheckRunOutput,
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub started_at: ::std::string::String,
    #[doc = "The phase of the lifecycle that the check is currently in."]
    pub status: CheckRunRerequestedCheckRunStatus,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunRerequestedCheckRun> for CheckRunRerequestedCheckRun {
    fn from(value: &CheckRunRerequestedCheckRun) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRerequestedCheckRunCheckSuite`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"$ref\": \"#/definitions/check-run-deployment\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The id of the check suite that this check run is part of.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunCheckSuite {
    pub after: ::std::option::Option<::std::string::String>,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub conclusion: CheckRunRerequestedCheckRunCheckSuiteConclusion,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployment: ::std::option::Option<CheckRunDeployment>,
    pub head_branch: ::std::option::Option<::std::string::String>,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    #[doc = "The id of the check suite that this check run is part of."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    pub status: CheckRunRerequestedCheckRunCheckSuiteStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckRunRerequestedCheckRunCheckSuite>
    for CheckRunRerequestedCheckRunCheckSuite
{
    fn from(value: &CheckRunRerequestedCheckRunCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "`CheckRunRerequestedCheckRunCheckSuiteConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRerequestedCheckRunCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunRerequestedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunRerequestedCheckRunCheckSuiteConclusion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunRerequestedCheckRunCheckSuiteStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRerequestedCheckRunCheckSuiteStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    fn from(value: &CheckRunRerequestedCheckRunCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRerequestedCheckRunCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CheckRunRerequestedCheckRunCheckSuiteStatus
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CheckRunRerequestedCheckRunCheckSuiteStatus
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\","]
#[doc = "    \"skipped\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRerequestedCheckRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
    #[serde(rename = "skipped")]
    Skipped,
}
impl ::std::convert::From<&Self> for CheckRunRerequestedCheckRunConclusion {
    fn from(value: &CheckRunRerequestedCheckRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRerequestedCheckRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
            Self::Skipped => write!(f, "skipped"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRerequestedCheckRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            "skipped" => Ok(Self::Skipped),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRerequestedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRerequestedCheckRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckRunRerequestedCheckRunOutput`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"annotations_count\","]
#[doc = "    \"annotations_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"text\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"annotations_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"annotations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunOutput {
    pub annotations_count: i64,
    pub annotations_url: ::std::string::String,
    pub summary: ::std::option::Option<::std::string::String>,
    pub text: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunRerequestedCheckRunOutput>
    for CheckRunRerequestedCheckRunOutput
{
    fn from(value: &CheckRunRerequestedCheckRunOutput) -> Self {
        value.clone()
    }
}
#[doc = "The phase of the lifecycle that the check is currently in."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The phase of the lifecycle that the check is currently in.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckRunRerequestedCheckRunStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckRunRerequestedCheckRunStatus {
    fn from(value: &CheckRunRerequestedCheckRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckRunRerequestedCheckRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckRunRerequestedCheckRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckRunRerequestedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckRunRerequestedCheckRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The action requested by the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action requested by the user.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"description\": \"The integrator reference of the action requested by the user.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedRequestedAction {
    #[doc = "The integrator reference of the action requested by the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub identifier: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CheckRunRerequestedRequestedAction>
    for CheckRunRerequestedRequestedAction
{
    fn from(value: &CheckRunRerequestedRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CheckRunRerequestedRequestedAction {
    fn default() -> Self {
        Self {
            identifier: Default::default(),
        }
    }
}
#[doc = "`CheckSuiteCompleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_suite completed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"check_runs_url\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_commit\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"latest_check_runs_count\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"check_runs_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"description\": \"The head branch name the changes are on.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_commit\": {"]
#[doc = "          \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"latest_check_runs_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"requested\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\","]
#[doc = "            \"queued\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompleted {
    pub action: CheckSuiteCompletedAction,
    pub check_suite: CheckSuiteCompletedCheckSuite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CheckSuiteCompleted> for CheckSuiteCompleted {
    fn from(value: &CheckSuiteCompleted) -> Self {
        value.clone()
    }
}
#[doc = "`CheckSuiteCompletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for CheckSuiteCompletedAction {
    fn from(value: &CheckSuiteCompletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteCompletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteCompletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"check_runs_url\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_commit\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"latest_check_runs_count\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_runs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"description\": \"The head branch name the changes are on.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_commit\": {"]
#[doc = "      \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"latest_check_runs_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\","]
#[doc = "        \"queued\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompletedCheckSuite {
    pub after: ::std::string::String,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub check_runs_url: ::std::string::String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
    pub conclusion: ::std::option::Option<CheckSuiteCompletedCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: ::std::option::Option<::std::string::String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: ::std::string::String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: ::std::option::Option<CheckSuiteCompletedCheckSuiteStatus>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckSuiteCompletedCheckSuite> for CheckSuiteCompletedCheckSuite {
    fn from(value: &CheckSuiteCompletedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteCompletedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckSuiteCompletedCheckSuiteConclusion {
    fn from(value: &CheckSuiteCompletedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteCompletedCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteCompletedCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteCompletedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteCompletedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for CheckSuiteCompletedCheckSuiteStatus {
    fn from(value: &CheckSuiteCompletedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteCompletedCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteCompletedCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteCompletedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckSuiteEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_suite$completed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_suite$requested\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_suite$rerequested\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CheckSuiteEvent {
    Completed(CheckSuiteCompleted),
    Requested(CheckSuiteRequested),
    Rerequested(CheckSuiteRerequested),
}
impl ::std::convert::From<&Self> for CheckSuiteEvent {
    fn from(value: &CheckSuiteEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CheckSuiteCompleted> for CheckSuiteEvent {
    fn from(value: CheckSuiteCompleted) -> Self {
        Self::Completed(value)
    }
}
impl ::std::convert::From<CheckSuiteRequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRequested) -> Self {
        Self::Requested(value)
    }
}
impl ::std::convert::From<CheckSuiteRerequested> for CheckSuiteEvent {
    fn from(value: CheckSuiteRerequested) -> Self {
        Self::Rerequested(value)
    }
}
#[doc = "`CheckSuiteRequested`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_suite requested event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"check_runs_url\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_commit\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"latest_check_runs_count\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"check_runs_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"description\": \"The head branch name the changes are on.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_commit\": {"]
#[doc = "          \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"latest_check_runs_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"requested\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\","]
#[doc = "            \"queued\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequested {
    pub action: CheckSuiteRequestedAction,
    pub check_suite: CheckSuiteRequestedCheckSuite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CheckSuiteRequested> for CheckSuiteRequested {
    fn from(value: &CheckSuiteRequested) -> Self {
        value.clone()
    }
}
#[doc = "`CheckSuiteRequestedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl ::std::convert::From<&Self> for CheckSuiteRequestedAction {
    fn from(value: &CheckSuiteRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRequestedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRequestedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"check_runs_url\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_commit\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"latest_check_runs_count\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_runs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"description\": \"The head branch name the changes are on.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_commit\": {"]
#[doc = "      \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"latest_check_runs_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\","]
#[doc = "        \"queued\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequestedCheckSuite {
    pub after: ::std::string::String,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub check_runs_url: ::std::string::String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: ::std::option::Option<CheckSuiteRequestedCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: ::std::option::Option<::std::string::String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: ::std::string::String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: ::std::option::Option<CheckSuiteRequestedCheckSuiteStatus>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckSuiteRequestedCheckSuite> for CheckSuiteRequestedCheckSuite {
    fn from(value: &CheckSuiteRequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckSuiteRequestedCheckSuiteConclusion {
    fn from(value: &CheckSuiteRequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRequestedCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRequestedCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for CheckSuiteRequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRequestedCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRequestedCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CheckSuiteRerequested`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"check_suite rerequested event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"rerequested\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_suite\": {"]
#[doc = "      \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after\","]
#[doc = "        \"app\","]
#[doc = "        \"before\","]
#[doc = "        \"check_runs_url\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"created_at\","]
#[doc = "        \"head_branch\","]
#[doc = "        \"head_commit\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"id\","]
#[doc = "        \"latest_check_runs_count\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_requests\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"app\": {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        \"before\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"check_runs_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"head_branch\": {"]
#[doc = "          \"description\": \"The head branch name the changes are on.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"head_commit\": {"]
#[doc = "          \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"latest_check_runs_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"requested\","]
#[doc = "            \"in_progress\","]
#[doc = "            \"completed\","]
#[doc = "            \"queued\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequested {
    pub action: CheckSuiteRerequestedAction,
    pub check_suite: CheckSuiteRerequestedCheckSuite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CheckSuiteRerequested> for CheckSuiteRerequested {
    fn from(value: &CheckSuiteRerequested) -> Self {
        value.clone()
    }
}
#[doc = "`CheckSuiteRerequestedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"rerequested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRerequestedAction {
    #[serde(rename = "rerequested")]
    Rerequested,
}
impl ::std::convert::From<&Self> for CheckSuiteRerequestedAction {
    fn from(value: &CheckSuiteRerequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRerequestedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Rerequested => write!(f, "rerequested"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRerequestedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "rerequested" => Ok(Self::Rerequested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRerequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [check_suite](https://docs.github.com/en/rest/reference/checks#suites)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"app\","]
#[doc = "    \"before\","]
#[doc = "    \"check_runs_url\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_commit\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"id\","]
#[doc = "    \"latest_check_runs_count\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"app\": {"]
#[doc = "      \"$ref\": \"#/definitions/app\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"check_runs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"description\": \"The head branch name the changes are on.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_commit\": {"]
#[doc = "      \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"description\": \"The SHA of the head commit that is being checked.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"latest_check_runs_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"description\": \"An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/check-run-pull-request\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\","]
#[doc = "        \"queued\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL that points to the check suite API resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequestedCheckSuite {
    pub after: ::std::string::String,
    pub app: App,
    pub before: ::std::option::Option<::std::string::String>,
    pub check_runs_url: ::std::string::String,
    #[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
    pub conclusion: ::std::option::Option<CheckSuiteRerequestedCheckSuiteConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The head branch name the changes are on."]
    pub head_branch: ::std::option::Option<::std::string::String>,
    pub head_commit: CommitSimple,
    #[doc = "The SHA of the head commit that is being checked."]
    pub head_sha: ::std::string::String,
    pub id: i64,
    pub latest_check_runs_count: i64,
    pub node_id: ::std::string::String,
    #[doc = "An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty."]
    pub pull_requests: ::std::vec::Vec<CheckRunPullRequest>,
    #[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
    pub status: ::std::option::Option<CheckSuiteRerequestedCheckSuiteStatus>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL that points to the check suite API resource."]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CheckSuiteRerequestedCheckSuite> for CheckSuiteRerequestedCheckSuite {
    fn from(value: &CheckSuiteRerequestedCheckSuite) -> Self {
        value.clone()
    }
}
#[doc = "The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRerequestedCheckSuiteConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for CheckSuiteRerequestedCheckSuiteConclusion {
    fn from(value: &CheckSuiteRerequestedCheckSuiteConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRerequestedCheckSuiteConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRerequestedCheckSuiteConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRerequestedCheckSuiteConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CheckSuiteRerequestedCheckSuiteStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for CheckSuiteRerequestedCheckSuiteStatus {
    fn from(value: &CheckSuiteRerequestedCheckSuiteStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CheckSuiteRerequestedCheckSuiteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for CheckSuiteRerequestedCheckSuiteStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CheckSuiteRerequestedCheckSuiteStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertAppearedInBranch`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert appeared_in_branch event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"appeared_in_branch\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"false positive\","]
#[doc = "            \"won't fix\","]
#[doc = "            \"used in tests\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"dismissed\","]
#[doc = "            \"fixed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/github-org\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranch {
    pub action: CodeScanningAlertAppearedInBranchAction,
    pub alert: CodeScanningAlertAppearedInBranchAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl ::std::convert::From<&CodeScanningAlertAppearedInBranch>
    for CodeScanningAlertAppearedInBranch
{
    fn from(value: &CodeScanningAlertAppearedInBranch) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertAppearedInBranchAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"appeared_in_branch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertAppearedInBranchAction {
    #[serde(rename = "appeared_in_branch")]
    AppearedInBranch,
}
impl ::std::convert::From<&Self> for CodeScanningAlertAppearedInBranchAction {
    fn from(value: &CodeScanningAlertAppearedInBranchAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertAppearedInBranchAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AppearedInBranch => write!(f, "appeared_in_branch"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertAppearedInBranchAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "appeared_in_branch" => Ok(Self::AppearedInBranch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertAppearedInBranchAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertAppearedInBranchAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"false positive\","]
#[doc = "        \"won't fix\","]
#[doc = "        \"used in tests\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"dismissed\","]
#[doc = "        \"fixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub dismissed_by: ::std::option::Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason:
        ::std::option::Option<CodeScanningAlertAppearedInBranchAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<AlertInstance>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertAppearedInBranchAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertAppearedInBranchAlertState,
    pub tool: CodeScanningAlertAppearedInBranchAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertAppearedInBranchAlert>
    for CodeScanningAlertAppearedInBranchAlert
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"false positive\","]
#[doc = "    \"won't fix\","]
#[doc = "    \"used in tests\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertAppearedInBranchAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ::std::convert::From<&Self> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    fn from(value: &CodeScanningAlertAppearedInBranchAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FalsePositive => write!(f, "false positive"),
            Self::WontFix => write!(f, "won't fix"),
            Self::UsedInTests => write!(f, "used in tests"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertDismissedReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertDismissedReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertAppearedInBranchAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertAppearedInBranchAlertRuleSeverity>,
}
impl ::std::convert::From<&CodeScanningAlertAppearedInBranchAlertRule>
    for CodeScanningAlertAppearedInBranchAlertRule
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    fn from(value: &CodeScanningAlertAppearedInBranchAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"dismissed\","]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertAppearedInBranchAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertAppearedInBranchAlertState {
    fn from(value: &CodeScanningAlertAppearedInBranchAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertAppearedInBranchAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Dismissed => write!(f, "dismissed"),
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertAppearedInBranchAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertAppearedInBranchAlertState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertAppearedInBranchAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertAppearedInBranchAlertTool>
    for CodeScanningAlertAppearedInBranchAlertTool
{
    fn from(value: &CodeScanningAlertAppearedInBranchAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertClosedByUser`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert closed_by_user event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"closed_by_user\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"false positive\","]
#[doc = "            \"won't fix\","]
#[doc = "            \"used in tests\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"state\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"dismissed\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"tsAdditionalProperties\": false"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"full_description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"help\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"tags\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"dismissed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"guid\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUser {
    pub action: CodeScanningAlertClosedByUserAction,
    pub alert: CodeScanningAlertClosedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUser> for CodeScanningAlertClosedByUser {
    fn from(value: &CodeScanningAlertClosedByUser) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertClosedByUserAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed_by_user\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertClosedByUserAction {
    #[serde(rename = "closed_by_user")]
    ClosedByUser,
}
impl ::std::convert::From<&Self> for CodeScanningAlertClosedByUserAction {
    fn from(value: &CodeScanningAlertClosedByUserAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertClosedByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ClosedByUser => write!(f, "closed_by_user"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertClosedByUserAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed_by_user" => Ok(Self::ClosedByUser),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertClosedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertClosedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"false positive\","]
#[doc = "        \"won't fix\","]
#[doc = "        \"used in tests\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"state\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"enum\": ["]
#[doc = "                  \"dismissed\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"tsAdditionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"full_description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"help\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tags\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"dismissed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"guid\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub dismissed_by: User,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: ::std::option::Option<CodeScanningAlertClosedByUserAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<CodeScanningAlertClosedByUserAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertClosedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertClosedByUserAlertState,
    pub tool: CodeScanningAlertClosedByUserAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlert>
    for CodeScanningAlertClosedByUserAlert
{
    fn from(value: &CodeScanningAlertClosedByUserAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"false positive\","]
#[doc = "    \"won't fix\","]
#[doc = "    \"used in tests\","]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertClosedByUserAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ::std::convert::From<&Self> for CodeScanningAlertClosedByUserAlertDismissedReason {
    fn from(value: &CodeScanningAlertClosedByUserAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertClosedByUserAlertDismissedReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FalsePositive => write!(f, "false positive"),
            Self::WontFix => write!(f, "won't fix"),
            Self::UsedInTests => write!(f, "used in tests"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertDismissedReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertClosedByUserAlertDismissedReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertClosedByUserAlertDismissedReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertInstancesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"dismissed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<CodeScanningAlertClosedByUserAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<CodeScanningAlertClosedByUserAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub state: CodeScanningAlertClosedByUserAlertInstancesItemState,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlertInstancesItem>
    for CodeScanningAlertClosedByUserAlertInstancesItem
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertInstancesItemLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlertInstancesItemLocation>
    for CodeScanningAlertClosedByUserAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertClosedByUserAlertInstancesItemLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertInstancesItemMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlertInstancesItemMessage>
    for CodeScanningAlertClosedByUserAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertClosedByUserAlertInstancesItemMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertInstancesItemState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertClosedByUserAlertInstancesItemState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertClosedByUserAlertInstancesItemState {
    fn from(value: &CodeScanningAlertClosedByUserAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertClosedByUserAlertInstancesItemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertInstancesItemState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertClosedByUserAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertClosedByUserAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"full_description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"help\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tags\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub full_description: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertClosedByUserAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlertRule>
    for CodeScanningAlertClosedByUserAlertRule
{
    fn from(value: &CodeScanningAlertClosedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertClosedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    fn from(value: &CodeScanningAlertClosedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertClosedByUserAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertClosedByUserAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertClosedByUserAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertClosedByUserAlertState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertClosedByUserAlertState {
    fn from(value: &CodeScanningAlertClosedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertClosedByUserAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertClosedByUserAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertClosedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertClosedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertClosedByUserAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"guid\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertTool {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub guid: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertClosedByUserAlertTool>
    for CodeScanningAlertClosedByUserAlertTool
{
    fn from(value: &CodeScanningAlertClosedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"state\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"open\","]
#[doc = "                      \"dismissed\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"tsAdditionalProperties\": false"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"full_description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"help\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"tags\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"dismissed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"guid\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/github-org\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreated {
    pub action: CodeScanningAlertCreatedAction,
    pub alert: CodeScanningAlertCreatedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl ::std::convert::From<&CodeScanningAlertCreated> for CodeScanningAlertCreated {
    fn from(value: &CodeScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for CodeScanningAlertCreatedAction {
    fn from(value: &CodeScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"state\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"enum\": ["]
#[doc = "                  \"open\","]
#[doc = "                  \"dismissed\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"tsAdditionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"full_description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"help\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tags\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"dismissed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"guid\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<CodeScanningAlertCreatedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertCreatedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertCreatedAlertState,
    pub tool: CodeScanningAlertCreatedAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlert> for CodeScanningAlertCreatedAlert {
    fn from(value: &CodeScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertCreatedAlertInstancesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"dismissed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<CodeScanningAlertCreatedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<CodeScanningAlertCreatedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub state: CodeScanningAlertCreatedAlertInstancesItemState,
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlertInstancesItem>
    for CodeScanningAlertCreatedAlertInstancesItem
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertCreatedAlertInstancesItemLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlertInstancesItemLocation>
    for CodeScanningAlertCreatedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertCreatedAlertInstancesItemLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertCreatedAlertInstancesItemMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlertInstancesItemMessage>
    for CodeScanningAlertCreatedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertCreatedAlertInstancesItemMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertCreatedAlertInstancesItemState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertCreatedAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertCreatedAlertInstancesItemState {
    fn from(value: &CodeScanningAlertCreatedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertCreatedAlertInstancesItemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertCreatedAlertInstancesItemState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertInstancesItemState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertCreatedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertCreatedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertCreatedAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"full_description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"help\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tags\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub full_description: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertCreatedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlertRule>
    for CodeScanningAlertCreatedAlertRule
{
    fn from(value: &CodeScanningAlertCreatedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertCreatedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertCreatedAlertRuleSeverity {
    fn from(value: &CodeScanningAlertCreatedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertCreatedAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertCreatedAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertCreatedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertCreatedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertCreatedAlertState {
    fn from(value: &CodeScanningAlertCreatedAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertCreatedAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertCreatedAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertCreatedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertCreatedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertCreatedAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"guid\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertTool {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub guid: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertCreatedAlertTool>
    for CodeScanningAlertCreatedAlertTool
{
    fn from(value: &CodeScanningAlertCreatedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$appeared_in_branch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$closed_by_user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$fixed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$reopened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert$reopened_by_user\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CodeScanningAlertEvent {
    AppearedInBranch(CodeScanningAlertAppearedInBranch),
    ClosedByUser(CodeScanningAlertClosedByUser),
    Created(CodeScanningAlertCreated),
    Fixed(CodeScanningAlertFixed),
    Reopened(CodeScanningAlertReopened),
    ReopenedByUser(CodeScanningAlertReopenedByUser),
}
impl ::std::convert::From<&Self> for CodeScanningAlertEvent {
    fn from(value: &CodeScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CodeScanningAlertAppearedInBranch> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertAppearedInBranch) -> Self {
        Self::AppearedInBranch(value)
    }
}
impl ::std::convert::From<CodeScanningAlertClosedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertClosedByUser) -> Self {
        Self::ClosedByUser(value)
    }
}
impl ::std::convert::From<CodeScanningAlertCreated> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<CodeScanningAlertFixed> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertFixed) -> Self {
        Self::Fixed(value)
    }
}
impl ::std::convert::From<CodeScanningAlertReopened> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl ::std::convert::From<CodeScanningAlertReopenedByUser> for CodeScanningAlertEvent {
    fn from(value: CodeScanningAlertReopenedByUser) -> Self {
        Self::ReopenedByUser(value)
    }
}
#[doc = "`CodeScanningAlertFixed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert fixed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"fixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"false positive\","]
#[doc = "            \"won't fix\","]
#[doc = "            \"used in tests\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"state\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"fixed\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"tsAdditionalProperties\": false"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"instances_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"full_description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"help\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"tags\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"fixed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"guid\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/github-org\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixed {
    pub action: CodeScanningAlertFixedAction,
    pub alert: CodeScanningAlertFixedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl ::std::convert::From<&CodeScanningAlertFixed> for CodeScanningAlertFixed {
    fn from(value: &CodeScanningAlertFixed) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertFixedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertFixedAction {
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertFixedAction {
    fn from(value: &CodeScanningAlertFixedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertFixedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertFixedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertFixedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertFixedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertFixedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"false positive\","]
#[doc = "        \"won't fix\","]
#[doc = "        \"used in tests\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"state\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"enum\": ["]
#[doc = "                  \"fixed\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"tsAdditionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"instances_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"full_description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"help\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tags\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"fixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"guid\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub dismissed_by: ::std::option::Option<User>,
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: ::std::option::Option<CodeScanningAlertFixedAlertDismissedReason>,
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<CodeScanningAlertFixedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub instances_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertFixedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertFixedAlertState,
    pub tool: CodeScanningAlertFixedAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertFixedAlert> for CodeScanningAlertFixedAlert {
    fn from(value: &CodeScanningAlertFixedAlert) -> Self {
        value.clone()
    }
}
#[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"false positive\","]
#[doc = "    \"won't fix\","]
#[doc = "    \"used in tests\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertFixedAlertDismissedReason {
    #[serde(rename = "false positive")]
    FalsePositive,
    #[serde(rename = "won't fix")]
    WontFix,
    #[serde(rename = "used in tests")]
    UsedInTests,
}
impl ::std::convert::From<&Self> for CodeScanningAlertFixedAlertDismissedReason {
    fn from(value: &CodeScanningAlertFixedAlertDismissedReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertFixedAlertDismissedReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FalsePositive => write!(f, "false positive"),
            Self::WontFix => write!(f, "won't fix"),
            Self::UsedInTests => write!(f, "used in tests"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertFixedAlertDismissedReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "false positive" => Ok(Self::FalsePositive),
            "won't fix" => Ok(Self::WontFix),
            "used in tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertFixedAlertDismissedReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertFixedAlertDismissedReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertFixedAlertInstancesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"fixed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<CodeScanningAlertFixedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<CodeScanningAlertFixedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub state: CodeScanningAlertFixedAlertInstancesItemState,
}
impl ::std::convert::From<&CodeScanningAlertFixedAlertInstancesItem>
    for CodeScanningAlertFixedAlertInstancesItem
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertFixedAlertInstancesItemLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CodeScanningAlertFixedAlertInstancesItemLocation>
    for CodeScanningAlertFixedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertFixedAlertInstancesItemLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertFixedAlertInstancesItemMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertFixedAlertInstancesItemMessage>
    for CodeScanningAlertFixedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertFixedAlertInstancesItemMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertFixedAlertInstancesItemState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertFixedAlertInstancesItemState {
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertFixedAlertInstancesItemState {
    fn from(value: &CodeScanningAlertFixedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertFixedAlertInstancesItemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertFixedAlertInstancesItemState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertInstancesItemState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertFixedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertFixedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertFixedAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"full_description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"help\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tags\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub full_description: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertFixedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl ::std::convert::From<&CodeScanningAlertFixedAlertRule> for CodeScanningAlertFixedAlertRule {
    fn from(value: &CodeScanningAlertFixedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertFixedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertFixedAlertRuleSeverity {
    fn from(value: &CodeScanningAlertFixedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertFixedAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertFixedAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertFixedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertFixedAlertState {
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertFixedAlertState {
    fn from(value: &CodeScanningAlertFixedAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertFixedAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertFixedAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertFixedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertFixedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertFixedAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"guid\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertTool {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub guid: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertFixedAlertTool> for CodeScanningAlertFixedAlertTool {
    fn from(value: &CodeScanningAlertFixedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert reopened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"state\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"open\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"tsAdditionalProperties\": false"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"full_description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"help\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"tags\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"dismissed\","]
#[doc = "            \"fixed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"guid\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/github-org\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopened {
    pub action: CodeScanningAlertReopenedAction,
    pub alert: CodeScanningAlertReopenedAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: GithubOrg,
}
impl ::std::convert::From<&CodeScanningAlertReopened> for CodeScanningAlertReopened {
    fn from(value: &CodeScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedAction {
    fn from(value: &CodeScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reopened => write!(f, "reopened"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"state\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"enum\": ["]
#[doc = "                  \"open\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"tsAdditionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"full_description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"help\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tags\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"dismissed\","]
#[doc = "        \"fixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"guid\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<CodeScanningAlertReopenedAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedAlertState,
    pub tool: CodeScanningAlertReopenedAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlert> for CodeScanningAlertReopenedAlert {
    fn from(value: &CodeScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedAlertInstancesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<CodeScanningAlertReopenedAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<CodeScanningAlertReopenedAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub state: CodeScanningAlertReopenedAlertInstancesItemState,
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlertInstancesItem>
    for CodeScanningAlertReopenedAlertInstancesItem
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedAlertInstancesItemLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlertInstancesItemLocation>
    for CodeScanningAlertReopenedAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertReopenedAlertInstancesItemLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertReopenedAlertInstancesItemMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlertInstancesItemMessage>
    for CodeScanningAlertReopenedAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertReopenedAlertInstancesItemMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertReopenedAlertInstancesItemState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedAlertInstancesItemState {
    fn from(value: &CodeScanningAlertReopenedAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedAlertInstancesItemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedAlertInstancesItemState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertInstancesItemState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertReopenedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertReopenedAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertReopenedAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"full_description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"help\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tags\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub full_description: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    pub help: (),
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertReopenedAlertRuleSeverity>,
    #[serde(default)]
    pub tags: (),
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlertRule>
    for CodeScanningAlertReopenedAlertRule
{
    fn from(value: &CodeScanningAlertReopenedAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedAlertRuleSeverity {
    fn from(value: &CodeScanningAlertReopenedAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertReopenedAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertReopenedAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"dismissed\","]
#[doc = "    \"fixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedAlertState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "dismissed")]
    Dismissed,
    #[serde(rename = "fixed")]
    Fixed,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedAlertState {
    fn from(value: &CodeScanningAlertReopenedAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Dismissed => write!(f, "dismissed"),
            Self::Fixed => write!(f, "fixed"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "dismissed" => Ok(Self::Dismissed),
            "fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertReopenedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertReopenedAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertReopenedAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"guid\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertTool {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub guid: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedAlertTool>
    for CodeScanningAlertReopenedAlertTool
{
    fn from(value: &CodeScanningAlertReopenedAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedByUser`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"code_scanning_alert reopened_by_user event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"commit_oid\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened_by_user\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismissed_by\","]
#[doc = "        \"dismissed_reason\","]
#[doc = "        \"html_url\","]
#[doc = "        \"instances\","]
#[doc = "        \"number\","]
#[doc = "        \"rule\","]
#[doc = "        \"state\","]
#[doc = "        \"tool\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"dismissed_reason\": {"]
#[doc = "          \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"instances\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"state\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"open\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"tsAdditionalProperties\": false"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"most_recent_instance\": {"]
#[doc = "          \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The code scanning alert number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"rule\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"description\","]
#[doc = "            \"id\","]
#[doc = "            \"severity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"description\": {"]
#[doc = "              \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"severity\": {"]
#[doc = "              \"description\": \"The severity of the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"note\","]
#[doc = "                \"warning\","]
#[doc = "                \"error\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of a code scanning alert.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"name\": {"]
#[doc = "              \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"commit_oid\": {"]
#[doc = "      \"description\": \"The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUser {
    pub action: CodeScanningAlertReopenedByUserAction,
    pub alert: CodeScanningAlertReopenedByUserAlert,
    #[doc = "The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    pub commit_oid: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUser> for CodeScanningAlertReopenedByUser {
    fn from(value: &CodeScanningAlertReopenedByUser) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened_by_user\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedByUserAction {
    #[serde(rename = "reopened_by_user")]
    ReopenedByUser,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedByUserAction {
    fn from(value: &CodeScanningAlertReopenedByUserAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReopenedByUser => write!(f, "reopened_by_user"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedByUserAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened_by_user" => Ok(Self::ReopenedByUser),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertReopenedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertReopenedByUserAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The code scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The code scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismissed_by\","]
#[doc = "    \"dismissed_reason\","]
#[doc = "    \"html_url\","]
#[doc = "    \"instances\","]
#[doc = "    \"number\","]
#[doc = "    \"rule\","]
#[doc = "    \"state\","]
#[doc = "    \"tool\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"description\": \"The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"description\": \"The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_by\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"dismissed_reason\": {"]
#[doc = "      \"description\": \"The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"The GitHub URL of the alert resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"instances\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"state\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"enum\": ["]
#[doc = "                  \"open\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"tsAdditionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"most_recent_instance\": {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The code scanning alert number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"rule\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"id\","]
#[doc = "        \"severity\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"description\": \"The severity of the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\","]
#[doc = "            \"note\","]
#[doc = "            \"warning\","]
#[doc = "            \"error\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of a code scanning alert.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlert {
    #[doc = "The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`"]
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`."]
    pub dismissed_at: (),
    pub dismissed_by: (),
    #[doc = "The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`."]
    pub dismissed_reason: (),
    #[doc = "The GitHub URL of the alert resource."]
    pub html_url: ::std::string::String,
    pub instances: ::std::vec::Vec<CodeScanningAlertReopenedByUserAlertInstancesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub most_recent_instance: ::std::option::Option<AlertInstance>,
    #[doc = "The code scanning alert number."]
    pub number: i64,
    pub rule: CodeScanningAlertReopenedByUserAlertRule,
    #[doc = "State of a code scanning alert."]
    pub state: CodeScanningAlertReopenedByUserAlertState,
    pub tool: CodeScanningAlertReopenedByUserAlertTool,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlert>
    for CodeScanningAlertReopenedByUserAlert
{
    fn from(value: &CodeScanningAlertReopenedByUserAlert) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertInstancesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alert-instance\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItem {
    #[doc = "Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name."]
    pub analysis_key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub classifications: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub commit_sha: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed."]
    pub environment: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub location: ::std::option::Option<CodeScanningAlertReopenedByUserAlertInstancesItemLocation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<CodeScanningAlertReopenedByUserAlertInstancesItemMessage>,
    #[doc = "The full Git reference, formatted as `refs/heads/<branch name>`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub state: CodeScanningAlertReopenedByUserAlertInstancesItemState,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlertInstancesItem>
    for CodeScanningAlertReopenedByUserAlertInstancesItem
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItem) -> Self {
        value.clone()
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertInstancesItemLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"end_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"end_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start_column\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItemLocation {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end_line: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_column: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_line: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlertInstancesItemLocation>
    for CodeScanningAlertReopenedByUserAlertInstancesItemLocation
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemLocation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertReopenedByUserAlertInstancesItemLocation {
    fn default() -> Self {
        Self {
            end_column: Default::default(),
            end_line: Default::default(),
            path: Default::default(),
            start_column: Default::default(),
            start_line: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertInstancesItemMessage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"text\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertInstancesItemMessage {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlertInstancesItemMessage>
    for CodeScanningAlertReopenedByUserAlertInstancesItemMessage
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemMessage) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CodeScanningAlertReopenedByUserAlertInstancesItemMessage {
    fn default() -> Self {
        Self {
            text: Default::default(),
        }
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertInstancesItemState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedByUserAlertInstancesItemState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    fn from(value: &CodeScanningAlertReopenedByUserAlertInstancesItemState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertInstancesItemState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertReopenedByUserAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertReopenedByUserAlertInstancesItemState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertRule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"severity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A short description of the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for the rule used to detect the alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"description\": \"The severity of the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"note\","]
#[doc = "        \"warning\","]
#[doc = "        \"error\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertRule {
    #[doc = "A short description of the rule used to detect the alert."]
    pub description: ::std::string::String,
    #[doc = "A unique identifier for the rule used to detect the alert."]
    pub id: ::std::string::String,
    #[doc = "The severity of the alert."]
    pub severity: ::std::option::Option<CodeScanningAlertReopenedByUserAlertRuleSeverity>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlertRule>
    for CodeScanningAlertReopenedByUserAlertRule
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertRule) -> Self {
        value.clone()
    }
}
#[doc = "The severity of the alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of the alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"note\","]
#[doc = "    \"warning\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedByUserAlertRuleSeverity {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "note")]
    Note,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    fn from(value: &CodeScanningAlertReopenedByUserAlertRuleSeverity) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Note => write!(f, "note"),
            Self::Warning => write!(f, "warning"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "note" => Ok(Self::Note),
            "warning" => Ok(Self::Warning),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for CodeScanningAlertReopenedByUserAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for CodeScanningAlertReopenedByUserAlertRuleSeverity
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of a code scanning alert."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of a code scanning alert.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CodeScanningAlertReopenedByUserAlertState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for CodeScanningAlertReopenedByUserAlertState {
    fn from(value: &CodeScanningAlertReopenedByUserAlertState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CodeScanningAlertReopenedByUserAlertState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for CodeScanningAlertReopenedByUserAlertState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CodeScanningAlertReopenedByUserAlertState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CodeScanningAlertReopenedByUserAlertTool`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool used to generate the code scanning analysis alert.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"The version of the tool used to detect the alert.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertTool {
    #[doc = "The name of the tool used to generate the code scanning analysis alert."]
    pub name: ::std::string::String,
    #[doc = "The version of the tool used to detect the alert."]
    pub version: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CodeScanningAlertReopenedByUserAlertTool>
    for CodeScanningAlertReopenedByUserAlertTool
{
    fn from(value: &CodeScanningAlertReopenedByUserAlertTool) -> Self {
        value.clone()
    }
}
#[doc = "`Commit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Commit\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"added\","]
#[doc = "    \"author\","]
#[doc = "    \"committer\","]
#[doc = "    \"distinct\","]
#[doc = "    \"id\","]
#[doc = "    \"message\","]
#[doc = "    \"modified\","]
#[doc = "    \"removed\","]
#[doc = "    \"timestamp\","]
#[doc = "    \"tree_id\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"added\": {"]
#[doc = "      \"description\": \"An array of files added in the commit.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    \"committer\": {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    \"distinct\": {"]
#[doc = "      \"description\": \"Whether this commit is distinct from any that have been pushed before.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"The commit message.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"modified\": {"]
#[doc = "      \"description\": \"An array of files modified by the commit.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"removed\": {"]
#[doc = "      \"description\": \"An array of files removed in the commit.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"timestamp\": {"]
#[doc = "      \"description\": \"The ISO 8601 timestamp of the commit.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tree_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL that points to the commit API resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Commit {
    #[doc = "An array of files added in the commit."]
    pub added: ::std::vec::Vec<::std::string::String>,
    pub author: Committer,
    pub committer: Committer,
    #[doc = "Whether this commit is distinct from any that have been pushed before."]
    pub distinct: bool,
    pub id: ::std::string::String,
    #[doc = "The commit message."]
    pub message: ::std::string::String,
    #[doc = "An array of files modified by the commit."]
    pub modified: ::std::vec::Vec<::std::string::String>,
    #[doc = "An array of files removed in the commit."]
    pub removed: ::std::vec::Vec<::std::string::String>,
    #[doc = "The ISO 8601 timestamp of the commit."]
    pub timestamp: ::std::string::String,
    pub tree_id: ::std::string::String,
    #[doc = "URL that points to the commit API resource."]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Commit> for Commit {
    fn from(value: &Commit) -> Self {
        value.clone()
    }
}
#[doc = "A commit comment is created. The type of activity is specified in the `action` property. "]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"commit_comment created event\","]
#[doc = "  \"description\": \"A commit comment is created. The type of activity is specified in the `action` property. \","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The action performed. Can be `created`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"description\": \"The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"commit_id\","]
#[doc = "        \"created_at\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"line\","]
#[doc = "        \"node_id\","]
#[doc = "        \"path\","]
#[doc = "        \"position\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"The text of the comment.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"commit_id\": {"]
#[doc = "          \"description\": \"The SHA of the commit to which the comment applies.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"The ID of the commit comment.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"line\": {"]
#[doc = "          \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\","]
#[doc = "          \"type\": ["]
#[doc = "            \"integer\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"description\": \"The node ID of the commit comment.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"path\": {"]
#[doc = "          \"description\": \"The relative path of the file to which the comment applies.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"position\": {"]
#[doc = "          \"description\": \"The line index in the diff to which the comment applies.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"integer\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreated {
    #[doc = "The action performed. Can be `created`."]
    pub action: CommitCommentCreatedAction,
    pub comment: CommitCommentCreatedComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CommitCommentCreated> for CommitCommentCreated {
    fn from(value: &CommitCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "The action performed. Can be `created`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action performed. Can be `created`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CommitCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for CommitCommentCreatedAction {
    fn from(value: &CommitCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CommitCommentCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for CommitCommentCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CommitCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CommitCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CommitCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"commit_id\","]
#[doc = "    \"created_at\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"line\","]
#[doc = "    \"node_id\","]
#[doc = "    \"path\","]
#[doc = "    \"position\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"The text of the comment.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"commit_id\": {"]
#[doc = "      \"description\": \"The SHA of the commit to which the comment applies.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The ID of the commit comment.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"description\": \"The node ID of the commit comment.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"description\": \"The relative path of the file to which the comment applies.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"position\": {"]
#[doc = "      \"description\": \"The line index in the diff to which the comment applies.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreatedComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: ::std::string::String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: ::std::string::String,
    pub created_at: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "The ID of the commit comment."]
    pub id: i64,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: ::std::option::Option<i64>,
    #[doc = "The node ID of the commit comment."]
    pub node_id: ::std::string::String,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: ::std::option::Option<::std::string::String>,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: ::std::option::Option<i64>,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&CommitCommentCreatedComment> for CommitCommentCreatedComment {
    fn from(value: &CommitCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[doc = "`CommitCommentEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/commit_comment$created\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct CommitCommentEvent(pub CommitCommentCreated);
impl ::std::ops::Deref for CommitCommentEvent {
    type Target = CommitCommentCreated;
    fn deref(&self) -> &CommitCommentCreated {
        &self.0
    }
}
impl ::std::convert::From<CommitCommentEvent> for CommitCommentCreated {
    fn from(value: CommitCommentEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CommitCommentEvent> for CommitCommentEvent {
    fn from(value: &CommitCommentEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CommitCommentCreated> for CommitCommentEvent {
    fn from(value: CommitCommentCreated) -> Self {
        Self(value)
    }
}
#[doc = "`CommitSimple`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SimpleCommit\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"committer\","]
#[doc = "    \"id\","]
#[doc = "    \"message\","]
#[doc = "    \"timestamp\","]
#[doc = "    \"tree_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    \"committer\": {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"timestamp\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tree_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CommitSimple {
    pub author: Committer,
    pub committer: Committer,
    pub id: ::std::string::String,
    pub message: ::std::string::String,
    pub timestamp: ::std::string::String,
    pub tree_id: ::std::string::String,
}
impl ::std::convert::From<&CommitSimple> for CommitSimple {
    fn from(value: &CommitSimple) -> Self {
        value.clone()
    }
}
#[doc = "Metaproperties for Git author/committer information."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Committer\","]
#[doc = "  \"description\": \"Metaproperties for Git author/committer information.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"email\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"date\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"description\": \"The git author's email address.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"email\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The git author's name.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"username\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Committer {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub date: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "The git author's email address."]
    pub email: ::std::option::Option<::std::string::String>,
    #[doc = "The git author's name."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub username: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Committer> for Committer {
    fn from(value: &Committer) -> Self {
        value.clone()
    }
}
#[doc = "`ContentReferenceCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"content_reference created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"installation\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content_reference\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"reference\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"reference\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreated {
    pub action: ContentReferenceCreatedAction,
    pub content_reference: ContentReferenceCreatedContentReference,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ContentReferenceCreated> for ContentReferenceCreated {
    fn from(value: &ContentReferenceCreated) -> Self {
        value.clone()
    }
}
#[doc = "`ContentReferenceCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContentReferenceCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for ContentReferenceCreatedAction {
    fn from(value: &ContentReferenceCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContentReferenceCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for ContentReferenceCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContentReferenceCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContentReferenceCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContentReferenceCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContentReferenceCreatedContentReference`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"reference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"reference\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ContentReferenceCreatedContentReference {
    pub id: i64,
    pub node_id: ::std::string::String,
    pub reference: ::std::string::String,
}
impl ::std::convert::From<&ContentReferenceCreatedContentReference>
    for ContentReferenceCreatedContentReference
{
    fn from(value: &ContentReferenceCreatedContentReference) -> Self {
        value.clone()
    }
}
#[doc = "`ContentReferenceEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/content_reference$created\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ContentReferenceEvent(pub ContentReferenceCreated);
impl ::std::ops::Deref for ContentReferenceEvent {
    type Target = ContentReferenceCreated;
    fn deref(&self) -> &ContentReferenceCreated {
        &self.0
    }
}
impl ::std::convert::From<ContentReferenceEvent> for ContentReferenceCreated {
    fn from(value: ContentReferenceEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ContentReferenceEvent> for ContentReferenceEvent {
    fn from(value: &ContentReferenceEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ContentReferenceCreated> for ContentReferenceEvent {
    fn from(value: ContentReferenceCreated) -> Self {
        Self(value)
    }
}
#[doc = "A Git branch or tag is created."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"create event\","]
#[doc = "  \"description\": \"A Git branch or tag is created.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"master_branch\","]
#[doc = "    \"pusher_type\","]
#[doc = "    \"ref\","]
#[doc = "    \"ref_type\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"The repository's current description.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"master_branch\": {"]
#[doc = "      \"description\": \"The name of the repository's default branch (usually `main`).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pusher_type\": {"]
#[doc = "      \"description\": \"The pusher type for the event. Can be either `user` or a deploy key.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref_type\": {"]
#[doc = "      \"description\": \"The type of Git ref object created in the repository. Can be either `branch` or `tag`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"tag\","]
#[doc = "        \"branch\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CreateEvent {
    #[doc = "The repository's current description."]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The name of the repository's default branch (usually `main`)."]
    pub master_branch: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: ::std::string::String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    #[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
    pub ref_type: CreateEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&CreateEvent> for CreateEvent {
    fn from(value: &CreateEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object created in the repository. Can be either `branch` or `tag`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The type of Git ref object created in the repository. Can be either `branch` or `tag`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"tag\","]
#[doc = "    \"branch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CreateEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl ::std::convert::From<&Self> for CreateEventRefType {
    fn from(value: &CreateEventRefType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CreateEventRefType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Tag => write!(f, "tag"),
            Self::Branch => write!(f, "branch"),
        }
    }
}
impl ::std::str::FromStr for CreateEventRefType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CreateEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CreateEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CreateEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Git branch or tag is deleted."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"delete event\","]
#[doc = "  \"description\": \"A Git branch or tag is deleted.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"pusher_type\","]
#[doc = "    \"ref\","]
#[doc = "    \"ref_type\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pusher_type\": {"]
#[doc = "      \"description\": \"The pusher type for the event. Can be either `user` or a deploy key.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref_type\": {"]
#[doc = "      \"description\": \"The type of Git ref object deleted in the repository. Can be either `branch` or `tag`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"tag\","]
#[doc = "        \"branch\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeleteEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The pusher type for the event. Can be either `user` or a deploy key."]
    pub pusher_type: ::std::string::String,
    #[doc = "The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    #[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
    pub ref_type: DeleteEventRefType,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DeleteEvent> for DeleteEvent {
    fn from(value: &DeleteEvent) -> Self {
        value.clone()
    }
}
#[doc = "The type of Git ref object deleted in the repository. Can be either `branch` or `tag`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The type of Git ref object deleted in the repository. Can be either `branch` or `tag`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"tag\","]
#[doc = "    \"branch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DeleteEventRefType {
    #[serde(rename = "tag")]
    Tag,
    #[serde(rename = "branch")]
    Branch,
}
impl ::std::convert::From<&Self> for DeleteEventRefType {
    fn from(value: &DeleteEventRefType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DeleteEventRefType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Tag => write!(f, "tag"),
            Self::Branch => write!(f, "branch"),
        }
    }
}
impl ::std::str::FromStr for DeleteEventRefType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tag" => Ok(Self::Tag),
            "branch" => Ok(Self::Branch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DeleteEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DeleteEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DeleteEventRefType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DeployKeyCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"deploy_key created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"key\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"id\","]
#[doc = "        \"key\","]
#[doc = "        \"read_only\","]
#[doc = "        \"title\","]
#[doc = "        \"url\","]
#[doc = "        \"verified\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"key\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"read_only\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"verified\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreated {
    pub action: DeployKeyCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub key: DeployKeyCreatedKey,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DeployKeyCreated> for DeployKeyCreated {
    fn from(value: &DeployKeyCreated) -> Self {
        value.clone()
    }
}
#[doc = "`DeployKeyCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DeployKeyCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for DeployKeyCreatedAction {
    fn from(value: &DeployKeyCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DeployKeyCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for DeployKeyCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DeployKeyCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DeployKeyCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DeployKeyCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"id\","]
#[doc = "    \"key\","]
#[doc = "    \"read_only\","]
#[doc = "    \"title\","]
#[doc = "    \"url\","]
#[doc = "    \"verified\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"read_only\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"verified\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreatedKey {
    pub created_at: ::std::string::String,
    pub id: i64,
    pub key: ::std::string::String,
    pub read_only: bool,
    pub title: ::std::string::String,
    pub url: ::std::string::String,
    pub verified: bool,
}
impl ::std::convert::From<&DeployKeyCreatedKey> for DeployKeyCreatedKey {
    fn from(value: &DeployKeyCreatedKey) -> Self {
        value.clone()
    }
}
#[doc = "`DeployKeyDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"deploy_key deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"key\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"id\","]
#[doc = "        \"key\","]
#[doc = "        \"read_only\","]
#[doc = "        \"title\","]
#[doc = "        \"url\","]
#[doc = "        \"verified\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"key\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"read_only\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"verified\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeleted {
    pub action: DeployKeyDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub key: DeployKeyDeletedKey,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DeployKeyDeleted> for DeployKeyDeleted {
    fn from(value: &DeployKeyDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`DeployKeyDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DeployKeyDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for DeployKeyDeletedAction {
    fn from(value: &DeployKeyDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DeployKeyDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for DeployKeyDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DeployKeyDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DeployKeyDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DeployKeyDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"id\","]
#[doc = "    \"key\","]
#[doc = "    \"read_only\","]
#[doc = "    \"title\","]
#[doc = "    \"url\","]
#[doc = "    \"verified\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"read_only\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"verified\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeletedKey {
    pub created_at: ::std::string::String,
    pub id: i64,
    pub key: ::std::string::String,
    pub read_only: bool,
    pub title: ::std::string::String,
    pub url: ::std::string::String,
    pub verified: bool,
}
impl ::std::convert::From<&DeployKeyDeletedKey> for DeployKeyDeletedKey {
    fn from(value: &DeployKeyDeletedKey) -> Self {
        value.clone()
    }
}
#[doc = "`DeployKeyEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deploy_key$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deploy_key$deleted\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DeployKeyEvent {
    Created(DeployKeyCreated),
    Deleted(DeployKeyDeleted),
}
impl ::std::convert::From<&Self> for DeployKeyEvent {
    fn from(value: &DeployKeyEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DeployKeyCreated> for DeployKeyEvent {
    fn from(value: DeployKeyCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<DeployKeyDeleted> for DeployKeyEvent {
    fn from(value: DeployKeyDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[doc = "`DeploymentCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"deployment created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"deployment\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"creator\","]
#[doc = "        \"description\","]
#[doc = "        \"environment\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"original_environment\","]
#[doc = "        \"payload\","]
#[doc = "        \"ref\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"sha\","]
#[doc = "        \"statuses_url\","]
#[doc = "        \"task\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"creator\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"environment\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"original_environment\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"payload\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"performed_via_github_app\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"statuses_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"task\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"workflow_run\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreated {
    pub action: DeploymentCreatedAction,
    pub deployment: DeploymentCreatedDeployment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: (),
    pub workflow_run: (),
}
impl ::std::convert::From<&DeploymentCreated> for DeploymentCreated {
    fn from(value: &DeploymentCreated) -> Self {
        value.clone()
    }
}
#[doc = "`DeploymentCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DeploymentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for DeploymentCreatedAction {
    fn from(value: &DeploymentCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DeploymentCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for DeploymentCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DeploymentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DeploymentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DeploymentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"description\","]
#[doc = "    \"environment\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"original_environment\","]
#[doc = "    \"payload\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"sha\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"task\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"original_environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"payload\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"performed_via_github_app\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeployment {
    pub created_at: ::std::string::String,
    pub creator: User,
    pub description: (),
    pub environment: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub original_environment: ::std::string::String,
    pub payload: DeploymentCreatedDeploymentPayload,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository_url: ::std::string::String,
    pub sha: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub task: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&DeploymentCreatedDeployment> for DeploymentCreatedDeployment {
    fn from(value: &DeploymentCreatedDeployment) -> Self {
        value.clone()
    }
}
#[doc = "`DeploymentCreatedDeploymentPayload`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreatedDeploymentPayload {}
impl ::std::convert::From<&DeploymentCreatedDeploymentPayload>
    for DeploymentCreatedDeploymentPayload
{
    fn from(value: &DeploymentCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DeploymentCreatedDeploymentPayload {
    fn default() -> Self {
        Self {}
    }
}
#[doc = "`DeploymentEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deployment$created\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct DeploymentEvent(pub DeploymentCreated);
impl ::std::ops::Deref for DeploymentEvent {
    type Target = DeploymentCreated;
    fn deref(&self) -> &DeploymentCreated {
        &self.0
    }
}
impl ::std::convert::From<DeploymentEvent> for DeploymentCreated {
    fn from(value: DeploymentEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DeploymentEvent> for DeploymentEvent {
    fn from(value: &DeploymentEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DeploymentCreated> for DeploymentEvent {
    fn from(value: DeploymentCreated) -> Self {
        Self(value)
    }
}
#[doc = "`DeploymentStatusCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"deployment_status created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployment\": {"]
#[doc = "      \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"creator\","]
#[doc = "        \"description\","]
#[doc = "        \"environment\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"original_environment\","]
#[doc = "        \"payload\","]
#[doc = "        \"performed_via_github_app\","]
#[doc = "        \"ref\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"sha\","]
#[doc = "        \"statuses_url\","]
#[doc = "        \"task\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"creator\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"environment\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"original_environment\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"payload\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"performed_via_github_app\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"statuses_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"task\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"deployment_status\": {"]
#[doc = "      \"description\": \"The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"creator\","]
#[doc = "        \"deployment_url\","]
#[doc = "        \"description\","]
#[doc = "        \"environment\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"state\","]
#[doc = "        \"target_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"creator\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"deployment_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"The optional human-readable description added to the status.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"environment\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"performed_via_github_app\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/app\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_url\": {"]
#[doc = "          \"description\": \"The optional link added to the status.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreated {
    pub action: DeploymentStatusCreatedAction,
    pub deployment: DeploymentStatusCreatedDeployment,
    pub deployment_status: DeploymentStatusCreatedDeploymentStatus,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DeploymentStatusCreated> for DeploymentStatusCreated {
    fn from(value: &DeploymentStatusCreated) -> Self {
        value.clone()
    }
}
#[doc = "`DeploymentStatusCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DeploymentStatusCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for DeploymentStatusCreatedAction {
    fn from(value: &DeploymentStatusCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DeploymentStatusCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for DeploymentStatusCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DeploymentStatusCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DeploymentStatusCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DeploymentStatusCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"description\","]
#[doc = "    \"environment\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"original_environment\","]
#[doc = "    \"payload\","]
#[doc = "    \"performed_via_github_app\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"sha\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"task\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"original_environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"payload\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"performed_via_github_app\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeployment {
    pub created_at: ::std::string::String,
    pub creator: User,
    pub description: (),
    pub environment: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub original_environment: ::std::string::String,
    pub payload: DeploymentStatusCreatedDeploymentPayload,
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository_url: ::std::string::String,
    pub sha: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub task: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&DeploymentStatusCreatedDeployment>
    for DeploymentStatusCreatedDeployment
{
    fn from(value: &DeploymentStatusCreatedDeployment) -> Self {
        value.clone()
    }
}
#[doc = "`DeploymentStatusCreatedDeploymentPayload`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentPayload {}
impl ::std::convert::From<&DeploymentStatusCreatedDeploymentPayload>
    for DeploymentStatusCreatedDeploymentPayload
{
    fn from(value: &DeploymentStatusCreatedDeploymentPayload) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DeploymentStatusCreatedDeploymentPayload {
    fn default() -> Self {
        Self {}
    }
}
#[doc = "The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"deployment_url\","]
#[doc = "    \"description\","]
#[doc = "    \"environment\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"state\","]
#[doc = "    \"target_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"deployment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"The optional human-readable description added to the status.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"performed_via_github_app\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_url\": {"]
#[doc = "      \"description\": \"The optional link added to the status.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentStatus {
    pub created_at: ::std::string::String,
    pub creator: User,
    pub deployment_url: ::std::string::String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: ::std::string::String,
    pub environment: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    pub repository_url: ::std::string::String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: ::std::string::String,
    #[doc = "The optional link added to the status."]
    pub target_url: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&DeploymentStatusCreatedDeploymentStatus>
    for DeploymentStatusCreatedDeploymentStatus
{
    fn from(value: &DeploymentStatusCreatedDeploymentStatus) -> Self {
        value.clone()
    }
}
#[doc = "`DeploymentStatusEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deployment_status$created\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct DeploymentStatusEvent(pub DeploymentStatusCreated);
impl ::std::ops::Deref for DeploymentStatusEvent {
    type Target = DeploymentStatusCreated;
    fn deref(&self) -> &DeploymentStatusCreated {
        &self.0
    }
}
impl ::std::convert::From<DeploymentStatusEvent> for DeploymentStatusCreated {
    fn from(value: DeploymentStatusEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DeploymentStatusEvent> for DeploymentStatusEvent {
    fn from(value: &DeploymentStatusEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DeploymentStatusCreated> for DeploymentStatusEvent {
    fn from(value: DeploymentStatusCreated) -> Self {
        Self(value)
    }
}
#[doc = "`Discussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Discussion\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"answer_chosen_at\","]
#[doc = "    \"answer_chosen_by\","]
#[doc = "    \"answer_html_url\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"category\","]
#[doc = "    \"comments\","]
#[doc = "    \"created_at\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"locked\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"state\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"answer_chosen_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"answer_chosen_by\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"answer_html_url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"category\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"emoji\","]
#[doc = "        \"id\","]
#[doc = "        \"is_answerable\","]
#[doc = "        \"name\","]
#[doc = "        \"repository_id\","]
#[doc = "        \"slug\","]
#[doc = "        \"updated_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"emoji\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"is_answerable\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repository_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"slug\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"comments\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"locked\","]
#[doc = "        \"converting\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Discussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: ::std::option::Option<::std::string::String>,
    pub answer_chosen_by: ::std::option::Option<User>,
    pub answer_html_url: ::std::option::Option<::std::string::String>,
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&Discussion> for Discussion {
    fn from(value: &Discussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnswered`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion answered event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"answer\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"answered\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"answer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"child_comment_count\","]
#[doc = "        \"created_at\","]
#[doc = "        \"discussion_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parent_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"child_comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"discussion_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parent_id\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"answer_chosen_at\","]
#[doc = "            \"answer_chosen_by\","]
#[doc = "            \"answer_html_url\","]
#[doc = "            \"category\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"answer_chosen_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"answer_chosen_by\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            \"answer_html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"category\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"is_answerable\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"is_answerable\": {"]
#[doc = "                  \"type\": \"boolean\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    true"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"tsAdditionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnswered {
    pub action: DiscussionAnsweredAction,
    pub answer: DiscussionAnsweredAnswer,
    pub discussion: DiscussionAnsweredDiscussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionAnswered> for DiscussionAnswered {
    fn from(value: &DiscussionAnswered) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnsweredAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"answered\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionAnsweredAction {
    #[serde(rename = "answered")]
    Answered,
}
impl ::std::convert::From<&Self> for DiscussionAnsweredAction {
    fn from(value: &DiscussionAnsweredAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionAnsweredAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Answered => write!(f, "answered"),
        }
    }
}
impl ::std::str::FromStr for DiscussionAnsweredAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "answered" => Ok(Self::Answered),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionAnsweredAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionAnsweredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionAnsweredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionAnsweredAnswer`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"child_comment_count\","]
#[doc = "    \"created_at\","]
#[doc = "    \"discussion_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parent_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"child_comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"discussion_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent_id\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredAnswer {
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub child_comment_count: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub parent_id: (),
    pub repository_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionAnsweredAnswer> for DiscussionAnsweredAnswer {
    fn from(value: &DiscussionAnsweredAnswer) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnsweredDiscussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"answer_chosen_at\","]
#[doc = "        \"answer_chosen_by\","]
#[doc = "        \"answer_html_url\","]
#[doc = "        \"category\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"answer_chosen_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"answer_chosen_by\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"answer_html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"category\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"is_answerable\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"is_answerable\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub answer_chosen_by: DiscussionAnsweredDiscussionAnswerChosenBy,
    pub answer_html_url: ::std::string::String,
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionAnsweredDiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionAnsweredDiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionAnsweredDiscussion> for DiscussionAnsweredDiscussion {
    fn from(value: &DiscussionAnsweredDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnsweredDiscussionAnswerChosenBy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"node_id\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"Bot\","]
#[doc = "            \"User\","]
#[doc = "            \"Organization\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussionAnswerChosenBy {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: DiscussionAnsweredDiscussionAnswerChosenByType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&DiscussionAnsweredDiscussionAnswerChosenBy>
    for DiscussionAnsweredDiscussionAnswerChosenBy
{
    fn from(value: &DiscussionAnsweredDiscussionAnswerChosenBy) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnsweredDiscussionAnswerChosenByType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionAnsweredDiscussionAnswerChosenByType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for DiscussionAnsweredDiscussionAnswerChosenByType {
    fn from(value: &DiscussionAnsweredDiscussionAnswerChosenByType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionAnsweredDiscussionAnswerChosenByType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionAnsweredDiscussionAnswerChosenByType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DiscussionAnsweredDiscussionAnswerChosenByType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DiscussionAnsweredDiscussionAnswerChosenByType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionAnsweredDiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\","]
#[doc = "      \"enum\": ["]
#[doc = "        true"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredDiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionAnsweredDiscussionCategory>
    for DiscussionAnsweredDiscussionCategory
{
    fn from(value: &DiscussionAnsweredDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionAnsweredDiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"locked\","]
#[doc = "    \"converting\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionAnsweredDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl ::std::convert::From<&Self> for DiscussionAnsweredDiscussionState {
    fn from(value: &DiscussionAnsweredDiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionAnsweredDiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Locked => write!(f, "locked"),
            Self::Converting => write!(f, "converting"),
        }
    }
}
impl ::std::str::FromStr for DiscussionAnsweredDiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionAnsweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionAnsweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionAnsweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionCategory> for DiscussionCategory {
    fn from(value: &DiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCategoryChanged`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion category changed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"category_changed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"category\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"category\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"created_at\","]
#[doc = "                \"description\","]
#[doc = "                \"emoji\","]
#[doc = "                \"id\","]
#[doc = "                \"is_answerable\","]
#[doc = "                \"name\","]
#[doc = "                \"repository_id\","]
#[doc = "                \"slug\","]
#[doc = "                \"updated_at\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"created_at\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"date-time\""]
#[doc = "                },"]
#[doc = "                \"description\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"emoji\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"id\": {"]
#[doc = "                  \"type\": \"integer\""]
#[doc = "                },"]
#[doc = "                \"is_answerable\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"name\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"repository_id\": {"]
#[doc = "                  \"type\": \"integer\""]
#[doc = "                },"]
#[doc = "                \"slug\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"updated_at\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChanged {
    pub action: DiscussionCategoryChangedAction,
    pub changes: DiscussionCategoryChangedChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionCategoryChanged> for DiscussionCategoryChanged {
    fn from(value: &DiscussionCategoryChanged) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCategoryChangedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"category_changed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCategoryChangedAction {
    #[serde(rename = "category_changed")]
    CategoryChanged,
}
impl ::std::convert::From<&Self> for DiscussionCategoryChangedAction {
    fn from(value: &DiscussionCategoryChangedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCategoryChangedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CategoryChanged => write!(f, "category_changed"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCategoryChangedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "category_changed" => Ok(Self::CategoryChanged),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCategoryChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCategoryChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCategoryChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCategoryChangedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"category\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"category\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"created_at\","]
#[doc = "            \"description\","]
#[doc = "            \"emoji\","]
#[doc = "            \"id\","]
#[doc = "            \"is_answerable\","]
#[doc = "            \"name\","]
#[doc = "            \"repository_id\","]
#[doc = "            \"slug\","]
#[doc = "            \"updated_at\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"emoji\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"is_answerable\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repository_id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"slug\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChanges {
    pub category: DiscussionCategoryChangedChangesCategory,
}
impl ::std::convert::From<&DiscussionCategoryChangedChanges> for DiscussionCategoryChangedChanges {
    fn from(value: &DiscussionCategoryChangedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCategoryChangedChangesCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"emoji\","]
#[doc = "        \"id\","]
#[doc = "        \"is_answerable\","]
#[doc = "        \"name\","]
#[doc = "        \"repository_id\","]
#[doc = "        \"slug\","]
#[doc = "        \"updated_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"emoji\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"is_answerable\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repository_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"slug\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategory {
    pub from: DiscussionCategoryChangedChangesCategoryFrom,
}
impl ::std::convert::From<&DiscussionCategoryChangedChangesCategory>
    for DiscussionCategoryChangedChangesCategory
{
    fn from(value: &DiscussionCategoryChangedChangesCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCategoryChangedChangesCategoryFrom`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategoryFrom {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionCategoryChangedChangesCategoryFrom>
    for DiscussionCategoryChangedChangesCategoryFrom
{
    fn from(value: &DiscussionCategoryChangedChangesCategoryFrom) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion_comment created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"discussion\","]
#[doc = "    \"installation\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"child_comment_count\","]
#[doc = "        \"created_at\","]
#[doc = "        \"discussion_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parent_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"child_comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"discussion_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parent_id\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"integer\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreated {
    pub action: DiscussionCommentCreatedAction,
    pub comment: DiscussionCommentCreatedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionCommentCreated> for DiscussionCommentCreated {
    fn from(value: &DiscussionCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for DiscussionCommentCreatedAction {
    fn from(value: &DiscussionCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCommentCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCommentCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCommentCreatedComment`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"child_comment_count\","]
#[doc = "    \"created_at\","]
#[doc = "    \"discussion_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parent_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"child_comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"discussion_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent_id\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreatedComment {
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub child_comment_count: i64,
    pub created_at: ::std::string::String,
    pub discussion_id: i64,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub parent_id: ::std::option::Option<i64>,
    pub repository_url: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&DiscussionCommentCreatedComment> for DiscussionCommentCreatedComment {
    fn from(value: &DiscussionCommentCreatedComment) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion_comment deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"discussion\","]
#[doc = "    \"installation\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"child_comment_count\","]
#[doc = "        \"created_at\","]
#[doc = "        \"discussion_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parent_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"child_comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"discussion_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parent_id\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"integer\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeleted {
    pub action: DiscussionCommentDeletedAction,
    pub comment: DiscussionCommentDeletedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionCommentDeleted> for DiscussionCommentDeleted {
    fn from(value: &DiscussionCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for DiscussionCommentDeletedAction {
    fn from(value: &DiscussionCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCommentDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCommentDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCommentDeletedComment`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"child_comment_count\","]
#[doc = "    \"created_at\","]
#[doc = "    \"discussion_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parent_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"child_comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"discussion_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent_id\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeletedComment {
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub child_comment_count: i64,
    pub created_at: ::std::string::String,
    pub discussion_id: i64,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub parent_id: ::std::option::Option<i64>,
    pub repository_url: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&DiscussionCommentDeletedComment> for DiscussionCommentDeletedComment {
    fn from(value: &DiscussionCommentDeletedComment) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion_comment edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"comment\","]
#[doc = "    \"discussion\","]
#[doc = "    \"installation\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"body\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"child_comment_count\","]
#[doc = "        \"created_at\","]
#[doc = "        \"discussion_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parent_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"child_comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"discussion_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parent_id\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"integer\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEdited {
    pub action: DiscussionCommentEditedAction,
    pub changes: DiscussionCommentEditedChanges,
    pub comment: DiscussionCommentEditedComment,
    pub discussion: Discussion,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionCommentEdited> for DiscussionCommentEdited {
    fn from(value: &DiscussionCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for DiscussionCommentEditedAction {
    fn from(value: &DiscussionCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCommentEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCommentEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCommentEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"body\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChanges {
    pub body: DiscussionCommentEditedChangesBody,
}
impl ::std::convert::From<&DiscussionCommentEditedChanges> for DiscussionCommentEditedChanges {
    fn from(value: &DiscussionCommentEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChangesBody {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&DiscussionCommentEditedChangesBody>
    for DiscussionCommentEditedChangesBody
{
    fn from(value: &DiscussionCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentEditedComment`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"child_comment_count\","]
#[doc = "    \"created_at\","]
#[doc = "    \"discussion_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parent_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"child_comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"discussion_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent_id\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedComment {
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub child_comment_count: i64,
    pub created_at: ::std::string::String,
    pub discussion_id: i64,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub parent_id: ::std::option::Option<i64>,
    pub repository_url: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&DiscussionCommentEditedComment> for DiscussionCommentEditedComment {
    fn from(value: &DiscussionCommentEditedComment) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCommentEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion_comment$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion_comment$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion_comment$edited\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DiscussionCommentEvent {
    Created(DiscussionCommentCreated),
    Deleted(DiscussionCommentDeleted),
    Edited(DiscussionCommentEdited),
}
impl ::std::convert::From<&Self> for DiscussionCommentEvent {
    fn from(value: &DiscussionCommentEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DiscussionCommentCreated> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<DiscussionCommentDeleted> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<DiscussionCommentEdited> for DiscussionCommentEvent {
    fn from(value: DiscussionCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "`DiscussionCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"answer_chosen_at\","]
#[doc = "            \"answer_chosen_by\","]
#[doc = "            \"answer_html_url\","]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"answer_chosen_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"answer_chosen_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"answer_html_url\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\","]
#[doc = "                \"converting\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreated {
    pub action: DiscussionCreatedAction,
    pub discussion: DiscussionCreatedDiscussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionCreated> for DiscussionCreated {
    fn from(value: &DiscussionCreated) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for DiscussionCreatedAction {
    fn from(value: &DiscussionCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionCreatedDiscussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"answer_chosen_at\","]
#[doc = "        \"answer_chosen_by\","]
#[doc = "        \"answer_html_url\","]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"answer_chosen_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"answer_chosen_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"answer_html_url\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"converting\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreatedDiscussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: (),
    pub answer_chosen_by: (),
    pub answer_html_url: (),
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionCreatedDiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionCreatedDiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionCreatedDiscussion> for DiscussionCreatedDiscussion {
    fn from(value: &DiscussionCreatedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCreatedDiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreatedDiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionCreatedDiscussionCategory>
    for DiscussionCreatedDiscussionCategory
{
    fn from(value: &DiscussionCreatedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionCreatedDiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"converting\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionCreatedDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "converting")]
    Converting,
}
impl ::std::convert::From<&Self> for DiscussionCreatedDiscussionState {
    fn from(value: &DiscussionCreatedDiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionCreatedDiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Converting => write!(f, "converting"),
        }
    }
}
impl ::std::str::FromStr for DiscussionCreatedDiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionCreatedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionCreatedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionCreatedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionDeleted {
    pub action: DiscussionDeletedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionDeleted> for DiscussionDeleted {
    fn from(value: &DiscussionDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for DiscussionDeletedAction {
    fn from(value: &DiscussionDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for DiscussionDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEdited {
    pub action: DiscussionEditedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub changes: ::std::option::Option<DiscussionEditedChanges>,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionEdited> for DiscussionEdited {
    fn from(value: &DiscussionEdited) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for DiscussionEditedAction {
    fn from(value: &DiscussionEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for DiscussionEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<DiscussionEditedChangesBody>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<DiscussionEditedChangesTitle>,
}
impl ::std::convert::From<&DiscussionEditedChanges> for DiscussionEditedChanges {
    fn from(value: &DiscussionEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DiscussionEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`DiscussionEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesBody {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&DiscussionEditedChangesBody> for DiscussionEditedChangesBody {
    fn from(value: &DiscussionEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionEditedChangesTitle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesTitle {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&DiscussionEditedChangesTitle> for DiscussionEditedChangesTitle {
    fn from(value: &DiscussionEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$answered\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$category_changed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$labeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$locked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$pinned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$transferred\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$unanswered\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$unlabeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$unlocked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion$unpinned\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DiscussionEvent {
    Answered(DiscussionAnswered),
    CategoryChanged(DiscussionCategoryChanged),
    Created(DiscussionCreated),
    Deleted(DiscussionDeleted),
    Edited(DiscussionEdited),
    Labeled(DiscussionLabeled),
    Locked(DiscussionLocked),
    Pinned(DiscussionPinned),
    Transferred(DiscussionTransferred),
    Unanswered(DiscussionUnanswered),
    Unlabeled(DiscussionUnlabeled),
    Unlocked(DiscussionUnlocked),
    Unpinned(DiscussionUnpinned),
}
impl ::std::convert::From<&Self> for DiscussionEvent {
    fn from(value: &DiscussionEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DiscussionAnswered> for DiscussionEvent {
    fn from(value: DiscussionAnswered) -> Self {
        Self::Answered(value)
    }
}
impl ::std::convert::From<DiscussionCategoryChanged> for DiscussionEvent {
    fn from(value: DiscussionCategoryChanged) -> Self {
        Self::CategoryChanged(value)
    }
}
impl ::std::convert::From<DiscussionCreated> for DiscussionEvent {
    fn from(value: DiscussionCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<DiscussionDeleted> for DiscussionEvent {
    fn from(value: DiscussionDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<DiscussionEdited> for DiscussionEvent {
    fn from(value: DiscussionEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<DiscussionLabeled> for DiscussionEvent {
    fn from(value: DiscussionLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl ::std::convert::From<DiscussionLocked> for DiscussionEvent {
    fn from(value: DiscussionLocked) -> Self {
        Self::Locked(value)
    }
}
impl ::std::convert::From<DiscussionPinned> for DiscussionEvent {
    fn from(value: DiscussionPinned) -> Self {
        Self::Pinned(value)
    }
}
impl ::std::convert::From<DiscussionTransferred> for DiscussionEvent {
    fn from(value: DiscussionTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl ::std::convert::From<DiscussionUnanswered> for DiscussionEvent {
    fn from(value: DiscussionUnanswered) -> Self {
        Self::Unanswered(value)
    }
}
impl ::std::convert::From<DiscussionUnlabeled> for DiscussionEvent {
    fn from(value: DiscussionUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl ::std::convert::From<DiscussionUnlocked> for DiscussionEvent {
    fn from(value: DiscussionUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl ::std::convert::From<DiscussionUnpinned> for DiscussionEvent {
    fn from(value: DiscussionUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[doc = "`DiscussionLabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion labeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"label\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"labeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLabeled {
    pub action: DiscussionLabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionLabeled> for DiscussionLabeled {
    fn from(value: &DiscussionLabeled) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionLabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"labeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl ::std::convert::From<&Self> for DiscussionLabeledAction {
    fn from(value: &DiscussionLabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionLabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Labeled => write!(f, "labeled"),
        }
    }
}
impl ::std::str::FromStr for DiscussionLabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionLocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion locked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"locked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"locked\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLocked {
    pub action: DiscussionLockedAction,
    pub discussion: DiscussionLockedDiscussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionLocked> for DiscussionLocked {
    fn from(value: &DiscussionLocked) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionLockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"locked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl ::std::convert::From<&Self> for DiscussionLockedAction {
    fn from(value: &DiscussionLockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionLockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Locked => write!(f, "locked"),
        }
    }
}
impl ::std::str::FromStr for DiscussionLockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionLockedDiscussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"locked\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLockedDiscussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: ::std::option::Option<::std::string::String>,
    pub answer_chosen_by: ::std::option::Option<User>,
    pub answer_html_url: ::std::option::Option<::std::string::String>,
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionLockedDiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionLockedDiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionLockedDiscussion> for DiscussionLockedDiscussion {
    fn from(value: &DiscussionLockedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionLockedDiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLockedDiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionLockedDiscussionCategory>
    for DiscussionLockedDiscussionCategory
{
    fn from(value: &DiscussionLockedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionLockedDiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"locked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionLockedDiscussionState {
    #[serde(rename = "locked")]
    Locked,
}
impl ::std::convert::From<&Self> for DiscussionLockedDiscussionState {
    fn from(value: &DiscussionLockedDiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionLockedDiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Locked => write!(f, "locked"),
        }
    }
}
impl ::std::str::FromStr for DiscussionLockedDiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionLockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionLockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionLockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionPinned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion pinned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pinned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionPinned {
    pub action: DiscussionPinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionPinned> for DiscussionPinned {
    fn from(value: &DiscussionPinned) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionPinnedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pinned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl ::std::convert::From<&Self> for DiscussionPinnedAction {
    fn from(value: &DiscussionPinnedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionPinnedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pinned => write!(f, "pinned"),
        }
    }
}
impl ::std::str::FromStr for DiscussionPinnedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"locked\","]
#[doc = "    \"converting\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl ::std::convert::From<&Self> for DiscussionState {
    fn from(value: &DiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Locked => write!(f, "locked"),
            Self::Converting => write!(f, "converting"),
        }
    }
}
impl ::std::str::FromStr for DiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionTransferred`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion transferred event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"transferred\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"new_discussion\","]
#[doc = "        \"new_repository\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"new_discussion\": {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        \"new_repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferred {
    pub action: DiscussionTransferredAction,
    pub changes: DiscussionTransferredChanges,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionTransferred> for DiscussionTransferred {
    fn from(value: &DiscussionTransferred) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionTransferredAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"transferred\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl ::std::convert::From<&Self> for DiscussionTransferredAction {
    fn from(value: &DiscussionTransferredAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionTransferredAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Transferred => write!(f, "transferred"),
        }
    }
}
impl ::std::str::FromStr for DiscussionTransferredAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionTransferredChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"new_discussion\","]
#[doc = "    \"new_repository\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"new_discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"new_repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferredChanges {
    pub new_discussion: Discussion,
    pub new_repository: Repository,
}
impl ::std::convert::From<&DiscussionTransferredChanges> for DiscussionTransferredChanges {
    fn from(value: &DiscussionTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnanswered`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion unanswered event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"old_answer\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unanswered\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"answer_chosen_at\","]
#[doc = "            \"answer_chosen_by\","]
#[doc = "            \"answer_html_url\","]
#[doc = "            \"category\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"answer_chosen_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"answer_chosen_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"answer_html_url\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"category\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"is_answerable\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"is_answerable\": {"]
#[doc = "                  \"type\": \"boolean\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    true"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"tsAdditionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"old_answer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"child_comment_count\","]
#[doc = "        \"created_at\","]
#[doc = "        \"discussion_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parent_id\","]
#[doc = "        \"repository_url\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"child_comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"discussion_id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parent_id\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"repository_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnanswered {
    pub action: DiscussionUnansweredAction,
    pub discussion: DiscussionUnansweredDiscussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub old_answer: DiscussionUnansweredOldAnswer,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionUnanswered> for DiscussionUnanswered {
    fn from(value: &DiscussionUnanswered) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnansweredAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unanswered\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnansweredAction {
    #[serde(rename = "unanswered")]
    Unanswered,
}
impl ::std::convert::From<&Self> for DiscussionUnansweredAction {
    fn from(value: &DiscussionUnansweredAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnansweredAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unanswered => write!(f, "unanswered"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnansweredAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unanswered" => Ok(Self::Unanswered),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnansweredAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnansweredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnansweredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionUnansweredDiscussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"answer_chosen_at\","]
#[doc = "        \"answer_chosen_by\","]
#[doc = "        \"answer_html_url\","]
#[doc = "        \"category\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"answer_chosen_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"answer_chosen_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"answer_html_url\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"category\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"is_answerable\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"is_answerable\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredDiscussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: (),
    pub answer_chosen_by: (),
    pub answer_html_url: (),
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionUnansweredDiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionUnansweredDiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionUnansweredDiscussion> for DiscussionUnansweredDiscussion {
    fn from(value: &DiscussionUnansweredDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnansweredDiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\","]
#[doc = "      \"enum\": ["]
#[doc = "        true"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredDiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionUnansweredDiscussionCategory>
    for DiscussionUnansweredDiscussionCategory
{
    fn from(value: &DiscussionUnansweredDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnansweredDiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"locked\","]
#[doc = "    \"converting\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnansweredDiscussionState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "locked")]
    Locked,
    #[serde(rename = "converting")]
    Converting,
}
impl ::std::convert::From<&Self> for DiscussionUnansweredDiscussionState {
    fn from(value: &DiscussionUnansweredDiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnansweredDiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Locked => write!(f, "locked"),
            Self::Converting => write!(f, "converting"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnansweredDiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "locked" => Ok(Self::Locked),
            "converting" => Ok(Self::Converting),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnansweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnansweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnansweredDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionUnansweredOldAnswer`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"child_comment_count\","]
#[doc = "    \"created_at\","]
#[doc = "    \"discussion_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parent_id\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"child_comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"discussion_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent_id\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredOldAnswer {
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub child_comment_count: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub discussion_id: i64,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub node_id: ::std::string::String,
    pub parent_id: (),
    pub repository_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionUnansweredOldAnswer> for DiscussionUnansweredOldAnswer {
    fn from(value: &DiscussionUnansweredOldAnswer) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnlabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion unlabeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"label\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlabeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlabeled {
    pub action: DiscussionUnlabeledAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub label: Label,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionUnlabeled> for DiscussionUnlabeled {
    fn from(value: &DiscussionUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnlabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlabeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ::std::convert::From<&Self> for DiscussionUnlabeledAction {
    fn from(value: &DiscussionUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnlabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlabeled => write!(f, "unlabeled"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnlabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionUnlocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion unlocked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlocked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/discussion\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlocked {
    pub action: DiscussionUnlockedAction,
    pub discussion: DiscussionUnlockedDiscussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionUnlocked> for DiscussionUnlocked {
    fn from(value: &DiscussionUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnlockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlocked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ::std::convert::From<&Self> for DiscussionUnlockedAction {
    fn from(value: &DiscussionUnlockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnlockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlocked => write!(f, "unlocked"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnlockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionUnlockedDiscussion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlockedDiscussion {
    pub active_lock_reason: ::std::option::Option<::std::string::String>,
    pub answer_chosen_at: ::std::option::Option<::std::string::String>,
    pub answer_chosen_by: ::std::option::Option<User>,
    pub answer_html_url: ::std::option::Option<::std::string::String>,
    pub author_association: AuthorAssociation,
    pub body: ::std::string::String,
    pub category: DiscussionUnlockedDiscussionCategory,
    pub comments: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub locked: bool,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub repository_url: ::std::string::String,
    pub state: DiscussionUnlockedDiscussionState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&DiscussionUnlockedDiscussion> for DiscussionUnlockedDiscussion {
    fn from(value: &DiscussionUnlockedDiscussion) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnlockedDiscussionCategory`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"emoji\","]
#[doc = "    \"id\","]
#[doc = "    \"is_answerable\","]
#[doc = "    \"name\","]
#[doc = "    \"repository_id\","]
#[doc = "    \"slug\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"emoji\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"is_answerable\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlockedDiscussionCategory {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub description: ::std::string::String,
    pub emoji: ::std::string::String,
    pub id: i64,
    pub is_answerable: bool,
    pub name: ::std::string::String,
    pub repository_id: i64,
    pub slug: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&DiscussionUnlockedDiscussionCategory>
    for DiscussionUnlockedDiscussionCategory
{
    fn from(value: &DiscussionUnlockedDiscussionCategory) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnlockedDiscussionState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnlockedDiscussionState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for DiscussionUnlockedDiscussionState {
    fn from(value: &DiscussionUnlockedDiscussionState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnlockedDiscussionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnlockedDiscussionState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnlockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnlockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnlockedDiscussionState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DiscussionUnpinned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"discussion unpinned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"discussion\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unpinned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussion\": {"]
#[doc = "      \"$ref\": \"#/definitions/discussion\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnpinned {
    pub action: DiscussionUnpinnedAction,
    pub discussion: Discussion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&DiscussionUnpinned> for DiscussionUnpinned {
    fn from(value: &DiscussionUnpinned) -> Self {
        value.clone()
    }
}
#[doc = "`DiscussionUnpinnedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unpinned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DiscussionUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl ::std::convert::From<&Self> for DiscussionUnpinnedAction {
    fn from(value: &DiscussionUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DiscussionUnpinnedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unpinned => write!(f, "unpinned"),
        }
    }
}
impl ::std::str::FromStr for DiscussionUnpinnedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DiscussionUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DiscussionUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DiscussionUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Everything`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Everything\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/branch_protection_rule_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_run_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/check_suite_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/code_scanning_alert_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/commit_comment_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/content_reference_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/create$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/delete$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deploy_key_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deployment_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/deployment_status_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/discussion_comment_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fork$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/github_app_authorization_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/gollum$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation_repositories_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue_comment_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/label_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/member_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/membership_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/meta_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/org_block_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/package_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/page_build$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/ping$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_column_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/public$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review_comment_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/push$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_dispatch_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_import$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_vulnerability_alert_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/secret_scanning_alert_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/security_advisory_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/star_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/status$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team_add$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/watch_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_dispatch$event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_job_event\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_run_event\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Everything {
    BranchProtectionRuleEvent(BranchProtectionRuleEvent),
    CheckRunEvent(CheckRunEvent),
    CheckSuiteEvent(CheckSuiteEvent),
    CodeScanningAlertEvent(CodeScanningAlertEvent),
    CommitCommentEvent(CommitCommentEvent),
    ContentReferenceEvent(ContentReferenceEvent),
    CreateEvent(CreateEvent),
    DeleteEvent(DeleteEvent),
    DeployKeyEvent(DeployKeyEvent),
    DeploymentEvent(DeploymentEvent),
    DeploymentStatusEvent(DeploymentStatusEvent),
    DiscussionEvent(DiscussionEvent),
    DiscussionCommentEvent(DiscussionCommentEvent),
    ForkEvent(ForkEvent),
    GithubAppAuthorizationEvent(GithubAppAuthorizationEvent),
    GollumEvent(GollumEvent),
    InstallationEvent(InstallationEvent),
    InstallationRepositoriesEvent(InstallationRepositoriesEvent),
    IssueCommentEvent(IssueCommentEvent),
    IssuesEvent(IssuesEvent),
    LabelEvent(LabelEvent),
    MarketplacePurchaseEvent(MarketplacePurchaseEvent),
    MemberEvent(MemberEvent),
    MembershipEvent(MembershipEvent),
    MetaEvent(MetaEvent),
    MilestoneEvent(MilestoneEvent),
    OrgBlockEvent(OrgBlockEvent),
    OrganizationEvent(OrganizationEvent),
    PackageEvent(PackageEvent),
    PageBuildEvent(PageBuildEvent),
    PingEvent(PingEvent),
    ProjectEvent(ProjectEvent),
    ProjectCardEvent(ProjectCardEvent),
    ProjectColumnEvent(ProjectColumnEvent),
    PublicEvent(PublicEvent),
    PullRequestEvent(PullRequestEvent),
    PullRequestReviewEvent(PullRequestReviewEvent),
    PullRequestReviewCommentEvent(PullRequestReviewCommentEvent),
    PushEvent(PushEvent),
    ReleaseEvent(ReleaseEvent),
    RepositoryEvent(RepositoryEvent),
    RepositoryDispatchEvent(RepositoryDispatchEvent),
    RepositoryImportEvent(RepositoryImportEvent),
    RepositoryVulnerabilityAlertEvent(RepositoryVulnerabilityAlertEvent),
    SecretScanningAlertEvent(SecretScanningAlertEvent),
    SecurityAdvisoryEvent(SecurityAdvisoryEvent),
    SponsorshipEvent(SponsorshipEvent),
    StarEvent(StarEvent),
    StatusEvent(StatusEvent),
    TeamEvent(TeamEvent),
    TeamAddEvent(TeamAddEvent),
    WatchEvent(WatchEvent),
    WorkflowDispatchEvent(WorkflowDispatchEvent),
    WorkflowJobEvent(WorkflowJobEvent),
    WorkflowRunEvent(WorkflowRunEvent),
}
impl ::std::convert::From<&Self> for Everything {
    fn from(value: &Everything) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BranchProtectionRuleEvent> for Everything {
    fn from(value: BranchProtectionRuleEvent) -> Self {
        Self::BranchProtectionRuleEvent(value)
    }
}
impl ::std::convert::From<CheckRunEvent> for Everything {
    fn from(value: CheckRunEvent) -> Self {
        Self::CheckRunEvent(value)
    }
}
impl ::std::convert::From<CheckSuiteEvent> for Everything {
    fn from(value: CheckSuiteEvent) -> Self {
        Self::CheckSuiteEvent(value)
    }
}
impl ::std::convert::From<CodeScanningAlertEvent> for Everything {
    fn from(value: CodeScanningAlertEvent) -> Self {
        Self::CodeScanningAlertEvent(value)
    }
}
impl ::std::convert::From<CommitCommentEvent> for Everything {
    fn from(value: CommitCommentEvent) -> Self {
        Self::CommitCommentEvent(value)
    }
}
impl ::std::convert::From<ContentReferenceEvent> for Everything {
    fn from(value: ContentReferenceEvent) -> Self {
        Self::ContentReferenceEvent(value)
    }
}
impl ::std::convert::From<CreateEvent> for Everything {
    fn from(value: CreateEvent) -> Self {
        Self::CreateEvent(value)
    }
}
impl ::std::convert::From<DeleteEvent> for Everything {
    fn from(value: DeleteEvent) -> Self {
        Self::DeleteEvent(value)
    }
}
impl ::std::convert::From<DeployKeyEvent> for Everything {
    fn from(value: DeployKeyEvent) -> Self {
        Self::DeployKeyEvent(value)
    }
}
impl ::std::convert::From<DeploymentEvent> for Everything {
    fn from(value: DeploymentEvent) -> Self {
        Self::DeploymentEvent(value)
    }
}
impl ::std::convert::From<DeploymentStatusEvent> for Everything {
    fn from(value: DeploymentStatusEvent) -> Self {
        Self::DeploymentStatusEvent(value)
    }
}
impl ::std::convert::From<DiscussionEvent> for Everything {
    fn from(value: DiscussionEvent) -> Self {
        Self::DiscussionEvent(value)
    }
}
impl ::std::convert::From<DiscussionCommentEvent> for Everything {
    fn from(value: DiscussionCommentEvent) -> Self {
        Self::DiscussionCommentEvent(value)
    }
}
impl ::std::convert::From<ForkEvent> for Everything {
    fn from(value: ForkEvent) -> Self {
        Self::ForkEvent(value)
    }
}
impl ::std::convert::From<GithubAppAuthorizationEvent> for Everything {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        Self::GithubAppAuthorizationEvent(value)
    }
}
impl ::std::convert::From<GollumEvent> for Everything {
    fn from(value: GollumEvent) -> Self {
        Self::GollumEvent(value)
    }
}
impl ::std::convert::From<InstallationEvent> for Everything {
    fn from(value: InstallationEvent) -> Self {
        Self::InstallationEvent(value)
    }
}
impl ::std::convert::From<InstallationRepositoriesEvent> for Everything {
    fn from(value: InstallationRepositoriesEvent) -> Self {
        Self::InstallationRepositoriesEvent(value)
    }
}
impl ::std::convert::From<IssueCommentEvent> for Everything {
    fn from(value: IssueCommentEvent) -> Self {
        Self::IssueCommentEvent(value)
    }
}
impl ::std::convert::From<IssuesEvent> for Everything {
    fn from(value: IssuesEvent) -> Self {
        Self::IssuesEvent(value)
    }
}
impl ::std::convert::From<LabelEvent> for Everything {
    fn from(value: LabelEvent) -> Self {
        Self::LabelEvent(value)
    }
}
impl ::std::convert::From<MarketplacePurchaseEvent> for Everything {
    fn from(value: MarketplacePurchaseEvent) -> Self {
        Self::MarketplacePurchaseEvent(value)
    }
}
impl ::std::convert::From<MemberEvent> for Everything {
    fn from(value: MemberEvent) -> Self {
        Self::MemberEvent(value)
    }
}
impl ::std::convert::From<MembershipEvent> for Everything {
    fn from(value: MembershipEvent) -> Self {
        Self::MembershipEvent(value)
    }
}
impl ::std::convert::From<MetaEvent> for Everything {
    fn from(value: MetaEvent) -> Self {
        Self::MetaEvent(value)
    }
}
impl ::std::convert::From<MilestoneEvent> for Everything {
    fn from(value: MilestoneEvent) -> Self {
        Self::MilestoneEvent(value)
    }
}
impl ::std::convert::From<OrgBlockEvent> for Everything {
    fn from(value: OrgBlockEvent) -> Self {
        Self::OrgBlockEvent(value)
    }
}
impl ::std::convert::From<OrganizationEvent> for Everything {
    fn from(value: OrganizationEvent) -> Self {
        Self::OrganizationEvent(value)
    }
}
impl ::std::convert::From<PackageEvent> for Everything {
    fn from(value: PackageEvent) -> Self {
        Self::PackageEvent(value)
    }
}
impl ::std::convert::From<PageBuildEvent> for Everything {
    fn from(value: PageBuildEvent) -> Self {
        Self::PageBuildEvent(value)
    }
}
impl ::std::convert::From<PingEvent> for Everything {
    fn from(value: PingEvent) -> Self {
        Self::PingEvent(value)
    }
}
impl ::std::convert::From<ProjectEvent> for Everything {
    fn from(value: ProjectEvent) -> Self {
        Self::ProjectEvent(value)
    }
}
impl ::std::convert::From<ProjectCardEvent> for Everything {
    fn from(value: ProjectCardEvent) -> Self {
        Self::ProjectCardEvent(value)
    }
}
impl ::std::convert::From<ProjectColumnEvent> for Everything {
    fn from(value: ProjectColumnEvent) -> Self {
        Self::ProjectColumnEvent(value)
    }
}
impl ::std::convert::From<PublicEvent> for Everything {
    fn from(value: PublicEvent) -> Self {
        Self::PublicEvent(value)
    }
}
impl ::std::convert::From<PullRequestEvent> for Everything {
    fn from(value: PullRequestEvent) -> Self {
        Self::PullRequestEvent(value)
    }
}
impl ::std::convert::From<PullRequestReviewEvent> for Everything {
    fn from(value: PullRequestReviewEvent) -> Self {
        Self::PullRequestReviewEvent(value)
    }
}
impl ::std::convert::From<PullRequestReviewCommentEvent> for Everything {
    fn from(value: PullRequestReviewCommentEvent) -> Self {
        Self::PullRequestReviewCommentEvent(value)
    }
}
impl ::std::convert::From<PushEvent> for Everything {
    fn from(value: PushEvent) -> Self {
        Self::PushEvent(value)
    }
}
impl ::std::convert::From<ReleaseEvent> for Everything {
    fn from(value: ReleaseEvent) -> Self {
        Self::ReleaseEvent(value)
    }
}
impl ::std::convert::From<RepositoryEvent> for Everything {
    fn from(value: RepositoryEvent) -> Self {
        Self::RepositoryEvent(value)
    }
}
impl ::std::convert::From<RepositoryDispatchEvent> for Everything {
    fn from(value: RepositoryDispatchEvent) -> Self {
        Self::RepositoryDispatchEvent(value)
    }
}
impl ::std::convert::From<RepositoryImportEvent> for Everything {
    fn from(value: RepositoryImportEvent) -> Self {
        Self::RepositoryImportEvent(value)
    }
}
impl ::std::convert::From<RepositoryVulnerabilityAlertEvent> for Everything {
    fn from(value: RepositoryVulnerabilityAlertEvent) -> Self {
        Self::RepositoryVulnerabilityAlertEvent(value)
    }
}
impl ::std::convert::From<SecretScanningAlertEvent> for Everything {
    fn from(value: SecretScanningAlertEvent) -> Self {
        Self::SecretScanningAlertEvent(value)
    }
}
impl ::std::convert::From<SecurityAdvisoryEvent> for Everything {
    fn from(value: SecurityAdvisoryEvent) -> Self {
        Self::SecurityAdvisoryEvent(value)
    }
}
impl ::std::convert::From<SponsorshipEvent> for Everything {
    fn from(value: SponsorshipEvent) -> Self {
        Self::SponsorshipEvent(value)
    }
}
impl ::std::convert::From<StarEvent> for Everything {
    fn from(value: StarEvent) -> Self {
        Self::StarEvent(value)
    }
}
impl ::std::convert::From<StatusEvent> for Everything {
    fn from(value: StatusEvent) -> Self {
        Self::StatusEvent(value)
    }
}
impl ::std::convert::From<TeamEvent> for Everything {
    fn from(value: TeamEvent) -> Self {
        Self::TeamEvent(value)
    }
}
impl ::std::convert::From<TeamAddEvent> for Everything {
    fn from(value: TeamAddEvent) -> Self {
        Self::TeamAddEvent(value)
    }
}
impl ::std::convert::From<WatchEvent> for Everything {
    fn from(value: WatchEvent) -> Self {
        Self::WatchEvent(value)
    }
}
impl ::std::convert::From<WorkflowDispatchEvent> for Everything {
    fn from(value: WorkflowDispatchEvent) -> Self {
        Self::WorkflowDispatchEvent(value)
    }
}
impl ::std::convert::From<WorkflowJobEvent> for Everything {
    fn from(value: WorkflowJobEvent) -> Self {
        Self::WorkflowJobEvent(value)
    }
}
impl ::std::convert::From<WorkflowRunEvent> for Everything {
    fn from(value: WorkflowRunEvent) -> Self {
        Self::WorkflowRunEvent(value)
    }
}
#[doc = "A user forks a repository."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"fork event\","]
#[doc = "  \"description\": \"A user forks a repository.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"forkee\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"forkee\": {"]
#[doc = "      \"description\": \"The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"fork\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ForkEvent {
    pub forkee: ForkEventForkee,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ForkEvent> for ForkEvent {
    fn from(value: &ForkEvent) -> Self {
        value.clone()
    }
}
#[doc = "The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"fork\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ForkEventForkee {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: ForkEventForkeeCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<ForkEventForkeePermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: ForkEventForkeePushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&ForkEventForkee> for ForkEventForkee {
    fn from(value: &ForkEventForkee) -> Self {
        value.clone()
    }
}
#[doc = "`ForkEventForkeeCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForkEventForkeeCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for ForkEventForkeeCreatedAt {
    fn from(value: &ForkEventForkeeCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ForkEventForkeeCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ForkEventForkeeCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ForkEventForkeeCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ForkEventForkeeCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ForkEventForkeeCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for ForkEventForkeeCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for ForkEventForkeeCreatedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForkEventForkeePermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ForkEventForkeePermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ForkEventForkeePermissions> for ForkEventForkeePermissions {
    fn from(value: &ForkEventForkeePermissions) -> Self {
        value.clone()
    }
}
#[doc = "`ForkEventForkeePushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForkEventForkeePushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for ForkEventForkeePushedAt {
    fn from(value: &ForkEventForkeePushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for ForkEventForkeePushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for ForkEventForkeePushedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GithubAppAuthorizationEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/github_app_authorization$revoked\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct GithubAppAuthorizationEvent(pub GithubAppAuthorizationRevoked);
impl ::std::ops::Deref for GithubAppAuthorizationEvent {
    type Target = GithubAppAuthorizationRevoked;
    fn deref(&self) -> &GithubAppAuthorizationRevoked {
        &self.0
    }
}
impl ::std::convert::From<GithubAppAuthorizationEvent> for GithubAppAuthorizationRevoked {
    fn from(value: GithubAppAuthorizationEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&GithubAppAuthorizationEvent> for GithubAppAuthorizationEvent {
    fn from(value: &GithubAppAuthorizationEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<GithubAppAuthorizationRevoked> for GithubAppAuthorizationEvent {
    fn from(value: GithubAppAuthorizationRevoked) -> Self {
        Self(value)
    }
}
#[doc = "`GithubAppAuthorizationRevoked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"github_app_authorization revoked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"revoked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GithubAppAuthorizationRevoked {
    pub action: GithubAppAuthorizationRevokedAction,
    pub sender: User,
}
impl ::std::convert::From<&GithubAppAuthorizationRevoked> for GithubAppAuthorizationRevoked {
    fn from(value: &GithubAppAuthorizationRevoked) -> Self {
        value.clone()
    }
}
#[doc = "`GithubAppAuthorizationRevokedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"revoked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GithubAppAuthorizationRevokedAction {
    #[serde(rename = "revoked")]
    Revoked,
}
impl ::std::convert::From<&Self> for GithubAppAuthorizationRevokedAction {
    fn from(value: &GithubAppAuthorizationRevokedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GithubAppAuthorizationRevokedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Revoked => write!(f, "revoked"),
        }
    }
}
impl ::std::str::FromStr for GithubAppAuthorizationRevokedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "revoked" => Ok(Self::Revoked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GithubAppAuthorizationRevokedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GithubAppAuthorizationRevokedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GithubAppAuthorizationRevokedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GithubOrg`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GitHub Org\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://avatars.githubusercontent.com/u/9919?v=4\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/events{/privacy}\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/followers\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/following{/other_user}\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/gists{/gist_id}\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://github.com/github\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"const\": 9919"]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"github\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"GitHub\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"MDEyOk9yZ2FuaXphdGlvbjk5MTk=\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/orgs\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/received_events\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/repos\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\","]
#[doc = "      \"const\": false"]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/starred{/owner}{/repo}\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github/subscriptions\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"Organization\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"const\": \"https://api.github.com/users/github\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GithubOrg {
    pub avatar_url: ::std::string::String,
    #[serde(default)]
    pub email: (),
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&GithubOrg> for GithubOrg {
    fn from(value: &GithubOrg) -> Self {
        value.clone()
    }
}
#[doc = "A wiki page is created or updated."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"gollum event\","]
#[doc = "  \"description\": \"A wiki page is created or updated.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"pages\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pages\": {"]
#[doc = "      \"description\": \"The pages that were updated.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"action\","]
#[doc = "          \"html_url\","]
#[doc = "          \"page_name\","]
#[doc = "          \"sha\","]
#[doc = "          \"summary\","]
#[doc = "          \"title\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"action\": {"]
#[doc = "            \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\","]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"enum\": ["]
#[doc = "              \"created\","]
#[doc = "              \"edited\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"html_url\": {"]
#[doc = "            \"description\": \"Points to the HTML wiki page.\","]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          },"]
#[doc = "          \"page_name\": {"]
#[doc = "            \"description\": \"The name of the page.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"sha\": {"]
#[doc = "            \"description\": \"The latest commit SHA of the page.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"summary\": {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          \"title\": {"]
#[doc = "            \"description\": \"The current page title.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GollumEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[doc = "The pages that were updated."]
    pub pages: ::std::vec::Vec<GollumEventPagesItem>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&GollumEvent> for GollumEvent {
    fn from(value: &GollumEvent) -> Self {
        value.clone()
    }
}
#[doc = "`GollumEventPagesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"html_url\","]
#[doc = "    \"page_name\","]
#[doc = "    \"sha\","]
#[doc = "    \"summary\","]
#[doc = "    \"title\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\","]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"Points to the HTML wiki page.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"page_name\": {"]
#[doc = "      \"description\": \"The name of the page.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"description\": \"The latest commit SHA of the page.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"The current page title.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GollumEventPagesItem {
    #[doc = "The action that was performed on the page. Can be `created` or `edited`."]
    pub action: GollumEventPagesItemAction,
    #[doc = "Points to the HTML wiki page."]
    pub html_url: ::std::string::String,
    #[doc = "The name of the page."]
    pub page_name: ::std::string::String,
    #[doc = "The latest commit SHA of the page."]
    pub sha: ::std::string::String,
    pub summary: (),
    #[doc = "The current page title."]
    pub title: ::std::string::String,
}
impl ::std::convert::From<&GollumEventPagesItem> for GollumEventPagesItem {
    fn from(value: &GollumEventPagesItem) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed on the page. Can be `created` or `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action that was performed on the page. Can be `created` or `edited`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\","]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GollumEventPagesItemAction {
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for GollumEventPagesItemAction {
    fn from(value: &GollumEventPagesItemAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GollumEventPagesItemAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for GollumEventPagesItemAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GollumEventPagesItemAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GollumEventPagesItemAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GollumEventPagesItemAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The GitHub App installation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Installation\","]
#[doc = "  \"description\": \"The GitHub App installation.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"access_tokens_url\","]
#[doc = "    \"account\","]
#[doc = "    \"app_id\","]
#[doc = "    \"created_at\","]
#[doc = "    \"events\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"permissions\","]
#[doc = "    \"repositories_url\","]
#[doc = "    \"repository_selection\","]
#[doc = "    \"single_file_name\","]
#[doc = "    \"suspended_at\","]
#[doc = "    \"suspended_by\","]
#[doc = "    \"target_id\","]
#[doc = "    \"target_type\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_tokens_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"account\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"app_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"app_slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"events\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\","]
#[doc = "        \"enum\": ["]
#[doc = "          \"check_run\","]
#[doc = "          \"check_suite\","]
#[doc = "          \"code_scanning_alert\","]
#[doc = "          \"commit_comment\","]
#[doc = "          \"content_reference\","]
#[doc = "          \"create\","]
#[doc = "          \"delete\","]
#[doc = "          \"deployment\","]
#[doc = "          \"deployment_review\","]
#[doc = "          \"deployment_status\","]
#[doc = "          \"deploy_key\","]
#[doc = "          \"discussion\","]
#[doc = "          \"discussion_comment\","]
#[doc = "          \"fork\","]
#[doc = "          \"gollum\","]
#[doc = "          \"issues\","]
#[doc = "          \"issue_comment\","]
#[doc = "          \"label\","]
#[doc = "          \"member\","]
#[doc = "          \"membership\","]
#[doc = "          \"merge_queue_entry\","]
#[doc = "          \"milestone\","]
#[doc = "          \"organization\","]
#[doc = "          \"org_block\","]
#[doc = "          \"page_build\","]
#[doc = "          \"project\","]
#[doc = "          \"project_card\","]
#[doc = "          \"project_column\","]
#[doc = "          \"public\","]
#[doc = "          \"pull_request\","]
#[doc = "          \"pull_request_review\","]
#[doc = "          \"pull_request_review_comment\","]
#[doc = "          \"push\","]
#[doc = "          \"registry_package\","]
#[doc = "          \"release\","]
#[doc = "          \"repository\","]
#[doc = "          \"repository_dispatch\","]
#[doc = "          \"secret_scanning_alert\","]
#[doc = "          \"star\","]
#[doc = "          \"status\","]
#[doc = "          \"team\","]
#[doc = "          \"team_add\","]
#[doc = "          \"watch\","]
#[doc = "          \"workflow_dispatch\","]
#[doc = "          \"workflow_run\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"has_multiple_single_files\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The ID of the installation.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"permissions\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"actions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"administration\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"checks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"content_references\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"contents\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"deployments\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"discussions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"emails\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"environments\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"issues\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"members\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_administration\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_events\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_hooks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_packages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_plan\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_projects\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_secrets\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_self_hosted_runners\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"organization_user_blocking\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"packages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"pages\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"pull_requests\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_hooks\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repository_projects\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"secret_scanning_alerts\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"secrets\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"security_events\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"security_scanning_alert\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"single_file\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"team_discussions\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"vulnerability_alerts\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"workflows\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"read\","]
#[doc = "            \"write\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repositories_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repository_selection\": {"]
#[doc = "      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"selected\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file_paths\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"suspended_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"suspended_by\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"target_id\": {"]
#[doc = "      \"description\": \"The ID of the user or organization this token is being scoped to.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"target_type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"User\","]
#[doc = "        \"Organization\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Installation {
    pub access_tokens_url: ::std::string::String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub app_slug: ::std::option::Option<::std::string::String>,
    pub created_at: InstallationCreatedAt,
    pub events: ::std::vec::Vec<InstallationEventsItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub has_multiple_single_files: ::std::option::Option<bool>,
    pub html_url: ::std::string::String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationPermissions,
    pub repositories_url: ::std::string::String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositorySelection,
    pub single_file_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub single_file_paths: ::std::vec::Vec<::std::string::String>,
    pub suspended_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub suspended_by: ::std::option::Option<User>,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationTargetType,
    pub updated_at: InstallationUpdatedAt,
}
impl ::std::convert::From<&Installation> for Installation {
    fn from(value: &Installation) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    \"repositories\": {"]
#[doc = "      \"description\": \"An array of repository objects that the installation can access.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreated {
    pub action: InstallationCreatedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub repositories: ::std::vec::Vec<InstallationCreatedRepositoriesItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requester: ::std::option::Option<User>,
    pub sender: User,
}
impl ::std::convert::From<&InstallationCreated> for InstallationCreated {
    fn from(value: &InstallationCreated) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for InstallationCreatedAction {
    fn from(value: &InstallationCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for InstallationCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationCreatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationCreatedAt {
    fn from(value: &InstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for InstallationCreatedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`InstallationCreatedRepositoriesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreatedRepositoriesItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationCreatedRepositoriesItem>
    for InstallationCreatedRepositoriesItem
{
    fn from(value: &InstallationCreatedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    \"repositories\": {"]
#[doc = "      \"description\": \"An array of repository objects that the installation can access.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeleted {
    pub action: InstallationDeletedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub repositories: ::std::vec::Vec<InstallationDeletedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl ::std::convert::From<&InstallationDeleted> for InstallationDeleted {
    fn from(value: &InstallationDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for InstallationDeletedAction {
    fn from(value: &InstallationDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for InstallationDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationDeletedRepositoriesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeletedRepositoriesItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationDeletedRepositoriesItem>
    for InstallationDeletedRepositoriesItem
{
    fn from(value: &InstallationDeletedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation$new_permissions_accepted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation$suspend\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation$unsuspend\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationEvent {
    Created(InstallationCreated),
    Deleted(InstallationDeleted),
    NewPermissionsAccepted(InstallationNewPermissionsAccepted),
    Suspend(InstallationSuspend),
    Unsuspend(InstallationUnsuspend),
}
impl ::std::convert::From<&Self> for InstallationEvent {
    fn from(value: &InstallationEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<InstallationCreated> for InstallationEvent {
    fn from(value: InstallationCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<InstallationDeleted> for InstallationEvent {
    fn from(value: InstallationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<InstallationNewPermissionsAccepted> for InstallationEvent {
    fn from(value: InstallationNewPermissionsAccepted) -> Self {
        Self::NewPermissionsAccepted(value)
    }
}
impl ::std::convert::From<InstallationSuspend> for InstallationEvent {
    fn from(value: InstallationSuspend) -> Self {
        Self::Suspend(value)
    }
}
impl ::std::convert::From<InstallationUnsuspend> for InstallationEvent {
    fn from(value: InstallationUnsuspend) -> Self {
        Self::Unsuspend(value)
    }
}
#[doc = "`InstallationEventsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"check_run\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"code_scanning_alert\","]
#[doc = "    \"commit_comment\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"create\","]
#[doc = "    \"delete\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_review\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"deploy_key\","]
#[doc = "    \"discussion\","]
#[doc = "    \"discussion_comment\","]
#[doc = "    \"fork\","]
#[doc = "    \"gollum\","]
#[doc = "    \"issues\","]
#[doc = "    \"issue_comment\","]
#[doc = "    \"label\","]
#[doc = "    \"member\","]
#[doc = "    \"membership\","]
#[doc = "    \"merge_queue_entry\","]
#[doc = "    \"milestone\","]
#[doc = "    \"organization\","]
#[doc = "    \"org_block\","]
#[doc = "    \"page_build\","]
#[doc = "    \"project\","]
#[doc = "    \"project_card\","]
#[doc = "    \"project_column\","]
#[doc = "    \"public\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"pull_request_review\","]
#[doc = "    \"pull_request_review_comment\","]
#[doc = "    \"push\","]
#[doc = "    \"registry_package\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"repository_dispatch\","]
#[doc = "    \"secret_scanning_alert\","]
#[doc = "    \"star\","]
#[doc = "    \"status\","]
#[doc = "    \"team\","]
#[doc = "    \"team_add\","]
#[doc = "    \"watch\","]
#[doc = "    \"workflow_dispatch\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ::std::convert::From<&Self> for InstallationEventsItem {
    fn from(value: &InstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationEventsItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CheckRun => write!(f, "check_run"),
            Self::CheckSuite => write!(f, "check_suite"),
            Self::CodeScanningAlert => write!(f, "code_scanning_alert"),
            Self::CommitComment => write!(f, "commit_comment"),
            Self::ContentReference => write!(f, "content_reference"),
            Self::Create => write!(f, "create"),
            Self::Delete => write!(f, "delete"),
            Self::Deployment => write!(f, "deployment"),
            Self::DeploymentReview => write!(f, "deployment_review"),
            Self::DeploymentStatus => write!(f, "deployment_status"),
            Self::DeployKey => write!(f, "deploy_key"),
            Self::Discussion => write!(f, "discussion"),
            Self::DiscussionComment => write!(f, "discussion_comment"),
            Self::Fork => write!(f, "fork"),
            Self::Gollum => write!(f, "gollum"),
            Self::Issues => write!(f, "issues"),
            Self::IssueComment => write!(f, "issue_comment"),
            Self::Label => write!(f, "label"),
            Self::Member => write!(f, "member"),
            Self::Membership => write!(f, "membership"),
            Self::MergeQueueEntry => write!(f, "merge_queue_entry"),
            Self::Milestone => write!(f, "milestone"),
            Self::Organization => write!(f, "organization"),
            Self::OrgBlock => write!(f, "org_block"),
            Self::PageBuild => write!(f, "page_build"),
            Self::Project => write!(f, "project"),
            Self::ProjectCard => write!(f, "project_card"),
            Self::ProjectColumn => write!(f, "project_column"),
            Self::Public => write!(f, "public"),
            Self::PullRequest => write!(f, "pull_request"),
            Self::PullRequestReview => write!(f, "pull_request_review"),
            Self::PullRequestReviewComment => write!(f, "pull_request_review_comment"),
            Self::Push => write!(f, "push"),
            Self::RegistryPackage => write!(f, "registry_package"),
            Self::Release => write!(f, "release"),
            Self::Repository => write!(f, "repository"),
            Self::RepositoryDispatch => write!(f, "repository_dispatch"),
            Self::SecretScanningAlert => write!(f, "secret_scanning_alert"),
            Self::Star => write!(f, "star"),
            Self::Status => write!(f, "status"),
            Self::Team => write!(f, "team"),
            Self::TeamAdd => write!(f, "team_add"),
            Self::Watch => write!(f, "watch"),
            Self::WorkflowDispatch => write!(f, "workflow_dispatch"),
            Self::WorkflowRun => write!(f, "workflow_run"),
        }
    }
}
impl ::std::str::FromStr for InstallationEventsItem {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Installation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"InstallationLite\","]
#[doc = "  \"description\": \"Installation\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"node_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The ID of the installation.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationLite {
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub node_id: ::std::string::String,
}
impl ::std::convert::From<&InstallationLite> for InstallationLite {
    fn from(value: &InstallationLite) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationNewPermissionsAccepted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation new_permissions_accepted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"new_permissions_accepted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    \"repositories\": {"]
#[doc = "      \"description\": \"An array of repository objects that the installation can access.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAccepted {
    pub action: InstallationNewPermissionsAcceptedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub repositories: ::std::vec::Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl ::std::convert::From<&InstallationNewPermissionsAccepted>
    for InstallationNewPermissionsAccepted
{
    fn from(value: &InstallationNewPermissionsAccepted) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationNewPermissionsAcceptedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"new_permissions_accepted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationNewPermissionsAcceptedAction {
    #[serde(rename = "new_permissions_accepted")]
    NewPermissionsAccepted,
}
impl ::std::convert::From<&Self> for InstallationNewPermissionsAcceptedAction {
    fn from(value: &InstallationNewPermissionsAcceptedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationNewPermissionsAcceptedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NewPermissionsAccepted => write!(f, "new_permissions_accepted"),
        }
    }
}
impl ::std::str::FromStr for InstallationNewPermissionsAcceptedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "new_permissions_accepted" => Ok(Self::NewPermissionsAccepted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationNewPermissionsAcceptedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationNewPermissionsAcceptedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationNewPermissionsAcceptedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationNewPermissionsAcceptedRepositoriesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAcceptedRepositoriesItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationNewPermissionsAcceptedRepositoriesItem>
    for InstallationNewPermissionsAcceptedRepositoriesItem
{
    fn from(value: &InstallationNewPermissionsAcceptedRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"checks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content_references\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"contents\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"emails\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"environments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"issues\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_plan\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_self_hosted_runners\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_user_blocking\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secret_scanning_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_scanning_alert\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"team_discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"vulnerability_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"workflows\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationPermissions {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub actions: ::std::option::Option<InstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub administration: ::std::option::Option<InstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub checks: ::std::option::Option<InstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_references: ::std::option::Option<InstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub contents: ::std::option::Option<InstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployments: ::std::option::Option<InstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub discussions: ::std::option::Option<InstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub emails: ::std::option::Option<InstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub environments: ::std::option::Option<InstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub issues: ::std::option::Option<InstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub members: ::std::option::Option<InstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<InstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_administration:
        ::std::option::Option<InstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_events: ::std::option::Option<InstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_hooks: ::std::option::Option<InstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_packages: ::std::option::Option<InstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_plan: ::std::option::Option<InstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_projects: ::std::option::Option<InstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_secrets: ::std::option::Option<InstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_self_hosted_runners:
        ::std::option::Option<InstallationPermissionsOrganizationSelfHostedRunners>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_user_blocking:
        ::std::option::Option<InstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub packages: ::std::option::Option<InstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pages: ::std::option::Option<InstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_requests: ::std::option::Option<InstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_hooks: ::std::option::Option<InstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_projects: ::std::option::Option<InstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret_scanning_alerts: ::std::option::Option<InstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secrets: ::std::option::Option<InstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_events: ::std::option::Option<InstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_scanning_alert:
        ::std::option::Option<InstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub single_file: ::std::option::Option<InstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub statuses: ::std::option::Option<InstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub team_discussions: ::std::option::Option<InstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub vulnerability_alerts: ::std::option::Option<InstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub workflows: ::std::option::Option<InstallationPermissionsWorkflows>,
}
impl ::std::convert::From<&InstallationPermissions> for InstallationPermissions {
    fn from(value: &InstallationPermissions) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InstallationPermissions {
    fn default() -> Self {
        Self {
            actions: Default::default(),
            administration: Default::default(),
            checks: Default::default(),
            content_references: Default::default(),
            contents: Default::default(),
            deployments: Default::default(),
            discussions: Default::default(),
            emails: Default::default(),
            environments: Default::default(),
            issues: Default::default(),
            members: Default::default(),
            metadata: Default::default(),
            organization_administration: Default::default(),
            organization_events: Default::default(),
            organization_hooks: Default::default(),
            organization_packages: Default::default(),
            organization_plan: Default::default(),
            organization_projects: Default::default(),
            organization_secrets: Default::default(),
            organization_self_hosted_runners: Default::default(),
            organization_user_blocking: Default::default(),
            packages: Default::default(),
            pages: Default::default(),
            pull_requests: Default::default(),
            repository_hooks: Default::default(),
            repository_projects: Default::default(),
            secret_scanning_alerts: Default::default(),
            secrets: Default::default(),
            security_events: Default::default(),
            security_scanning_alert: Default::default(),
            single_file: Default::default(),
            statuses: Default::default(),
            team_discussions: Default::default(),
            vulnerability_alerts: Default::default(),
            workflows: Default::default(),
        }
    }
}
#[doc = "`InstallationPermissionsActions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsActions {
    fn from(value: &InstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsActions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsAdministration {
    fn from(value: &InstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsChecks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsChecks {
    fn from(value: &InstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsChecks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsChecks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsContentReferences`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsContentReferences {
    fn from(value: &InstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsContentReferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsContentReferences {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsContents {
    fn from(value: &InstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsContents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsDeployments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsDeployments {
    fn from(value: &InstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsDeployments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsDeployments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsDiscussions {
    fn from(value: &InstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsEmails`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsEmails {
    fn from(value: &InstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsEmails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsEmails {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsEnvironments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsEnvironments {
    fn from(value: &InstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsEnvironments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsEnvironments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsIssues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsIssues {
    fn from(value: &InstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsIssues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsIssues {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsMembers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsMembers {
    fn from(value: &InstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsMembers {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsMetadata`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsMetadata {
    fn from(value: &InstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsMetadata {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationAdministration {
    fn from(value: &InstallationPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationEvents {
    fn from(value: &InstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationEvents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsOrganizationEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsOrganizationEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationHooks {
    fn from(value: &InstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationPackages {
    fn from(value: &InstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationPlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationPlan {
    fn from(value: &InstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationPlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationPlan {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationProjects {
    fn from(value: &InstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationProjects {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationSecrets {
    fn from(value: &InstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsOrganizationSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationSelfHostedRunners`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationSelfHostedRunners {
    fn from(value: &InstallationPermissionsOrganizationSelfHostedRunners) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationSelfHostedRunners {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationSelfHostedRunners {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSelfHostedRunners {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsOrganizationUserBlocking`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsOrganizationUserBlocking {
    fn from(value: &InstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsOrganizationUserBlocking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsOrganizationUserBlocking {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsOrganizationUserBlocking {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsPackages {
    fn from(value: &InstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsPages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsPages {
    fn from(value: &InstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsPages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsPages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsPullRequests`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsPullRequests {
    fn from(value: &InstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsPullRequests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsPullRequests {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsRepositoryHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsRepositoryHooks {
    fn from(value: &InstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsRepositoryHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsRepositoryHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsRepositoryProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsRepositoryProjects {
    fn from(value: &InstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsRepositoryProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsRepositoryProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsRepositoryProjects {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsSecretScanningAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsSecretScanningAlerts {
    fn from(value: &InstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsSecretScanningAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsSecretScanningAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsSecretScanningAlerts {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsSecrets {
    fn from(value: &InstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsSecurityEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsSecurityEvents {
    fn from(value: &InstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsSecurityEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsSecurityEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsSecurityScanningAlert`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsSecurityScanningAlert {
    fn from(value: &InstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsSecurityScanningAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsSecurityScanningAlert {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsSecurityScanningAlert {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsSingleFile`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsSingleFile {
    fn from(value: &InstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsSingleFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsSingleFile {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsStatuses`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsStatuses {
    fn from(value: &InstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsStatuses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsStatuses {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsTeamDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsTeamDiscussions {
    fn from(value: &InstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsTeamDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsTeamDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsVulnerabilityAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsVulnerabilityAlerts {
    fn from(value: &InstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsVulnerabilityAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsVulnerabilityAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsVulnerabilityAlerts {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsVulnerabilityAlerts {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationPermissionsWorkflows`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationPermissionsWorkflows {
    fn from(value: &InstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationPermissionsWorkflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationPermissionsWorkflows {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationRepositoriesAdded`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation_repositories added event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"repositories_added\","]
#[doc = "    \"repositories_removed\","]
#[doc = "    \"repository_selection\","]
#[doc = "    \"requester\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"added\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    \"repositories_added\": {"]
#[doc = "      \"description\": \"An array of repository objects, which were added to the installation.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"repositories_removed\": {"]
#[doc = "      \"description\": \"An array of repository objects, which were removed from the installation.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 0"]
#[doc = "    },"]
#[doc = "    \"repository_selection\": {"]
#[doc = "      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"selected\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAdded {
    pub action: InstallationRepositoriesAddedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: ::std::vec::Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed: ::std::vec::Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesAddedRepositorySelection,
    pub requester: ::std::option::Option<User>,
    pub sender: User,
}
impl ::std::convert::From<&InstallationRepositoriesAdded> for InstallationRepositoriesAdded {
    fn from(value: &InstallationRepositoriesAdded) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationRepositoriesAddedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"added\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationRepositoriesAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl ::std::convert::From<&Self> for InstallationRepositoriesAddedAction {
    fn from(value: &InstallationRepositoriesAddedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationRepositoriesAddedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Added => write!(f, "added"),
        }
    }
}
impl ::std::str::FromStr for InstallationRepositoriesAddedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationRepositoriesAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationRepositoriesAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationRepositoriesAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationRepositoriesAddedRepositoriesAddedItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesAddedItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationRepositoriesAddedRepositoriesAddedItem>
    for InstallationRepositoriesAddedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationRepositoriesAddedRepositoriesRemovedItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesRemovedItem {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub full_name: ::std::option::Option<::std::string::String>,
    #[doc = "Unique identifier of the repository"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[doc = "The name of the repository."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_id: ::std::option::Option<::std::string::String>,
    #[doc = "Whether the repository is private or public."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub private: ::std::option::Option<bool>,
}
impl ::std::convert::From<&InstallationRepositoriesAddedRepositoriesRemovedItem>
    for InstallationRepositoriesAddedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesAddedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InstallationRepositoriesAddedRepositoriesRemovedItem {
    fn default() -> Self {
        Self {
            full_name: Default::default(),
            id: Default::default(),
            name: Default::default(),
            node_id: Default::default(),
            private: Default::default(),
        }
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"selected\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationRepositoriesAddedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ::std::convert::From<&Self> for InstallationRepositoriesAddedRepositorySelection {
    fn from(value: &InstallationRepositoriesAddedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationRepositoriesAddedRepositorySelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Selected => write!(f, "selected"),
        }
    }
}
impl ::std::str::FromStr for InstallationRepositoriesAddedRepositorySelection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationRepositoriesAddedRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationRepositoriesAddedRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationRepositoriesAddedRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationRepositoriesEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation_repositories$added\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation_repositories$removed\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationRepositoriesEvent {
    Added(InstallationRepositoriesAdded),
    Removed(InstallationRepositoriesRemoved),
}
impl ::std::convert::From<&Self> for InstallationRepositoriesEvent {
    fn from(value: &InstallationRepositoriesEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<InstallationRepositoriesAdded> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesAdded) -> Self {
        Self::Added(value)
    }
}
impl ::std::convert::From<InstallationRepositoriesRemoved> for InstallationRepositoriesEvent {
    fn from(value: InstallationRepositoriesRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "`InstallationRepositoriesRemoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation_repositories removed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"repositories_added\","]
#[doc = "    \"repositories_removed\","]
#[doc = "    \"repository_selection\","]
#[doc = "    \"requester\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    \"repositories_added\": {"]
#[doc = "      \"description\": \"An array of repository objects, which were added to the installation.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 0"]
#[doc = "    },"]
#[doc = "    \"repositories_removed\": {"]
#[doc = "      \"description\": \"An array of repository objects, which were removed from the installation.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"repository_selection\": {"]
#[doc = "      \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"selected\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemoved {
    pub action: InstallationRepositoriesRemovedAction,
    pub installation: Installation,
    #[doc = "An array of repository objects, which were added to the installation."]
    pub repositories_added: ::std::vec::Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
    #[doc = "An array of repository objects, which were removed from the installation."]
    pub repositories_removed:
        ::std::vec::Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationRepositoriesRemovedRepositorySelection,
    pub requester: ::std::option::Option<User>,
    pub sender: User,
}
impl ::std::convert::From<&InstallationRepositoriesRemoved> for InstallationRepositoriesRemoved {
    fn from(value: &InstallationRepositoriesRemoved) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationRepositoriesRemovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationRepositoriesRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl ::std::convert::From<&Self> for InstallationRepositoriesRemovedAction {
    fn from(value: &InstallationRepositoriesRemovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationRepositoriesRemovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Removed => write!(f, "removed"),
        }
    }
}
impl ::std::str::FromStr for InstallationRepositoriesRemovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationRepositoriesRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationRepositoriesRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationRepositoriesRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationRepositoriesRemovedRepositoriesAddedItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesAddedItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationRepositoriesRemovedRepositoriesAddedItem>
    for InstallationRepositoriesRemovedRepositoriesAddedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesAddedItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationRepositoriesRemovedRepositoriesRemovedItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesRemovedItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationRepositoriesRemovedRepositoriesRemovedItem>
    for InstallationRepositoriesRemovedRepositoriesRemovedItem
{
    fn from(value: &InstallationRepositoriesRemovedRepositoriesRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"selected\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationRepositoriesRemovedRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ::std::convert::From<&Self> for InstallationRepositoriesRemovedRepositorySelection {
    fn from(value: &InstallationRepositoriesRemovedRepositorySelection) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationRepositoriesRemovedRepositorySelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Selected => write!(f, "selected"),
        }
    }
}
impl ::std::str::FromStr for InstallationRepositoriesRemovedRepositorySelection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationRepositoriesRemovedRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationRepositoriesRemovedRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationRepositoriesRemovedRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"selected\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ::std::convert::From<&Self> for InstallationRepositorySelection {
    fn from(value: &InstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationRepositorySelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Selected => write!(f, "selected"),
        }
    }
}
impl ::std::str::FromStr for InstallationRepositorySelection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspend`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation suspend event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"suspend\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/installation\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"suspended_at\","]
#[doc = "            \"suspended_by\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"suspended_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"suspended_by\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repositories\": {"]
#[doc = "      \"description\": \"An array of repository objects that the installation can access.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspend {
    pub action: InstallationSuspendAction,
    pub installation: InstallationSuspendInstallation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub repositories: ::std::vec::Vec<InstallationSuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl ::std::convert::From<&InstallationSuspend> for InstallationSuspend {
    fn from(value: &InstallationSuspend) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationSuspendAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"suspend\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendAction {
    #[serde(rename = "suspend")]
    Suspend,
}
impl ::std::convert::From<&Self> for InstallationSuspendAction {
    fn from(value: &InstallationSuspendAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Suspend => write!(f, "suspend"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "suspend" => Ok(Self::Suspend),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationSuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationSuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"suspended_at\","]
#[doc = "        \"suspended_by\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"suspended_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"suspended_by\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallation {
    pub access_tokens_url: ::std::string::String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub app_slug: ::std::option::Option<::std::string::String>,
    pub created_at: InstallationSuspendInstallationCreatedAt,
    pub events: ::std::vec::Vec<InstallationSuspendInstallationEventsItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub has_multiple_single_files: ::std::option::Option<bool>,
    pub html_url: ::std::string::String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationSuspendInstallationPermissions,
    pub repositories_url: ::std::string::String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationSuspendInstallationRepositorySelection,
    pub single_file_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub single_file_paths: ::std::vec::Vec<::std::string::String>,
    pub suspended_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub suspended_by: InstallationSuspendInstallationSuspendedBy,
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationSuspendInstallationTargetType,
    pub updated_at: InstallationSuspendInstallationUpdatedAt,
}
impl ::std::convert::From<&InstallationSuspendInstallation> for InstallationSuspendInstallation {
    fn from(value: &InstallationSuspendInstallation) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationSuspendInstallationCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationSuspendInstallationCreatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationCreatedAt {
    fn from(value: &InstallationSuspendInstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationSuspendInstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationSuspendInstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for InstallationSuspendInstallationCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationSuspendInstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`InstallationSuspendInstallationEventsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"check_run\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"code_scanning_alert\","]
#[doc = "    \"commit_comment\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"create\","]
#[doc = "    \"delete\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_review\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"deploy_key\","]
#[doc = "    \"discussion\","]
#[doc = "    \"discussion_comment\","]
#[doc = "    \"fork\","]
#[doc = "    \"gollum\","]
#[doc = "    \"issues\","]
#[doc = "    \"issue_comment\","]
#[doc = "    \"label\","]
#[doc = "    \"member\","]
#[doc = "    \"membership\","]
#[doc = "    \"merge_queue_entry\","]
#[doc = "    \"milestone\","]
#[doc = "    \"organization\","]
#[doc = "    \"org_block\","]
#[doc = "    \"page_build\","]
#[doc = "    \"project\","]
#[doc = "    \"project_card\","]
#[doc = "    \"project_column\","]
#[doc = "    \"public\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"pull_request_review\","]
#[doc = "    \"pull_request_review_comment\","]
#[doc = "    \"push\","]
#[doc = "    \"registry_package\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"repository_dispatch\","]
#[doc = "    \"secret_scanning_alert\","]
#[doc = "    \"star\","]
#[doc = "    \"status\","]
#[doc = "    \"team\","]
#[doc = "    \"team_add\","]
#[doc = "    \"watch\","]
#[doc = "    \"workflow_dispatch\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationEventsItem {
    fn from(value: &InstallationSuspendInstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationEventsItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CheckRun => write!(f, "check_run"),
            Self::CheckSuite => write!(f, "check_suite"),
            Self::CodeScanningAlert => write!(f, "code_scanning_alert"),
            Self::CommitComment => write!(f, "commit_comment"),
            Self::ContentReference => write!(f, "content_reference"),
            Self::Create => write!(f, "create"),
            Self::Delete => write!(f, "delete"),
            Self::Deployment => write!(f, "deployment"),
            Self::DeploymentReview => write!(f, "deployment_review"),
            Self::DeploymentStatus => write!(f, "deployment_status"),
            Self::DeployKey => write!(f, "deploy_key"),
            Self::Discussion => write!(f, "discussion"),
            Self::DiscussionComment => write!(f, "discussion_comment"),
            Self::Fork => write!(f, "fork"),
            Self::Gollum => write!(f, "gollum"),
            Self::Issues => write!(f, "issues"),
            Self::IssueComment => write!(f, "issue_comment"),
            Self::Label => write!(f, "label"),
            Self::Member => write!(f, "member"),
            Self::Membership => write!(f, "membership"),
            Self::MergeQueueEntry => write!(f, "merge_queue_entry"),
            Self::Milestone => write!(f, "milestone"),
            Self::Organization => write!(f, "organization"),
            Self::OrgBlock => write!(f, "org_block"),
            Self::PageBuild => write!(f, "page_build"),
            Self::Project => write!(f, "project"),
            Self::ProjectCard => write!(f, "project_card"),
            Self::ProjectColumn => write!(f, "project_column"),
            Self::Public => write!(f, "public"),
            Self::PullRequest => write!(f, "pull_request"),
            Self::PullRequestReview => write!(f, "pull_request_review"),
            Self::PullRequestReviewComment => write!(f, "pull_request_review_comment"),
            Self::Push => write!(f, "push"),
            Self::RegistryPackage => write!(f, "registry_package"),
            Self::Release => write!(f, "release"),
            Self::Repository => write!(f, "repository"),
            Self::RepositoryDispatch => write!(f, "repository_dispatch"),
            Self::SecretScanningAlert => write!(f, "secret_scanning_alert"),
            Self::Star => write!(f, "star"),
            Self::Status => write!(f, "status"),
            Self::Team => write!(f, "team"),
            Self::TeamAdd => write!(f, "team_add"),
            Self::Watch => write!(f, "watch"),
            Self::WorkflowDispatch => write!(f, "workflow_dispatch"),
            Self::WorkflowRun => write!(f, "workflow_run"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationEventsItem {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationSuspendInstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationSuspendInstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"checks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content_references\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"contents\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"emails\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"environments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"issues\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_plan\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_self_hosted_runners\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_user_blocking\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secret_scanning_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_scanning_alert\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"team_discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"vulnerability_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"workflows\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallationPermissions {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub actions: ::std::option::Option<InstallationSuspendInstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub administration:
        ::std::option::Option<InstallationSuspendInstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub checks: ::std::option::Option<InstallationSuspendInstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_references:
        ::std::option::Option<InstallationSuspendInstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub contents: ::std::option::Option<InstallationSuspendInstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployments: ::std::option::Option<InstallationSuspendInstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub discussions: ::std::option::Option<InstallationSuspendInstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub emails: ::std::option::Option<InstallationSuspendInstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub environments: ::std::option::Option<InstallationSuspendInstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub issues: ::std::option::Option<InstallationSuspendInstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub members: ::std::option::Option<InstallationSuspendInstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<InstallationSuspendInstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_administration:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_events:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_hooks:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_packages:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_plan:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_projects:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_secrets:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_self_hosted_runners: ::std::option::Option<
        InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_user_blocking:
        ::std::option::Option<InstallationSuspendInstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub packages: ::std::option::Option<InstallationSuspendInstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pages: ::std::option::Option<InstallationSuspendInstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_requests:
        ::std::option::Option<InstallationSuspendInstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_hooks:
        ::std::option::Option<InstallationSuspendInstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_projects:
        ::std::option::Option<InstallationSuspendInstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret_scanning_alerts:
        ::std::option::Option<InstallationSuspendInstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secrets: ::std::option::Option<InstallationSuspendInstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_events:
        ::std::option::Option<InstallationSuspendInstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_scanning_alert:
        ::std::option::Option<InstallationSuspendInstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub single_file: ::std::option::Option<InstallationSuspendInstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub statuses: ::std::option::Option<InstallationSuspendInstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub team_discussions:
        ::std::option::Option<InstallationSuspendInstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub vulnerability_alerts:
        ::std::option::Option<InstallationSuspendInstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub workflows: ::std::option::Option<InstallationSuspendInstallationPermissionsWorkflows>,
}
impl ::std::convert::From<&InstallationSuspendInstallationPermissions>
    for InstallationSuspendInstallationPermissions
{
    fn from(value: &InstallationSuspendInstallationPermissions) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InstallationSuspendInstallationPermissions {
    fn default() -> Self {
        Self {
            actions: Default::default(),
            administration: Default::default(),
            checks: Default::default(),
            content_references: Default::default(),
            contents: Default::default(),
            deployments: Default::default(),
            discussions: Default::default(),
            emails: Default::default(),
            environments: Default::default(),
            issues: Default::default(),
            members: Default::default(),
            metadata: Default::default(),
            organization_administration: Default::default(),
            organization_events: Default::default(),
            organization_hooks: Default::default(),
            organization_packages: Default::default(),
            organization_plan: Default::default(),
            organization_projects: Default::default(),
            organization_secrets: Default::default(),
            organization_self_hosted_runners: Default::default(),
            organization_user_blocking: Default::default(),
            packages: Default::default(),
            pages: Default::default(),
            pull_requests: Default::default(),
            repository_hooks: Default::default(),
            repository_projects: Default::default(),
            secret_scanning_alerts: Default::default(),
            secrets: Default::default(),
            security_events: Default::default(),
            security_scanning_alert: Default::default(),
            single_file: Default::default(),
            statuses: Default::default(),
            team_discussions: Default::default(),
            vulnerability_alerts: Default::default(),
            workflows: Default::default(),
        }
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsActions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsActions {
    fn from(value: &InstallationSuspendInstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsActions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsActions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsActions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsAdministration {
    fn from(value: &InstallationSuspendInstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsChecks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsChecks {
    fn from(value: &InstallationSuspendInstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsChecks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsChecks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsChecks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsChecks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsContentReferences`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsContentReferences {
    fn from(value: &InstallationSuspendInstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsContentReferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsContentReferences {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsContentReferences {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsContentReferences
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsContentReferences
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsContents {
    fn from(value: &InstallationSuspendInstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsContents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsContents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsContents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsDeployments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsDeployments {
    fn from(value: &InstallationSuspendInstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsDeployments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsDeployments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsDeployments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsDeployments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsDiscussions {
    fn from(value: &InstallationSuspendInstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsEmails`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsEmails {
    fn from(value: &InstallationSuspendInstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsEmails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsEmails {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsEmails
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsEmails
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsEnvironments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsEnvironments {
    fn from(value: &InstallationSuspendInstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsEnvironments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsEnvironments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsEnvironments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsEnvironments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsIssues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsIssues {
    fn from(value: &InstallationSuspendInstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsIssues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsIssues {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsIssues
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsIssues
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsMembers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsMembers {
    fn from(value: &InstallationSuspendInstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsMembers {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsMembers
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsMembers
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsMetadata`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsMetadata {
    fn from(value: &InstallationSuspendInstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsMetadata {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsMetadata
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsMetadata
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsOrganizationEvents {
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsOrganizationHooks {
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationPlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsOrganizationPlan {
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationPlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsOrganizationPlan {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationPlan
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationPlan
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(
        value: &InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsOrganizationUserBlocking`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationSuspendInstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsOrganizationUserBlocking {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsPackages {
    fn from(value: &InstallationSuspendInstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsPages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsPages {
    fn from(value: &InstallationSuspendInstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsPages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsPages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsPages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsPages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsPullRequests`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsPullRequests {
    fn from(value: &InstallationSuspendInstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsPullRequests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsPullRequests {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsPullRequests
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsPullRequests
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsRepositoryHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsRepositoryHooks {
    fn from(value: &InstallationSuspendInstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsRepositoryHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsRepositoryHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsRepositoryHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsRepositoryProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsRepositoryProjects {
    fn from(value: &InstallationSuspendInstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsRepositoryProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsRepositoryProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsSecretScanningAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsSecretScanningAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsSecrets {
    fn from(value: &InstallationSuspendInstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsSecurityEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsSecurityEvents {
    fn from(value: &InstallationSuspendInstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsSecurityEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsSecurityEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsSecurityEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsSecurityScanningAlert`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationSuspendInstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsSecurityScanningAlert {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsSingleFile`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsSingleFile {
    fn from(value: &InstallationSuspendInstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsSingleFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsSingleFile {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsSingleFile
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsSingleFile
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsStatuses`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsStatuses {
    fn from(value: &InstallationSuspendInstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsStatuses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsStatuses {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsStatuses
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsStatuses
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsTeamDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsTeamDiscussions {
    fn from(value: &InstallationSuspendInstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsTeamDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsTeamDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsTeamDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsVulnerabilityAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    fn from(value: &InstallationSuspendInstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsVulnerabilityAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationPermissionsWorkflows`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationPermissionsWorkflows {
    fn from(value: &InstallationSuspendInstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationPermissionsWorkflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationPermissionsWorkflows {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationPermissionsWorkflows
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationPermissionsWorkflows
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"selected\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationRepositorySelection {
    fn from(value: &InstallationSuspendInstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationRepositorySelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Selected => write!(f, "selected"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationRepositorySelection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationSuspendedBy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"node_id\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"Bot\","]
#[doc = "            \"User\","]
#[doc = "            \"Organization\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendInstallationSuspendedBy {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: InstallationSuspendInstallationSuspendedByType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&InstallationSuspendInstallationSuspendedBy>
    for InstallationSuspendInstallationSuspendedBy
{
    fn from(value: &InstallationSuspendInstallationSuspendedBy) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationSuspendInstallationSuspendedByType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationSuspendedByType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationSuspendedByType {
    fn from(value: &InstallationSuspendInstallationSuspendedByType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationSuspendedByType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationSuspendedByType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationSuspendedByType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationSuspendInstallationSuspendedByType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationSuspendInstallationSuspendedByType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationTargetType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationSuspendInstallationTargetType {
    User,
    Organization,
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationTargetType {
    fn from(value: &InstallationSuspendInstallationTargetType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationTargetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationTargetType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationSuspendInstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationSuspendInstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationSuspendInstallationUpdatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationSuspendInstallationUpdatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationSuspendInstallationUpdatedAt {
    fn from(value: &InstallationSuspendInstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationSuspendInstallationUpdatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationSuspendInstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationSuspendInstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationSuspendInstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationSuspendInstallationUpdatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for InstallationSuspendInstallationUpdatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationSuspendInstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`InstallationSuspendRepositoriesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendRepositoriesItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationSuspendRepositoriesItem>
    for InstallationSuspendRepositoriesItem
{
    fn from(value: &InstallationSuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationTargetType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationTargetType {
    User,
    Organization,
}
impl ::std::convert::From<&Self> for InstallationTargetType {
    fn from(value: &InstallationTargetType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationTargetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for InstallationTargetType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspend`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"installation unsuspend event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"installation\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unsuspend\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/installation\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"suspended_at\","]
#[doc = "            \"suspended_by\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"suspended_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"suspended_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repositories\": {"]
#[doc = "      \"description\": \"An array of repository objects that the installation can access.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"full_name\","]
#[doc = "          \"id\","]
#[doc = "          \"name\","]
#[doc = "          \"node_id\","]
#[doc = "          \"private\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"full_name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"description\": \"Unique identifier of the repository\","]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"description\": \"The name of the repository.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"node_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"private\": {"]
#[doc = "            \"description\": \"Whether the repository is private or public.\","]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requester\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspend {
    pub action: InstallationUnsuspendAction,
    pub installation: InstallationUnsuspendInstallation,
    #[doc = "An array of repository objects that the installation can access."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub repositories: ::std::vec::Vec<InstallationUnsuspendRepositoriesItem>,
    #[serde(default)]
    pub requester: (),
    pub sender: User,
}
impl ::std::convert::From<&InstallationUnsuspend> for InstallationUnsuspend {
    fn from(value: &InstallationUnsuspend) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationUnsuspendAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unsuspend\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendAction {
    #[serde(rename = "unsuspend")]
    Unsuspend,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendAction {
    fn from(value: &InstallationUnsuspendAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unsuspend => write!(f, "unsuspend"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unsuspend" => Ok(Self::Unsuspend),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationUnsuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationUnsuspendAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/installation\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"suspended_at\","]
#[doc = "        \"suspended_by\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"suspended_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"suspended_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendInstallation {
    pub access_tokens_url: ::std::string::String,
    pub account: User,
    pub app_id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub app_slug: ::std::option::Option<::std::string::String>,
    pub created_at: InstallationUnsuspendInstallationCreatedAt,
    pub events: ::std::vec::Vec<InstallationUnsuspendInstallationEventsItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub has_multiple_single_files: ::std::option::Option<bool>,
    pub html_url: ::std::string::String,
    #[doc = "The ID of the installation."]
    pub id: i64,
    pub permissions: InstallationUnsuspendInstallationPermissions,
    pub repositories_url: ::std::string::String,
    #[doc = "Describe whether all repositories have been selected or there's a selection involved"]
    pub repository_selection: InstallationUnsuspendInstallationRepositorySelection,
    pub single_file_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub single_file_paths: ::std::vec::Vec<::std::string::String>,
    pub suspended_at: (),
    pub suspended_by: (),
    #[doc = "The ID of the user or organization this token is being scoped to."]
    pub target_id: i64,
    pub target_type: InstallationUnsuspendInstallationTargetType,
    pub updated_at: InstallationUnsuspendInstallationUpdatedAt,
}
impl ::std::convert::From<&InstallationUnsuspendInstallation>
    for InstallationUnsuspendInstallation
{
    fn from(value: &InstallationUnsuspendInstallation) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationUnsuspendInstallationCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationUnsuspendInstallationCreatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationCreatedAt {
    fn from(value: &InstallationUnsuspendInstallationCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationCreatedAt
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationUnsuspendInstallationCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for InstallationUnsuspendInstallationCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationUnsuspendInstallationCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`InstallationUnsuspendInstallationEventsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"check_run\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"code_scanning_alert\","]
#[doc = "    \"commit_comment\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"create\","]
#[doc = "    \"delete\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_review\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"deploy_key\","]
#[doc = "    \"discussion\","]
#[doc = "    \"discussion_comment\","]
#[doc = "    \"fork\","]
#[doc = "    \"gollum\","]
#[doc = "    \"issues\","]
#[doc = "    \"issue_comment\","]
#[doc = "    \"label\","]
#[doc = "    \"member\","]
#[doc = "    \"membership\","]
#[doc = "    \"merge_queue_entry\","]
#[doc = "    \"milestone\","]
#[doc = "    \"organization\","]
#[doc = "    \"org_block\","]
#[doc = "    \"page_build\","]
#[doc = "    \"project\","]
#[doc = "    \"project_card\","]
#[doc = "    \"project_column\","]
#[doc = "    \"public\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"pull_request_review\","]
#[doc = "    \"pull_request_review_comment\","]
#[doc = "    \"push\","]
#[doc = "    \"registry_package\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"repository_dispatch\","]
#[doc = "    \"secret_scanning_alert\","]
#[doc = "    \"star\","]
#[doc = "    \"status\","]
#[doc = "    \"team\","]
#[doc = "    \"team_add\","]
#[doc = "    \"watch\","]
#[doc = "    \"workflow_dispatch\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationEventsItem {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "merge_queue_entry")]
    MergeQueueEntry,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationEventsItem {
    fn from(value: &InstallationUnsuspendInstallationEventsItem) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationEventsItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CheckRun => write!(f, "check_run"),
            Self::CheckSuite => write!(f, "check_suite"),
            Self::CodeScanningAlert => write!(f, "code_scanning_alert"),
            Self::CommitComment => write!(f, "commit_comment"),
            Self::ContentReference => write!(f, "content_reference"),
            Self::Create => write!(f, "create"),
            Self::Delete => write!(f, "delete"),
            Self::Deployment => write!(f, "deployment"),
            Self::DeploymentReview => write!(f, "deployment_review"),
            Self::DeploymentStatus => write!(f, "deployment_status"),
            Self::DeployKey => write!(f, "deploy_key"),
            Self::Discussion => write!(f, "discussion"),
            Self::DiscussionComment => write!(f, "discussion_comment"),
            Self::Fork => write!(f, "fork"),
            Self::Gollum => write!(f, "gollum"),
            Self::Issues => write!(f, "issues"),
            Self::IssueComment => write!(f, "issue_comment"),
            Self::Label => write!(f, "label"),
            Self::Member => write!(f, "member"),
            Self::Membership => write!(f, "membership"),
            Self::MergeQueueEntry => write!(f, "merge_queue_entry"),
            Self::Milestone => write!(f, "milestone"),
            Self::Organization => write!(f, "organization"),
            Self::OrgBlock => write!(f, "org_block"),
            Self::PageBuild => write!(f, "page_build"),
            Self::Project => write!(f, "project"),
            Self::ProjectCard => write!(f, "project_card"),
            Self::ProjectColumn => write!(f, "project_column"),
            Self::Public => write!(f, "public"),
            Self::PullRequest => write!(f, "pull_request"),
            Self::PullRequestReview => write!(f, "pull_request_review"),
            Self::PullRequestReviewComment => write!(f, "pull_request_review_comment"),
            Self::Push => write!(f, "push"),
            Self::RegistryPackage => write!(f, "registry_package"),
            Self::Release => write!(f, "release"),
            Self::Repository => write!(f, "repository"),
            Self::RepositoryDispatch => write!(f, "repository_dispatch"),
            Self::SecretScanningAlert => write!(f, "secret_scanning_alert"),
            Self::Star => write!(f, "star"),
            Self::Status => write!(f, "status"),
            Self::Team => write!(f, "team"),
            Self::TeamAdd => write!(f, "team_add"),
            Self::Watch => write!(f, "watch"),
            Self::WorkflowDispatch => write!(f, "workflow_dispatch"),
            Self::WorkflowRun => write!(f, "workflow_run"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationEventsItem {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "merge_queue_entry" => Ok(Self::MergeQueueEntry),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationEventsItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationEventsItem
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationEventsItem
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"checks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content_references\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"contents\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deployments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"emails\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"environments\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"issues\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_administration\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_plan\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_self_hosted_runners\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization_user_blocking\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"packages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pages\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_hooks\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository_projects\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secret_scanning_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"secrets\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_events\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_scanning_alert\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"single_file\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"team_discussions\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"vulnerability_alerts\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"workflows\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"read\","]
#[doc = "        \"write\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendInstallationPermissions {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub actions: ::std::option::Option<InstallationUnsuspendInstallationPermissionsActions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub administration:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsAdministration>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub checks: ::std::option::Option<InstallationUnsuspendInstallationPermissionsChecks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_references:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsContentReferences>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub contents: ::std::option::Option<InstallationUnsuspendInstallationPermissionsContents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deployments: ::std::option::Option<InstallationUnsuspendInstallationPermissionsDeployments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub discussions: ::std::option::Option<InstallationUnsuspendInstallationPermissionsDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub emails: ::std::option::Option<InstallationUnsuspendInstallationPermissionsEmails>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub environments:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsEnvironments>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub issues: ::std::option::Option<InstallationUnsuspendInstallationPermissionsIssues>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub members: ::std::option::Option<InstallationUnsuspendInstallationPermissionsMembers>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<InstallationUnsuspendInstallationPermissionsMetadata>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_administration: ::std::option::Option<
        InstallationUnsuspendInstallationPermissionsOrganizationAdministration,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_events:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_hooks:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_packages:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_plan:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationPlan>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_projects:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_secrets:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_self_hosted_runners: ::std::option::Option<
        InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization_user_blocking:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub packages: ::std::option::Option<InstallationUnsuspendInstallationPermissionsPackages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pages: ::std::option::Option<InstallationUnsuspendInstallationPermissionsPages>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_requests:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsPullRequests>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_hooks:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsRepositoryHooks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository_projects:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsRepositoryProjects>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret_scanning_alerts:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsSecretScanningAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secrets: ::std::option::Option<InstallationUnsuspendInstallationPermissionsSecrets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_events:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsSecurityEvents>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub security_scanning_alert:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsSecurityScanningAlert>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub single_file: ::std::option::Option<InstallationUnsuspendInstallationPermissionsSingleFile>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub statuses: ::std::option::Option<InstallationUnsuspendInstallationPermissionsStatuses>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub team_discussions:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsTeamDiscussions>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub vulnerability_alerts:
        ::std::option::Option<InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub workflows: ::std::option::Option<InstallationUnsuspendInstallationPermissionsWorkflows>,
}
impl ::std::convert::From<&InstallationUnsuspendInstallationPermissions>
    for InstallationUnsuspendInstallationPermissions
{
    fn from(value: &InstallationUnsuspendInstallationPermissions) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InstallationUnsuspendInstallationPermissions {
    fn default() -> Self {
        Self {
            actions: Default::default(),
            administration: Default::default(),
            checks: Default::default(),
            content_references: Default::default(),
            contents: Default::default(),
            deployments: Default::default(),
            discussions: Default::default(),
            emails: Default::default(),
            environments: Default::default(),
            issues: Default::default(),
            members: Default::default(),
            metadata: Default::default(),
            organization_administration: Default::default(),
            organization_events: Default::default(),
            organization_hooks: Default::default(),
            organization_packages: Default::default(),
            organization_plan: Default::default(),
            organization_projects: Default::default(),
            organization_secrets: Default::default(),
            organization_self_hosted_runners: Default::default(),
            organization_user_blocking: Default::default(),
            packages: Default::default(),
            pages: Default::default(),
            pull_requests: Default::default(),
            repository_hooks: Default::default(),
            repository_projects: Default::default(),
            secret_scanning_alerts: Default::default(),
            secrets: Default::default(),
            security_events: Default::default(),
            security_scanning_alert: Default::default(),
            single_file: Default::default(),
            statuses: Default::default(),
            team_discussions: Default::default(),
            vulnerability_alerts: Default::default(),
            workflows: Default::default(),
        }
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsActions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsActions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsActions {
    fn from(value: &InstallationUnsuspendInstallationPermissionsActions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsActions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsActions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsActions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsActions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsAdministration {
    fn from(value: &InstallationUnsuspendInstallationPermissionsAdministration) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsAdministration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsAdministration {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsAdministration {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsChecks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsChecks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsChecks {
    fn from(value: &InstallationUnsuspendInstallationPermissionsChecks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsChecks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsChecks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsChecks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsChecks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsChecks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsContentReferences`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsContentReferences {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsContentReferences {
    fn from(value: &InstallationUnsuspendInstallationPermissionsContentReferences) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsContentReferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsContentReferences {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsContentReferences
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsContents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsContents {
    fn from(value: &InstallationUnsuspendInstallationPermissionsContents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsContents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsContents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsContents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsContents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsDeployments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsDeployments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsDeployments {
    fn from(value: &InstallationUnsuspendInstallationPermissionsDeployments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsDeployments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsDeployments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsDeployments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsDeployments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsDeployments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsDiscussions {
    fn from(value: &InstallationUnsuspendInstallationPermissionsDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsEmails`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsEmails {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsEmails {
    fn from(value: &InstallationUnsuspendInstallationPermissionsEmails) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsEmails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsEmails {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsEmails {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsEmails
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsEmails
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsEnvironments`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsEnvironments {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsEnvironments {
    fn from(value: &InstallationUnsuspendInstallationPermissionsEnvironments) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsEnvironments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsEnvironments {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsEnvironments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsEnvironments
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsIssues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsIssues {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsIssues {
    fn from(value: &InstallationUnsuspendInstallationPermissionsIssues) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsIssues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsIssues {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsIssues {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsIssues
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsIssues
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsMembers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsMembers {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsMembers {
    fn from(value: &InstallationUnsuspendInstallationPermissionsMembers) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsMembers {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsMembers {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsMembers
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsMembers
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsMetadata`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsMetadata {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsMetadata {
    fn from(value: &InstallationUnsuspendInstallationPermissionsMetadata) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsMetadata {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsMetadata {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsMetadata
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsMetadata
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationAdministration`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationAdministration {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    fn from(
        value: &InstallationUnsuspendInstallationPermissionsOrganizationAdministration,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationAdministration
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationPlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationPlan) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationPlan {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationPlan
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn from(
        value: &InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationSelfHostedRunners
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsOrganizationUserBlocking
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsPackages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsPackages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsPackages {
    fn from(value: &InstallationUnsuspendInstallationPermissionsPackages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsPackages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsPackages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPackages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPackages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsPages`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsPages {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsPages {
    fn from(value: &InstallationUnsuspendInstallationPermissionsPages) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsPages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsPages {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPages {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPages
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsPullRequests`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsPullRequests {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsPullRequests {
    fn from(value: &InstallationUnsuspendInstallationPermissionsPullRequests) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsPullRequests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsPullRequests {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPullRequests
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsPullRequests
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsRepositoryHooks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    fn from(value: &InstallationUnsuspendInstallationPermissionsRepositoryHooks) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsRepositoryHooks {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsRepositoryHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsRepositoryHooks
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsRepositoryProjects`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsRepositoryProjects) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsRepositoryProjects {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsRepositoryProjects
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsSecretScanningAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecretScanningAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecretScanningAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsSecrets`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsSecrets {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsSecrets {
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecrets) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsSecrets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecrets {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSecrets {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecrets
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsSecurityEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsSecurityEvents {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecurityEvents) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSecurityEvents {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecurityEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecurityEvents
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsSecurityScanningAlert`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsSecurityScanningAlert) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSecurityScanningAlert
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsSingleFile`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsSingleFile {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsSingleFile {
    fn from(value: &InstallationUnsuspendInstallationPermissionsSingleFile) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsSingleFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsSingleFile {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSingleFile
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsSingleFile
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsStatuses`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsStatuses {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsStatuses {
    fn from(value: &InstallationUnsuspendInstallationPermissionsStatuses) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsStatuses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsStatuses {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsStatuses {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsStatuses
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsStatuses
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsTeamDiscussions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    fn from(value: &InstallationUnsuspendInstallationPermissionsTeamDiscussions) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsTeamDiscussions {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsTeamDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsTeamDiscussions
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    fn from(value: &InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsVulnerabilityAlerts
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationPermissionsWorkflows`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"read\","]
#[doc = "    \"write\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationPermissionsWorkflows {
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "write")]
    Write,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationPermissionsWorkflows {
    fn from(value: &InstallationUnsuspendInstallationPermissionsWorkflows) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationPermissionsWorkflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationPermissionsWorkflows {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationPermissionsWorkflows
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationPermissionsWorkflows
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Describe whether all repositories have been selected or there's a selection involved"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describe whether all repositories have been selected or there's a selection involved\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"selected\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationRepositorySelection {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "selected")]
    Selected,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationRepositorySelection {
    fn from(value: &InstallationUnsuspendInstallationRepositorySelection) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationRepositorySelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Selected => write!(f, "selected"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationRepositorySelection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "selected" => Ok(Self::Selected),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationRepositorySelection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationRepositorySelection
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationTargetType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InstallationUnsuspendInstallationTargetType {
    User,
    Organization,
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationTargetType {
    fn from(value: &InstallationUnsuspendInstallationTargetType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationTargetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationTargetType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationTargetType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationTargetType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for InstallationUnsuspendInstallationTargetType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`InstallationUnsuspendInstallationUpdatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationUnsuspendInstallationUpdatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationUnsuspendInstallationUpdatedAt {
    fn from(value: &InstallationUnsuspendInstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationUnsuspendInstallationUpdatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUnsuspendInstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for InstallationUnsuspendInstallationUpdatedAt
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationUnsuspendInstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationUnsuspendInstallationUpdatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for InstallationUnsuspendInstallationUpdatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationUnsuspendInstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`InstallationUnsuspendRepositoriesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_name\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"private\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendRepositoriesItem {
    pub full_name: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
}
impl ::std::convert::From<&InstallationUnsuspendRepositoriesItem>
    for InstallationUnsuspendRepositoriesItem
{
    fn from(value: &InstallationUnsuspendRepositoriesItem) -> Self {
        value.clone()
    }
}
#[doc = "`InstallationUpdatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InstallationUpdatedAt {
    Variant0(::chrono::DateTime<::chrono::offset::Utc>),
    Variant1(i64),
}
impl ::std::convert::From<&Self> for InstallationUpdatedAt {
    fn from(value: &InstallationUpdatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for InstallationUpdatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for InstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InstallationUpdatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for InstallationUpdatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for InstallationUpdatedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<i64> for InstallationUpdatedAt {
    fn from(value: i64) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Issue\","]
#[doc = "  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"events_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"labels_url\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"repository_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"Contents of the issue\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"comments\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"labels_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"performed_via_github_app\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"diff_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"patch_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Title of the issue\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the issue\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Issue {
    pub active_lock_reason: ::std::option::Option<IssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuePullRequest>,
    pub repository_url: ::std::string::String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub state: ::std::option::Option<IssueState>,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&Issue> for Issue {
    fn from(value: &Issue) -> Self {
        value.clone()
    }
}
#[doc = "`IssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssueActiveLockReason {
    fn from(value: &IssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issue comment\","]
#[doc = "  \"description\": \"The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"created_at\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"node_id\","]
#[doc = "    \"performed_via_github_app\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"Contents of the issue comment\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the issue comment\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"performed_via_github_app\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/app\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the issue comment\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueComment {
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue comment"]
    pub body: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the issue comment"]
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub node_id: ::std::string::String,
    pub performed_via_github_app: ::std::option::Option<App>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue comment"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssueComment> for IssueComment {
    fn from(value: &IssueComment) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issue_comment created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"assignee\","]
#[doc = "            \"labels\","]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"assignee\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"labels\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/label\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"diff_url\","]
#[doc = "                \"html_url\","]
#[doc = "                \"patch_url\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"diff_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"html_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"patch_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\","]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreated {
    pub action: IssueCommentCreatedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssueCommentCreatedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssueCommentCreated> for IssueCommentCreated {
    fn from(value: &IssueCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for IssueCommentCreatedAction {
    fn from(value: &IssueCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"assignee\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"diff_url\","]
#[doc = "            \"html_url\","]
#[doc = "            \"patch_url\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"diff_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"patch_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssue {
    pub active_lock_reason: ::std::option::Option<IssueCommentCreatedIssueActiveLockReason>,
    pub assignee: ::std::option::Option<IssueCommentCreatedIssueAssignee>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    pub locked: bool,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssueCommentCreatedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssueCommentCreatedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssueCommentCreatedIssue> for IssueCommentCreatedIssue {
    fn from(value: &IssueCommentCreatedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentCreatedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentCreatedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssueCommentCreatedIssueActiveLockReason {
    fn from(value: &IssueCommentCreatedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentCreatedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentCreatedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentCreatedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentCreatedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentCreatedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentCreatedIssueAssignee`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssueAssignee {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: IssueCommentCreatedIssueAssigneeType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentCreatedIssueAssignee> for IssueCommentCreatedIssueAssignee {
    fn from(value: &IssueCommentCreatedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentCreatedIssueAssigneeType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentCreatedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for IssueCommentCreatedIssueAssigneeType {
    fn from(value: &IssueCommentCreatedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentCreatedIssueAssigneeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentCreatedIssueAssigneeType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentCreatedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentCreatedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentCreatedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentCreatedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"diff_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreatedIssuePullRequest {
    pub diff_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub patch_url: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentCreatedIssuePullRequest>
    for IssueCommentCreatedIssuePullRequest
{
    fn from(value: &IssueCommentCreatedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentCreatedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentCreatedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssueCommentCreatedIssueState {
    fn from(value: &IssueCommentCreatedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentCreatedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentCreatedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentCreatedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentCreatedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentCreatedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issue_comment deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"assignee\","]
#[doc = "            \"labels\","]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"assignee\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"labels\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/label\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"diff_url\","]
#[doc = "                \"html_url\","]
#[doc = "                \"patch_url\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"diff_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"html_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"patch_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\","]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeleted {
    pub action: IssueCommentDeletedAction,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssueCommentDeletedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssueCommentDeleted> for IssueCommentDeleted {
    fn from(value: &IssueCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for IssueCommentDeletedAction {
    fn from(value: &IssueCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"assignee\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"diff_url\","]
#[doc = "            \"html_url\","]
#[doc = "            \"patch_url\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"diff_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"patch_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssue {
    pub active_lock_reason: ::std::option::Option<IssueCommentDeletedIssueActiveLockReason>,
    pub assignee: ::std::option::Option<IssueCommentDeletedIssueAssignee>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    pub locked: bool,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssueCommentDeletedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssueCommentDeletedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssueCommentDeletedIssue> for IssueCommentDeletedIssue {
    fn from(value: &IssueCommentDeletedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentDeletedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentDeletedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssueCommentDeletedIssueActiveLockReason {
    fn from(value: &IssueCommentDeletedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentDeletedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentDeletedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentDeletedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentDeletedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentDeletedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentDeletedIssueAssignee`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssueAssignee {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: IssueCommentDeletedIssueAssigneeType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentDeletedIssueAssignee> for IssueCommentDeletedIssueAssignee {
    fn from(value: &IssueCommentDeletedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentDeletedIssueAssigneeType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentDeletedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for IssueCommentDeletedIssueAssigneeType {
    fn from(value: &IssueCommentDeletedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentDeletedIssueAssigneeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentDeletedIssueAssigneeType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentDeletedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentDeletedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentDeletedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentDeletedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"diff_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeletedIssuePullRequest {
    pub diff_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub patch_url: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentDeletedIssuePullRequest>
    for IssueCommentDeletedIssuePullRequest
{
    fn from(value: &IssueCommentDeletedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentDeletedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentDeletedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssueCommentDeletedIssueState {
    fn from(value: &IssueCommentDeletedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentDeletedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentDeletedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentDeletedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentDeletedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentDeletedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issue_comment edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"comment\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the comment.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"assignee\","]
#[doc = "            \"labels\","]
#[doc = "            \"locked\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"assignee\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"labels\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/label\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"diff_url\","]
#[doc = "                \"html_url\","]
#[doc = "                \"patch_url\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"diff_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"html_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"patch_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\","]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEdited {
    pub action: IssueCommentEditedAction,
    pub changes: IssueCommentEditedChanges,
    pub comment: IssueComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssueCommentEditedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssueCommentEdited> for IssueCommentEdited {
    fn from(value: &IssueCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for IssueCommentEditedAction {
    fn from(value: &IssueCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the comment.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<IssueCommentEditedChangesBody>,
}
impl ::std::convert::From<&IssueCommentEditedChanges> for IssueCommentEditedChanges {
    fn from(value: &IssueCommentEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssueCommentEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
        }
    }
}
#[doc = "`IssueCommentEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentEditedChangesBody> for IssueCommentEditedChangesBody {
    fn from(value: &IssueCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"assignee\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"diff_url\","]
#[doc = "            \"html_url\","]
#[doc = "            \"patch_url\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"diff_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"patch_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssue {
    pub active_lock_reason: ::std::option::Option<IssueCommentEditedIssueActiveLockReason>,
    pub assignee: ::std::option::Option<IssueCommentEditedIssueAssignee>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    pub locked: bool,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssueCommentEditedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssueCommentEditedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssueCommentEditedIssue> for IssueCommentEditedIssue {
    fn from(value: &IssueCommentEditedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentEditedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentEditedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssueCommentEditedIssueActiveLockReason {
    fn from(value: &IssueCommentEditedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentEditedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentEditedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentEditedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentEditedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentEditedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentEditedIssueAssignee`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssueAssignee {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: IssueCommentEditedIssueAssigneeType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentEditedIssueAssignee> for IssueCommentEditedIssueAssignee {
    fn from(value: &IssueCommentEditedIssueAssignee) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentEditedIssueAssigneeType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentEditedIssueAssigneeType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for IssueCommentEditedIssueAssigneeType {
    fn from(value: &IssueCommentEditedIssueAssigneeType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentEditedIssueAssigneeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentEditedIssueAssigneeType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentEditedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentEditedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentEditedIssueAssigneeType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentEditedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"diff_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedIssuePullRequest {
    pub diff_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub patch_url: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssueCommentEditedIssuePullRequest>
    for IssueCommentEditedIssuePullRequest
{
    fn from(value: &IssueCommentEditedIssuePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`IssueCommentEditedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueCommentEditedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssueCommentEditedIssueState {
    fn from(value: &IssueCommentEditedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueCommentEditedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssueCommentEditedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueCommentEditedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueCommentEditedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueCommentEditedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssueCommentEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue_comment$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue_comment$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue_comment$edited\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IssueCommentEvent {
    Created(IssueCommentCreated),
    Deleted(IssueCommentDeleted),
    Edited(IssueCommentEdited),
}
impl ::std::convert::From<&Self> for IssueCommentEvent {
    fn from(value: &IssueCommentEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<IssueCommentCreated> for IssueCommentEvent {
    fn from(value: IssueCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<IssueCommentDeleted> for IssueCommentEvent {
    fn from(value: IssueCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<IssueCommentEdited> for IssueCommentEvent {
    fn from(value: IssueCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "`IssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuePullRequest> for IssuePullRequest {
    fn from(value: &IssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssueState {
    fn from(value: &IssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Activity related to an issue. The type of activity is specified in the action property."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues assigned event\","]
#[doc = "  \"description\": \"Activity related to an issue. The type of activity is specified in the action property.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The action that was performed.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"assigned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"description\": \"The optional user who was assigned or unassigned from the issue.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesAssigned {
    #[doc = "The action that was performed."]
    pub action: IssuesAssignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesAssigned> for IssuesAssigned {
    fn from(value: &IssuesAssigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action that was performed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"assigned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl ::std::convert::From<&Self> for IssuesAssignedAction {
    fn from(value: &IssuesAssignedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesAssignedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Assigned => write!(f, "assigned"),
        }
    }
}
impl ::std::str::FromStr for IssuesAssignedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesClosed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues closed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The action that was performed.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosed {
    #[doc = "The action that was performed."]
    pub action: IssuesClosedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesClosedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesClosed> for IssuesClosed {
    fn from(value: &IssuesClosed) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action that was performed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesClosedAction {
    fn from(value: &IssuesClosedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesClosedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesClosedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [issue](https://docs.github.com/en/rest/reference/issues) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [issue](https://docs.github.com/en/rest/reference/issues) itself.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesClosedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesClosedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssuesClosedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesClosedIssue> for IssuesClosedIssue {
    fn from(value: &IssuesClosedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesClosedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesClosedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesClosedIssueActiveLockReason {
    fn from(value: &IssuesClosedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesClosedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesClosedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesClosedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesClosedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesClosedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesClosedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesClosedIssuePullRequest> for IssuesClosedIssuePullRequest {
    fn from(value: &IssuesClosedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesClosedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "`IssuesClosedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesClosedIssueState {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesClosedIssueState {
    fn from(value: &IssuesClosedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesClosedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesClosedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesClosedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesClosedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesClosedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesDeleted {
    pub action: IssuesDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesDeleted> for IssuesDeleted {
    fn from(value: &IssuesDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for IssuesDeletedAction {
    fn from(value: &IssuesDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for IssuesDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesDemilestoned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues demilestoned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"demilestoned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"milestone\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"milestone\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestoned {
    pub action: IssuesDemilestonedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesDemilestonedIssue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesDemilestoned> for IssuesDemilestoned {
    fn from(value: &IssuesDemilestoned) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesDemilestonedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"demilestoned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesDemilestonedAction {
    #[serde(rename = "demilestoned")]
    Demilestoned,
}
impl ::std::convert::From<&Self> for IssuesDemilestonedAction {
    fn from(value: &IssuesDemilestonedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesDemilestonedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Demilestoned => write!(f, "demilestoned"),
        }
    }
}
impl ::std::str::FromStr for IssuesDemilestonedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "demilestoned" => Ok(Self::Demilestoned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesDemilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesDemilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesDemilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesDemilestonedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"milestone\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"milestone\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestonedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesDemilestonedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: (),
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesDemilestonedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub state: ::std::option::Option<IssuesDemilestonedIssueState>,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesDemilestonedIssue> for IssuesDemilestonedIssue {
    fn from(value: &IssuesDemilestonedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesDemilestonedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesDemilestonedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesDemilestonedIssueActiveLockReason {
    fn from(value: &IssuesDemilestonedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesDemilestonedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesDemilestonedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesDemilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesDemilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesDemilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesDemilestonedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestonedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesDemilestonedIssuePullRequest>
    for IssuesDemilestonedIssuePullRequest
{
    fn from(value: &IssuesDemilestonedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesDemilestonedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesDemilestonedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesDemilestonedIssueState {
    fn from(value: &IssuesDemilestonedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesDemilestonedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesDemilestonedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesDemilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesDemilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesDemilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the issue.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the title.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesEdited {
    pub action: IssuesEditedAction,
    pub changes: IssuesEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub label: ::std::option::Option<Label>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesEdited> for IssuesEdited {
    fn from(value: &IssuesEdited) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for IssuesEditedAction {
    fn from(value: &IssuesEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for IssuesEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the issue."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the issue.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the title.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<IssuesEditedChangesBody>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<IssuesEditedChangesTitle>,
}
impl ::std::convert::From<&IssuesEditedChanges> for IssuesEditedChanges {
    fn from(value: &IssuesEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`IssuesEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&IssuesEditedChangesBody> for IssuesEditedChangesBody {
    fn from(value: &IssuesEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesEditedChangesTitle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the title.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesTitle {
    #[doc = "The previous version of the title."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&IssuesEditedChangesTitle> for IssuesEditedChangesTitle {
    fn from(value: &IssuesEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$assigned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$closed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$demilestoned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$labeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$locked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$milestoned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$opened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$pinned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$reopened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$transferred\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$unassigned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$unlabeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$unlocked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issues$unpinned\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IssuesEvent {
    Assigned(IssuesAssigned),
    Closed(IssuesClosed),
    Deleted(IssuesDeleted),
    Demilestoned(IssuesDemilestoned),
    Edited(IssuesEdited),
    Labeled(IssuesLabeled),
    Locked(IssuesLocked),
    Milestoned(IssuesMilestoned),
    Opened(IssuesOpened),
    Pinned(IssuesPinned),
    Reopened(IssuesReopened),
    Transferred(IssuesTransferred),
    Unassigned(IssuesUnassigned),
    Unlabeled(IssuesUnlabeled),
    Unlocked(IssuesUnlocked),
    Unpinned(IssuesUnpinned),
}
impl ::std::convert::From<&Self> for IssuesEvent {
    fn from(value: &IssuesEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<IssuesAssigned> for IssuesEvent {
    fn from(value: IssuesAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl ::std::convert::From<IssuesClosed> for IssuesEvent {
    fn from(value: IssuesClosed) -> Self {
        Self::Closed(value)
    }
}
impl ::std::convert::From<IssuesDeleted> for IssuesEvent {
    fn from(value: IssuesDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<IssuesDemilestoned> for IssuesEvent {
    fn from(value: IssuesDemilestoned) -> Self {
        Self::Demilestoned(value)
    }
}
impl ::std::convert::From<IssuesEdited> for IssuesEvent {
    fn from(value: IssuesEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<IssuesLabeled> for IssuesEvent {
    fn from(value: IssuesLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl ::std::convert::From<IssuesLocked> for IssuesEvent {
    fn from(value: IssuesLocked) -> Self {
        Self::Locked(value)
    }
}
impl ::std::convert::From<IssuesMilestoned> for IssuesEvent {
    fn from(value: IssuesMilestoned) -> Self {
        Self::Milestoned(value)
    }
}
impl ::std::convert::From<IssuesOpened> for IssuesEvent {
    fn from(value: IssuesOpened) -> Self {
        Self::Opened(value)
    }
}
impl ::std::convert::From<IssuesPinned> for IssuesEvent {
    fn from(value: IssuesPinned) -> Self {
        Self::Pinned(value)
    }
}
impl ::std::convert::From<IssuesReopened> for IssuesEvent {
    fn from(value: IssuesReopened) -> Self {
        Self::Reopened(value)
    }
}
impl ::std::convert::From<IssuesTransferred> for IssuesEvent {
    fn from(value: IssuesTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl ::std::convert::From<IssuesUnassigned> for IssuesEvent {
    fn from(value: IssuesUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl ::std::convert::From<IssuesUnlabeled> for IssuesEvent {
    fn from(value: IssuesUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl ::std::convert::From<IssuesUnlocked> for IssuesEvent {
    fn from(value: IssuesUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
impl ::std::convert::From<IssuesUnpinned> for IssuesEvent {
    fn from(value: IssuesUnpinned) -> Self {
        Self::Unpinned(value)
    }
}
#[doc = "`IssuesLabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues labeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"labeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label that was added to the issue.\","]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesLabeled {
    pub action: IssuesLabeledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was added to the issue."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub label: ::std::option::Option<Label>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesLabeled> for IssuesLabeled {
    fn from(value: &IssuesLabeled) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesLabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"labeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl ::std::convert::From<&Self> for IssuesLabeledAction {
    fn from(value: &IssuesLabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesLabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Labeled => write!(f, "labeled"),
        }
    }
}
impl ::std::str::FromStr for IssuesLabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesLocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues locked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"locked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"active_lock_reason\","]
#[doc = "            \"locked\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"active_lock_reason\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ],"]
#[doc = "              \"enum\": ["]
#[doc = "                \"resolved\","]
#[doc = "                \"off-topic\","]
#[doc = "                \"too heated\","]
#[doc = "                \"spam\","]
#[doc = "                null"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesLocked {
    pub action: IssuesLockedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesLockedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesLocked> for IssuesLocked {
    fn from(value: &IssuesLocked) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesLockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"locked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl ::std::convert::From<&Self> for IssuesLockedAction {
    fn from(value: &IssuesLockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesLockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Locked => write!(f, "locked"),
        }
    }
}
impl ::std::str::FromStr for IssuesLockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesLockedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"locked\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"resolved\","]
#[doc = "            \"off-topic\","]
#[doc = "            \"too heated\","]
#[doc = "            \"spam\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesLockedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesLockedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    pub locked: bool,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesLockedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub state: ::std::option::Option<IssuesLockedIssueState>,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesLockedIssue> for IssuesLockedIssue {
    fn from(value: &IssuesLockedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesLockedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesLockedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesLockedIssueActiveLockReason {
    fn from(value: &IssuesLockedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesLockedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesLockedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesLockedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesLockedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesLockedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesLockedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesLockedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesLockedIssuePullRequest> for IssuesLockedIssuePullRequest {
    fn from(value: &IssuesLockedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesLockedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesLockedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesLockedIssueState {
    fn from(value: &IssuesLockedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesLockedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesLockedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesLockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesLockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesLockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesMilestoned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues milestoned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"milestoned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"milestone\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"milestone\": {"]
#[doc = "              \"$ref\": \"#/definitions/milestone\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestoned {
    pub action: IssuesMilestonedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesMilestonedIssue,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesMilestoned> for IssuesMilestoned {
    fn from(value: &IssuesMilestoned) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesMilestonedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"milestoned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesMilestonedAction {
    #[serde(rename = "milestoned")]
    Milestoned,
}
impl ::std::convert::From<&Self> for IssuesMilestonedAction {
    fn from(value: &IssuesMilestonedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesMilestonedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Milestoned => write!(f, "milestoned"),
        }
    }
}
impl ::std::str::FromStr for IssuesMilestonedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "milestoned" => Ok(Self::Milestoned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesMilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesMilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesMilestonedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesMilestonedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"milestone\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"milestone\": {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesMilestonedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: IssuesMilestonedIssueMilestone,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesMilestonedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub state: ::std::option::Option<IssuesMilestonedIssueState>,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesMilestonedIssue> for IssuesMilestonedIssue {
    fn from(value: &IssuesMilestonedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesMilestonedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesMilestonedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesMilestonedIssueActiveLockReason {
    fn from(value: &IssuesMilestonedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesMilestonedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesMilestonedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesMilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesMilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesMilestonedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesMilestonedIssueMilestone`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"closed_issues\","]
#[doc = "        \"created_at\","]
#[doc = "        \"creator\","]
#[doc = "        \"description\","]
#[doc = "        \"due_on\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"labels_url\","]
#[doc = "        \"node_id\","]
#[doc = "        \"number\","]
#[doc = "        \"open_issues\","]
#[doc = "        \"state\","]
#[doc = "        \"title\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"closed_issues\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"creator\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"due_on\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"labels_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The number of the milestone.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"open_issues\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"The state of the milestone.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"description\": \"The title of the milestone.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"null\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssueMilestone {
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub description: ::std::option::Option<::std::string::String>,
    pub due_on: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels_url: ::std::string::String,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub open_issues: i64,
    pub state: IssuesMilestonedIssueMilestoneState,
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&IssuesMilestonedIssueMilestone> for IssuesMilestonedIssueMilestone {
    fn from(value: &IssuesMilestonedIssueMilestone) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesMilestonedIssueMilestoneState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesMilestonedIssueMilestoneState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesMilestonedIssueMilestoneState {
    fn from(value: &IssuesMilestonedIssueMilestoneState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesMilestonedIssueMilestoneState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesMilestonedIssueMilestoneState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesMilestonedIssueMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesMilestonedIssueMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesMilestonedIssueMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesMilestonedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestonedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesMilestonedIssuePullRequest> for IssuesMilestonedIssuePullRequest {
    fn from(value: &IssuesMilestonedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesMilestonedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesMilestonedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesMilestonedIssueState {
    fn from(value: &IssuesMilestonedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesMilestonedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesMilestonedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesMilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesMilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesMilestonedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesOpened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues opened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"opened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"old_issue\","]
#[doc = "        \"old_repository\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"old_issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        \"old_repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpened {
    pub action: IssuesOpenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub changes: ::std::option::Option<IssuesOpenedChanges>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesOpenedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesOpened> for IssuesOpened {
    fn from(value: &IssuesOpened) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesOpenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"opened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl ::std::convert::From<&Self> for IssuesOpenedAction {
    fn from(value: &IssuesOpenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesOpenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Opened => write!(f, "opened"),
        }
    }
}
impl ::std::str::FromStr for IssuesOpenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesOpenedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"old_issue\","]
#[doc = "    \"old_repository\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"old_issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"old_repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedChanges {
    pub old_issue: Issue,
    pub old_repository: Repository,
}
impl ::std::convert::From<&IssuesOpenedChanges> for IssuesOpenedChanges {
    fn from(value: &IssuesOpenedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesOpenedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesOpenedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesOpenedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssuesOpenedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesOpenedIssue> for IssuesOpenedIssue {
    fn from(value: &IssuesOpenedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesOpenedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesOpenedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesOpenedIssueActiveLockReason {
    fn from(value: &IssuesOpenedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesOpenedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesOpenedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesOpenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesOpenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesOpenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesOpenedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesOpenedIssuePullRequest> for IssuesOpenedIssuePullRequest {
    fn from(value: &IssuesOpenedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesOpenedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "`IssuesOpenedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesOpenedIssueState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for IssuesOpenedIssueState {
    fn from(value: &IssuesOpenedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesOpenedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for IssuesOpenedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesOpenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesOpenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesOpenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesPinned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues pinned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pinned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesPinned {
    pub action: IssuesPinnedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesPinned> for IssuesPinned {
    fn from(value: &IssuesPinned) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesPinnedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pinned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesPinnedAction {
    #[serde(rename = "pinned")]
    Pinned,
}
impl ::std::convert::From<&Self> for IssuesPinnedAction {
    fn from(value: &IssuesPinnedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesPinnedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pinned => write!(f, "pinned"),
        }
    }
}
impl ::std::str::FromStr for IssuesPinnedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pinned" => Ok(Self::Pinned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesPinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesReopened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues reopened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopened {
    pub action: IssuesReopenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesReopenedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesReopened> for IssuesReopened {
    fn from(value: &IssuesReopened) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesReopenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl ::std::convert::From<&Self> for IssuesReopenedAction {
    fn from(value: &IssuesReopenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesReopenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reopened => write!(f, "reopened"),
        }
    }
}
impl ::std::str::FromStr for IssuesReopenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesReopenedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopenedIssue {
    pub active_lock_reason: ::std::option::Option<IssuesReopenedIssueActiveLockReason>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub locked: ::std::option::Option<bool>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesReopenedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    pub state: IssuesReopenedIssueState,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesReopenedIssue> for IssuesReopenedIssue {
    fn from(value: &IssuesReopenedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesReopenedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesReopenedIssueActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for IssuesReopenedIssueActiveLockReason {
    fn from(value: &IssuesReopenedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesReopenedIssueActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for IssuesReopenedIssueActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesReopenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesReopenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesReopenedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesReopenedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopenedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesReopenedIssuePullRequest> for IssuesReopenedIssuePullRequest {
    fn from(value: &IssuesReopenedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesReopenedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "`IssuesReopenedIssueState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesReopenedIssueState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for IssuesReopenedIssueState {
    fn from(value: &IssuesReopenedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesReopenedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for IssuesReopenedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesReopenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesReopenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesReopenedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesTransferred`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues transferred event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"transferred\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"new_issue\","]
#[doc = "        \"new_repository\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"new_issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        \"new_repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferred {
    pub action: IssuesTransferredAction,
    pub changes: IssuesTransferredChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesTransferred> for IssuesTransferred {
    fn from(value: &IssuesTransferred) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesTransferredAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"transferred\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl ::std::convert::From<&Self> for IssuesTransferredAction {
    fn from(value: &IssuesTransferredAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesTransferredAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Transferred => write!(f, "transferred"),
        }
    }
}
impl ::std::str::FromStr for IssuesTransferredAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesTransferredChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"new_issue\","]
#[doc = "    \"new_repository\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"new_issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"new_repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferredChanges {
    pub new_issue: Issue,
    pub new_repository: Repository,
}
impl ::std::convert::From<&IssuesTransferredChanges> for IssuesTransferredChanges {
    fn from(value: &IssuesTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesUnassigned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues unassigned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The action that was performed.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unassigned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"description\": \"The optional user who was assigned or unassigned from the issue.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnassigned {
    #[doc = "The action that was performed."]
    pub action: IssuesUnassignedAction,
    #[doc = "The optional user who was assigned or unassigned from the issue."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesUnassigned> for IssuesUnassigned {
    fn from(value: &IssuesUnassigned) -> Self {
        value.clone()
    }
}
#[doc = "The action that was performed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The action that was performed.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unassigned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl ::std::convert::From<&Self> for IssuesUnassignedAction {
    fn from(value: &IssuesUnassignedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesUnassignedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unassigned => write!(f, "unassigned"),
        }
    }
}
impl ::std::str::FromStr for IssuesUnassignedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesUnlabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues unlabeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlabeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label that was removed from the issue.\","]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlabeled {
    pub action: IssuesUnlabeledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[doc = "The label that was removed from the issue."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub label: ::std::option::Option<Label>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesUnlabeled> for IssuesUnlabeled {
    fn from(value: &IssuesUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesUnlabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlabeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ::std::convert::From<&Self> for IssuesUnlabeledAction {
    fn from(value: &IssuesUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesUnlabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlabeled => write!(f, "unlabeled"),
        }
    }
}
impl ::std::str::FromStr for IssuesUnlabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesUnlocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues unlocked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlocked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/issue\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"active_lock_reason\","]
#[doc = "            \"locked\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"active_lock_reason\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlocked {
    pub action: IssuesUnlockedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: IssuesUnlockedIssue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesUnlocked> for IssuesUnlocked {
    fn from(value: &IssuesUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesUnlockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlocked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ::std::convert::From<&Self> for IssuesUnlockedAction {
    fn from(value: &IssuesUnlockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesUnlockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlocked => write!(f, "unlocked"),
        }
    }
}
impl ::std::str::FromStr for IssuesUnlockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesUnlockedIssue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"locked\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlockedIssue {
    pub active_lock_reason: IssuesUnlockedIssueActiveLockReason,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[doc = "Contents of the issue"]
    pub body: ::std::option::Option<::std::string::String>,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub events_url: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub labels: ::std::vec::Vec<Label>,
    pub labels_url: ::std::string::String,
    pub locked: bool,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub performed_via_github_app: ::std::option::Option<App>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull_request: ::std::option::Option<IssuesUnlockedIssuePullRequest>,
    pub repository_url: ::std::string::String,
    #[doc = "State of the issue; either 'open' or 'closed'"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub state: ::std::option::Option<IssuesUnlockedIssueState>,
    #[doc = "Title of the issue"]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the issue"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&IssuesUnlockedIssue> for IssuesUnlockedIssue {
    fn from(value: &IssuesUnlockedIssue) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesUnlockedIssueActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"null\","]
#[doc = "  \"enum\": ["]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct IssuesUnlockedIssueActiveLockReason(());
impl ::std::ops::Deref for IssuesUnlockedIssueActiveLockReason {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<IssuesUnlockedIssueActiveLockReason> for () {
    fn from(value: IssuesUnlockedIssueActiveLockReason) -> Self {
        value.0
    }
}
impl ::std::convert::From<&IssuesUnlockedIssueActiveLockReason>
    for IssuesUnlockedIssueActiveLockReason
{
    fn from(value: &IssuesUnlockedIssueActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<()> for IssuesUnlockedIssueActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: ()) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![()].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for IssuesUnlockedIssueActiveLockReason {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`IssuesUnlockedIssuePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlockedIssuePullRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diff_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&IssuesUnlockedIssuePullRequest> for IssuesUnlockedIssuePullRequest {
    fn from(value: &IssuesUnlockedIssuePullRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IssuesUnlockedIssuePullRequest {
    fn default() -> Self {
        Self {
            diff_url: Default::default(),
            html_url: Default::default(),
            patch_url: Default::default(),
            url: Default::default(),
        }
    }
}
#[doc = "State of the issue; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the issue; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesUnlockedIssueState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for IssuesUnlockedIssueState {
    fn from(value: &IssuesUnlockedIssueState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesUnlockedIssueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for IssuesUnlockedIssueState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesUnlockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesUnlockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesUnlockedIssueState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IssuesUnpinned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"issues unpinned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"issue\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unpinned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/issue\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnpinned {
    pub action: IssuesUnpinnedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub issue: Issue,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&IssuesUnpinned> for IssuesUnpinned {
    fn from(value: &IssuesUnpinned) -> Self {
        value.clone()
    }
}
#[doc = "`IssuesUnpinnedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unpinned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IssuesUnpinnedAction {
    #[serde(rename = "unpinned")]
    Unpinned,
}
impl ::std::convert::From<&Self> for IssuesUnpinnedAction {
    fn from(value: &IssuesUnpinnedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IssuesUnpinnedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unpinned => write!(f, "unpinned"),
        }
    }
}
impl ::std::str::FromStr for IssuesUnpinnedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unpinned" => Ok(Self::Unpinned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IssuesUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IssuesUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IssuesUnpinnedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Label`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Label\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"color\","]
#[doc = "    \"default\","]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"color\": {"]
#[doc = "      \"description\": \"6-character hex code, without the leading #, identifying the color\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"default\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the label.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the label\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Label {
    #[doc = "6-character hex code, without the leading #, identifying the color"]
    pub color: ::std::string::String,
    pub default: bool,
    pub description: ::std::option::Option<::std::string::String>,
    pub id: i64,
    #[doc = "The name of the label."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "URL for the label"]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Label> for Label {
    fn from(value: &Label) -> Self {
        value.clone()
    }
}
#[doc = "`LabelCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"label created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"label\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label that was added.\","]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelCreated {
    pub action: LabelCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The label that was added."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&LabelCreated> for LabelCreated {
    fn from(value: &LabelCreated) -> Self {
        value.clone()
    }
}
#[doc = "`LabelCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LabelCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for LabelCreatedAction {
    fn from(value: &LabelCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LabelCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for LabelCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LabelCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LabelCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LabelCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LabelDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"label deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"label\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label that was removed.\","]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelDeleted {
    pub action: LabelDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The label that was removed."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&LabelDeleted> for LabelDeleted {
    fn from(value: &LabelDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`LabelDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LabelDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for LabelDeletedAction {
    fn from(value: &LabelDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LabelDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for LabelDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LabelDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LabelDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LabelDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LabelEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"label edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"label\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the label if the action was `edited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"color\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the color if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"description\": \"The label that was edited.\","]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelEdited {
    pub action: LabelEditedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub changes: ::std::option::Option<LabelEditedChanges>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The label that was edited."]
    pub label: Label,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&LabelEdited> for LabelEdited {
    fn from(value: &LabelEdited) -> Self {
        value.clone()
    }
}
#[doc = "`LabelEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LabelEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for LabelEditedAction {
    fn from(value: &LabelEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LabelEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for LabelEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LabelEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LabelEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LabelEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the label if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the label if the action was `edited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"color\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the color if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub color: ::std::option::Option<LabelEditedChangesColor>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<LabelEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<LabelEditedChangesName>,
}
impl ::std::convert::From<&LabelEditedChanges> for LabelEditedChanges {
    fn from(value: &LabelEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelEditedChanges {
    fn default() -> Self {
        Self {
            color: Default::default(),
            description: Default::default(),
            name: Default::default(),
        }
    }
}
#[doc = "`LabelEditedChangesColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the color if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesColor {
    #[doc = "The previous version of the color if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&LabelEditedChangesColor> for LabelEditedChangesColor {
    fn from(value: &LabelEditedChangesColor) -> Self {
        value.clone()
    }
}
#[doc = "`LabelEditedChangesDescription`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&LabelEditedChangesDescription> for LabelEditedChangesDescription {
    fn from(value: &LabelEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "`LabelEditedChangesName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&LabelEditedChangesName> for LabelEditedChangesName {
    fn from(value: &LabelEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "`LabelEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/label$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/label$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/label$edited\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelEvent {
    Created(LabelCreated),
    Deleted(LabelDeleted),
    Edited(LabelEdited),
}
impl ::std::convert::From<&Self> for LabelEvent {
    fn from(value: &LabelEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LabelCreated> for LabelEvent {
    fn from(value: LabelCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<LabelDeleted> for LabelEvent {
    fn from(value: LabelDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<LabelEdited> for LabelEvent {
    fn from(value: LabelEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "`License`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"License\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"key\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"spdx_id\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"key\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"spdx_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct License {
    pub key: ::std::string::String,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub spdx_id: ::std::string::String,
    pub url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&License> for License {
    fn from(value: &License) -> Self {
        value.clone()
    }
}
#[doc = "`Link`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Link\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"href\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"href\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Link {
    pub href: ::std::string::String,
}
impl ::std::convert::From<&Link> for Link {
    fn from(value: &Link) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Marketplace Purchase\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account\","]
#[doc = "    \"billing_cycle\","]
#[doc = "    \"free_trial_ends_on\","]
#[doc = "    \"on_free_trial\","]
#[doc = "    \"plan\","]
#[doc = "    \"unit_count\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"node_id\","]
#[doc = "        \"organization_billing_email\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organization_billing_email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"billing_cycle\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"free_trial_ends_on\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"next_billing_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"on_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"plan\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"bullets\","]
#[doc = "        \"description\","]
#[doc = "        \"has_free_trial\","]
#[doc = "        \"id\","]
#[doc = "        \"monthly_price_in_cents\","]
#[doc = "        \"name\","]
#[doc = "        \"price_model\","]
#[doc = "        \"unit_name\","]
#[doc = "        \"yearly_price_in_cents\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bullets\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"has_free_trial\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"monthly_price_in_cents\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"price_model\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"unit_name\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"yearly_price_in_cents\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"unit_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchase {
    pub account: MarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub next_billing_date: ::std::option::Option<::std::string::String>,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchase> for MarketplacePurchase {
    fn from(value: &MarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchaseAccount> for MarketplacePurchaseAccount {
    fn from(value: &MarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseCancelled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"marketplace_purchase cancelled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"effective_date\","]
#[doc = "    \"marketplace_purchase\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"cancelled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"marketplace_purchase\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"next_billing_date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"next_billing_date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"previous_marketplace_purchase\": {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"email\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelled {
    pub action: MarketplacePurchaseCancelledAction,
    pub effective_date: ::std::string::String,
    pub marketplace_purchase: MarketplacePurchaseCancelledMarketplacePurchase,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub previous_marketplace_purchase: ::std::option::Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseCancelledSender,
}
impl ::std::convert::From<&MarketplacePurchaseCancelled> for MarketplacePurchaseCancelled {
    fn from(value: &MarketplacePurchaseCancelled) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseCancelledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"cancelled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarketplacePurchaseCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl ::std::convert::From<&Self> for MarketplacePurchaseCancelledAction {
    fn from(value: &MarketplacePurchaseCancelledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarketplacePurchaseCancelledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Cancelled => write!(f, "cancelled"),
        }
    }
}
impl ::std::str::FromStr for MarketplacePurchaseCancelledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarketplacePurchaseCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MarketplacePurchaseCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MarketplacePurchaseCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarketplacePurchaseCancelledMarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"next_billing_date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"next_billing_date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchase {
    pub account: MarketplacePurchaseCancelledMarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    pub next_billing_date: ::std::string::String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchaseCancelledMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchaseCancelledMarketplacePurchase>
    for MarketplacePurchaseCancelledMarketplacePurchase
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseCancelledMarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchaseCancelledMarketplacePurchaseAccount>
    for MarketplacePurchaseCancelledMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseCancelledMarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledMarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchaseCancelledMarketplacePurchasePlan>
    for MarketplacePurchaseCancelledMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchaseCancelledMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseCancelledSender`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"email\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledSender {
    pub avatar_url: ::std::string::String,
    pub email: ::std::string::String,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchaseCancelledSender>
    for MarketplacePurchaseCancelledSender
{
    fn from(value: &MarketplacePurchaseCancelledSender) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseChanged`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"marketplace_purchase changed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"effective_date\","]
#[doc = "    \"marketplace_purchase\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"changed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"marketplace_purchase\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"next_billing_date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"next_billing_date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"previous_marketplace_purchase\": {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"email\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChanged {
    pub action: MarketplacePurchaseChangedAction,
    pub effective_date: ::std::string::String,
    pub marketplace_purchase: MarketplacePurchaseChangedMarketplacePurchase,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub previous_marketplace_purchase: ::std::option::Option<MarketplacePurchase>,
    pub sender: MarketplacePurchaseChangedSender,
}
impl ::std::convert::From<&MarketplacePurchaseChanged> for MarketplacePurchaseChanged {
    fn from(value: &MarketplacePurchaseChanged) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseChangedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"changed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarketplacePurchaseChangedAction {
    #[serde(rename = "changed")]
    Changed,
}
impl ::std::convert::From<&Self> for MarketplacePurchaseChangedAction {
    fn from(value: &MarketplacePurchaseChangedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarketplacePurchaseChangedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Changed => write!(f, "changed"),
        }
    }
}
impl ::std::str::FromStr for MarketplacePurchaseChangedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "changed" => Ok(Self::Changed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarketplacePurchaseChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MarketplacePurchaseChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MarketplacePurchaseChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarketplacePurchaseChangedMarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"next_billing_date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"next_billing_date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchase {
    pub account: MarketplacePurchaseChangedMarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    pub next_billing_date: ::std::string::String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchaseChangedMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchaseChangedMarketplacePurchase>
    for MarketplacePurchaseChangedMarketplacePurchase
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseChangedMarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchaseChangedMarketplacePurchaseAccount>
    for MarketplacePurchaseChangedMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseChangedMarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedMarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchaseChangedMarketplacePurchasePlan>
    for MarketplacePurchaseChangedMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchaseChangedMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseChangedSender`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"email\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedSender {
    pub avatar_url: ::std::string::String,
    pub email: ::std::string::String,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchaseChangedSender> for MarketplacePurchaseChangedSender {
    fn from(value: &MarketplacePurchaseChangedSender) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchaseEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase$cancelled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase$changed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase$pending_change\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase$pending_change_cancelled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace_purchase$purchased\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MarketplacePurchaseEvent {
    Cancelled(MarketplacePurchaseCancelled),
    Changed(MarketplacePurchaseChanged),
    PendingChange(MarketplacePurchasePendingChange),
    PendingChangeCancelled(MarketplacePurchasePendingChangeCancelled),
    Purchased(MarketplacePurchasePurchased),
}
impl ::std::convert::From<&Self> for MarketplacePurchaseEvent {
    fn from(value: &MarketplacePurchaseEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MarketplacePurchaseCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl ::std::convert::From<MarketplacePurchaseChanged> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchaseChanged) -> Self {
        Self::Changed(value)
    }
}
impl ::std::convert::From<MarketplacePurchasePendingChange> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChange) -> Self {
        Self::PendingChange(value)
    }
}
impl ::std::convert::From<MarketplacePurchasePendingChangeCancelled> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePendingChangeCancelled) -> Self {
        Self::PendingChangeCancelled(value)
    }
}
impl ::std::convert::From<MarketplacePurchasePurchased> for MarketplacePurchaseEvent {
    fn from(value: MarketplacePurchasePurchased) -> Self {
        Self::Purchased(value)
    }
}
#[doc = "`MarketplacePurchasePendingChange`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"marketplace_purchase pending_change event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"effective_date\","]
#[doc = "    \"marketplace_purchase\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending_change\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"marketplace_purchase\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"next_billing_date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"next_billing_date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"previous_marketplace_purchase\": {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"email\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChange {
    pub action: MarketplacePurchasePendingChangeAction,
    pub effective_date: ::std::string::String,
    pub marketplace_purchase: MarketplacePurchasePendingChangeMarketplacePurchase,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub previous_marketplace_purchase: ::std::option::Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeSender,
}
impl ::std::convert::From<&MarketplacePurchasePendingChange> for MarketplacePurchasePendingChange {
    fn from(value: &MarketplacePurchasePendingChange) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending_change\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarketplacePurchasePendingChangeAction {
    #[serde(rename = "pending_change")]
    PendingChange,
}
impl ::std::convert::From<&Self> for MarketplacePurchasePendingChangeAction {
    fn from(value: &MarketplacePurchasePendingChangeAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarketplacePurchasePendingChangeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PendingChange => write!(f, "pending_change"),
        }
    }
}
impl ::std::str::FromStr for MarketplacePurchasePendingChangeAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending_change" => Ok(Self::PendingChange),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MarketplacePurchasePendingChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MarketplacePurchasePendingChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"marketplace_purchase pending_change_cancelled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"effective_date\","]
#[doc = "    \"marketplace_purchase\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending_change_cancelled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"marketplace_purchase\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"next_billing_date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"next_billing_date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"previous_marketplace_purchase\": {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"email\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelled {
    pub action: MarketplacePurchasePendingChangeCancelledAction,
    pub effective_date: ::std::string::String,
    pub marketplace_purchase: MarketplacePurchasePendingChangeCancelledMarketplacePurchase,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub previous_marketplace_purchase: ::std::option::Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePendingChangeCancelledSender,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeCancelled>
    for MarketplacePurchasePendingChangeCancelled
{
    fn from(value: &MarketplacePurchasePendingChangeCancelled) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending_change_cancelled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarketplacePurchasePendingChangeCancelledAction {
    #[serde(rename = "pending_change_cancelled")]
    PendingChangeCancelled,
}
impl ::std::convert::From<&Self> for MarketplacePurchasePendingChangeCancelledAction {
    fn from(value: &MarketplacePurchasePendingChangeCancelledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarketplacePurchasePendingChangeCancelledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PendingChangeCancelled => write!(f, "pending_change_cancelled"),
        }
    }
}
impl ::std::str::FromStr for MarketplacePurchasePendingChangeCancelledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending_change_cancelled" => Ok(Self::PendingChangeCancelled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for MarketplacePurchasePendingChangeCancelledAction
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for MarketplacePurchasePendingChangeCancelledAction
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelledMarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"next_billing_date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"next_billing_date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchase {
    pub account: MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    pub next_billing_date: ::std::string::String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchase>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan>
    for MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeCancelledSender`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"email\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledSender {
    pub avatar_url: ::std::string::String,
    pub email: ::std::string::String,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeCancelledSender>
    for MarketplacePurchasePendingChangeCancelledSender
{
    fn from(value: &MarketplacePurchasePendingChangeCancelledSender) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeMarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"next_billing_date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"next_billing_date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchase {
    pub account: MarketplacePurchasePendingChangeMarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    pub next_billing_date: ::std::string::String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePendingChangeMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeMarketplacePurchase>
    for MarketplacePurchasePendingChangeMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeMarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeMarketplacePurchaseAccount>
    for MarketplacePurchasePendingChangeMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeMarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeMarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeMarketplacePurchasePlan>
    for MarketplacePurchasePendingChangeMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePendingChangeMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePendingChangeSender`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"email\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeSender {
    pub avatar_url: ::std::string::String,
    pub email: ::std::string::String,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePendingChangeSender>
    for MarketplacePurchasePendingChangeSender
{
    fn from(value: &MarketplacePurchasePendingChangeSender) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchasePlan> for MarketplacePurchasePlan {
    fn from(value: &MarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePurchased`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"marketplace_purchase purchased event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"effective_date\","]
#[doc = "    \"marketplace_purchase\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"purchased\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"marketplace_purchase\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"next_billing_date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"next_billing_date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"previous_marketplace_purchase\": {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"avatar_url\","]
#[doc = "        \"email\","]
#[doc = "        \"events_url\","]
#[doc = "        \"followers_url\","]
#[doc = "        \"following_url\","]
#[doc = "        \"gists_url\","]
#[doc = "        \"gravatar_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"login\","]
#[doc = "        \"organizations_url\","]
#[doc = "        \"received_events_url\","]
#[doc = "        \"repos_url\","]
#[doc = "        \"site_admin\","]
#[doc = "        \"starred_url\","]
#[doc = "        \"subscriptions_url\","]
#[doc = "        \"type\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"avatar_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"followers_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"following_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gists_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"gravatar_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"organizations_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"received_events_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"repos_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"site_admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"starred_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"subscriptions_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchased {
    pub action: MarketplacePurchasePurchasedAction,
    pub effective_date: ::std::string::String,
    pub marketplace_purchase: MarketplacePurchasePurchasedMarketplacePurchase,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub previous_marketplace_purchase: ::std::option::Option<MarketplacePurchase>,
    pub sender: MarketplacePurchasePurchasedSender,
}
impl ::std::convert::From<&MarketplacePurchasePurchased> for MarketplacePurchasePurchased {
    fn from(value: &MarketplacePurchasePurchased) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePurchasedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"purchased\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarketplacePurchasePurchasedAction {
    #[serde(rename = "purchased")]
    Purchased,
}
impl ::std::convert::From<&Self> for MarketplacePurchasePurchasedAction {
    fn from(value: &MarketplacePurchasePurchasedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarketplacePurchasePurchasedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Purchased => write!(f, "purchased"),
        }
    }
}
impl ::std::str::FromStr for MarketplacePurchasePurchasedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "purchased" => Ok(Self::Purchased),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarketplacePurchasePurchasedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MarketplacePurchasePurchasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MarketplacePurchasePurchasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarketplacePurchasePurchasedMarketplacePurchase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/marketplace-purchase\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"next_billing_date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"next_billing_date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchase {
    pub account: MarketplacePurchasePurchasedMarketplacePurchaseAccount,
    pub billing_cycle: ::std::string::String,
    pub free_trial_ends_on: (),
    pub next_billing_date: ::std::string::String,
    pub on_free_trial: bool,
    pub plan: MarketplacePurchasePurchasedMarketplacePurchasePlan,
    pub unit_count: i64,
}
impl ::std::convert::From<&MarketplacePurchasePurchasedMarketplacePurchase>
    for MarketplacePurchasePurchasedMarketplacePurchase
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchase) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePurchasedMarketplacePurchaseAccount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organization_billing_email\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization_billing_email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchaseAccount {
    pub id: i64,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub organization_billing_email: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePurchasedMarketplacePurchaseAccount>
    for MarketplacePurchasePurchasedMarketplacePurchaseAccount
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchaseAccount) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePurchasedMarketplacePurchasePlan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bullets\","]
#[doc = "    \"description\","]
#[doc = "    \"has_free_trial\","]
#[doc = "    \"id\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"name\","]
#[doc = "    \"price_model\","]
#[doc = "    \"unit_name\","]
#[doc = "    \"yearly_price_in_cents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bullets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"has_free_trial\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"price_model\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"unit_name\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"yearly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedMarketplacePurchasePlan {
    pub bullets: ::std::vec::Vec<::std::string::String>,
    pub description: ::std::string::String,
    pub has_free_trial: bool,
    pub id: i64,
    pub monthly_price_in_cents: i64,
    pub name: ::std::string::String,
    pub price_model: ::std::string::String,
    pub unit_name: ::std::option::Option<::std::string::String>,
    pub yearly_price_in_cents: i64,
}
impl ::std::convert::From<&MarketplacePurchasePurchasedMarketplacePurchasePlan>
    for MarketplacePurchasePurchasedMarketplacePurchasePlan
{
    fn from(value: &MarketplacePurchasePurchasedMarketplacePurchasePlan) -> Self {
        value.clone()
    }
}
#[doc = "`MarketplacePurchasePurchasedSender`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"email\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedSender {
    pub avatar_url: ::std::string::String,
    pub email: ::std::string::String,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MarketplacePurchasePurchasedSender>
    for MarketplacePurchasePurchasedSender
{
    fn from(value: &MarketplacePurchasePurchasedSender) -> Self {
        value.clone()
    }
}
#[doc = "Activity related to repository collaborators. The type of activity is specified in the action property."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"member added event\","]
#[doc = "  \"description\": \"Activity related to repository collaborators. The type of activity is specified in the action property.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"member\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"added\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"permission\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"to\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"to\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"write\","]
#[doc = "                \"admin\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"member\": {"]
#[doc = "      \"description\": \"The user that was added.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberAdded {
    pub action: MemberAddedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub changes: ::std::option::Option<MemberAddedChanges>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The user that was added."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MemberAdded> for MemberAdded {
    fn from(value: &MemberAdded) -> Self {
        value.clone()
    }
}
#[doc = "`MemberAddedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"added\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemberAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl ::std::convert::From<&Self> for MemberAddedAction {
    fn from(value: &MemberAddedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemberAddedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Added => write!(f, "added"),
        }
    }
}
impl ::std::str::FromStr for MemberAddedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MemberAddedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"permission\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"to\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"to\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"write\","]
#[doc = "            \"admin\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permission: ::std::option::Option<MemberAddedChangesPermission>,
}
impl ::std::convert::From<&MemberAddedChanges> for MemberAddedChanges {
    fn from(value: &MemberAddedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for MemberAddedChanges {
    fn default() -> Self {
        Self {
            permission: Default::default(),
        }
    }
}
#[doc = "`MemberAddedChangesPermission`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"to\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"to\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"write\","]
#[doc = "        \"admin\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChangesPermission {
    pub to: MemberAddedChangesPermissionTo,
}
impl ::std::convert::From<&MemberAddedChangesPermission> for MemberAddedChangesPermission {
    fn from(value: &MemberAddedChangesPermission) -> Self {
        value.clone()
    }
}
#[doc = "`MemberAddedChangesPermissionTo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"write\","]
#[doc = "    \"admin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemberAddedChangesPermissionTo {
    #[serde(rename = "write")]
    Write,
    #[serde(rename = "admin")]
    Admin,
}
impl ::std::convert::From<&Self> for MemberAddedChangesPermissionTo {
    fn from(value: &MemberAddedChangesPermissionTo) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemberAddedChangesPermissionTo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Write => write!(f, "write"),
            Self::Admin => write!(f, "admin"),
        }
    }
}
impl ::std::str::FromStr for MemberAddedChangesPermissionTo {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "write" => Ok(Self::Write),
            "admin" => Ok(Self::Admin),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemberAddedChangesPermissionTo {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemberAddedChangesPermissionTo {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemberAddedChangesPermissionTo {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MemberEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"member edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"member\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the collaborator permissions\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"old_permission\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"old_permission\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous permissions of the collaborator if the action was edited.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"member\": {"]
#[doc = "      \"description\": \"The user who's permissions are changed.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberEdited {
    pub action: MemberEditedAction,
    pub changes: MemberEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The user who's permissions are changed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MemberEdited> for MemberEdited {
    fn from(value: &MemberEdited) -> Self {
        value.clone()
    }
}
#[doc = "`MemberEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemberEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for MemberEditedAction {
    fn from(value: &MemberEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemberEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for MemberEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemberEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemberEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemberEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the collaborator permissions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the collaborator permissions\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"old_permission\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"old_permission\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous permissions of the collaborator if the action was edited.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChanges {
    pub old_permission: MemberEditedChangesOldPermission,
}
impl ::std::convert::From<&MemberEditedChanges> for MemberEditedChanges {
    fn from(value: &MemberEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`MemberEditedChangesOldPermission`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous permissions of the collaborator if the action was edited.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChangesOldPermission {
    #[doc = "The previous permissions of the collaborator if the action was edited."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&MemberEditedChangesOldPermission> for MemberEditedChangesOldPermission {
    fn from(value: &MemberEditedChangesOldPermission) -> Self {
        value.clone()
    }
}
#[doc = "`MemberEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/member$added\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/member$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/member$removed\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MemberEvent {
    Added(MemberAdded),
    Edited(MemberEdited),
    Removed(MemberRemoved),
}
impl ::std::convert::From<&Self> for MemberEvent {
    fn from(value: &MemberEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MemberAdded> for MemberEvent {
    fn from(value: MemberAdded) -> Self {
        Self::Added(value)
    }
}
impl ::std::convert::From<MemberEdited> for MemberEvent {
    fn from(value: MemberEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<MemberRemoved> for MemberEvent {
    fn from(value: MemberRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "`MemberRemoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"member removed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"member\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"member\": {"]
#[doc = "      \"description\": \"The user that was removed.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MemberRemoved {
    pub action: MemberRemovedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The user that was removed."]
    pub member: User,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MemberRemoved> for MemberRemoved {
    fn from(value: &MemberRemoved) -> Self {
        value.clone()
    }
}
#[doc = "`MemberRemovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MemberRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl ::std::convert::From<&Self> for MemberRemovedAction {
    fn from(value: &MemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MemberRemovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Removed => write!(f, "removed"),
        }
    }
}
impl ::std::str::FromStr for MemberRemovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The membership between the user and the organization. Not present when the action is `member_invited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Membership\","]
#[doc = "  \"description\": \"The membership between the user and the organization. Not present when the action is `member_invited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"organization_url\","]
#[doc = "    \"role\","]
#[doc = "    \"state\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"organization_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Membership {
    pub organization_url: ::std::string::String,
    pub role: ::std::string::String,
    pub state: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&Membership> for Membership {
    fn from(value: &Membership) -> Self {
        value.clone()
    }
}
#[doc = "`MembershipAdded`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"membership added event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"member\","]
#[doc = "    \"organization\","]
#[doc = "    \"scope\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"added\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"member\": {"]
#[doc = "      \"description\": \"The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"scope\": {"]
#[doc = "      \"description\": \"The scope of the membership. Currently, can only be `team`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"team\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\","]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MembershipAdded {
    pub action: MembershipAddedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipAddedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: Team,
}
impl ::std::convert::From<&MembershipAdded> for MembershipAdded {
    fn from(value: &MembershipAdded) -> Self {
        value.clone()
    }
}
#[doc = "`MembershipAddedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"added\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MembershipAddedAction {
    #[serde(rename = "added")]
    Added,
}
impl ::std::convert::From<&Self> for MembershipAddedAction {
    fn from(value: &MembershipAddedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MembershipAddedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Added => write!(f, "added"),
        }
    }
}
impl ::std::str::FromStr for MembershipAddedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "added" => Ok(Self::Added),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MembershipAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MembershipAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MembershipAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The scope of the membership. Currently, can only be `team`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"team\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MembershipAddedScope {
    #[serde(rename = "team")]
    Team,
}
impl ::std::convert::From<&Self> for MembershipAddedScope {
    fn from(value: &MembershipAddedScope) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MembershipAddedScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Team => write!(f, "team"),
        }
    }
}
impl ::std::str::FromStr for MembershipAddedScope {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "team" => Ok(Self::Team),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MembershipAddedScope {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MembershipAddedScope {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MembershipAddedScope {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MembershipEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/membership$added\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/membership$removed\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MembershipEvent {
    Added(MembershipAdded),
    Removed(MembershipRemoved),
}
impl ::std::convert::From<&Self> for MembershipEvent {
    fn from(value: &MembershipEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MembershipAdded> for MembershipEvent {
    fn from(value: MembershipAdded) -> Self {
        Self::Added(value)
    }
}
impl ::std::convert::From<MembershipRemoved> for MembershipEvent {
    fn from(value: MembershipRemoved) -> Self {
        Self::Removed(value)
    }
}
#[doc = "`MembershipRemoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"membership removed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"member\","]
#[doc = "    \"organization\","]
#[doc = "    \"scope\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"removed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"member\": {"]
#[doc = "      \"description\": \"The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"scope\": {"]
#[doc = "      \"description\": \"The scope of the membership. Currently, can only be `team`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"team\","]
#[doc = "        \"organization\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/team\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\","]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"deleted\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MembershipRemoved {
    pub action: MembershipRemovedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The [user](https://docs.github.com/en/rest/reference/users) that was added or removed."]
    pub member: User,
    pub organization: Organization,
    #[doc = "The scope of the membership. Currently, can only be `team`."]
    pub scope: MembershipRemovedScope,
    pub sender: User,
    #[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
    pub team: MembershipRemovedTeam,
}
impl ::std::convert::From<&MembershipRemoved> for MembershipRemoved {
    fn from(value: &MembershipRemoved) -> Self {
        value.clone()
    }
}
#[doc = "`MembershipRemovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MembershipRemovedAction {
    #[serde(rename = "removed")]
    Removed,
}
impl ::std::convert::From<&Self> for MembershipRemovedAction {
    fn from(value: &MembershipRemovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MembershipRemovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Removed => write!(f, "removed"),
        }
    }
}
impl ::std::str::FromStr for MembershipRemovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "removed" => Ok(Self::Removed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MembershipRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MembershipRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MembershipRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The scope of the membership. Currently, can only be `team`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The scope of the membership. Currently, can only be `team`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"team\","]
#[doc = "    \"organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MembershipRemovedScope {
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "organization")]
    Organization,
}
impl ::std::convert::From<&Self> for MembershipRemovedScope {
    fn from(value: &MembershipRemovedScope) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MembershipRemovedScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Team => write!(f, "team"),
            Self::Organization => write!(f, "organization"),
        }
    }
}
impl ::std::str::FromStr for MembershipRemovedScope {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "team" => Ok(Self::Team),
            "organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MembershipRemovedScope {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MembershipRemovedScope {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MembershipRemovedScope {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The [team](https://docs.github.com/en/rest/reference/teams) for the membership."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [team](https://docs.github.com/en/rest/reference/teams) for the membership.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"deleted\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum MembershipRemovedTeam {
    Variant0(Team),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        deleted: ::std::option::Option<bool>,
        id: i64,
        name: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for MembershipRemovedTeam {
    fn from(value: &MembershipRemovedTeam) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Team> for MembershipRemovedTeam {
    fn from(value: Team) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`MetaDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"meta deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"hook\","]
#[doc = "    \"hook_id\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"hook\": {"]
#[doc = "      \"description\": \"The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"active\","]
#[doc = "        \"config\","]
#[doc = "        \"created_at\","]
#[doc = "        \"events\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"type\","]
#[doc = "        \"updated_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"active\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"config\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"content_type\","]
#[doc = "            \"insecure_ssl\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"content_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\","]
#[doc = "                \"form\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"insecure_ssl\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events\": {"]
#[doc = "          \"$ref\": \"#/definitions/webhook-events\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"hook_id\": {"]
#[doc = "      \"description\": \"The id of the modified webhook.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MetaDeleted {
    pub action: MetaDeletedAction,
    pub hook: MetaDeletedHook,
    #[doc = "The id of the modified webhook."]
    pub hook_id: i64,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MetaDeleted> for MetaDeleted {
    fn from(value: &MetaDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`MetaDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MetaDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for MetaDeletedAction {
    fn from(value: &MetaDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MetaDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for MetaDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MetaDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MetaDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MetaDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"active\","]
#[doc = "    \"config\","]
#[doc = "    \"created_at\","]
#[doc = "    \"events\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"type\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"active\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"config\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"content_type\","]
#[doc = "        \"insecure_ssl\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"content_type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"json\","]
#[doc = "            \"form\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"insecure_ssl\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events\": {"]
#[doc = "      \"$ref\": \"#/definitions/webhook-events\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHook {
    pub active: bool,
    pub config: MetaDeletedHookConfig,
    pub created_at: ::std::string::String,
    pub events: WebhookEvents,
    pub id: i64,
    pub name: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&MetaDeletedHook> for MetaDeletedHook {
    fn from(value: &MetaDeletedHook) -> Self {
        value.clone()
    }
}
#[doc = "`MetaDeletedHookConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content_type\","]
#[doc = "    \"insecure_ssl\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content_type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\","]
#[doc = "        \"form\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"insecure_ssl\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHookConfig {
    pub content_type: MetaDeletedHookConfigContentType,
    pub insecure_ssl: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MetaDeletedHookConfig> for MetaDeletedHookConfig {
    fn from(value: &MetaDeletedHookConfig) -> Self {
        value.clone()
    }
}
#[doc = "`MetaDeletedHookConfigContentType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\","]
#[doc = "    \"form\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MetaDeletedHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl ::std::convert::From<&Self> for MetaDeletedHookConfigContentType {
    fn from(value: &MetaDeletedHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MetaDeletedHookConfigContentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Json => write!(f, "json"),
            Self::Form => write!(f, "form"),
        }
    }
}
impl ::std::str::FromStr for MetaDeletedHookConfigContentType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MetaDeletedHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MetaDeletedHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MetaDeletedHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MetaEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/meta$deleted\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct MetaEvent(pub MetaDeleted);
impl ::std::ops::Deref for MetaEvent {
    type Target = MetaDeleted;
    fn deref(&self) -> &MetaDeleted {
        &self.0
    }
}
impl ::std::convert::From<MetaEvent> for MetaDeleted {
    fn from(value: MetaEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&MetaEvent> for MetaEvent {
    fn from(value: &MetaEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MetaDeleted> for MetaEvent {
    fn from(value: MetaDeleted) -> Self {
        Self(value)
    }
}
#[doc = "A collection of related issues and pull requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Milestone\","]
#[doc = "  \"description\": \"A collection of related issues and pull requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"closed_at\","]
#[doc = "    \"closed_issues\","]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"description\","]
#[doc = "    \"due_on\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"labels_url\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"open_issues\","]
#[doc = "    \"state\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"closed_issues\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"due_on\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"labels_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The number of the milestone.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"open_issues\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"The state of the milestone.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"The title of the milestone.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Milestone {
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub closed_issues: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub description: ::std::option::Option<::std::string::String>,
    pub due_on: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels_url: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    #[doc = "The state of the milestone."]
    pub state: MilestoneState,
    #[doc = "The title of the milestone."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Milestone> for Milestone {
    fn from(value: &Milestone) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneClosed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"milestone closed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosed {
    pub action: MilestoneClosedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub milestone: MilestoneClosedMilestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MilestoneClosed> for MilestoneClosed {
    fn from(value: &MilestoneClosed) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneClosedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for MilestoneClosedAction {
    fn from(value: &MilestoneClosedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneClosedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for MilestoneClosedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneClosedMilestone`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosedMilestone {
    pub closed_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub closed_issues: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub description: ::std::option::Option<::std::string::String>,
    pub due_on: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels_url: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneClosedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MilestoneClosedMilestone> for MilestoneClosedMilestone {
    fn from(value: &MilestoneClosedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneClosedMilestoneState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneClosedMilestoneState {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for MilestoneClosedMilestoneState {
    fn from(value: &MilestoneClosedMilestoneState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneClosedMilestoneState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for MilestoneClosedMilestoneState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneClosedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneClosedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneClosedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"milestone created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreated {
    pub action: MilestoneCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub milestone: MilestoneCreatedMilestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MilestoneCreated> for MilestoneCreated {
    fn from(value: &MilestoneCreated) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for MilestoneCreatedAction {
    fn from(value: &MilestoneCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for MilestoneCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneCreatedMilestone`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreatedMilestone {
    pub closed_at: (),
    pub closed_issues: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub description: ::std::option::Option<::std::string::String>,
    pub due_on: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels_url: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneCreatedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MilestoneCreatedMilestone> for MilestoneCreatedMilestone {
    fn from(value: &MilestoneCreatedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneCreatedMilestoneState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneCreatedMilestoneState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for MilestoneCreatedMilestoneState {
    fn from(value: &MilestoneCreatedMilestoneState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneCreatedMilestoneState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for MilestoneCreatedMilestoneState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneCreatedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneCreatedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneCreatedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"milestone deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneDeleted {
    pub action: MilestoneDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MilestoneDeleted> for MilestoneDeleted {
    fn from(value: &MilestoneDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for MilestoneDeletedAction {
    fn from(value: &MilestoneDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for MilestoneDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"milestone edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the milestone if the action was `edited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"due_on\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the due date if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEdited {
    pub action: MilestoneEditedAction,
    pub changes: MilestoneEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub milestone: Milestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MilestoneEdited> for MilestoneEdited {
    fn from(value: &MilestoneEdited) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for MilestoneEditedAction {
    fn from(value: &MilestoneEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for MilestoneEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the milestone if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the milestone if the action was `edited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"due_on\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the due date if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<MilestoneEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub due_on: ::std::option::Option<MilestoneEditedChangesDueOn>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<MilestoneEditedChangesTitle>,
}
impl ::std::convert::From<&MilestoneEditedChanges> for MilestoneEditedChanges {
    fn from(value: &MilestoneEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for MilestoneEditedChanges {
    fn default() -> Self {
        Self {
            description: Default::default(),
            due_on: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`MilestoneEditedChangesDescription`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&MilestoneEditedChangesDescription>
    for MilestoneEditedChangesDescription
{
    fn from(value: &MilestoneEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneEditedChangesDueOn`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the due date if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDueOn {
    #[doc = "The previous version of the due date if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&MilestoneEditedChangesDueOn> for MilestoneEditedChangesDueOn {
    fn from(value: &MilestoneEditedChangesDueOn) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneEditedChangesTitle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&MilestoneEditedChangesTitle> for MilestoneEditedChangesTitle {
    fn from(value: &MilestoneEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone$closed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone$opened\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MilestoneEvent {
    Closed(MilestoneClosed),
    Created(MilestoneCreated),
    Deleted(MilestoneDeleted),
    Edited(MilestoneEdited),
    Opened(MilestoneOpened),
}
impl ::std::convert::From<&Self> for MilestoneEvent {
    fn from(value: &MilestoneEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MilestoneClosed> for MilestoneEvent {
    fn from(value: MilestoneClosed) -> Self {
        Self::Closed(value)
    }
}
impl ::std::convert::From<MilestoneCreated> for MilestoneEvent {
    fn from(value: MilestoneCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<MilestoneDeleted> for MilestoneEvent {
    fn from(value: MilestoneDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<MilestoneEdited> for MilestoneEvent {
    fn from(value: MilestoneEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<MilestoneOpened> for MilestoneEvent {
    fn from(value: MilestoneOpened) -> Self {
        Self::Opened(value)
    }
}
#[doc = "`MilestoneOpened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"milestone opened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"milestone\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"opened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpened {
    pub action: MilestoneOpenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub milestone: MilestoneOpenedMilestone,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&MilestoneOpened> for MilestoneOpened {
    fn from(value: &MilestoneOpened) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneOpenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"opened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl ::std::convert::From<&Self> for MilestoneOpenedAction {
    fn from(value: &MilestoneOpenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneOpenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Opened => write!(f, "opened"),
        }
    }
}
impl ::std::str::FromStr for MilestoneOpenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MilestoneOpenedMilestone`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/milestone\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpenedMilestone {
    pub closed_at: (),
    pub closed_issues: i64,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub description: ::std::option::Option<::std::string::String>,
    pub due_on: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels_url: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "The number of the milestone."]
    pub number: i64,
    pub open_issues: i64,
    pub state: MilestoneOpenedMilestoneState,
    #[doc = "The title of the milestone."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&MilestoneOpenedMilestone> for MilestoneOpenedMilestone {
    fn from(value: &MilestoneOpenedMilestone) -> Self {
        value.clone()
    }
}
#[doc = "`MilestoneOpenedMilestoneState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneOpenedMilestoneState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for MilestoneOpenedMilestoneState {
    fn from(value: &MilestoneOpenedMilestoneState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneOpenedMilestoneState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for MilestoneOpenedMilestoneState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneOpenedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneOpenedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneOpenedMilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The state of the milestone."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The state of the milestone.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MilestoneState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for MilestoneState {
    fn from(value: &MilestoneState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MilestoneState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for MilestoneState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MilestoneState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrgBlockBlocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"org_block blocked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"blocked_user\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"blocked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"blocked_user\": {"]
#[doc = "      \"description\": \"Information about the user that was blocked or unblocked.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockBlocked {
    pub action: OrgBlockBlockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrgBlockBlocked> for OrgBlockBlocked {
    fn from(value: &OrgBlockBlocked) -> Self {
        value.clone()
    }
}
#[doc = "`OrgBlockBlockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"blocked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrgBlockBlockedAction {
    #[serde(rename = "blocked")]
    Blocked,
}
impl ::std::convert::From<&Self> for OrgBlockBlockedAction {
    fn from(value: &OrgBlockBlockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrgBlockBlockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Blocked => write!(f, "blocked"),
        }
    }
}
impl ::std::str::FromStr for OrgBlockBlockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "blocked" => Ok(Self::Blocked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrgBlockBlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrgBlockBlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrgBlockBlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrgBlockEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/org_block$blocked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/org_block$unblocked\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrgBlockEvent {
    Blocked(OrgBlockBlocked),
    Unblocked(OrgBlockUnblocked),
}
impl ::std::convert::From<&Self> for OrgBlockEvent {
    fn from(value: &OrgBlockEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<OrgBlockBlocked> for OrgBlockEvent {
    fn from(value: OrgBlockBlocked) -> Self {
        Self::Blocked(value)
    }
}
impl ::std::convert::From<OrgBlockUnblocked> for OrgBlockEvent {
    fn from(value: OrgBlockUnblocked) -> Self {
        Self::Unblocked(value)
    }
}
#[doc = "`OrgBlockUnblocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"org_block unblocked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"blocked_user\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unblocked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"blocked_user\": {"]
#[doc = "      \"description\": \"Information about the user that was blocked or unblocked.\","]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockUnblocked {
    pub action: OrgBlockUnblockedAction,
    #[doc = "Information about the user that was blocked or unblocked."]
    pub blocked_user: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrgBlockUnblocked> for OrgBlockUnblocked {
    fn from(value: &OrgBlockUnblocked) -> Self {
        value.clone()
    }
}
#[doc = "`OrgBlockUnblockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unblocked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrgBlockUnblockedAction {
    #[serde(rename = "unblocked")]
    Unblocked,
}
impl ::std::convert::From<&Self> for OrgBlockUnblockedAction {
    fn from(value: &OrgBlockUnblockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrgBlockUnblockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unblocked => write!(f, "unblocked"),
        }
    }
}
impl ::std::str::FromStr for OrgBlockUnblockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unblocked" => Ok(Self::Unblocked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrgBlockUnblockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrgBlockUnblockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrgBlockUnblockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Organization`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Organization\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"description\","]
#[doc = "    \"events_url\","]
#[doc = "    \"hooks_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issues_url\","]
#[doc = "    \"login\","]
#[doc = "    \"members_url\","]
#[doc = "    \"node_id\","]
#[doc = "    \"public_members_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"hooks_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issues_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"members_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"public_members_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Organization {
    pub avatar_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub hooks_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub html_url: ::std::option::Option<::std::string::String>,
    pub id: i64,
    pub issues_url: ::std::string::String,
    pub login: ::std::string::String,
    pub members_url: ::std::string::String,
    pub node_id: ::std::string::String,
    pub public_members_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Organization> for Organization {
    fn from(value: &Organization) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"organization deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"membership\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"membership\": {"]
#[doc = "      \"$ref\": \"#/definitions/membership\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationDeleted {
    pub action: OrganizationDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrganizationDeleted> for OrganizationDeleted {
    fn from(value: &OrganizationDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrganizationDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for OrganizationDeletedAction {
    fn from(value: &OrganizationDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrganizationDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for OrganizationDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrganizationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrganizationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrganizationDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrganizationEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization$member_added\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization$member_invited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization$member_removed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/organization$renamed\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrganizationEvent {
    Deleted(OrganizationDeleted),
    MemberAdded(OrganizationMemberAdded),
    MemberInvited(OrganizationMemberInvited),
    MemberRemoved(OrganizationMemberRemoved),
    Renamed(OrganizationRenamed),
}
impl ::std::convert::From<&Self> for OrganizationEvent {
    fn from(value: &OrganizationEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<OrganizationDeleted> for OrganizationEvent {
    fn from(value: OrganizationDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<OrganizationMemberAdded> for OrganizationEvent {
    fn from(value: OrganizationMemberAdded) -> Self {
        Self::MemberAdded(value)
    }
}
impl ::std::convert::From<OrganizationMemberInvited> for OrganizationEvent {
    fn from(value: OrganizationMemberInvited) -> Self {
        Self::MemberInvited(value)
    }
}
impl ::std::convert::From<OrganizationMemberRemoved> for OrganizationEvent {
    fn from(value: OrganizationMemberRemoved) -> Self {
        Self::MemberRemoved(value)
    }
}
impl ::std::convert::From<OrganizationRenamed> for OrganizationEvent {
    fn from(value: OrganizationRenamed) -> Self {
        Self::Renamed(value)
    }
}
#[doc = "`OrganizationMemberAdded`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"organization member_added event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"membership\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"member_added\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"membership\": {"]
#[doc = "      \"$ref\": \"#/definitions/membership\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberAdded {
    pub action: OrganizationMemberAddedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrganizationMemberAdded> for OrganizationMemberAdded {
    fn from(value: &OrganizationMemberAdded) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationMemberAddedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"member_added\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrganizationMemberAddedAction {
    #[serde(rename = "member_added")]
    MemberAdded,
}
impl ::std::convert::From<&Self> for OrganizationMemberAddedAction {
    fn from(value: &OrganizationMemberAddedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrganizationMemberAddedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::MemberAdded => write!(f, "member_added"),
        }
    }
}
impl ::std::str::FromStr for OrganizationMemberAddedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "member_added" => Ok(Self::MemberAdded),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrganizationMemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrganizationMemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrganizationMemberAddedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrganizationMemberInvited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"organization member_invited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"invitation\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"member_invited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"invitation\": {"]
#[doc = "      \"description\": \"The invitation for the user or email if the action is `member_invited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"email\","]
#[doc = "        \"failed_at\","]
#[doc = "        \"failed_reason\","]
#[doc = "        \"id\","]
#[doc = "        \"invitation_teams_url\","]
#[doc = "        \"inviter\","]
#[doc = "        \"login\","]
#[doc = "        \"node_id\","]
#[doc = "        \"role\","]
#[doc = "        \"team_count\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"email\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"failed_at\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"failed_reason\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"invitation_teams_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"inviter\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"login\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"role\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"team_count\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvited {
    pub action: OrganizationMemberInvitedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub invitation: OrganizationMemberInvitedInvitation,
    pub organization: Organization,
    pub sender: User,
    pub user: User,
}
impl ::std::convert::From<&OrganizationMemberInvited> for OrganizationMemberInvited {
    fn from(value: &OrganizationMemberInvited) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationMemberInvitedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"member_invited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrganizationMemberInvitedAction {
    #[serde(rename = "member_invited")]
    MemberInvited,
}
impl ::std::convert::From<&Self> for OrganizationMemberInvitedAction {
    fn from(value: &OrganizationMemberInvitedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrganizationMemberInvitedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::MemberInvited => write!(f, "member_invited"),
        }
    }
}
impl ::std::str::FromStr for OrganizationMemberInvitedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "member_invited" => Ok(Self::MemberInvited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrganizationMemberInvitedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrganizationMemberInvitedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrganizationMemberInvitedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The invitation for the user or email if the action is `member_invited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The invitation for the user or email if the action is `member_invited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"email\","]
#[doc = "    \"failed_at\","]
#[doc = "    \"failed_reason\","]
#[doc = "    \"id\","]
#[doc = "    \"invitation_teams_url\","]
#[doc = "    \"inviter\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"role\","]
#[doc = "    \"team_count\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"failed_at\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"failed_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"invitation_teams_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"inviter\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"team_count\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvitedInvitation {
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub email: ::std::option::Option<::std::string::String>,
    pub failed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub failed_reason: ::std::option::Option<::std::string::String>,
    pub id: f64,
    pub invitation_teams_url: ::std::string::String,
    pub inviter: User,
    pub login: ::std::string::String,
    pub node_id: ::std::string::String,
    pub role: ::std::string::String,
    pub team_count: f64,
}
impl ::std::convert::From<&OrganizationMemberInvitedInvitation>
    for OrganizationMemberInvitedInvitation
{
    fn from(value: &OrganizationMemberInvitedInvitation) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationMemberRemoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"organization member_removed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"membership\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"member_removed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"membership\": {"]
#[doc = "      \"$ref\": \"#/definitions/membership\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberRemoved {
    pub action: OrganizationMemberRemovedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrganizationMemberRemoved> for OrganizationMemberRemoved {
    fn from(value: &OrganizationMemberRemoved) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationMemberRemovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"member_removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrganizationMemberRemovedAction {
    #[serde(rename = "member_removed")]
    MemberRemoved,
}
impl ::std::convert::From<&Self> for OrganizationMemberRemovedAction {
    fn from(value: &OrganizationMemberRemovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrganizationMemberRemovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::MemberRemoved => write!(f, "member_removed"),
        }
    }
}
impl ::std::str::FromStr for OrganizationMemberRemovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "member_removed" => Ok(Self::MemberRemoved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrganizationMemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrganizationMemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrganizationMemberRemovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrganizationRenamed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"organization renamed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"membership\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"renamed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"membership\": {"]
#[doc = "      \"$ref\": \"#/definitions/membership\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamed {
    pub action: OrganizationRenamedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub membership: Membership,
    pub organization: Organization,
    pub sender: User,
}
impl ::std::convert::From<&OrganizationRenamed> for OrganizationRenamed {
    fn from(value: &OrganizationRenamed) -> Self {
        value.clone()
    }
}
#[doc = "`OrganizationRenamedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"renamed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrganizationRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl ::std::convert::From<&Self> for OrganizationRenamedAction {
    fn from(value: &OrganizationRenamedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrganizationRenamedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Renamed => write!(f, "renamed"),
        }
    }
}
impl ::std::str::FromStr for OrganizationRenamedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrganizationRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrganizationRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrganizationRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PackageEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/package$published\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/package$updated\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackageEvent {
    Published(PackagePublished),
    Updated(PackageUpdated),
}
impl ::std::convert::From<&Self> for PackageEvent {
    fn from(value: &PackageEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PackagePublished> for PackageEvent {
    fn from(value: PackagePublished) -> Self {
        Self::Published(value)
    }
}
impl ::std::convert::From<PackageUpdated> for PackageEvent {
    fn from(value: PackageUpdated) -> Self {
        Self::Updated(value)
    }
}
#[doc = "`PackagePublished`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"package published event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"package\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"published\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"description\": \"Information about the package.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"ecosystem\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"namespace\","]
#[doc = "        \"owner\","]
#[doc = "        \"package_type\","]
#[doc = "        \"package_version\","]
#[doc = "        \"registry\","]
#[doc = "        \"updated_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"namespace\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"owner\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"package_type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"package_version\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"author\","]
#[doc = "            \"body\","]
#[doc = "            \"body_html\","]
#[doc = "            \"created_at\","]
#[doc = "            \"description\","]
#[doc = "            \"docker_metadata\","]
#[doc = "            \"draft\","]
#[doc = "            \"html_url\","]
#[doc = "            \"id\","]
#[doc = "            \"installation_command\","]
#[doc = "            \"manifest\","]
#[doc = "            \"metadata\","]
#[doc = "            \"name\","]
#[doc = "            \"package_files\","]
#[doc = "            \"prerelease\","]
#[doc = "            \"release\","]
#[doc = "            \"source_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"tag_name\","]
#[doc = "            \"target_commitish\","]
#[doc = "            \"target_oid\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"author\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            \"body\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"body_html\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"docker_metadata\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"installation_command\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"manifest\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"metadata\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"package_files\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"content_type\","]
#[doc = "                  \"created_at\","]
#[doc = "                  \"download_url\","]
#[doc = "                  \"id\","]
#[doc = "                  \"md5\","]
#[doc = "                  \"name\","]
#[doc = "                  \"sha1\","]
#[doc = "                  \"sha256\","]
#[doc = "                  \"size\","]
#[doc = "                  \"state\","]
#[doc = "                  \"updated_at\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"content_type\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"created_at\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"download_url\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"format\": \"uri\""]
#[doc = "                  },"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"type\": \"integer\""]
#[doc = "                  },"]
#[doc = "                  \"md5\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"sha1\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"sha256\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"size\": {"]
#[doc = "                    \"type\": \"integer\""]
#[doc = "                  },"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"updated_at\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"prerelease\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"release\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"author\","]
#[doc = "                \"created_at\","]
#[doc = "                \"draft\","]
#[doc = "                \"html_url\","]
#[doc = "                \"id\","]
#[doc = "                \"name\","]
#[doc = "                \"prerelease\","]
#[doc = "                \"published_at\","]
#[doc = "                \"tag_name\","]
#[doc = "                \"target_commitish\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"author\": {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                },"]
#[doc = "                \"created_at\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"draft\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"html_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"id\": {"]
#[doc = "                  \"type\": \"integer\""]
#[doc = "                },"]
#[doc = "                \"name\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"prerelease\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"published_at\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"tag_name\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"target_commitish\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"source_url\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tag_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_commitish\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_oid\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"registry\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"about_url\","]
#[doc = "            \"name\","]
#[doc = "            \"type\","]
#[doc = "            \"url\","]
#[doc = "            \"vendor\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"about_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"vendor\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublished {
    pub action: PackagePublishedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub package: PackagePublishedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PackagePublished> for PackagePublished {
    fn from(value: &PackagePublished) -> Self {
        value.clone()
    }
}
#[doc = "`PackagePublishedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"published\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PackagePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl ::std::convert::From<&Self> for PackagePublishedAction {
    fn from(value: &PackagePublishedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PackagePublishedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Published => write!(f, "published"),
        }
    }
}
impl ::std::str::FromStr for PackagePublishedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PackagePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PackagePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PackagePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Information about the package.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"ecosystem\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"namespace\","]
#[doc = "    \"owner\","]
#[doc = "    \"package_type\","]
#[doc = "    \"package_version\","]
#[doc = "    \"registry\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namespace\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"owner\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"package_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"package_version\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"body\","]
#[doc = "        \"body_html\","]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"docker_metadata\","]
#[doc = "        \"draft\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"installation_command\","]
#[doc = "        \"manifest\","]
#[doc = "        \"metadata\","]
#[doc = "        \"name\","]
#[doc = "        \"package_files\","]
#[doc = "        \"prerelease\","]
#[doc = "        \"release\","]
#[doc = "        \"source_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"tag_name\","]
#[doc = "        \"target_commitish\","]
#[doc = "        \"target_oid\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"body_html\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"docker_metadata\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"installation_command\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"manifest\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"package_files\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"content_type\","]
#[doc = "              \"created_at\","]
#[doc = "              \"download_url\","]
#[doc = "              \"id\","]
#[doc = "              \"md5\","]
#[doc = "              \"name\","]
#[doc = "              \"sha1\","]
#[doc = "              \"sha256\","]
#[doc = "              \"size\","]
#[doc = "              \"state\","]
#[doc = "              \"updated_at\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"content_type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"created_at\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"download_url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              },"]
#[doc = "              \"id\": {"]
#[doc = "                \"type\": \"integer\""]
#[doc = "              },"]
#[doc = "              \"md5\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"sha1\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"sha256\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"size\": {"]
#[doc = "                \"type\": \"integer\""]
#[doc = "              },"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"updated_at\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"prerelease\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"release\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"author\","]
#[doc = "            \"created_at\","]
#[doc = "            \"draft\","]
#[doc = "            \"html_url\","]
#[doc = "            \"id\","]
#[doc = "            \"name\","]
#[doc = "            \"prerelease\","]
#[doc = "            \"published_at\","]
#[doc = "            \"tag_name\","]
#[doc = "            \"target_commitish\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"author\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"prerelease\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"published_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tag_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_commitish\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"source_url\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tag_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_commitish\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_oid\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"registry\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"about_url\","]
#[doc = "        \"name\","]
#[doc = "        \"type\","]
#[doc = "        \"url\","]
#[doc = "        \"vendor\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"about_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"vendor\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackage {
    pub created_at: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    pub ecosystem: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub namespace: ::std::string::String,
    pub owner: User,
    pub package_type: ::std::string::String,
    pub package_version: PackagePublishedPackagePackageVersion,
    pub registry: PackagePublishedPackageRegistry,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&PackagePublishedPackage> for PackagePublishedPackage {
    fn from(value: &PackagePublishedPackage) -> Self {
        value.clone()
    }
}
#[doc = "`PackagePublishedPackagePackageVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"body\","]
#[doc = "    \"body_html\","]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"docker_metadata\","]
#[doc = "    \"draft\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"installation_command\","]
#[doc = "    \"manifest\","]
#[doc = "    \"metadata\","]
#[doc = "    \"name\","]
#[doc = "    \"package_files\","]
#[doc = "    \"prerelease\","]
#[doc = "    \"release\","]
#[doc = "    \"source_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"tag_name\","]
#[doc = "    \"target_commitish\","]
#[doc = "    \"target_oid\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"body_html\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"docker_metadata\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"installation_command\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"manifest\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"package_files\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"content_type\","]
#[doc = "          \"created_at\","]
#[doc = "          \"download_url\","]
#[doc = "          \"id\","]
#[doc = "          \"md5\","]
#[doc = "          \"name\","]
#[doc = "          \"sha1\","]
#[doc = "          \"sha256\","]
#[doc = "          \"size\","]
#[doc = "          \"state\","]
#[doc = "          \"updated_at\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"content_type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"created_at\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"download_url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"md5\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"sha1\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"sha256\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"size\": {"]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"state\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"updated_at\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"prerelease\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"created_at\","]
#[doc = "        \"draft\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"prerelease\","]
#[doc = "        \"published_at\","]
#[doc = "        \"tag_name\","]
#[doc = "        \"target_commitish\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"prerelease\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tag_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_commitish\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"source_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tag_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_commitish\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_oid\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersion {
    pub author: User,
    pub body: ::std::string::String,
    pub body_html: ::std::string::String,
    pub created_at: ::std::string::String,
    pub description: ::std::string::String,
    pub docker_metadata: ::std::vec::Vec<::serde_json::Value>,
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub installation_command: ::std::string::String,
    pub manifest: ::std::string::String,
    pub metadata: ::std::vec::Vec<::serde_json::Value>,
    pub name: ::std::string::String,
    pub package_files: ::std::vec::Vec<PackagePublishedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackagePublishedPackagePackageVersionRelease,
    pub source_url: ::std::string::String,
    pub summary: ::std::string::String,
    pub tag_name: ::std::string::String,
    pub target_commitish: ::std::string::String,
    pub target_oid: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub version: ::std::string::String,
}
impl ::std::convert::From<&PackagePublishedPackagePackageVersion>
    for PackagePublishedPackagePackageVersion
{
    fn from(value: &PackagePublishedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[doc = "`PackagePublishedPackagePackageVersionPackageFilesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content_type\","]
#[doc = "    \"created_at\","]
#[doc = "    \"download_url\","]
#[doc = "    \"id\","]
#[doc = "    \"md5\","]
#[doc = "    \"name\","]
#[doc = "    \"sha1\","]
#[doc = "    \"sha256\","]
#[doc = "    \"size\","]
#[doc = "    \"state\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"download_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"md5\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sha1\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sha256\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionPackageFilesItem {
    pub content_type: ::std::string::String,
    pub created_at: ::std::string::String,
    pub download_url: ::std::string::String,
    pub id: i64,
    pub md5: ::std::string::String,
    pub name: ::std::string::String,
    pub sha1: ::std::string::String,
    pub sha256: ::std::string::String,
    pub size: i64,
    pub state: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&PackagePublishedPackagePackageVersionPackageFilesItem>
    for PackagePublishedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackagePublishedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[doc = "`PackagePublishedPackagePackageVersionRelease`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"created_at\","]
#[doc = "    \"draft\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"prerelease\","]
#[doc = "    \"published_at\","]
#[doc = "    \"tag_name\","]
#[doc = "    \"target_commitish\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"prerelease\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tag_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_commitish\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: ::std::string::String,
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub prerelease: bool,
    pub published_at: ::std::string::String,
    pub tag_name: ::std::string::String,
    pub target_commitish: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&PackagePublishedPackagePackageVersionRelease>
    for PackagePublishedPackagePackageVersionRelease
{
    fn from(value: &PackagePublishedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[doc = "`PackagePublishedPackageRegistry`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"about_url\","]
#[doc = "    \"name\","]
#[doc = "    \"type\","]
#[doc = "    \"url\","]
#[doc = "    \"vendor\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"about_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"vendor\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackageRegistry {
    pub about_url: ::std::string::String,
    pub name: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
    pub vendor: ::std::string::String,
}
impl ::std::convert::From<&PackagePublishedPackageRegistry> for PackagePublishedPackageRegistry {
    fn from(value: &PackagePublishedPackageRegistry) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"package updated event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"package\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"updated\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"description\": \"Information about the package.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"ecosystem\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"namespace\","]
#[doc = "        \"owner\","]
#[doc = "        \"package_type\","]
#[doc = "        \"package_version\","]
#[doc = "        \"registry\","]
#[doc = "        \"updated_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"namespace\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"owner\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"package_type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"package_version\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"author\","]
#[doc = "            \"body\","]
#[doc = "            \"body_html\","]
#[doc = "            \"created_at\","]
#[doc = "            \"description\","]
#[doc = "            \"docker_metadata\","]
#[doc = "            \"draft\","]
#[doc = "            \"html_url\","]
#[doc = "            \"id\","]
#[doc = "            \"installation_command\","]
#[doc = "            \"manifest\","]
#[doc = "            \"metadata\","]
#[doc = "            \"name\","]
#[doc = "            \"package_files\","]
#[doc = "            \"prerelease\","]
#[doc = "            \"release\","]
#[doc = "            \"source_url\","]
#[doc = "            \"summary\","]
#[doc = "            \"tag_name\","]
#[doc = "            \"target_commitish\","]
#[doc = "            \"target_oid\","]
#[doc = "            \"updated_at\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"author\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            \"body\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"body_html\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"description\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"docker_metadata\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"installation_command\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"manifest\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"metadata\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"package_files\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"content_type\","]
#[doc = "                  \"created_at\","]
#[doc = "                  \"download_url\","]
#[doc = "                  \"id\","]
#[doc = "                  \"md5\","]
#[doc = "                  \"name\","]
#[doc = "                  \"sha1\","]
#[doc = "                  \"sha256\","]
#[doc = "                  \"size\","]
#[doc = "                  \"state\","]
#[doc = "                  \"updated_at\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"content_type\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"created_at\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"download_url\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"format\": \"uri\""]
#[doc = "                  },"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"type\": \"integer\""]
#[doc = "                  },"]
#[doc = "                  \"md5\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"sha1\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"sha256\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"size\": {"]
#[doc = "                    \"type\": \"integer\""]
#[doc = "                  },"]
#[doc = "                  \"state\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"updated_at\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"prerelease\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"release\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"author\","]
#[doc = "                \"created_at\","]
#[doc = "                \"draft\","]
#[doc = "                \"html_url\","]
#[doc = "                \"id\","]
#[doc = "                \"name\","]
#[doc = "                \"prerelease\","]
#[doc = "                \"published_at\","]
#[doc = "                \"tag_name\","]
#[doc = "                \"target_commitish\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"author\": {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                },"]
#[doc = "                \"created_at\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"draft\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"html_url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                },"]
#[doc = "                \"id\": {"]
#[doc = "                  \"type\": \"integer\""]
#[doc = "                },"]
#[doc = "                \"name\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"prerelease\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"published_at\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"tag_name\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"target_commitish\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"source_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"summary\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tag_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_commitish\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_oid\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"updated_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"registry\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"about_url\","]
#[doc = "            \"name\","]
#[doc = "            \"type\","]
#[doc = "            \"url\","]
#[doc = "            \"vendor\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"about_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"vendor\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdated {
    pub action: PackageUpdatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub package: PackageUpdatedPackage,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PackageUpdated> for PackageUpdated {
    fn from(value: &PackageUpdated) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"updated\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PackageUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl ::std::convert::From<&Self> for PackageUpdatedAction {
    fn from(value: &PackageUpdatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PackageUpdatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Updated => write!(f, "updated"),
        }
    }
}
impl ::std::str::FromStr for PackageUpdatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PackageUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PackageUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PackageUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Information about the package."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Information about the package.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"ecosystem\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"namespace\","]
#[doc = "    \"owner\","]
#[doc = "    \"package_type\","]
#[doc = "    \"package_version\","]
#[doc = "    \"registry\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namespace\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"owner\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"package_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"package_version\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"body\","]
#[doc = "        \"body_html\","]
#[doc = "        \"created_at\","]
#[doc = "        \"description\","]
#[doc = "        \"docker_metadata\","]
#[doc = "        \"draft\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"installation_command\","]
#[doc = "        \"manifest\","]
#[doc = "        \"metadata\","]
#[doc = "        \"name\","]
#[doc = "        \"package_files\","]
#[doc = "        \"prerelease\","]
#[doc = "        \"release\","]
#[doc = "        \"source_url\","]
#[doc = "        \"summary\","]
#[doc = "        \"tag_name\","]
#[doc = "        \"target_commitish\","]
#[doc = "        \"target_oid\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"body_html\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"docker_metadata\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"installation_command\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"manifest\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"package_files\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"content_type\","]
#[doc = "              \"created_at\","]
#[doc = "              \"download_url\","]
#[doc = "              \"id\","]
#[doc = "              \"md5\","]
#[doc = "              \"name\","]
#[doc = "              \"sha1\","]
#[doc = "              \"sha256\","]
#[doc = "              \"size\","]
#[doc = "              \"state\","]
#[doc = "              \"updated_at\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"content_type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"created_at\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"download_url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              },"]
#[doc = "              \"id\": {"]
#[doc = "                \"type\": \"integer\""]
#[doc = "              },"]
#[doc = "              \"md5\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"sha1\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"sha256\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"size\": {"]
#[doc = "                \"type\": \"integer\""]
#[doc = "              },"]
#[doc = "              \"state\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"updated_at\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"prerelease\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"release\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"author\","]
#[doc = "            \"created_at\","]
#[doc = "            \"draft\","]
#[doc = "            \"html_url\","]
#[doc = "            \"id\","]
#[doc = "            \"name\","]
#[doc = "            \"prerelease\","]
#[doc = "            \"published_at\","]
#[doc = "            \"tag_name\","]
#[doc = "            \"target_commitish\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"author\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            \"created_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"html_url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"prerelease\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"published_at\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tag_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"target_commitish\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"source_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tag_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_commitish\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_oid\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"registry\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"about_url\","]
#[doc = "        \"name\","]
#[doc = "        \"type\","]
#[doc = "        \"url\","]
#[doc = "        \"vendor\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"about_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"vendor\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackage {
    pub created_at: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    pub ecosystem: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub namespace: ::std::string::String,
    pub owner: User,
    pub package_type: ::std::string::String,
    pub package_version: PackageUpdatedPackagePackageVersion,
    pub registry: PackageUpdatedPackageRegistry,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&PackageUpdatedPackage> for PackageUpdatedPackage {
    fn from(value: &PackageUpdatedPackage) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdatedPackagePackageVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"body\","]
#[doc = "    \"body_html\","]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"docker_metadata\","]
#[doc = "    \"draft\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"installation_command\","]
#[doc = "    \"manifest\","]
#[doc = "    \"metadata\","]
#[doc = "    \"name\","]
#[doc = "    \"package_files\","]
#[doc = "    \"prerelease\","]
#[doc = "    \"release\","]
#[doc = "    \"source_url\","]
#[doc = "    \"summary\","]
#[doc = "    \"tag_name\","]
#[doc = "    \"target_commitish\","]
#[doc = "    \"target_oid\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"body_html\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"docker_metadata\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"installation_command\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"manifest\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"package_files\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"content_type\","]
#[doc = "          \"created_at\","]
#[doc = "          \"download_url\","]
#[doc = "          \"id\","]
#[doc = "          \"md5\","]
#[doc = "          \"name\","]
#[doc = "          \"sha1\","]
#[doc = "          \"sha256\","]
#[doc = "          \"size\","]
#[doc = "          \"state\","]
#[doc = "          \"updated_at\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"content_type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"created_at\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"download_url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"md5\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"sha1\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"sha256\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"size\": {"]
#[doc = "            \"type\": \"integer\""]
#[doc = "          },"]
#[doc = "          \"state\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"updated_at\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"prerelease\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"created_at\","]
#[doc = "        \"draft\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"prerelease\","]
#[doc = "        \"published_at\","]
#[doc = "        \"tag_name\","]
#[doc = "        \"target_commitish\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"prerelease\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tag_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"target_commitish\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"source_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tag_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_commitish\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_oid\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersion {
    pub author: User,
    pub body: ::std::string::String,
    pub body_html: ::std::string::String,
    pub created_at: ::std::string::String,
    pub description: ::std::string::String,
    pub docker_metadata: ::std::vec::Vec<::serde_json::Value>,
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub installation_command: ::std::string::String,
    pub manifest: ::std::string::String,
    pub metadata: ::std::vec::Vec<::serde_json::Value>,
    pub name: ::std::string::String,
    pub package_files: ::std::vec::Vec<PackageUpdatedPackagePackageVersionPackageFilesItem>,
    pub prerelease: bool,
    pub release: PackageUpdatedPackagePackageVersionRelease,
    pub source_url: ::std::string::String,
    pub summary: ::std::string::String,
    pub tag_name: ::std::string::String,
    pub target_commitish: ::std::string::String,
    pub target_oid: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub version: ::std::string::String,
}
impl ::std::convert::From<&PackageUpdatedPackagePackageVersion>
    for PackageUpdatedPackagePackageVersion
{
    fn from(value: &PackageUpdatedPackagePackageVersion) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdatedPackagePackageVersionPackageFilesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content_type\","]
#[doc = "    \"created_at\","]
#[doc = "    \"download_url\","]
#[doc = "    \"id\","]
#[doc = "    \"md5\","]
#[doc = "    \"name\","]
#[doc = "    \"sha1\","]
#[doc = "    \"sha256\","]
#[doc = "    \"size\","]
#[doc = "    \"state\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"download_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"md5\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sha1\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sha256\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionPackageFilesItem {
    pub content_type: ::std::string::String,
    pub created_at: ::std::string::String,
    pub download_url: ::std::string::String,
    pub id: i64,
    pub md5: ::std::string::String,
    pub name: ::std::string::String,
    pub sha1: ::std::string::String,
    pub sha256: ::std::string::String,
    pub size: i64,
    pub state: ::std::string::String,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&PackageUpdatedPackagePackageVersionPackageFilesItem>
    for PackageUpdatedPackagePackageVersionPackageFilesItem
{
    fn from(value: &PackageUpdatedPackagePackageVersionPackageFilesItem) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdatedPackagePackageVersionRelease`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"created_at\","]
#[doc = "    \"draft\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"prerelease\","]
#[doc = "    \"published_at\","]
#[doc = "    \"tag_name\","]
#[doc = "    \"target_commitish\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"prerelease\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tag_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"target_commitish\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionRelease {
    pub author: User,
    pub created_at: ::std::string::String,
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub prerelease: bool,
    pub published_at: ::std::string::String,
    pub tag_name: ::std::string::String,
    pub target_commitish: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&PackageUpdatedPackagePackageVersionRelease>
    for PackageUpdatedPackagePackageVersionRelease
{
    fn from(value: &PackageUpdatedPackagePackageVersionRelease) -> Self {
        value.clone()
    }
}
#[doc = "`PackageUpdatedPackageRegistry`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"about_url\","]
#[doc = "    \"name\","]
#[doc = "    \"type\","]
#[doc = "    \"url\","]
#[doc = "    \"vendor\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"about_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"vendor\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackageRegistry {
    pub about_url: ::std::string::String,
    pub name: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub url: ::std::string::String,
    pub vendor: ::std::string::String,
}
impl ::std::convert::From<&PackageUpdatedPackageRegistry> for PackageUpdatedPackageRegistry {
    fn from(value: &PackageUpdatedPackageRegistry) -> Self {
        value.clone()
    }
}
#[doc = "Page Build"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"page_build event\","]
#[doc = "  \"description\": \"Page Build\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"build\","]
#[doc = "    \"id\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"build\": {"]
#[doc = "      \"description\": \"The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"commit\","]
#[doc = "        \"created_at\","]
#[doc = "        \"duration\","]
#[doc = "        \"error\","]
#[doc = "        \"pusher\","]
#[doc = "        \"status\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"commit\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"duration\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"error\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"message\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"message\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"pusher\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEvent {
    pub build: PageBuildEventBuild,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PageBuildEvent> for PageBuildEvent {
    fn from(value: &PageBuildEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"commit\","]
#[doc = "    \"created_at\","]
#[doc = "    \"duration\","]
#[doc = "    \"error\","]
#[doc = "    \"pusher\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"commit\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"duration\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"error\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"pusher\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuild {
    pub commit: ::std::string::String,
    pub created_at: ::std::string::String,
    pub duration: i64,
    pub error: PageBuildEventBuildError,
    pub pusher: User,
    pub status: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&PageBuildEventBuild> for PageBuildEventBuild {
    fn from(value: &PageBuildEventBuild) -> Self {
        value.clone()
    }
}
#[doc = "`PageBuildEventBuildError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuildError {
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&PageBuildEventBuildError> for PageBuildEventBuildError {
    fn from(value: &PageBuildEventBuildError) -> Self {
        value.clone()
    }
}
#[doc = "`PingEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ping event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hook\","]
#[doc = "    \"hook_id\","]
#[doc = "    \"zen\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hook\": {"]
#[doc = "      \"description\": \"The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"active\","]
#[doc = "        \"config\","]
#[doc = "        \"created_at\","]
#[doc = "        \"events\","]
#[doc = "        \"id\","]
#[doc = "        \"name\","]
#[doc = "        \"ping_url\","]
#[doc = "        \"type\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"active\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"app_id\": {"]
#[doc = "          \"description\": \"When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"config\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"content_type\","]
#[doc = "            \"insecure_ssl\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"content_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\","]
#[doc = "                \"form\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"insecure_ssl\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"secret\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"events\": {"]
#[doc = "          \"$ref\": \"#/definitions/webhook-events\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"last_response\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\","]
#[doc = "            \"message\","]
#[doc = "            \"status\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"status\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ping_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"test_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"hook_id\": {"]
#[doc = "      \"description\": \"The ID of the webhook that triggered the ping.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"zen\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PingEvent {
    pub hook: PingEventHook,
    #[doc = "The ID of the webhook that triggered the ping."]
    pub hook_id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sender: ::std::option::Option<User>,
    pub zen: ::std::string::String,
}
impl ::std::convert::From<&PingEvent> for PingEvent {
    fn from(value: &PingEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"active\","]
#[doc = "    \"config\","]
#[doc = "    \"created_at\","]
#[doc = "    \"events\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"ping_url\","]
#[doc = "    \"type\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"active\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"app_id\": {"]
#[doc = "      \"description\": \"When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"config\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"content_type\","]
#[doc = "        \"insecure_ssl\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"content_type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"json\","]
#[doc = "            \"form\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"insecure_ssl\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"secret\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"events\": {"]
#[doc = "      \"$ref\": \"#/definitions/webhook-events\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"last_response\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\","]
#[doc = "        \"status\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ping_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"test_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PingEventHook {
    pub active: bool,
    #[doc = "When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub app_id: ::std::option::Option<i64>,
    pub config: PingEventHookConfig,
    pub created_at: ::std::string::String,
    pub events: WebhookEvents,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub last_response: ::std::option::Option<PingEventHookLastResponse>,
    pub name: ::std::string::String,
    pub ping_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub test_url: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&PingEventHook> for PingEventHook {
    fn from(value: &PingEventHook) -> Self {
        value.clone()
    }
}
#[doc = "`PingEventHookConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content_type\","]
#[doc = "    \"insecure_ssl\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content_type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\","]
#[doc = "        \"form\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"insecure_ssl\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"secret\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookConfig {
    pub content_type: PingEventHookConfigContentType,
    pub insecure_ssl: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret: ::std::option::Option<::std::string::String>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&PingEventHookConfig> for PingEventHookConfig {
    fn from(value: &PingEventHookConfig) -> Self {
        value.clone()
    }
}
#[doc = "`PingEventHookConfigContentType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\","]
#[doc = "    \"form\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PingEventHookConfigContentType {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "form")]
    Form,
}
impl ::std::convert::From<&Self> for PingEventHookConfigContentType {
    fn from(value: &PingEventHookConfigContentType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PingEventHookConfigContentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Json => write!(f, "json"),
            Self::Form => write!(f, "form"),
        }
    }
}
impl ::std::str::FromStr for PingEventHookConfigContentType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            "form" => Ok(Self::Form),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PingEventHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PingEventHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PingEventHookConfigContentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PingEventHookLastResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\","]
#[doc = "    \"status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookLastResponse {
    pub code: (),
    pub message: (),
    pub status: ::std::string::String,
}
impl ::std::convert::From<&PingEventHookLastResponse> for PingEventHookLastResponse {
    fn from(value: &PingEventHookLastResponse) -> Self {
        value.clone()
    }
}
#[doc = "`Project`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Project\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"body\","]
#[doc = "    \"columns_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"owner_url\","]
#[doc = "    \"state\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"Body of the project\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"columns_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Name of the project\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"owner_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of the project; either 'open' or 'closed'\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Project {
    #[doc = "Body of the project"]
    pub body: ::std::option::Option<::std::string::String>,
    pub columns_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    pub html_url: ::std::string::String,
    pub id: i64,
    #[doc = "Name of the project"]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub owner_url: ::std::string::String,
    #[doc = "State of the project; either 'open' or 'closed'"]
    pub state: ProjectState,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Project> for Project {
    fn from(value: &Project) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCard`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Project Card\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"archived\","]
#[doc = "    \"column_id\","]
#[doc = "    \"column_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"creator\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"note\","]
#[doc = "    \"project_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after_id\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"archived\": {"]
#[doc = "      \"description\": \"Whether or not the card is archived\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"column_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"column_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"content_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"creator\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The project card's ID\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"note\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"project_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCard {
    #[serde(default)]
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_url: ::std::option::Option<::std::string::String>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: ::std::string::String,
    pub note: ::std::option::Option<::std::string::String>,
    pub project_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&ProjectCard> for ProjectCard {
    fn from(value: &ProjectCard) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardConverted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_card converted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"project_card\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"converted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"note\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"note\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_card\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-card\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConverted {
    pub action: ProjectCardConvertedAction,
    pub changes: ProjectCardConvertedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCardConverted> for ProjectCardConverted {
    fn from(value: &ProjectCardConverted) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardConvertedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"converted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCardConvertedAction {
    #[serde(rename = "converted")]
    Converted,
}
impl ::std::convert::From<&Self> for ProjectCardConvertedAction {
    fn from(value: &ProjectCardConvertedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCardConvertedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Converted => write!(f, "converted"),
        }
    }
}
impl ::std::str::FromStr for ProjectCardConvertedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "converted" => Ok(Self::Converted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCardConvertedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCardConvertedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCardConvertedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCardConvertedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"note\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"note\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChanges {
    pub note: ProjectCardConvertedChangesNote,
}
impl ::std::convert::From<&ProjectCardConvertedChanges> for ProjectCardConvertedChanges {
    fn from(value: &ProjectCardConvertedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardConvertedChangesNote`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChangesNote {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ProjectCardConvertedChangesNote> for ProjectCardConvertedChangesNote {
    fn from(value: &ProjectCardConvertedChangesNote) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_card created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project_card\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_card\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-card\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardCreated {
    pub action: ProjectCardCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCardCreated> for ProjectCardCreated {
    fn from(value: &ProjectCardCreated) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCardCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for ProjectCardCreatedAction {
    fn from(value: &ProjectCardCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCardCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for ProjectCardCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCardCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCardCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCardCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCardDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_card deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project_card\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_card\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-card\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardDeleted {
    pub action: ProjectCardDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCardDeleted> for ProjectCardDeleted {
    fn from(value: &ProjectCardDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCardDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for ProjectCardDeletedAction {
    fn from(value: &ProjectCardDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCardDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for ProjectCardDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCardDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCardDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCardDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCardEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_card edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"project_card\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"note\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"note\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_card\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-card\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEdited {
    pub action: ProjectCardEditedAction,
    pub changes: ProjectCardEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_card: ProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCardEdited> for ProjectCardEdited {
    fn from(value: &ProjectCardEdited) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCardEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for ProjectCardEditedAction {
    fn from(value: &ProjectCardEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCardEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for ProjectCardEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCardEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCardEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCardEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCardEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"note\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"note\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChanges {
    pub note: ProjectCardEditedChangesNote,
}
impl ::std::convert::From<&ProjectCardEditedChanges> for ProjectCardEditedChanges {
    fn from(value: &ProjectCardEditedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardEditedChangesNote`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChangesNote {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ProjectCardEditedChangesNote> for ProjectCardEditedChangesNote {
    fn from(value: &ProjectCardEditedChangesNote) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card$converted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_card$moved\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectCardEvent {
    Converted(ProjectCardConverted),
    Created(ProjectCardCreated),
    Deleted(ProjectCardDeleted),
    Edited(ProjectCardEdited),
    Moved(ProjectCardMoved),
}
impl ::std::convert::From<&Self> for ProjectCardEvent {
    fn from(value: &ProjectCardEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ProjectCardConverted> for ProjectCardEvent {
    fn from(value: ProjectCardConverted) -> Self {
        Self::Converted(value)
    }
}
impl ::std::convert::From<ProjectCardCreated> for ProjectCardEvent {
    fn from(value: ProjectCardCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<ProjectCardDeleted> for ProjectCardEvent {
    fn from(value: ProjectCardDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<ProjectCardEdited> for ProjectCardEvent {
    fn from(value: ProjectCardEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<ProjectCardMoved> for ProjectCardEvent {
    fn from(value: ProjectCardMoved) -> Self {
        Self::Moved(value)
    }
}
#[doc = "`ProjectCardMoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_card moved event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"project_card\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"moved\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"column_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"column_id\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_card\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/project-card\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"after_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"after_id\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"number\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMoved {
    pub action: ProjectCardMovedAction,
    pub changes: ProjectCardMovedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_card: ProjectCardMovedProjectCard,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCardMoved> for ProjectCardMoved {
    fn from(value: &ProjectCardMoved) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardMovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"moved\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCardMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl ::std::convert::From<&Self> for ProjectCardMovedAction {
    fn from(value: &ProjectCardMovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCardMovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Moved => write!(f, "moved"),
        }
    }
}
impl ::std::str::FromStr for ProjectCardMovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCardMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCardMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCardMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCardMovedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"column_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"column_id\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChanges {
    pub column_id: ProjectCardMovedChangesColumnId,
}
impl ::std::convert::From<&ProjectCardMovedChanges> for ProjectCardMovedChanges {
    fn from(value: &ProjectCardMovedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardMovedChangesColumnId`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChangesColumnId {
    pub from: i64,
}
impl ::std::convert::From<&ProjectCardMovedChangesColumnId> for ProjectCardMovedChangesColumnId {
    fn from(value: &ProjectCardMovedChangesColumnId) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCardMovedProjectCard`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project-card\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"after_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"after_id\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"number\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedProjectCard {
    pub after_id: (),
    #[doc = "Whether or not the card is archived"]
    pub archived: bool,
    pub column_id: i64,
    pub column_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content_url: ::std::option::Option<::std::string::String>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub creator: User,
    #[doc = "The project card's ID"]
    pub id: i64,
    pub node_id: ::std::string::String,
    pub note: ::std::option::Option<::std::string::String>,
    pub project_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&ProjectCardMovedProjectCard> for ProjectCardMovedProjectCard {
    fn from(value: &ProjectCardMovedProjectCard) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectClosed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project closed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project\": {"]
#[doc = "      \"$ref\": \"#/definitions/project\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectClosed {
    pub action: ProjectClosedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectClosed> for ProjectClosed {
    fn from(value: &ProjectClosed) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectClosedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for ProjectClosedAction {
    fn from(value: &ProjectClosedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectClosedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for ProjectClosedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectColumn`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Project Column\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cards_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"project_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cards_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The unique identifier of the project column\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Name of the project column\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"project_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumn {
    pub cards_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The unique identifier of the project column"]
    pub id: i64,
    #[doc = "Name of the project column"]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub project_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&ProjectColumn> for ProjectColumn {
    fn from(value: &ProjectColumn) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_column created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project_column\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_column\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-column\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnCreated {
    pub action: ProjectColumnCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectColumnCreated> for ProjectColumnCreated {
    fn from(value: &ProjectColumnCreated) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectColumnCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for ProjectColumnCreatedAction {
    fn from(value: &ProjectColumnCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectColumnCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for ProjectColumnCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectColumnCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectColumnCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectColumnCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectColumnDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_column deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project_column\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_column\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-column\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnDeleted {
    pub action: ProjectColumnDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectColumnDeleted> for ProjectColumnDeleted {
    fn from(value: &ProjectColumnDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectColumnDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for ProjectColumnDeletedAction {
    fn from(value: &ProjectColumnDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectColumnDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for ProjectColumnDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectColumnDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectColumnDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectColumnDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectColumnEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_column edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"project_column\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_column\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-column\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEdited {
    pub action: ProjectColumnEditedAction,
    pub changes: ProjectColumnEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectColumnEdited> for ProjectColumnEdited {
    fn from(value: &ProjectColumnEdited) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectColumnEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for ProjectColumnEditedAction {
    fn from(value: &ProjectColumnEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectColumnEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for ProjectColumnEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectColumnEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectColumnEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectColumnEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectColumnEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<ProjectColumnEditedChangesName>,
}
impl ::std::convert::From<&ProjectColumnEditedChanges> for ProjectColumnEditedChanges {
    fn from(value: &ProjectColumnEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ProjectColumnEditedChanges {
    fn default() -> Self {
        Self {
            name: Default::default(),
        }
    }
}
#[doc = "`ProjectColumnEditedChangesName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChangesName {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ProjectColumnEditedChangesName> for ProjectColumnEditedChangesName {
    fn from(value: &ProjectColumnEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_column$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_column$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_column$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project_column$moved\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectColumnEvent {
    Created(ProjectColumnCreated),
    Deleted(ProjectColumnDeleted),
    Edited(ProjectColumnEdited),
    Moved(ProjectColumnMoved),
}
impl ::std::convert::From<&Self> for ProjectColumnEvent {
    fn from(value: &ProjectColumnEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ProjectColumnCreated> for ProjectColumnEvent {
    fn from(value: ProjectColumnCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<ProjectColumnDeleted> for ProjectColumnEvent {
    fn from(value: ProjectColumnDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<ProjectColumnEdited> for ProjectColumnEvent {
    fn from(value: ProjectColumnEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<ProjectColumnMoved> for ProjectColumnEvent {
    fn from(value: ProjectColumnMoved) -> Self {
        Self::Moved(value)
    }
}
#[doc = "`ProjectColumnMoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project_column moved event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project_column\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"moved\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project_column\": {"]
#[doc = "      \"$ref\": \"#/definitions/project-column\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnMoved {
    pub action: ProjectColumnMovedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project_column: ProjectColumn,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectColumnMoved> for ProjectColumnMoved {
    fn from(value: &ProjectColumnMoved) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectColumnMovedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"moved\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectColumnMovedAction {
    #[serde(rename = "moved")]
    Moved,
}
impl ::std::convert::From<&Self> for ProjectColumnMovedAction {
    fn from(value: &ProjectColumnMovedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectColumnMovedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Moved => write!(f, "moved"),
        }
    }
}
impl ::std::str::FromStr for ProjectColumnMovedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "moved" => Ok(Self::Moved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectColumnMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectColumnMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectColumnMovedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project\": {"]
#[doc = "      \"$ref\": \"#/definitions/project\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectCreated {
    pub action: ProjectCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectCreated> for ProjectCreated {
    fn from(value: &ProjectCreated) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for ProjectCreatedAction {
    fn from(value: &ProjectCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for ProjectCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project\": {"]
#[doc = "      \"$ref\": \"#/definitions/project\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectDeleted {
    pub action: ProjectDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectDeleted> for ProjectDeleted {
    fn from(value: &ProjectDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for ProjectDeletedAction {
    fn from(value: &ProjectDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for ProjectDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ProjectEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"project\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the project if the action was `edited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The changes to the project if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project\": {"]
#[doc = "      \"$ref\": \"#/definitions/project\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectEdited {
    pub action: ProjectEditedAction,
    pub changes: ProjectEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectEdited> for ProjectEdited {
    fn from(value: &ProjectEdited) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for ProjectEditedAction {
    fn from(value: &ProjectEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for ProjectEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the project if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the project if the action was `edited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The changes to the project if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<ProjectEditedChangesBody>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<ProjectEditedChangesName>,
}
impl ::std::convert::From<&ProjectEditedChanges> for ProjectEditedChanges {
    fn from(value: &ProjectEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ProjectEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
            name: Default::default(),
        }
    }
}
#[doc = "`ProjectEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ProjectEditedChangesBody> for ProjectEditedChangesBody {
    fn from(value: &ProjectEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectEditedChangesName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The changes to the project if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesName {
    #[doc = "The changes to the project if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ProjectEditedChangesName> for ProjectEditedChangesName {
    fn from(value: &ProjectEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project$closed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/project$reopened\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectEvent {
    Closed(ProjectClosed),
    Created(ProjectCreated),
    Deleted(ProjectDeleted),
    Edited(ProjectEdited),
    Reopened(ProjectReopened),
}
impl ::std::convert::From<&Self> for ProjectEvent {
    fn from(value: &ProjectEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ProjectClosed> for ProjectEvent {
    fn from(value: ProjectClosed) -> Self {
        Self::Closed(value)
    }
}
impl ::std::convert::From<ProjectCreated> for ProjectEvent {
    fn from(value: ProjectCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<ProjectDeleted> for ProjectEvent {
    fn from(value: ProjectDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<ProjectEdited> for ProjectEvent {
    fn from(value: ProjectEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<ProjectReopened> for ProjectEvent {
    fn from(value: ProjectReopened) -> Self {
        Self::Reopened(value)
    }
}
#[doc = "`ProjectReopened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"project reopened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"project\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"project\": {"]
#[doc = "      \"$ref\": \"#/definitions/project\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectReopened {
    pub action: ProjectReopenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub project: Project,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ProjectReopened> for ProjectReopened {
    fn from(value: &ProjectReopened) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectReopenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl ::std::convert::From<&Self> for ProjectReopenedAction {
    fn from(value: &ProjectReopenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectReopenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reopened => write!(f, "reopened"),
        }
    }
}
impl ::std::str::FromStr for ProjectReopenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "State of the project; either 'open' or 'closed'"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the project; either 'open' or 'closed'\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for ProjectState {
    fn from(value: &ProjectState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for ProjectState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "When a private repository is made public."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"public event\","]
#[doc = "  \"description\": \"When a private repository is made public.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"private\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"private\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PublicEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: PublicEventRepository,
    pub sender: User,
}
impl ::std::convert::From<&PublicEvent> for PublicEvent {
    fn from(value: &PublicEvent) -> Self {
        value.clone()
    }
}
#[doc = "`PublicEventRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"private\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"private\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PublicEventRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: PublicEventRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<PublicEventRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: PublicEventRepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&PublicEventRepository> for PublicEventRepository {
    fn from(value: &PublicEventRepository) -> Self {
        value.clone()
    }
}
#[doc = "`PublicEventRepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PublicEventRepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for PublicEventRepositoryCreatedAt {
    fn from(value: &PublicEventRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for PublicEventRepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for PublicEventRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PublicEventRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PublicEventRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for PublicEventRepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for PublicEventRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for PublicEventRepositoryCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PublicEventRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PublicEventRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&PublicEventRepositoryPermissions> for PublicEventRepositoryPermissions {
    fn from(value: &PublicEventRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`PublicEventRepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PublicEventRepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for PublicEventRepositoryPushedAt {
    fn from(value: &PublicEventRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for PublicEventRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for PublicEventRepositoryPushedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Pull Request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"additions\","]
#[doc = "    \"assignee\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"auto_merge\","]
#[doc = "    \"base\","]
#[doc = "    \"body\","]
#[doc = "    \"changed_files\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"deletions\","]
#[doc = "    \"diff_url\","]
#[doc = "    \"draft\","]
#[doc = "    \"head\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"labels\","]
#[doc = "    \"locked\","]
#[doc = "    \"maintainer_can_modify\","]
#[doc = "    \"merge_commit_sha\","]
#[doc = "    \"mergeable\","]
#[doc = "    \"mergeable_state\","]
#[doc = "    \"merged\","]
#[doc = "    \"merged_at\","]
#[doc = "    \"merged_by\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"rebaseable\","]
#[doc = "    \"requested_reviewers\","]
#[doc = "    \"requested_teams\","]
#[doc = "    \"review_comment_url\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"review_comments_url\","]
#[doc = "    \"state\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"comments\","]
#[doc = "        \"commits\","]
#[doc = "        \"html\","]
#[doc = "        \"issue\","]
#[doc = "        \"review_comment\","]
#[doc = "        \"review_comments\","]
#[doc = "        \"self\","]
#[doc = "        \"statuses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"commits\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comment\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"additions\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"auto_merge\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changed_files\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"comments\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"deletions\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"description\": \"Indicates whether or not the pull request is a draft.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintainer_can_modify\": {"]
#[doc = "      \"description\": \"Indicates whether maintainers can modify the pull request.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"merge_commit_sha\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"mergeable\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"mergeable_state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"merged\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merged_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"merged_by\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"Number uniquely identifying the pull request within its repository.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"rebaseable\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"requested_reviewers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requested_teams\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/team\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"review_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"review_comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of this Pull Request. Either `open` or `closed`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"The title of the pull request.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequest {
    pub active_lock_reason: ::std::option::Option<PullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: ::std::option::Option<bool>,
    pub merged_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub merged_by: ::std::option::Option<User>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers: ::std::vec::Vec<PullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequest> for PullRequest {
    fn from(value: &PullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestActiveLockReason {
    fn from(value: &PullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestAssigned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request assigned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"assignee\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"assigned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAssigned {
    pub action: PullRequestAssignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestAssigned> for PullRequestAssigned {
    fn from(value: &PullRequestAssigned) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestAssignedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"assigned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestAssignedAction {
    #[serde(rename = "assigned")]
    Assigned,
}
impl ::std::convert::From<&Self> for PullRequestAssignedAction {
    fn from(value: &PullRequestAssignedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestAssignedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Assigned => write!(f, "assigned"),
        }
    }
}
impl ::std::str::FromStr for PullRequestAssignedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "assigned" => Ok(Self::Assigned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestAssignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestAutoMergeDisabled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request auto_merge_disabled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto_merge_disabled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeDisabled {
    pub action: PullRequestAutoMergeDisabledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestAutoMergeDisabled> for PullRequestAutoMergeDisabled {
    fn from(value: &PullRequestAutoMergeDisabled) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestAutoMergeDisabledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto_merge_disabled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestAutoMergeDisabledAction {
    #[serde(rename = "auto_merge_disabled")]
    AutoMergeDisabled,
}
impl ::std::convert::From<&Self> for PullRequestAutoMergeDisabledAction {
    fn from(value: &PullRequestAutoMergeDisabledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestAutoMergeDisabledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AutoMergeDisabled => write!(f, "auto_merge_disabled"),
        }
    }
}
impl ::std::str::FromStr for PullRequestAutoMergeDisabledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto_merge_disabled" => Ok(Self::AutoMergeDisabled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestAutoMergeDisabledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestAutoMergeDisabledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestAutoMergeDisabledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestAutoMergeEnabled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request auto_merge_enabled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto_merge_enabled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeEnabled {
    pub action: PullRequestAutoMergeEnabledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestAutoMergeEnabled> for PullRequestAutoMergeEnabled {
    fn from(value: &PullRequestAutoMergeEnabled) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestAutoMergeEnabledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto_merge_enabled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestAutoMergeEnabledAction {
    #[serde(rename = "auto_merge_enabled")]
    AutoMergeEnabled,
}
impl ::std::convert::From<&Self> for PullRequestAutoMergeEnabledAction {
    fn from(value: &PullRequestAutoMergeEnabledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestAutoMergeEnabledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AutoMergeEnabled => write!(f, "auto_merge_enabled"),
        }
    }
}
impl ::std::str::FromStr for PullRequestAutoMergeEnabledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto_merge_enabled" => Ok(Self::AutoMergeEnabled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestAutoMergeEnabledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestAutoMergeEnabledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestAutoMergeEnabledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestBase> for PullRequestBase {
    fn from(value: &PullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request closed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"merged\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            },"]
#[doc = "            \"merged\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"description\": \"State of this Pull Request. Either `open` or `closed`.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"closed\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosed {
    pub action: PullRequestClosedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestClosedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestClosed> for PullRequestClosed {
    fn from(value: &PullRequestClosed) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestClosedAction {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestClosedAction {
    fn from(value: &PullRequestClosedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestClosedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestClosedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestClosedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestClosedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"merged\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"merged\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"description\": \"State of this Pull Request. Either `open` or `closed`.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequest {
    pub active_lock_reason: ::std::option::Option<PullRequestClosedPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestClosedPullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestClosedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestClosedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: bool,
    pub merged_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    pub merged_by: ::std::option::Option<User>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers: ::std::vec::Vec<PullRequestClosedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestClosedPullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestClosedPullRequest> for PullRequestClosedPullRequest {
    fn from(value: &PullRequestClosedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestClosedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestClosedPullRequestActiveLockReason {
    fn from(value: &PullRequestClosedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestClosedPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestClosedPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestClosedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestClosedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestClosedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestClosedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestClosedPullRequestBase> for PullRequestClosedPullRequestBase {
    fn from(value: &PullRequestClosedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestClosedPullRequestHead> for PullRequestClosedPullRequestHead {
    fn from(value: &PullRequestClosedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestClosedPullRequestLinks>
    for PullRequestClosedPullRequestLinks
{
    fn from(value: &PullRequestClosedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestClosedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestClosedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestClosedPullRequestRequestedReviewersItem {
    fn from(value: &PullRequestClosedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestClosedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestClosedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestClosedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestClosedPullRequestState {
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestClosedPullRequestState {
    fn from(value: &PullRequestClosedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestClosedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestClosedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestClosedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestClosedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestClosedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestConvertedToDraft`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request converted_to_draft event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"converted_to_draft\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"draft\","]
#[doc = "            \"merged\","]
#[doc = "            \"merged_at\","]
#[doc = "            \"merged_by\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"description\": \"Indicates whether or not the pull request is a draft.\","]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"merged\": {"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"merged_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraft {
    pub action: PullRequestConvertedToDraftAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestConvertedToDraftPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestConvertedToDraft> for PullRequestConvertedToDraft {
    fn from(value: &PullRequestConvertedToDraft) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestConvertedToDraftAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"converted_to_draft\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestConvertedToDraftAction {
    #[serde(rename = "converted_to_draft")]
    ConvertedToDraft,
}
impl ::std::convert::From<&Self> for PullRequestConvertedToDraftAction {
    fn from(value: &PullRequestConvertedToDraftAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestConvertedToDraftAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ConvertedToDraft => write!(f, "converted_to_draft"),
        }
    }
}
impl ::std::str::FromStr for PullRequestConvertedToDraftAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "converted_to_draft" => Ok(Self::ConvertedToDraft),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestConvertedToDraftAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestConvertedToDraftAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestConvertedToDraftAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"draft\","]
#[doc = "        \"merged\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"merged_by\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"description\": \"Indicates whether or not the pull request is a draft.\","]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged\": {"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequest {
    pub active_lock_reason:
        ::std::option::Option<PullRequestConvertedToDraftPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestConvertedToDraftPullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    pub draft: bool,
    pub head: PullRequestConvertedToDraftPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestConvertedToDraftPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers:
        ::std::vec::Vec<PullRequestConvertedToDraftPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    #[doc = "State of this Pull Request. Either `open` or `closed`."]
    pub state: PullRequestConvertedToDraftPullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestConvertedToDraftPullRequest>
    for PullRequestConvertedToDraftPullRequest
{
    fn from(value: &PullRequestConvertedToDraftPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestConvertedToDraftPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestConvertedToDraftPullRequestActiveLockReason {
    fn from(value: &PullRequestConvertedToDraftPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestConvertedToDraftPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestConvertedToDraftPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestConvertedToDraftPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestConvertedToDraftPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestConvertedToDraftPullRequestBase>
    for PullRequestConvertedToDraftPullRequestBase
{
    fn from(value: &PullRequestConvertedToDraftPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestConvertedToDraftPullRequestHead>
    for PullRequestConvertedToDraftPullRequestHead
{
    fn from(value: &PullRequestConvertedToDraftPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraftPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestConvertedToDraftPullRequestLinks>
    for PullRequestConvertedToDraftPullRequestLinks
{
    fn from(value: &PullRequestConvertedToDraftPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestConvertedToDraftPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    fn from(value: &PullRequestConvertedToDraftPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestConvertedToDraftPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of this Pull Request. Either `open` or `closed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestConvertedToDraftPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestConvertedToDraftPullRequestState {
    fn from(value: &PullRequestConvertedToDraftPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestConvertedToDraftPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestConvertedToDraftPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestConvertedToDraftPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestConvertedToDraftPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestConvertedToDraftPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the comment if the action was `edited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEdited {
    pub action: PullRequestEditedAction,
    pub changes: PullRequestEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestEdited> for PullRequestEdited {
    fn from(value: &PullRequestEdited) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for PullRequestEditedAction {
    fn from(value: &PullRequestEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for PullRequestEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the comment if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the comment if the action was `edited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<PullRequestEditedChangesBody>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<PullRequestEditedChangesTitle>,
}
impl ::std::convert::From<&PullRequestEditedChanges> for PullRequestEditedChanges {
    fn from(value: &PullRequestEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PullRequestEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`PullRequestEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&PullRequestEditedChangesBody> for PullRequestEditedChangesBody {
    fn from(value: &PullRequestEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestEditedChangesTitle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the title if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesTitle {
    #[doc = "The previous version of the title if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&PullRequestEditedChangesTitle> for PullRequestEditedChangesTitle {
    fn from(value: &PullRequestEditedChangesTitle) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$assigned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$auto_merge_disabled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$auto_merge_enabled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$closed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$converted_to_draft\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$labeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$locked\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$opened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$ready_for_review\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$reopened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$review_request_removed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$review_requested\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$synchronize\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$unassigned\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$unlabeled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request$unlocked\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestEvent {
    Assigned(PullRequestAssigned),
    AutoMergeDisabled(PullRequestAutoMergeDisabled),
    AutoMergeEnabled(PullRequestAutoMergeEnabled),
    Closed(PullRequestClosed),
    ConvertedToDraft(PullRequestConvertedToDraft),
    Edited(PullRequestEdited),
    Labeled(PullRequestLabeled),
    Locked(PullRequestLocked),
    Opened(PullRequestOpened),
    ReadyForReview(PullRequestReadyForReview),
    Reopened(PullRequestReopened),
    ReviewRequestRemoved(PullRequestReviewRequestRemoved),
    ReviewRequested(PullRequestReviewRequested),
    Synchronize(PullRequestSynchronize),
    Unassigned(PullRequestUnassigned),
    Unlabeled(PullRequestUnlabeled),
    Unlocked(PullRequestUnlocked),
}
impl ::std::convert::From<&Self> for PullRequestEvent {
    fn from(value: &PullRequestEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PullRequestAssigned> for PullRequestEvent {
    fn from(value: PullRequestAssigned) -> Self {
        Self::Assigned(value)
    }
}
impl ::std::convert::From<PullRequestAutoMergeDisabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeDisabled) -> Self {
        Self::AutoMergeDisabled(value)
    }
}
impl ::std::convert::From<PullRequestAutoMergeEnabled> for PullRequestEvent {
    fn from(value: PullRequestAutoMergeEnabled) -> Self {
        Self::AutoMergeEnabled(value)
    }
}
impl ::std::convert::From<PullRequestClosed> for PullRequestEvent {
    fn from(value: PullRequestClosed) -> Self {
        Self::Closed(value)
    }
}
impl ::std::convert::From<PullRequestConvertedToDraft> for PullRequestEvent {
    fn from(value: PullRequestConvertedToDraft) -> Self {
        Self::ConvertedToDraft(value)
    }
}
impl ::std::convert::From<PullRequestEdited> for PullRequestEvent {
    fn from(value: PullRequestEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<PullRequestLabeled> for PullRequestEvent {
    fn from(value: PullRequestLabeled) -> Self {
        Self::Labeled(value)
    }
}
impl ::std::convert::From<PullRequestLocked> for PullRequestEvent {
    fn from(value: PullRequestLocked) -> Self {
        Self::Locked(value)
    }
}
impl ::std::convert::From<PullRequestOpened> for PullRequestEvent {
    fn from(value: PullRequestOpened) -> Self {
        Self::Opened(value)
    }
}
impl ::std::convert::From<PullRequestReadyForReview> for PullRequestEvent {
    fn from(value: PullRequestReadyForReview) -> Self {
        Self::ReadyForReview(value)
    }
}
impl ::std::convert::From<PullRequestReopened> for PullRequestEvent {
    fn from(value: PullRequestReopened) -> Self {
        Self::Reopened(value)
    }
}
impl ::std::convert::From<PullRequestReviewRequestRemoved> for PullRequestEvent {
    fn from(value: PullRequestReviewRequestRemoved) -> Self {
        Self::ReviewRequestRemoved(value)
    }
}
impl ::std::convert::From<PullRequestReviewRequested> for PullRequestEvent {
    fn from(value: PullRequestReviewRequested) -> Self {
        Self::ReviewRequested(value)
    }
}
impl ::std::convert::From<PullRequestSynchronize> for PullRequestEvent {
    fn from(value: PullRequestSynchronize) -> Self {
        Self::Synchronize(value)
    }
}
impl ::std::convert::From<PullRequestUnassigned> for PullRequestEvent {
    fn from(value: PullRequestUnassigned) -> Self {
        Self::Unassigned(value)
    }
}
impl ::std::convert::From<PullRequestUnlabeled> for PullRequestEvent {
    fn from(value: PullRequestUnlabeled) -> Self {
        Self::Unlabeled(value)
    }
}
impl ::std::convert::From<PullRequestUnlocked> for PullRequestEvent {
    fn from(value: PullRequestUnlocked) -> Self {
        Self::Unlocked(value)
    }
}
#[doc = "`PullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestHead> for PullRequestHead {
    fn from(value: &PullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestLabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request labeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"label\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"labeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLabeled {
    pub action: PullRequestLabeledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestLabeled> for PullRequestLabeled {
    fn from(value: &PullRequestLabeled) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestLabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"labeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestLabeledAction {
    #[serde(rename = "labeled")]
    Labeled,
}
impl ::std::convert::From<&Self> for PullRequestLabeledAction {
    fn from(value: &PullRequestLabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestLabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Labeled => write!(f, "labeled"),
        }
    }
}
impl ::std::str::FromStr for PullRequestLabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "labeled" => Ok(Self::Labeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestLabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestLinks> for PullRequestLinks {
    fn from(value: &PullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestLocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request locked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"locked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLocked {
    pub action: PullRequestLockedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestLocked> for PullRequestLocked {
    fn from(value: &PullRequestLocked) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestLockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"locked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestLockedAction {
    #[serde(rename = "locked")]
    Locked,
}
impl ::std::convert::From<&Self> for PullRequestLockedAction {
    fn from(value: &PullRequestLockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestLockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Locked => write!(f, "locked"),
        }
    }
}
impl ::std::str::FromStr for PullRequestLockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "locked" => Ok(Self::Locked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestLockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestOpened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request opened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"opened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"active_lock_reason\","]
#[doc = "            \"closed_at\","]
#[doc = "            \"merge_commit_sha\","]
#[doc = "            \"merged_at\","]
#[doc = "            \"merged_by\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"active_lock_reason\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merge_commit_sha\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpened {
    pub action: PullRequestOpenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestOpenedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestOpened> for PullRequestOpened {
    fn from(value: &PullRequestOpened) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestOpenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"opened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestOpenedAction {
    #[serde(rename = "opened")]
    Opened,
}
impl ::std::convert::From<&Self> for PullRequestOpenedAction {
    fn from(value: &PullRequestOpenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestOpenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Opened => write!(f, "opened"),
        }
    }
}
impl ::std::str::FromStr for PullRequestOpenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "opened" => Ok(Self::Opened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestOpenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestOpenedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"closed_at\","]
#[doc = "        \"merge_commit_sha\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"merged_by\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merge_commit_sha\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequest {
    pub active_lock_reason: PullRequestOpenedPullRequestActiveLockReason,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestOpenedPullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestOpenedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestOpenedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: (),
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: ::std::option::Option<bool>,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers: ::std::vec::Vec<PullRequestOpenedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestOpenedPullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestOpenedPullRequest> for PullRequestOpenedPullRequest {
    fn from(value: &PullRequestOpenedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestOpenedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"null\","]
#[doc = "  \"enum\": ["]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct PullRequestOpenedPullRequestActiveLockReason(());
impl ::std::ops::Deref for PullRequestOpenedPullRequestActiveLockReason {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<PullRequestOpenedPullRequestActiveLockReason> for () {
    fn from(value: PullRequestOpenedPullRequestActiveLockReason) -> Self {
        value.0
    }
}
impl ::std::convert::From<&PullRequestOpenedPullRequestActiveLockReason>
    for PullRequestOpenedPullRequestActiveLockReason
{
    fn from(value: &PullRequestOpenedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<()> for PullRequestOpenedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: ()) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![()].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for PullRequestOpenedPullRequestActiveLockReason {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`PullRequestOpenedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestOpenedPullRequestBase> for PullRequestOpenedPullRequestBase {
    fn from(value: &PullRequestOpenedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestOpenedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestOpenedPullRequestHead> for PullRequestOpenedPullRequestHead {
    fn from(value: &PullRequestOpenedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestOpenedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpenedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestOpenedPullRequestLinks>
    for PullRequestOpenedPullRequestLinks
{
    fn from(value: &PullRequestOpenedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestOpenedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestOpenedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestOpenedPullRequestRequestedReviewersItem {
    fn from(value: &PullRequestOpenedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestOpenedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestOpenedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestOpenedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestOpenedPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for PullRequestOpenedPullRequestState {
    fn from(value: &PullRequestOpenedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestOpenedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for PullRequestOpenedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestOpenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestOpenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestOpenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReadyForReview`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request ready_for_review event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"ready_for_review\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"draft\","]
#[doc = "            \"merged\","]
#[doc = "            \"merged_at\","]
#[doc = "            \"merged_by\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"draft\": {"]
#[doc = "              \"description\": \"Indicates whether or not the pull request is a draft.\","]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"merged\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"merged_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReview {
    pub action: PullRequestReadyForReviewAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestReadyForReviewPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReadyForReview> for PullRequestReadyForReview {
    fn from(value: &PullRequestReadyForReview) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReadyForReviewAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"ready_for_review\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReadyForReviewAction {
    #[serde(rename = "ready_for_review")]
    ReadyForReview,
}
impl ::std::convert::From<&Self> for PullRequestReadyForReviewAction {
    fn from(value: &PullRequestReadyForReviewAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReadyForReviewAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReadyForReview => write!(f, "ready_for_review"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReadyForReviewAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ready_for_review" => Ok(Self::ReadyForReview),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReadyForReviewAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReadyForReviewAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReadyForReviewAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"draft\","]
#[doc = "        \"merged\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"merged_by\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"description\": \"Indicates whether or not the pull request is a draft.\","]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequest {
    pub active_lock_reason:
        ::std::option::Option<PullRequestReadyForReviewPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestReadyForReviewPullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    pub draft: bool,
    pub head: PullRequestReadyForReviewPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReadyForReviewPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers:
        ::std::vec::Vec<PullRequestReadyForReviewPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestReadyForReviewPullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReadyForReviewPullRequest>
    for PullRequestReadyForReviewPullRequest
{
    fn from(value: &PullRequestReadyForReviewPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReadyForReviewPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestReadyForReviewPullRequestActiveLockReason {
    fn from(value: &PullRequestReadyForReviewPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReadyForReviewPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReadyForReviewPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReadyForReviewPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReadyForReviewPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReadyForReviewPullRequestBase>
    for PullRequestReadyForReviewPullRequestBase
{
    fn from(value: &PullRequestReadyForReviewPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReadyForReviewPullRequestHead>
    for PullRequestReadyForReviewPullRequestHead
{
    fn from(value: &PullRequestReadyForReviewPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReviewPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestReadyForReviewPullRequestLinks>
    for PullRequestReadyForReviewPullRequestLinks
{
    fn from(value: &PullRequestReadyForReviewPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    fn from(value: &PullRequestReadyForReviewPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestReadyForReviewPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestReadyForReviewPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReadyForReviewPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for PullRequestReadyForReviewPullRequestState {
    fn from(value: &PullRequestReadyForReviewPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReadyForReviewPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReadyForReviewPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReadyForReviewPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReadyForReviewPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReadyForReviewPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReopened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request reopened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"closed_at\","]
#[doc = "            \"merge_commit_sha\","]
#[doc = "            \"merged\","]
#[doc = "            \"merged_at\","]
#[doc = "            \"merged_by\","]
#[doc = "            \"state\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"closed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merge_commit_sha\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"merged_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"merged_by\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"state\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"open\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopened {
    pub action: PullRequestReopenedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestReopenedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReopened> for PullRequestReopened {
    fn from(value: &PullRequestReopened) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReopenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl ::std::convert::From<&Self> for PullRequestReopenedAction {
    fn from(value: &PullRequestReopenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReopenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reopened => write!(f, "reopened"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReopenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReopenedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"closed_at\","]
#[doc = "        \"merge_commit_sha\","]
#[doc = "        \"merged\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"merged_by\","]
#[doc = "        \"state\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merge_commit_sha\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"merged_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequest {
    pub active_lock_reason: ::std::option::Option<PullRequestReopenedPullRequestActiveLockReason>,
    pub additions: i64,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: PullRequestReopenedPullRequestBase,
    pub body: ::std::option::Option<::std::string::String>,
    pub changed_files: i64,
    pub closed_at: (),
    pub comments: i64,
    pub comments_url: ::std::string::String,
    pub commits: i64,
    pub commits_url: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub deletions: i64,
    pub diff_url: ::std::string::String,
    #[doc = "Indicates whether or not the pull request is a draft."]
    pub draft: bool,
    pub head: PullRequestReopenedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReopenedPullRequestLinks,
    pub locked: bool,
    #[doc = "Indicates whether maintainers can modify the pull request."]
    pub maintainer_can_modify: bool,
    pub merge_commit_sha: (),
    pub mergeable: ::std::option::Option<bool>,
    pub mergeable_state: ::std::string::String,
    pub merged: bool,
    pub merged_at: (),
    pub merged_by: (),
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    #[doc = "Number uniquely identifying the pull request within its repository."]
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub rebaseable: ::std::option::Option<bool>,
    pub requested_reviewers: ::std::vec::Vec<PullRequestReopenedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments: i64,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestReopenedPullRequestState,
    pub statuses_url: ::std::string::String,
    #[doc = "The title of the pull request."]
    pub title: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReopenedPullRequest> for PullRequestReopenedPullRequest {
    fn from(value: &PullRequestReopenedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReopenedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReopenedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestReopenedPullRequestActiveLockReason {
    fn from(value: &PullRequestReopenedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReopenedPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReopenedPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReopenedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReopenedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReopenedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReopenedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReopenedPullRequestBase>
    for PullRequestReopenedPullRequestBase
{
    fn from(value: &PullRequestReopenedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReopenedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReopenedPullRequestHead>
    for PullRequestReopenedPullRequestHead
{
    fn from(value: &PullRequestReopenedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReopenedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopenedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestReopenedPullRequestLinks>
    for PullRequestReopenedPullRequestLinks
{
    fn from(value: &PullRequestReopenedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReopenedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReopenedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestReopenedPullRequestRequestedReviewersItem {
    fn from(value: &PullRequestReopenedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestReopenedPullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestReopenedPullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestReopenedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReopenedPullRequestState {
    #[serde(rename = "open")]
    Open,
}
impl ::std::convert::From<&Self> for PullRequestReopenedPullRequestState {
    fn from(value: &PullRequestReopenedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReopenedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReopenedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReopenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReopenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReopenedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for PullRequestRequestedReviewersItem {
    fn from(value: &PullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for PullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for PullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Pull Request Review Comment\","]
#[doc = "  \"description\": \"The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"commit_id\","]
#[doc = "    \"created_at\","]
#[doc = "    \"diff_hunk\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"line\","]
#[doc = "    \"node_id\","]
#[doc = "    \"original_commit_id\","]
#[doc = "    \"original_line\","]
#[doc = "    \"original_position\","]
#[doc = "    \"original_start_line\","]
#[doc = "    \"path\","]
#[doc = "    \"position\","]
#[doc = "    \"pull_request_review_id\","]
#[doc = "    \"pull_request_url\","]
#[doc = "    \"side\","]
#[doc = "    \"start_line\","]
#[doc = "    \"start_side\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"html\","]
#[doc = "        \"pull_request\","]
#[doc = "        \"self\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"The text of the comment.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"commit_id\": {"]
#[doc = "      \"description\": \"The SHA of the commit to which the comment applies.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"diff_hunk\": {"]
#[doc = "      \"description\": \"The diff of the line that the comment refers to.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"description\": \"HTML URL for the pull request review comment.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The ID of the pull request review comment.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"in_reply_to_id\": {"]
#[doc = "      \"description\": \"The comment ID to reply to.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"line\": {"]
#[doc = "      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"description\": \"The node ID of the pull request review comment.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"original_commit_id\": {"]
#[doc = "      \"description\": \"The SHA of the original commit to which the comment applies.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"original_line\": {"]
#[doc = "      \"description\": \"The line of the blob to which the comment applies. The last line of the range for a multi-line comment\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"original_position\": {"]
#[doc = "      \"description\": \"The index of the original line in the diff to which the comment applies.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"original_start_line\": {"]
#[doc = "      \"description\": \"The first line of the range for a multi-line comment.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"description\": \"The relative path of the file to which the comment applies.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"position\": {"]
#[doc = "      \"description\": \"The line index in the diff to which the comment applies.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pull_request_review_id\": {"]
#[doc = "      \"description\": \"The ID of the pull request review to which the comment belongs.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"pull_request_url\": {"]
#[doc = "      \"description\": \"URL for the pull request that the review comment belongs to.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"side\": {"]
#[doc = "      \"description\": \"The side of the first line of the range for a multi-line comment.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"LEFT\","]
#[doc = "        \"RIGHT\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"start_line\": {"]
#[doc = "      \"description\": \"The first line of the range for a multi-line comment.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"start_side\": {"]
#[doc = "      \"description\": \"The side of the first line of the range for a multi-line comment.\","]
#[doc = "      \"default\": \"RIGHT\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"LEFT\","]
#[doc = "        \"RIGHT\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the pull request review comment\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewComment {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the comment."]
    pub body: ::std::string::String,
    #[doc = "The SHA of the commit to which the comment applies."]
    pub commit_id: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The diff of the line that the comment refers to."]
    pub diff_hunk: ::std::string::String,
    #[doc = "HTML URL for the pull request review comment."]
    pub html_url: ::std::string::String,
    #[doc = "The ID of the pull request review comment."]
    pub id: i64,
    #[doc = "The comment ID to reply to."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub in_reply_to_id: ::std::option::Option<i64>,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub line: ::std::option::Option<i64>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentLinks,
    #[doc = "The node ID of the pull request review comment."]
    pub node_id: ::std::string::String,
    #[doc = "The SHA of the original commit to which the comment applies."]
    pub original_commit_id: ::std::string::String,
    #[doc = "The line of the blob to which the comment applies. The last line of the range for a multi-line comment"]
    pub original_line: i64,
    #[doc = "The index of the original line in the diff to which the comment applies."]
    pub original_position: i64,
    #[doc = "The first line of the range for a multi-line comment."]
    pub original_start_line: ::std::option::Option<i64>,
    #[doc = "The relative path of the file to which the comment applies."]
    pub path: ::std::string::String,
    #[doc = "The line index in the diff to which the comment applies."]
    pub position: ::std::option::Option<i64>,
    #[doc = "The ID of the pull request review to which the comment belongs."]
    pub pull_request_review_id: i64,
    #[doc = "URL for the pull request that the review comment belongs to."]
    pub pull_request_url: ::std::string::String,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub side: PullRequestReviewCommentSide,
    #[doc = "The first line of the range for a multi-line comment."]
    pub start_line: ::std::option::Option<i64>,
    #[doc = "The side of the first line of the range for a multi-line comment."]
    pub start_side: ::std::option::Option<PullRequestReviewCommentStartSide>,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "URL for the pull request review comment"]
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewComment> for PullRequestReviewComment {
    fn from(value: &PullRequestReviewComment) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review_comment created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request-review-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"assignee\","]
#[doc = "        \"assignees\","]
#[doc = "        \"author_association\","]
#[doc = "        \"base\","]
#[doc = "        \"body\","]
#[doc = "        \"closed_at\","]
#[doc = "        \"comments_url\","]
#[doc = "        \"commits_url\","]
#[doc = "        \"created_at\","]
#[doc = "        \"diff_url\","]
#[doc = "        \"head\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"issue_url\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"merge_commit_sha\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"milestone\","]
#[doc = "        \"node_id\","]
#[doc = "        \"number\","]
#[doc = "        \"patch_url\","]
#[doc = "        \"requested_reviewers\","]
#[doc = "        \"requested_teams\","]
#[doc = "        \"review_comment_url\","]
#[doc = "        \"review_comments_url\","]
#[doc = "        \"state\","]
#[doc = "        \"statuses_url\","]
#[doc = "        \"title\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"comments\","]
#[doc = "            \"commits\","]
#[doc = "            \"html\","]
#[doc = "            \"issue\","]
#[doc = "            \"review_comment\","]
#[doc = "            \"review_comments\","]
#[doc = "            \"self\","]
#[doc = "            \"statuses\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"commits\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"issue\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comment\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"self\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"statuses\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"resolved\","]
#[doc = "            \"off-topic\","]
#[doc = "            \"too heated\","]
#[doc = "            \"spam\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignees\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"auto_merge\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"base\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"commits_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"diff_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"head\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"issue_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"merge_commit_sha\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"milestone\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/milestone\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"patch_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"requested_reviewers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/user\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/team\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"requested_teams\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"review_comment_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"review_comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"statuses_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreated {
    pub action: PullRequestReviewCommentCreatedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestReviewCommentCreatedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewCommentCreated> for PullRequestReviewCommentCreated {
    fn from(value: &PullRequestReviewCommentCreated) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentCreatedAction {
    fn from(value: &PullRequestReviewCommentCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewCommentCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"assignee\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"base\","]
#[doc = "    \"body\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"diff_url\","]
#[doc = "    \"head\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"labels\","]
#[doc = "    \"locked\","]
#[doc = "    \"merge_commit_sha\","]
#[doc = "    \"merged_at\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"requested_reviewers\","]
#[doc = "    \"requested_teams\","]
#[doc = "    \"review_comment_url\","]
#[doc = "    \"review_comments_url\","]
#[doc = "    \"state\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"comments\","]
#[doc = "        \"commits\","]
#[doc = "        \"html\","]
#[doc = "        \"issue\","]
#[doc = "        \"review_comment\","]
#[doc = "        \"review_comments\","]
#[doc = "        \"self\","]
#[doc = "        \"statuses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"commits\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comment\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"auto_merge\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"merge_commit_sha\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merged_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"requested_reviewers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requested_teams\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/team\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"review_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"review_comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequest {
    pub active_lock_reason:
        ::std::option::Option<PullRequestReviewCommentCreatedPullRequestActiveLockReason>,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentCreatedPullRequestBase,
    pub body: ::std::string::String,
    pub closed_at: ::std::option::Option<::std::string::String>,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub created_at: ::std::string::String,
    pub diff_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub draft: ::std::option::Option<bool>,
    pub head: PullRequestReviewCommentCreatedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentCreatedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub merged_at: ::std::option::Option<::std::string::String>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub requested_reviewers:
        ::std::vec::Vec<PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestReviewCommentCreatedPullRequestState,
    pub statuses_url: ::std::string::String,
    pub title: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentCreatedPullRequest>
    for PullRequestReviewCommentCreatedPullRequest
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    fn from(value: &PullRequestReviewCommentCreatedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentCreatedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentCreatedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentCreatedPullRequestBase>
    for PullRequestReviewCommentCreatedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentCreatedPullRequestHead>
    for PullRequestReviewCommentCreatedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestReviewCommentCreatedPullRequestLinks>
    for PullRequestReviewCommentCreatedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self>
    for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User>
    for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team>
    for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestReviewCommentCreatedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentCreatedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentCreatedPullRequestState {
    fn from(value: &PullRequestReviewCommentCreatedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentCreatedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentCreatedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentCreatedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentCreatedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review_comment deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"comment\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request-review-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"assignee\","]
#[doc = "        \"assignees\","]
#[doc = "        \"author_association\","]
#[doc = "        \"base\","]
#[doc = "        \"body\","]
#[doc = "        \"closed_at\","]
#[doc = "        \"comments_url\","]
#[doc = "        \"commits_url\","]
#[doc = "        \"created_at\","]
#[doc = "        \"diff_url\","]
#[doc = "        \"head\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"issue_url\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"merge_commit_sha\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"milestone\","]
#[doc = "        \"node_id\","]
#[doc = "        \"number\","]
#[doc = "        \"patch_url\","]
#[doc = "        \"requested_reviewers\","]
#[doc = "        \"requested_teams\","]
#[doc = "        \"review_comment_url\","]
#[doc = "        \"review_comments_url\","]
#[doc = "        \"state\","]
#[doc = "        \"statuses_url\","]
#[doc = "        \"title\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"comments\","]
#[doc = "            \"commits\","]
#[doc = "            \"html\","]
#[doc = "            \"issue\","]
#[doc = "            \"review_comment\","]
#[doc = "            \"review_comments\","]
#[doc = "            \"self\","]
#[doc = "            \"statuses\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"commits\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"issue\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comment\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"self\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"statuses\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"resolved\","]
#[doc = "            \"off-topic\","]
#[doc = "            \"too heated\","]
#[doc = "            \"spam\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignees\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"auto_merge\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"base\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"commits_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"diff_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"head\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"issue_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"merge_commit_sha\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"milestone\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/milestone\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"patch_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"requested_reviewers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/user\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/team\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"requested_teams\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"review_comment_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"review_comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"statuses_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeleted {
    pub action: PullRequestReviewCommentDeletedAction,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestReviewCommentDeletedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewCommentDeleted> for PullRequestReviewCommentDeleted {
    fn from(value: &PullRequestReviewCommentDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentDeletedAction {
    fn from(value: &PullRequestReviewCommentDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewCommentDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"assignee\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"base\","]
#[doc = "    \"body\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"diff_url\","]
#[doc = "    \"head\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"labels\","]
#[doc = "    \"locked\","]
#[doc = "    \"merge_commit_sha\","]
#[doc = "    \"merged_at\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"requested_reviewers\","]
#[doc = "    \"requested_teams\","]
#[doc = "    \"review_comment_url\","]
#[doc = "    \"review_comments_url\","]
#[doc = "    \"state\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"comments\","]
#[doc = "        \"commits\","]
#[doc = "        \"html\","]
#[doc = "        \"issue\","]
#[doc = "        \"review_comment\","]
#[doc = "        \"review_comments\","]
#[doc = "        \"self\","]
#[doc = "        \"statuses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"commits\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comment\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"auto_merge\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"merge_commit_sha\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merged_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"requested_reviewers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requested_teams\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/team\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"review_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"review_comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequest {
    pub active_lock_reason:
        ::std::option::Option<PullRequestReviewCommentDeletedPullRequestActiveLockReason>,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentDeletedPullRequestBase,
    pub body: ::std::string::String,
    pub closed_at: ::std::option::Option<::std::string::String>,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub created_at: ::std::string::String,
    pub diff_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub draft: ::std::option::Option<bool>,
    pub head: PullRequestReviewCommentDeletedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentDeletedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub merged_at: ::std::option::Option<::std::string::String>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub requested_reviewers:
        ::std::vec::Vec<PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestReviewCommentDeletedPullRequestState,
    pub statuses_url: ::std::string::String,
    pub title: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentDeletedPullRequest>
    for PullRequestReviewCommentDeletedPullRequest
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    fn from(value: &PullRequestReviewCommentDeletedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentDeletedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentDeletedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentDeletedPullRequestBase>
    for PullRequestReviewCommentDeletedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentDeletedPullRequestHead>
    for PullRequestReviewCommentDeletedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestReviewCommentDeletedPullRequestLinks>
    for PullRequestReviewCommentDeletedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self>
    for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User>
    for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team>
    for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestReviewCommentDeletedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentDeletedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentDeletedPullRequestState {
    fn from(value: &PullRequestReviewCommentDeletedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentDeletedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentDeletedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentDeletedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentDeletedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review_comment edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"comment\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the comment.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request-review-comment\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"active_lock_reason\","]
#[doc = "        \"assignee\","]
#[doc = "        \"assignees\","]
#[doc = "        \"author_association\","]
#[doc = "        \"base\","]
#[doc = "        \"body\","]
#[doc = "        \"closed_at\","]
#[doc = "        \"comments_url\","]
#[doc = "        \"commits_url\","]
#[doc = "        \"created_at\","]
#[doc = "        \"diff_url\","]
#[doc = "        \"head\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"issue_url\","]
#[doc = "        \"labels\","]
#[doc = "        \"locked\","]
#[doc = "        \"merge_commit_sha\","]
#[doc = "        \"merged_at\","]
#[doc = "        \"milestone\","]
#[doc = "        \"node_id\","]
#[doc = "        \"number\","]
#[doc = "        \"patch_url\","]
#[doc = "        \"requested_reviewers\","]
#[doc = "        \"requested_teams\","]
#[doc = "        \"review_comment_url\","]
#[doc = "        \"review_comments_url\","]
#[doc = "        \"state\","]
#[doc = "        \"statuses_url\","]
#[doc = "        \"title\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"url\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"comments\","]
#[doc = "            \"commits\","]
#[doc = "            \"html\","]
#[doc = "            \"issue\","]
#[doc = "            \"review_comment\","]
#[doc = "            \"review_comments\","]
#[doc = "            \"self\","]
#[doc = "            \"statuses\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"commits\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"issue\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comment\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"review_comments\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"self\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"statuses\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"active_lock_reason\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ],"]
#[doc = "          \"enum\": ["]
#[doc = "            \"resolved\","]
#[doc = "            \"off-topic\","]
#[doc = "            \"too heated\","]
#[doc = "            \"spam\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignee\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"assignees\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"auto_merge\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"base\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"closed_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"commits_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"diff_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"draft\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"head\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"label\","]
#[doc = "            \"ref\","]
#[doc = "            \"repo\","]
#[doc = "            \"sha\","]
#[doc = "            \"user\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"label\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ref\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"repo\": {"]
#[doc = "              \"$ref\": \"#/definitions/repository\""]
#[doc = "            },"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"issue_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/label\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"locked\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"merge_commit_sha\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"merged_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"milestone\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/milestone\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"patch_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"requested_reviewers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/user\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/team\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"requested_teams\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"review_comment_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"review_comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"statuses_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEdited {
    pub action: PullRequestReviewCommentEditedAction,
    pub changes: PullRequestReviewCommentEditedChanges,
    pub comment: PullRequestReviewComment,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequestReviewCommentEditedPullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewCommentEdited> for PullRequestReviewCommentEdited {
    fn from(value: &PullRequestReviewCommentEdited) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentEditedAction {
    fn from(value: &PullRequestReviewCommentEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewCommentEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the comment.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<PullRequestReviewCommentEditedChangesBody>,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedChanges>
    for PullRequestReviewCommentEditedChanges
{
    fn from(value: &PullRequestReviewCommentEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PullRequestReviewCommentEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
        }
    }
}
#[doc = "`PullRequestReviewCommentEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChangesBody {
    #[doc = "The previous version of the body."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedChangesBody>
    for PullRequestReviewCommentEditedChangesBody
{
    fn from(value: &PullRequestReviewCommentEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"assignee\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"base\","]
#[doc = "    \"body\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"diff_url\","]
#[doc = "    \"head\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"labels\","]
#[doc = "    \"locked\","]
#[doc = "    \"merge_commit_sha\","]
#[doc = "    \"merged_at\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"requested_reviewers\","]
#[doc = "    \"requested_teams\","]
#[doc = "    \"review_comment_url\","]
#[doc = "    \"review_comments_url\","]
#[doc = "    \"state\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"comments\","]
#[doc = "        \"commits\","]
#[doc = "        \"html\","]
#[doc = "        \"issue\","]
#[doc = "        \"review_comment\","]
#[doc = "        \"review_comments\","]
#[doc = "        \"self\","]
#[doc = "        \"statuses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"commits\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comment\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"auto_merge\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"merge_commit_sha\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merged_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"requested_reviewers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requested_teams\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/team\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"review_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"review_comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequest {
    pub active_lock_reason:
        ::std::option::Option<PullRequestReviewCommentEditedPullRequestActiveLockReason>,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    #[serde(default)]
    pub auto_merge: (),
    pub base: PullRequestReviewCommentEditedPullRequestBase,
    pub body: ::std::string::String,
    pub closed_at: ::std::option::Option<::std::string::String>,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub created_at: ::std::string::String,
    pub diff_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub draft: ::std::option::Option<bool>,
    pub head: PullRequestReviewCommentEditedPullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewCommentEditedPullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub merged_at: ::std::option::Option<::std::string::String>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub requested_reviewers:
        ::std::vec::Vec<PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments_url: ::std::string::String,
    pub state: PullRequestReviewCommentEditedPullRequestState,
    pub statuses_url: ::std::string::String,
    pub title: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedPullRequest>
    for PullRequestReviewCommentEditedPullRequest
{
    fn from(value: &PullRequestReviewCommentEditedPullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentEditedPullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    fn from(value: &PullRequestReviewCommentEditedPullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentEditedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentEditedPullRequestActiveLockReason
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedPullRequestBase>
    for PullRequestReviewCommentEditedPullRequestBase
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedPullRequestHead>
    for PullRequestReviewCommentEditedPullRequestHead
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&PullRequestReviewCommentEditedPullRequestLinks>
    for PullRequestReviewCommentEditedPullRequestLinks
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self>
    for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
    fn from(value: &PullRequestReviewCommentEditedPullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User>
    for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team>
    for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`PullRequestReviewCommentEditedPullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentEditedPullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentEditedPullRequestState {
    fn from(value: &PullRequestReviewCommentEditedPullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentEditedPullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentEditedPullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewCommentEditedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewCommentEditedPullRequestState
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewCommentEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review_comment$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review_comment$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review_comment$edited\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEvent {
    Created(PullRequestReviewCommentCreated),
    Deleted(PullRequestReviewCommentDeleted),
    Edited(PullRequestReviewCommentEdited),
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentEvent {
    fn from(value: &PullRequestReviewCommentEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PullRequestReviewCommentCreated> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<PullRequestReviewCommentDeleted> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<PullRequestReviewCommentEdited> for PullRequestReviewCommentEvent {
    fn from(value: PullRequestReviewCommentEdited) -> Self {
        Self::Edited(value)
    }
}
#[doc = "`PullRequestReviewCommentLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"html\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"self\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentLinks {
    pub html: Link,
    pub pull_request: Link,
    #[serde(rename = "self")]
    pub self_: Link,
}
impl ::std::convert::From<&PullRequestReviewCommentLinks> for PullRequestReviewCommentLinks {
    fn from(value: &PullRequestReviewCommentLinks) -> Self {
        value.clone()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The side of the first line of the range for a multi-line comment.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"LEFT\","]
#[doc = "    \"RIGHT\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentSide {
    fn from(value: &PullRequestReviewCommentSide) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentSide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "LEFT"),
            Self::Right => write!(f, "RIGHT"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentSide {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentSide {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewCommentSide {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewCommentSide {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The side of the first line of the range for a multi-line comment."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The side of the first line of the range for a multi-line comment.\","]
#[doc = "  \"default\": \"RIGHT\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"LEFT\","]
#[doc = "    \"RIGHT\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewCommentStartSide {
    #[serde(rename = "LEFT")]
    Left,
    #[serde(rename = "RIGHT")]
    Right,
}
impl ::std::convert::From<&Self> for PullRequestReviewCommentStartSide {
    fn from(value: &PullRequestReviewCommentStartSide) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewCommentStartSide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "LEFT"),
            Self::Right => write!(f, "RIGHT"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewCommentStartSide {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "LEFT" => Ok(Self::Left),
            "RIGHT" => Ok(Self::Right),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewCommentStartSide {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewCommentStartSide {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewCommentStartSide {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewDismissed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review dismissed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"review\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"dismissed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/simple-pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"review\": {"]
#[doc = "      \"description\": \"The review that was affected.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"commit_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_request_url\","]
#[doc = "        \"state\","]
#[doc = "        \"submitted_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"html\","]
#[doc = "            \"pull_request\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"The text of the review.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"commit_id\": {"]
#[doc = "          \"description\": \"A commit SHA for the review.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Unique identifier of the review\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_request_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"dismissed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"submitted_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissed {
    pub action: PullRequestReviewDismissedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewDismissedReview,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewDismissed> for PullRequestReviewDismissed {
    fn from(value: &PullRequestReviewDismissed) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewDismissedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewDismissedAction {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for PullRequestReviewDismissedAction {
    fn from(value: &PullRequestReviewDismissedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewDismissedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewDismissedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewDismissedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewDismissedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewDismissedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The review that was affected.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"commit_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_request_url\","]
#[doc = "    \"state\","]
#[doc = "    \"submitted_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"html\","]
#[doc = "        \"pull_request\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"The text of the review.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"commit_id\": {"]
#[doc = "      \"description\": \"A commit SHA for the review.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the review\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_request_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"dismissed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"submitted_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: ::std::option::Option<::std::string::String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewDismissedReviewLinks,
    pub node_id: ::std::string::String,
    pub pull_request_url: ::std::string::String,
    pub state: PullRequestReviewDismissedReviewState,
    pub submitted_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewDismissedReview> for PullRequestReviewDismissedReview {
    fn from(value: &PullRequestReviewDismissedReview) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewDismissedReviewLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"html\","]
#[doc = "    \"pull_request\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl ::std::convert::From<&PullRequestReviewDismissedReviewLinks>
    for PullRequestReviewDismissedReviewLinks
{
    fn from(value: &PullRequestReviewDismissedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewDismissedReviewState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dismissed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewDismissedReviewState {
    #[serde(rename = "dismissed")]
    Dismissed,
}
impl ::std::convert::From<&Self> for PullRequestReviewDismissedReviewState {
    fn from(value: &PullRequestReviewDismissedReviewState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewDismissedReviewState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dismissed => write!(f, "dismissed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewDismissedReviewState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dismissed" => Ok(Self::Dismissed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewDismissedReviewState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewDismissedReviewState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewDismissedReviewState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"review\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/simple-pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"review\": {"]
#[doc = "      \"description\": \"The review that was affected.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"commit_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_request_url\","]
#[doc = "        \"state\","]
#[doc = "        \"submitted_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"html\","]
#[doc = "            \"pull_request\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"The text of the review.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"commit_id\": {"]
#[doc = "          \"description\": \"A commit SHA for the review.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Unique identifier of the review\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_request_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"submitted_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEdited {
    pub action: PullRequestReviewEditedAction,
    pub changes: PullRequestReviewEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewEditedReview,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewEdited> for PullRequestReviewEdited {
    fn from(value: &PullRequestReviewEdited) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for PullRequestReviewEditedAction {
    fn from(value: &PullRequestReviewEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<PullRequestReviewEditedChangesBody>,
}
impl ::std::convert::From<&PullRequestReviewEditedChanges> for PullRequestReviewEditedChanges {
    fn from(value: &PullRequestReviewEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PullRequestReviewEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
        }
    }
}
#[doc = "`PullRequestReviewEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&PullRequestReviewEditedChangesBody>
    for PullRequestReviewEditedChangesBody
{
    fn from(value: &PullRequestReviewEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The review that was affected.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"commit_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_request_url\","]
#[doc = "    \"state\","]
#[doc = "    \"submitted_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"html\","]
#[doc = "        \"pull_request\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"The text of the review.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"commit_id\": {"]
#[doc = "      \"description\": \"A commit SHA for the review.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the review\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_request_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"submitted_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: ::std::option::Option<::std::string::String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewEditedReviewLinks,
    pub node_id: ::std::string::String,
    pub pull_request_url: ::std::string::String,
    pub state: ::std::string::String,
    pub submitted_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewEditedReview> for PullRequestReviewEditedReview {
    fn from(value: &PullRequestReviewEditedReview) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewEditedReviewLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"html\","]
#[doc = "    \"pull_request\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl ::std::convert::From<&PullRequestReviewEditedReviewLinks>
    for PullRequestReviewEditedReviewLinks
{
    fn from(value: &PullRequestReviewEditedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review$dismissed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pull_request_review$submitted\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PullRequestReviewEvent {
    Dismissed(PullRequestReviewDismissed),
    Edited(PullRequestReviewEdited),
    Submitted(PullRequestReviewSubmitted),
}
impl ::std::convert::From<&Self> for PullRequestReviewEvent {
    fn from(value: &PullRequestReviewEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PullRequestReviewDismissed> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewDismissed) -> Self {
        Self::Dismissed(value)
    }
}
impl ::std::convert::From<PullRequestReviewEdited> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<PullRequestReviewSubmitted> for PullRequestReviewEvent {
    fn from(value: PullRequestReviewSubmitted) -> Self {
        Self::Submitted(value)
    }
}
#[doc = "`PullRequestReviewRequestRemoved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request review_request_removed event\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"action\","]
#[doc = "        \"number\","]
#[doc = "        \"pull_request\","]
#[doc = "        \"repository\","]
#[doc = "        \"requested_reviewer\","]
#[doc = "        \"sender\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"action\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"review_request_removed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"installation\": {"]
#[doc = "          \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The pull request number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"organization\": {"]
#[doc = "          \"$ref\": \"#/definitions/organization\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        \"repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"requested_reviewer\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sender\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"action\","]
#[doc = "        \"number\","]
#[doc = "        \"pull_request\","]
#[doc = "        \"repository\","]
#[doc = "        \"requested_team\","]
#[doc = "        \"sender\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"action\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"review_request_removed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"installation\": {"]
#[doc = "          \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The pull request number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"organization\": {"]
#[doc = "          \"$ref\": \"#/definitions/organization\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        \"repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"requested_team\": {"]
#[doc = "          \"$ref\": \"#/definitions/team\""]
#[doc = "        },"]
#[doc = "        \"sender\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequestRemoved {
    Variant0 {
        action: PullRequestReviewRequestRemovedVariant0Action,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        installation: ::std::option::Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        organization: ::std::option::Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestRemovedVariant1Action,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        installation: ::std::option::Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        organization: ::std::option::Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl ::std::convert::From<&Self> for PullRequestReviewRequestRemoved {
    fn from(value: &PullRequestReviewRequestRemoved) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewRequestRemovedVariant0Action`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"review_request_removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewRequestRemovedVariant0Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl ::std::convert::From<&Self> for PullRequestReviewRequestRemovedVariant0Action {
    fn from(value: &PullRequestReviewRequestRemovedVariant0Action) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewRequestRemovedVariant0Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReviewRequestRemoved => write!(f, "review_request_removed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewRequestRemovedVariant0Action {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant0Action {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewRequestRemovedVariant0Action
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewRequestRemovedVariant0Action
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewRequestRemovedVariant1Action`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"review_request_removed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewRequestRemovedVariant1Action {
    #[serde(rename = "review_request_removed")]
    ReviewRequestRemoved,
}
impl ::std::convert::From<&Self> for PullRequestReviewRequestRemovedVariant1Action {
    fn from(value: &PullRequestReviewRequestRemovedVariant1Action) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewRequestRemovedVariant1Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReviewRequestRemoved => write!(f, "review_request_removed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewRequestRemovedVariant1Action {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "review_request_removed" => Ok(Self::ReviewRequestRemoved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant1Action {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for PullRequestReviewRequestRemovedVariant1Action
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for PullRequestReviewRequestRemovedVariant1Action
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewRequested`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request review_requested event\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"action\","]
#[doc = "        \"number\","]
#[doc = "        \"pull_request\","]
#[doc = "        \"repository\","]
#[doc = "        \"requested_reviewer\","]
#[doc = "        \"sender\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"action\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"review_requested\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"installation\": {"]
#[doc = "          \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The pull request number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"organization\": {"]
#[doc = "          \"$ref\": \"#/definitions/organization\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        \"repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"requested_reviewer\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sender\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"action\","]
#[doc = "        \"number\","]
#[doc = "        \"pull_request\","]
#[doc = "        \"repository\","]
#[doc = "        \"requested_team\","]
#[doc = "        \"sender\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"action\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"review_requested\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"installation\": {"]
#[doc = "          \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "        },"]
#[doc = "        \"number\": {"]
#[doc = "          \"description\": \"The pull request number.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"organization\": {"]
#[doc = "          \"$ref\": \"#/definitions/organization\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/pull-request\""]
#[doc = "        },"]
#[doc = "        \"repository\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"requested_team\": {"]
#[doc = "          \"$ref\": \"#/definitions/team\""]
#[doc = "        },"]
#[doc = "        \"sender\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequested {
    Variant0 {
        action: PullRequestReviewRequestedVariant0Action,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        installation: ::std::option::Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        organization: ::std::option::Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_reviewer: User,
        sender: User,
    },
    Variant1 {
        action: PullRequestReviewRequestedVariant1Action,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        installation: ::std::option::Option<InstallationLite>,
        #[doc = "The pull request number."]
        number: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        organization: ::std::option::Option<Organization>,
        pull_request: PullRequest,
        repository: Repository,
        requested_team: Team,
        sender: User,
    },
}
impl ::std::convert::From<&Self> for PullRequestReviewRequested {
    fn from(value: &PullRequestReviewRequested) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewRequestedVariant0Action`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"review_requested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewRequestedVariant0Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl ::std::convert::From<&Self> for PullRequestReviewRequestedVariant0Action {
    fn from(value: &PullRequestReviewRequestedVariant0Action) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewRequestedVariant0Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReviewRequested => write!(f, "review_requested"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewRequestedVariant0Action {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant0Action {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewRequestedVariant0Action {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewRequestedVariant0Action {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewRequestedVariant1Action`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"review_requested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewRequestedVariant1Action {
    #[serde(rename = "review_requested")]
    ReviewRequested,
}
impl ::std::convert::From<&Self> for PullRequestReviewRequestedVariant1Action {
    fn from(value: &PullRequestReviewRequestedVariant1Action) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewRequestedVariant1Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReviewRequested => write!(f, "review_requested"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewRequestedVariant1Action {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "review_requested" => Ok(Self::ReviewRequested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant1Action {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewRequestedVariant1Action {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewRequestedVariant1Action {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestReviewSubmitted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request_review submitted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"review\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"submitted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/simple-pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"review\": {"]
#[doc = "      \"description\": \"The review that was affected.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"_links\","]
#[doc = "        \"author_association\","]
#[doc = "        \"body\","]
#[doc = "        \"commit_id\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"node_id\","]
#[doc = "        \"pull_request_url\","]
#[doc = "        \"state\","]
#[doc = "        \"submitted_at\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"_links\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"html\","]
#[doc = "            \"pull_request\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"html\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            },"]
#[doc = "            \"pull_request\": {"]
#[doc = "              \"$ref\": \"#/definitions/link\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"author_association\": {"]
#[doc = "          \"$ref\": \"#/definitions/author_association\""]
#[doc = "        },"]
#[doc = "        \"body\": {"]
#[doc = "          \"description\": \"The text of the review.\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"commit_id\": {"]
#[doc = "          \"description\": \"A commit SHA for the review.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Unique identifier of the review\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"pull_request_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"state\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"submitted_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmitted {
    pub action: PullRequestReviewSubmittedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: SimplePullRequest,
    pub repository: Repository,
    pub review: PullRequestReviewSubmittedReview,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestReviewSubmitted> for PullRequestReviewSubmitted {
    fn from(value: &PullRequestReviewSubmitted) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewSubmittedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"submitted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestReviewSubmittedAction {
    #[serde(rename = "submitted")]
    Submitted,
}
impl ::std::convert::From<&Self> for PullRequestReviewSubmittedAction {
    fn from(value: &PullRequestReviewSubmittedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestReviewSubmittedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Submitted => write!(f, "submitted"),
        }
    }
}
impl ::std::str::FromStr for PullRequestReviewSubmittedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "submitted" => Ok(Self::Submitted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestReviewSubmittedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestReviewSubmittedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestReviewSubmittedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The review that was affected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The review that was affected.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"author_association\","]
#[doc = "    \"body\","]
#[doc = "    \"commit_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_request_url\","]
#[doc = "    \"state\","]
#[doc = "    \"submitted_at\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"html\","]
#[doc = "        \"pull_request\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"pull_request\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"description\": \"The text of the review.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"commit_id\": {"]
#[doc = "      \"description\": \"A commit SHA for the review.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the review\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_request_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"submitted_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReview {
    pub author_association: AuthorAssociation,
    #[doc = "The text of the review."]
    pub body: ::std::option::Option<::std::string::String>,
    #[doc = "A commit SHA for the review."]
    pub commit_id: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the review"]
    pub id: i64,
    #[serde(rename = "_links")]
    pub links: PullRequestReviewSubmittedReviewLinks,
    pub node_id: ::std::string::String,
    pub pull_request_url: ::std::string::String,
    pub state: ::std::string::String,
    pub submitted_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub user: User,
}
impl ::std::convert::From<&PullRequestReviewSubmittedReview> for PullRequestReviewSubmittedReview {
    fn from(value: &PullRequestReviewSubmittedReview) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestReviewSubmittedReviewLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"html\","]
#[doc = "    \"pull_request\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmittedReviewLinks {
    pub html: Link,
    pub pull_request: Link,
}
impl ::std::convert::From<&PullRequestReviewSubmittedReviewLinks>
    for PullRequestReviewSubmittedReviewLinks
{
    fn from(value: &PullRequestReviewSubmittedReviewLinks) -> Self {
        value.clone()
    }
}
#[doc = "State of this Pull Request. Either `open` or `closed`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of this Pull Request. Either `open` or `closed`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for PullRequestState {
    fn from(value: &PullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for PullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestSynchronize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request synchronize event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"after\","]
#[doc = "    \"before\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"synchronize\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"after\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestSynchronize {
    pub action: PullRequestSynchronizeAction,
    pub after: ::std::string::String,
    pub before: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestSynchronize> for PullRequestSynchronize {
    fn from(value: &PullRequestSynchronize) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestSynchronizeAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"synchronize\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestSynchronizeAction {
    #[serde(rename = "synchronize")]
    Synchronize,
}
impl ::std::convert::From<&Self> for PullRequestSynchronizeAction {
    fn from(value: &PullRequestSynchronizeAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestSynchronizeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Synchronize => write!(f, "synchronize"),
        }
    }
}
impl ::std::str::FromStr for PullRequestSynchronizeAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "synchronize" => Ok(Self::Synchronize),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestSynchronizeAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestSynchronizeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestSynchronizeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestUnassigned`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request unassigned event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"assignee\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unassigned\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnassigned {
    pub action: PullRequestUnassignedAction,
    pub assignee: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestUnassigned> for PullRequestUnassigned {
    fn from(value: &PullRequestUnassigned) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestUnassignedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unassigned\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestUnassignedAction {
    #[serde(rename = "unassigned")]
    Unassigned,
}
impl ::std::convert::From<&Self> for PullRequestUnassignedAction {
    fn from(value: &PullRequestUnassignedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestUnassignedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unassigned => write!(f, "unassigned"),
        }
    }
}
impl ::std::str::FromStr for PullRequestUnassignedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unassigned" => Ok(Self::Unassigned),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestUnassignedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestUnlabeled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request unlabeled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"label\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlabeled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"$ref\": \"#/definitions/label\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlabeled {
    pub action: PullRequestUnlabeledAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub label: Label,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestUnlabeled> for PullRequestUnlabeled {
    fn from(value: &PullRequestUnlabeled) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestUnlabeledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlabeled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestUnlabeledAction {
    #[serde(rename = "unlabeled")]
    Unlabeled,
}
impl ::std::convert::From<&Self> for PullRequestUnlabeledAction {
    fn from(value: &PullRequestUnlabeledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestUnlabeledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlabeled => write!(f, "unlabeled"),
        }
    }
}
impl ::std::str::FromStr for PullRequestUnlabeledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlabeled" => Ok(Self::Unlabeled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestUnlabeledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PullRequestUnlocked`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"pull_request unlocked event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"number\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unlocked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"description\": \"The pull request number.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pull_request\": {"]
#[doc = "      \"$ref\": \"#/definitions/pull-request\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlocked {
    pub action: PullRequestUnlockedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[doc = "The pull request number."]
    pub number: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pull_request: PullRequest,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PullRequestUnlocked> for PullRequestUnlocked {
    fn from(value: &PullRequestUnlocked) -> Self {
        value.clone()
    }
}
#[doc = "`PullRequestUnlockedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unlocked\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PullRequestUnlockedAction {
    #[serde(rename = "unlocked")]
    Unlocked,
}
impl ::std::convert::From<&Self> for PullRequestUnlockedAction {
    fn from(value: &PullRequestUnlockedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PullRequestUnlockedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unlocked => write!(f, "unlocked"),
        }
    }
}
impl ::std::str::FromStr for PullRequestUnlockedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unlocked" => Ok(Self::Unlocked),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PullRequestUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PullRequestUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PullRequestUnlockedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PushEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"push event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\","]
#[doc = "    \"base_ref\","]
#[doc = "    \"before\","]
#[doc = "    \"commits\","]
#[doc = "    \"compare\","]
#[doc = "    \"created\","]
#[doc = "    \"deleted\","]
#[doc = "    \"forced\","]
#[doc = "    \"head_commit\","]
#[doc = "    \"pusher\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"description\": \"The SHA of the most recent commit on `ref` after the push.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"base_ref\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"description\": \"The SHA of the most recent commit on `ref` before the push.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"description\": \"An array of commit objects describing the pushed commits.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/commit\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"compare\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"deleted\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"forced\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head_commit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/commit\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"pusher\": {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"description\": \"The full git ref that was pushed. Example: `refs/heads/main`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PushEvent {
    #[doc = "The SHA of the most recent commit on `ref` after the push."]
    pub after: ::std::string::String,
    pub base_ref: ::std::option::Option<::std::string::String>,
    #[doc = "The SHA of the most recent commit on `ref` before the push."]
    pub before: ::std::string::String,
    #[doc = "An array of commit objects describing the pushed commits."]
    pub commits: ::std::vec::Vec<Commit>,
    pub compare: ::std::string::String,
    pub created: bool,
    pub deleted: bool,
    pub forced: bool,
    pub head_commit: ::std::option::Option<Commit>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub pusher: Committer,
    #[doc = "The full git ref that was pushed. Example: `refs/heads/main`."]
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&PushEvent> for PushEvent {
    fn from(value: &PushEvent) -> Self {
        value.clone()
    }
}
#[doc = "The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Release\","]
#[doc = "  \"description\": \"The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"assets\","]
#[doc = "    \"assets_url\","]
#[doc = "    \"author\","]
#[doc = "    \"body\","]
#[doc = "    \"created_at\","]
#[doc = "    \"draft\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"prerelease\","]
#[doc = "    \"published_at\","]
#[doc = "    \"tag_name\","]
#[doc = "    \"tarball_url\","]
#[doc = "    \"target_commitish\","]
#[doc = "    \"upload_url\","]
#[doc = "    \"url\","]
#[doc = "    \"zipball_url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"assets\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/release-asset\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"assets_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"description\": \"Wether the release is a draft or published\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"prerelease\": {"]
#[doc = "      \"description\": \"Whether the release is identified as a prerelease or a full release.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"tag_name\": {"]
#[doc = "      \"description\": \"The name of the tag.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tarball_url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"target_commitish\": {"]
#[doc = "      \"description\": \"Specifies the commitish value that determines where the Git tag is created from.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"upload_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"zipball_url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Release {
    pub assets: ::std::vec::Vec<ReleaseAsset>,
    pub assets_url: ::std::string::String,
    pub author: User,
    pub body: ::std::string::String,
    pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: ::std::string::String,
    pub tarball_url: ::std::option::Option<::std::string::String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: ::std::string::String,
    pub upload_url: ::std::string::String,
    pub url: ::std::string::String,
    pub zipball_url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Release> for Release {
    fn from(value: &Release) -> Self {
        value.clone()
    }
}
#[doc = "Data related to a release."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Release Asset\","]
#[doc = "  \"description\": \"Data related to a release.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"browser_download_url\","]
#[doc = "    \"content_type\","]
#[doc = "    \"created_at\","]
#[doc = "    \"download_count\","]
#[doc = "    \"id\","]
#[doc = "    \"label\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"size\","]
#[doc = "    \"state\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"browser_download_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"content_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"download_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The file name of the asset.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"State of the release asset.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"uploaded\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"uploader\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseAsset {
    pub browser_download_url: ::std::string::String,
    pub content_type: ::std::string::String,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub download_count: i64,
    pub id: i64,
    pub label: ::std::option::Option<::std::string::String>,
    #[doc = "The file name of the asset."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub size: i64,
    #[doc = "State of the release asset."]
    pub state: ReleaseAssetState,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub uploader: ::std::option::Option<User>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&ReleaseAsset> for ReleaseAsset {
    fn from(value: &ReleaseAsset) -> Self {
        value.clone()
    }
}
#[doc = "State of the release asset."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"State of the release asset.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"uploaded\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseAssetState {
    #[serde(rename = "uploaded")]
    Uploaded,
}
impl ::std::convert::From<&Self> for ReleaseAssetState {
    fn from(value: &ReleaseAssetState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseAssetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Uploaded => write!(f, "uploaded"),
        }
    }
}
impl ::std::str::FromStr for ReleaseAssetState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "uploaded" => Ok(Self::Uploaded),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseAssetState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseAssetState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseAssetState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseCreated {
    pub action: ReleaseCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleaseCreated> for ReleaseCreated {
    fn from(value: &ReleaseCreated) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for ReleaseCreatedAction {
    fn from(value: &ReleaseCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for ReleaseCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseDeleted {
    pub action: ReleaseDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleaseDeleted> for ReleaseDeleted {
    fn from(value: &ReleaseDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for ReleaseDeletedAction {
    fn from(value: &ReleaseDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for ReleaseDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"body\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEdited {
    pub action: ReleaseEditedAction,
    pub changes: ReleaseEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleaseEdited> for ReleaseEdited {
    fn from(value: &ReleaseEdited) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for ReleaseEditedAction {
    fn from(value: &ReleaseEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for ReleaseEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<ReleaseEditedChangesBody>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<ReleaseEditedChangesName>,
}
impl ::std::convert::From<&ReleaseEditedChanges> for ReleaseEditedChanges {
    fn from(value: &ReleaseEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ReleaseEditedChanges {
    fn default() -> Self {
        Self {
            body: Default::default(),
            name: Default::default(),
        }
    }
}
#[doc = "`ReleaseEditedChangesBody`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the body if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesBody {
    #[doc = "The previous version of the body if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ReleaseEditedChangesBody> for ReleaseEditedChangesBody {
    fn from(value: &ReleaseEditedChangesBody) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseEditedChangesName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&ReleaseEditedChangesName> for ReleaseEditedChangesName {
    fn from(value: &ReleaseEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$prereleased\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$published\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$released\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release$unpublished\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ReleaseEvent {
    Created(ReleaseCreated),
    Deleted(ReleaseDeleted),
    Edited(ReleaseEdited),
    Prereleased(ReleasePrereleased),
    Published(ReleasePublished),
    Released(ReleaseReleased),
    Unpublished(ReleaseUnpublished),
}
impl ::std::convert::From<&Self> for ReleaseEvent {
    fn from(value: &ReleaseEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ReleaseCreated> for ReleaseEvent {
    fn from(value: ReleaseCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<ReleaseDeleted> for ReleaseEvent {
    fn from(value: ReleaseDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<ReleaseEdited> for ReleaseEvent {
    fn from(value: ReleaseEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<ReleasePrereleased> for ReleaseEvent {
    fn from(value: ReleasePrereleased) -> Self {
        Self::Prereleased(value)
    }
}
impl ::std::convert::From<ReleasePublished> for ReleaseEvent {
    fn from(value: ReleasePublished) -> Self {
        Self::Published(value)
    }
}
impl ::std::convert::From<ReleaseReleased> for ReleaseEvent {
    fn from(value: ReleaseReleased) -> Self {
        Self::Released(value)
    }
}
impl ::std::convert::From<ReleaseUnpublished> for ReleaseEvent {
    fn from(value: ReleaseUnpublished) -> Self {
        Self::Unpublished(value)
    }
}
#[doc = "`ReleasePrereleased`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release prereleased event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"prereleased\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/release\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"prerelease\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"prerelease\": {"]
#[doc = "              \"description\": \"Whether the release is identified as a prerelease or a full release.\","]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleased {
    pub action: ReleasePrereleasedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: ReleasePrereleasedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleasePrereleased> for ReleasePrereleased {
    fn from(value: &ReleasePrereleased) -> Self {
        value.clone()
    }
}
#[doc = "`ReleasePrereleasedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"prereleased\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleasePrereleasedAction {
    #[serde(rename = "prereleased")]
    Prereleased,
}
impl ::std::convert::From<&Self> for ReleasePrereleasedAction {
    fn from(value: &ReleasePrereleasedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleasePrereleasedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Prereleased => write!(f, "prereleased"),
        }
    }
}
impl ::std::str::FromStr for ReleasePrereleasedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "prereleased" => Ok(Self::Prereleased),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleasePrereleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleasePrereleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleasePrereleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleasePrereleasedRelease`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"prerelease\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"prerelease\": {"]
#[doc = "          \"description\": \"Whether the release is identified as a prerelease or a full release.\","]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleasedRelease {
    pub assets: ::std::vec::Vec<ReleaseAsset>,
    pub assets_url: ::std::string::String,
    pub author: User,
    pub body: ::std::string::String,
    pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub prerelease: bool,
    pub published_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "The name of the tag."]
    pub tag_name: ::std::string::String,
    pub tarball_url: ::std::option::Option<::std::string::String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: ::std::string::String,
    pub upload_url: ::std::string::String,
    pub url: ::std::string::String,
    pub zipball_url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ReleasePrereleasedRelease> for ReleasePrereleasedRelease {
    fn from(value: &ReleasePrereleasedRelease) -> Self {
        value.clone()
    }
}
#[doc = "`ReleasePublished`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release published event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"published\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/release\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"published_at\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"published_at\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"date-time\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublished {
    pub action: ReleasePublishedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: ReleasePublishedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleasePublished> for ReleasePublished {
    fn from(value: &ReleasePublished) -> Self {
        value.clone()
    }
}
#[doc = "`ReleasePublishedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"published\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleasePublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl ::std::convert::From<&Self> for ReleasePublishedAction {
    fn from(value: &ReleasePublishedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleasePublishedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Published => write!(f, "published"),
        }
    }
}
impl ::std::str::FromStr for ReleasePublishedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleasePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleasePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleasePublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleasePublishedRelease`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"published_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublishedRelease {
    pub assets: ::std::vec::Vec<ReleaseAsset>,
    pub assets_url: ::std::string::String,
    pub author: User,
    pub body: ::std::string::String,
    pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The name of the tag."]
    pub tag_name: ::std::string::String,
    pub tarball_url: ::std::option::Option<::std::string::String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: ::std::string::String,
    pub upload_url: ::std::string::String,
    pub url: ::std::string::String,
    pub zipball_url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ReleasePublishedRelease> for ReleasePublishedRelease {
    fn from(value: &ReleasePublishedRelease) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseReleased`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release released event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"released\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseReleased {
    pub action: ReleaseReleasedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: Release,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleaseReleased> for ReleaseReleased {
    fn from(value: &ReleaseReleased) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseReleasedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"released\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseReleasedAction {
    #[serde(rename = "released")]
    Released,
}
impl ::std::convert::From<&Self> for ReleaseReleasedAction {
    fn from(value: &ReleaseReleasedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseReleasedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Released => write!(f, "released"),
        }
    }
}
impl ::std::str::FromStr for ReleaseReleasedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "released" => Ok(Self::Released),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseReleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseReleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseReleasedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseUnpublished`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"release unpublished event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unpublished\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"release\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/release\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"published_at\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"published_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublished {
    pub action: ReleaseUnpublishedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub release: ReleaseUnpublishedRelease,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&ReleaseUnpublished> for ReleaseUnpublished {
    fn from(value: &ReleaseUnpublished) -> Self {
        value.clone()
    }
}
#[doc = "`ReleaseUnpublishedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unpublished\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseUnpublishedAction {
    #[serde(rename = "unpublished")]
    Unpublished,
}
impl ::std::convert::From<&Self> for ReleaseUnpublishedAction {
    fn from(value: &ReleaseUnpublishedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseUnpublishedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unpublished => write!(f, "unpublished"),
        }
    }
}
impl ::std::str::FromStr for ReleaseUnpublishedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unpublished" => Ok(Self::Unpublished),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseUnpublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseUnpublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseUnpublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ReleaseUnpublishedRelease`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/release\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"published_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublishedRelease {
    pub assets: ::std::vec::Vec<ReleaseAsset>,
    pub assets_url: ::std::string::String,
    pub author: User,
    pub body: ::std::string::String,
    pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    #[doc = "Wether the release is a draft or published"]
    pub draft: bool,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Whether the release is identified as a prerelease or a full release."]
    pub prerelease: bool,
    pub published_at: (),
    #[doc = "The name of the tag."]
    pub tag_name: ::std::string::String,
    pub tarball_url: ::std::option::Option<::std::string::String>,
    #[doc = "Specifies the commitish value that determines where the Git tag is created from."]
    pub target_commitish: ::std::string::String,
    pub upload_url: ::std::string::String,
    pub url: ::std::string::String,
    pub zipball_url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ReleaseUnpublishedRelease> for ReleaseUnpublishedRelease {
    fn from(value: &ReleaseUnpublishedRelease) -> Self {
        value.clone()
    }
}
#[doc = "`RepoRef`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Repo Ref\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepoRef {
    pub id: i64,
    pub name: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&RepoRef> for RepoRef {
    fn from(value: &RepoRef) -> Self {
        value.clone()
    }
}
#[doc = "A git repository"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Repository\","]
#[doc = "  \"description\": \"A git repository\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"archive_url\","]
#[doc = "    \"archived\","]
#[doc = "    \"assignees_url\","]
#[doc = "    \"blobs_url\","]
#[doc = "    \"branches_url\","]
#[doc = "    \"clone_url\","]
#[doc = "    \"collaborators_url\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"compare_url\","]
#[doc = "    \"contents_url\","]
#[doc = "    \"contributors_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"default_branch\","]
#[doc = "    \"deployments_url\","]
#[doc = "    \"description\","]
#[doc = "    \"downloads_url\","]
#[doc = "    \"events_url\","]
#[doc = "    \"fork\","]
#[doc = "    \"forks\","]
#[doc = "    \"forks_count\","]
#[doc = "    \"forks_url\","]
#[doc = "    \"full_name\","]
#[doc = "    \"git_commits_url\","]
#[doc = "    \"git_refs_url\","]
#[doc = "    \"git_tags_url\","]
#[doc = "    \"git_url\","]
#[doc = "    \"has_downloads\","]
#[doc = "    \"has_issues\","]
#[doc = "    \"has_pages\","]
#[doc = "    \"has_projects\","]
#[doc = "    \"has_wiki\","]
#[doc = "    \"homepage\","]
#[doc = "    \"hooks_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_comment_url\","]
#[doc = "    \"issue_events_url\","]
#[doc = "    \"issues_url\","]
#[doc = "    \"keys_url\","]
#[doc = "    \"labels_url\","]
#[doc = "    \"language\","]
#[doc = "    \"languages_url\","]
#[doc = "    \"license\","]
#[doc = "    \"merges_url\","]
#[doc = "    \"milestones_url\","]
#[doc = "    \"mirror_url\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"notifications_url\","]
#[doc = "    \"open_issues\","]
#[doc = "    \"open_issues_count\","]
#[doc = "    \"owner\","]
#[doc = "    \"private\","]
#[doc = "    \"pulls_url\","]
#[doc = "    \"pushed_at\","]
#[doc = "    \"releases_url\","]
#[doc = "    \"size\","]
#[doc = "    \"ssh_url\","]
#[doc = "    \"stargazers_count\","]
#[doc = "    \"stargazers_url\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"subscribers_url\","]
#[doc = "    \"subscription_url\","]
#[doc = "    \"svn_url\","]
#[doc = "    \"tags_url\","]
#[doc = "    \"teams_url\","]
#[doc = "    \"trees_url\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"watchers\","]
#[doc = "    \"watchers_count\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allow_auto_merge\": {"]
#[doc = "      \"description\": \"Whether to allow auto-merge for pull requests.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"allow_forking\": {"]
#[doc = "      \"description\": \"Whether to allow private forks\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"allow_merge_commit\": {"]
#[doc = "      \"description\": \"Whether to allow merge commits for pull requests.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"allow_rebase_merge\": {"]
#[doc = "      \"description\": \"Whether to allow rebase merges for pull requests.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"allow_squash_merge\": {"]
#[doc = "      \"description\": \"Whether to allow squash merges for pull requests.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"archive_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"archived\": {"]
#[doc = "      \"description\": \"Whether the repository is archived.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"assignees_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"blobs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"branches_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"clone_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"collaborators_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"compare_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"contents_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"contributors_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"default_branch\": {"]
#[doc = "      \"description\": \"The default branch of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"delete_branch_on_merge\": {"]
#[doc = "      \"description\": \"Whether to delete head branches when pull requests are merged\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"deployments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"disabled\": {"]
#[doc = "      \"description\": \"Returns whether or not this repository is disabled.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"downloads_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"fork\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"forks\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"forks_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"forks_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"git_commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"git_refs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"git_tags_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"git_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"has_downloads\": {"]
#[doc = "      \"description\": \"Whether downloads are enabled.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"has_issues\": {"]
#[doc = "      \"description\": \"Whether issues are enabled.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"has_pages\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"has_projects\": {"]
#[doc = "      \"description\": \"Whether projects are enabled.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"has_wiki\": {"]
#[doc = "      \"description\": \"Whether the wiki is enabled.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"homepage\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"hooks_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"issue_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"issues_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"keys_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"labels_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"language\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"languages_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"license\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/license\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"master_branch\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"merges_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"milestones_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"mirror_url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"notifications_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"open_issues\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"open_issues_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"owner\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"permissions\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"admin\","]
#[doc = "        \"pull\","]
#[doc = "        \"push\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"admin\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"maintain\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"pull\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"push\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"triage\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"public\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pulls_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"pushed_at\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"releases_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"ssh_url\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stargazers\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"stargazers_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"stargazers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscribers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"subscription_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"svn_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"tags_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"teams_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"trees_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"watchers\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"watchers_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Repository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: RepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<RepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: RepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&Repository> for Repository {
    fn from(value: &Repository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryArchived`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository archived event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"archived\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"archived\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"archived\": {"]
#[doc = "              \"description\": \"Whether the repository is archived.\","]
#[doc = "              \"default\": false,"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchived {
    pub action: RepositoryArchivedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: RepositoryArchivedRepository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryArchived> for RepositoryArchived {
    fn from(value: &RepositoryArchived) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryArchivedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"archived\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryArchivedAction {
    #[serde(rename = "archived")]
    Archived,
}
impl ::std::convert::From<&Self> for RepositoryArchivedAction {
    fn from(value: &RepositoryArchivedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryArchivedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Archived => write!(f, "archived"),
        }
    }
}
impl ::std::str::FromStr for RepositoryArchivedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "archived" => Ok(Self::Archived),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryArchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryArchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryArchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryArchivedRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"archived\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"archived\": {"]
#[doc = "          \"description\": \"Whether the repository is archived.\","]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchivedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: RepositoryArchivedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<RepositoryArchivedRepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: RepositoryArchivedRepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&RepositoryArchivedRepository> for RepositoryArchivedRepository {
    fn from(value: &RepositoryArchivedRepository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryArchivedRepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryArchivedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for RepositoryArchivedRepositoryCreatedAt {
    fn from(value: &RepositoryArchivedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RepositoryArchivedRepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryArchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryArchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryArchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RepositoryArchivedRepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RepositoryArchivedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryArchivedRepositoryCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryArchivedRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchivedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&RepositoryArchivedRepositoryPermissions>
    for RepositoryArchivedRepositoryPermissions
{
    fn from(value: &RepositoryArchivedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryArchivedRepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryArchivedRepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for RepositoryArchivedRepositoryPushedAt {
    fn from(value: &RepositoryArchivedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for RepositoryArchivedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryArchivedRepositoryPushedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryCreated {
    pub action: RepositoryCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryCreated> for RepositoryCreated {
    fn from(value: &RepositoryCreated) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for RepositoryCreatedAction {
    fn from(value: &RepositoryCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for RepositoryCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for RepositoryCreatedAt {
    fn from(value: &RepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for RepositoryCreatedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDeleted {
    pub action: RepositoryDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryDeleted> for RepositoryDeleted {
    fn from(value: &RepositoryDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for RepositoryDeletedAction {
    fn from(value: &RepositoryDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for RepositoryDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryDispatchEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_dispatch$on-demand-test\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RepositoryDispatchEvent(pub RepositoryDispatchOnDemandTest);
impl ::std::ops::Deref for RepositoryDispatchEvent {
    type Target = RepositoryDispatchOnDemandTest;
    fn deref(&self) -> &RepositoryDispatchOnDemandTest {
        &self.0
    }
}
impl ::std::convert::From<RepositoryDispatchEvent> for RepositoryDispatchOnDemandTest {
    fn from(value: RepositoryDispatchEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RepositoryDispatchEvent> for RepositoryDispatchEvent {
    fn from(value: &RepositoryDispatchEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<RepositoryDispatchOnDemandTest> for RepositoryDispatchEvent {
    fn from(value: RepositoryDispatchOnDemandTest) -> Self {
        Self(value)
    }
}
#[doc = "`RepositoryDispatchOnDemandTest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository_dispatch on-demand-test event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"branch\","]
#[doc = "    \"client_payload\","]
#[doc = "    \"installation\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"on-demand-test\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"branch\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"client_payload\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDispatchOnDemandTest {
    pub action: RepositoryDispatchOnDemandTestAction,
    pub branch: ::std::string::String,
    pub client_payload: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    pub installation: InstallationLite,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryDispatchOnDemandTest> for RepositoryDispatchOnDemandTest {
    fn from(value: &RepositoryDispatchOnDemandTest) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryDispatchOnDemandTestAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"on-demand-test\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryDispatchOnDemandTestAction {
    #[serde(rename = "on-demand-test")]
    OnDemandTest,
}
impl ::std::convert::From<&Self> for RepositoryDispatchOnDemandTestAction {
    fn from(value: &RepositoryDispatchOnDemandTestAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryDispatchOnDemandTestAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::OnDemandTest => write!(f, "on-demand-test"),
        }
    }
}
impl ::std::str::FromStr for RepositoryDispatchOnDemandTestAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "on-demand-test" => Ok(Self::OnDemandTest),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryDispatchOnDemandTestAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryDispatchOnDemandTestAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryDispatchOnDemandTestAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"default_branch\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"homepage\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEdited {
    pub action: RepositoryEditedAction,
    pub changes: RepositoryEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryEdited> for RepositoryEdited {
    fn from(value: &RepositoryEdited) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for RepositoryEditedAction {
    fn from(value: &RepositoryEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for RepositoryEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"default_branch\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"homepage\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default_branch: ::std::option::Option<RepositoryEditedChangesDefaultBranch>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<RepositoryEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub homepage: ::std::option::Option<RepositoryEditedChangesHomepage>,
}
impl ::std::convert::From<&RepositoryEditedChanges> for RepositoryEditedChanges {
    fn from(value: &RepositoryEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RepositoryEditedChanges {
    fn default() -> Self {
        Self {
            default_branch: Default::default(),
            description: Default::default(),
            homepage: Default::default(),
        }
    }
}
#[doc = "`RepositoryEditedChangesDefaultBranch`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDefaultBranch {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&RepositoryEditedChangesDefaultBranch>
    for RepositoryEditedChangesDefaultBranch
{
    fn from(value: &RepositoryEditedChangesDefaultBranch) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryEditedChangesDescription`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDescription {
    pub from: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RepositoryEditedChangesDescription>
    for RepositoryEditedChangesDescription
{
    fn from(value: &RepositoryEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryEditedChangesHomepage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesHomepage {
    pub from: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RepositoryEditedChangesHomepage> for RepositoryEditedChangesHomepage {
    fn from(value: &RepositoryEditedChangesHomepage) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$archived\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$privatized\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$publicized\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$renamed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$transferred\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository$unarchived\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryEvent {
    Archived(RepositoryArchived),
    Created(RepositoryCreated),
    Deleted(RepositoryDeleted),
    Edited(RepositoryEdited),
    Privatized(RepositoryPrivatized),
    Publicized(RepositoryPublicized),
    Renamed(RepositoryRenamed),
    Transferred(RepositoryTransferred),
    Unarchived(RepositoryUnarchived),
}
impl ::std::convert::From<&Self> for RepositoryEvent {
    fn from(value: &RepositoryEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<RepositoryArchived> for RepositoryEvent {
    fn from(value: RepositoryArchived) -> Self {
        Self::Archived(value)
    }
}
impl ::std::convert::From<RepositoryCreated> for RepositoryEvent {
    fn from(value: RepositoryCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<RepositoryDeleted> for RepositoryEvent {
    fn from(value: RepositoryDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<RepositoryEdited> for RepositoryEvent {
    fn from(value: RepositoryEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<RepositoryPrivatized> for RepositoryEvent {
    fn from(value: RepositoryPrivatized) -> Self {
        Self::Privatized(value)
    }
}
impl ::std::convert::From<RepositoryPublicized> for RepositoryEvent {
    fn from(value: RepositoryPublicized) -> Self {
        Self::Publicized(value)
    }
}
impl ::std::convert::From<RepositoryRenamed> for RepositoryEvent {
    fn from(value: RepositoryRenamed) -> Self {
        Self::Renamed(value)
    }
}
impl ::std::convert::From<RepositoryTransferred> for RepositoryEvent {
    fn from(value: RepositoryTransferred) -> Self {
        Self::Transferred(value)
    }
}
impl ::std::convert::From<RepositoryUnarchived> for RepositoryEvent {
    fn from(value: RepositoryUnarchived) -> Self {
        Self::Unarchived(value)
    }
}
#[doc = "`RepositoryImportEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository_import event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"failure\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryImportEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub status: RepositoryImportEventStatus,
}
impl ::std::convert::From<&RepositoryImportEvent> for RepositoryImportEvent {
    fn from(value: &RepositoryImportEvent) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryImportEventStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"failure\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryImportEventStatus {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "failure")]
    Failure,
}
impl ::std::convert::From<&Self> for RepositoryImportEventStatus {
    fn from(value: &RepositoryImportEventStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryImportEventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::Failure => write!(f, "failure"),
        }
    }
}
impl ::std::str::FromStr for RepositoryImportEventStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "cancelled" => Ok(Self::Cancelled),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryImportEventStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryImportEventStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryImportEventStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryLite`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Repository Lite\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"archive_url\","]
#[doc = "    \"assignees_url\","]
#[doc = "    \"blobs_url\","]
#[doc = "    \"branches_url\","]
#[doc = "    \"collaborators_url\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"compare_url\","]
#[doc = "    \"contents_url\","]
#[doc = "    \"contributors_url\","]
#[doc = "    \"deployments_url\","]
#[doc = "    \"description\","]
#[doc = "    \"downloads_url\","]
#[doc = "    \"events_url\","]
#[doc = "    \"fork\","]
#[doc = "    \"forks_url\","]
#[doc = "    \"full_name\","]
#[doc = "    \"git_commits_url\","]
#[doc = "    \"git_refs_url\","]
#[doc = "    \"git_tags_url\","]
#[doc = "    \"hooks_url\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_comment_url\","]
#[doc = "    \"issue_events_url\","]
#[doc = "    \"issues_url\","]
#[doc = "    \"keys_url\","]
#[doc = "    \"labels_url\","]
#[doc = "    \"languages_url\","]
#[doc = "    \"merges_url\","]
#[doc = "    \"milestones_url\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"notifications_url\","]
#[doc = "    \"owner\","]
#[doc = "    \"private\","]
#[doc = "    \"pulls_url\","]
#[doc = "    \"releases_url\","]
#[doc = "    \"stargazers_url\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"subscribers_url\","]
#[doc = "    \"subscription_url\","]
#[doc = "    \"tags_url\","]
#[doc = "    \"teams_url\","]
#[doc = "    \"trees_url\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"archive_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"assignees_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"blobs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"branches_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"collaborators_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"compare_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"contents_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"contributors_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"deployments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"downloads_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"fork\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"forks_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"full_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"git_commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"git_refs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"git_tags_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"hooks_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the repository\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"issue_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"issues_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"keys_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"labels_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"languages_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"merges_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"milestones_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the repository.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"notifications_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"owner\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"private\": {"]
#[doc = "      \"description\": \"Whether the repository is private or public.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pulls_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"releases_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"stargazers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscribers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"subscription_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"tags_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"teams_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"trees_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryLite {
    pub archive_url: ::std::string::String,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub languages_url: ::std::string::String,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub owner: User,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    pub pulls_url: ::std::string::String,
    pub releases_url: ::std::string::String,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&RepositoryLite> for RepositoryLite {
    fn from(value: &RepositoryLite) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&RepositoryPermissions> for RepositoryPermissions {
    fn from(value: &RepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPrivatized`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository privatized event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"privatized\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"private\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"private\": {"]
#[doc = "              \"description\": \"Whether the repository is private or public.\","]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                true"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatized {
    pub action: RepositoryPrivatizedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: RepositoryPrivatizedRepository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryPrivatized> for RepositoryPrivatized {
    fn from(value: &RepositoryPrivatized) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPrivatizedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"privatized\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryPrivatizedAction {
    #[serde(rename = "privatized")]
    Privatized,
}
impl ::std::convert::From<&Self> for RepositoryPrivatizedAction {
    fn from(value: &RepositoryPrivatizedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryPrivatizedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Privatized => write!(f, "privatized"),
        }
    }
}
impl ::std::str::FromStr for RepositoryPrivatizedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "privatized" => Ok(Self::Privatized),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryPrivatizedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryPrivatizedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryPrivatizedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryPrivatizedRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"private\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"private\": {"]
#[doc = "          \"description\": \"Whether the repository is private or public.\","]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            true"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatizedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: RepositoryPrivatizedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<RepositoryPrivatizedRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: RepositoryPrivatizedRepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&RepositoryPrivatizedRepository> for RepositoryPrivatizedRepository {
    fn from(value: &RepositoryPrivatizedRepository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPrivatizedRepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryPrivatizedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for RepositoryPrivatizedRepositoryCreatedAt {
    fn from(value: &RepositoryPrivatizedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RepositoryPrivatizedRepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryPrivatizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RepositoryPrivatizedRepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RepositoryPrivatizedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryPrivatizedRepositoryCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryPrivatizedRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatizedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&RepositoryPrivatizedRepositoryPermissions>
    for RepositoryPrivatizedRepositoryPermissions
{
    fn from(value: &RepositoryPrivatizedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPrivatizedRepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryPrivatizedRepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for RepositoryPrivatizedRepositoryPushedAt {
    fn from(value: &RepositoryPrivatizedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for RepositoryPrivatizedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryPrivatizedRepositoryPushedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryPublicized`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository publicized event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"publicized\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"private\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"private\": {"]
#[doc = "              \"description\": \"Whether the repository is private or public.\","]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicized {
    pub action: RepositoryPublicizedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: RepositoryPublicizedRepository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryPublicized> for RepositoryPublicized {
    fn from(value: &RepositoryPublicized) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPublicizedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"publicized\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryPublicizedAction {
    #[serde(rename = "publicized")]
    Publicized,
}
impl ::std::convert::From<&Self> for RepositoryPublicizedAction {
    fn from(value: &RepositoryPublicizedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryPublicizedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Publicized => write!(f, "publicized"),
        }
    }
}
impl ::std::str::FromStr for RepositoryPublicizedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "publicized" => Ok(Self::Publicized),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryPublicizedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryPublicizedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryPublicizedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryPublicizedRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"private\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"private\": {"]
#[doc = "          \"description\": \"Whether the repository is private or public.\","]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicizedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    #[doc = "Whether the repository is archived."]
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: RepositoryPublicizedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<RepositoryPublicizedRepositoryPermissions>,
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: RepositoryPublicizedRepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&RepositoryPublicizedRepository> for RepositoryPublicizedRepository {
    fn from(value: &RepositoryPublicizedRepository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPublicizedRepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryPublicizedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for RepositoryPublicizedRepositoryCreatedAt {
    fn from(value: &RepositoryPublicizedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RepositoryPublicizedRepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryPublicizedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RepositoryPublicizedRepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RepositoryPublicizedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryPublicizedRepositoryCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryPublicizedRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicizedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&RepositoryPublicizedRepositoryPermissions>
    for RepositoryPublicizedRepositoryPermissions
{
    fn from(value: &RepositoryPublicizedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryPublicizedRepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryPublicizedRepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for RepositoryPublicizedRepositoryPushedAt {
    fn from(value: &RepositoryPublicizedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for RepositoryPublicizedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryPublicizedRepositoryPushedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for RepositoryPushedAt {
    fn from(value: &RepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for RepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>> for RepositoryPushedAt {
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryRenamed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository renamed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"renamed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"repository\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"repository\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"from\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"from\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamed {
    pub action: RepositoryRenamedAction,
    pub changes: RepositoryRenamedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryRenamed> for RepositoryRenamed {
    fn from(value: &RepositoryRenamed) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryRenamedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"renamed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryRenamedAction {
    #[serde(rename = "renamed")]
    Renamed,
}
impl ::std::convert::From<&Self> for RepositoryRenamedAction {
    fn from(value: &RepositoryRenamedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryRenamedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Renamed => write!(f, "renamed"),
        }
    }
}
impl ::std::str::FromStr for RepositoryRenamedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "renamed" => Ok(Self::Renamed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryRenamedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryRenamedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"repository\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"repository\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChanges {
    pub repository: RepositoryRenamedChangesRepository,
}
impl ::std::convert::From<&RepositoryRenamedChanges> for RepositoryRenamedChanges {
    fn from(value: &RepositoryRenamedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryRenamedChangesRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepository {
    pub name: RepositoryRenamedChangesRepositoryName,
}
impl ::std::convert::From<&RepositoryRenamedChangesRepository>
    for RepositoryRenamedChangesRepository
{
    fn from(value: &RepositoryRenamedChangesRepository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryRenamedChangesRepositoryName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepositoryName {
    pub from: ::std::string::String,
}
impl ::std::convert::From<&RepositoryRenamedChangesRepositoryName>
    for RepositoryRenamedChangesRepositoryName
{
    fn from(value: &RepositoryRenamedChangesRepositoryName) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryTransferred`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository transferred event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"transferred\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"owner\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"owner\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"user\": {"]
#[doc = "                  \"$ref\": \"#/definitions/user\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferred {
    pub action: RepositoryTransferredAction,
    pub changes: RepositoryTransferredChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryTransferred> for RepositoryTransferred {
    fn from(value: &RepositoryTransferred) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryTransferredAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"transferred\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryTransferredAction {
    #[serde(rename = "transferred")]
    Transferred,
}
impl ::std::convert::From<&Self> for RepositoryTransferredAction {
    fn from(value: &RepositoryTransferredAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryTransferredAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Transferred => write!(f, "transferred"),
        }
    }
}
impl ::std::str::FromStr for RepositoryTransferredAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "transferred" => Ok(Self::Transferred),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryTransferredAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryTransferredChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"owner\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"owner\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"user\": {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChanges {
    pub owner: RepositoryTransferredChangesOwner,
}
impl ::std::convert::From<&RepositoryTransferredChanges> for RepositoryTransferredChanges {
    fn from(value: &RepositoryTransferredChanges) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryTransferredChangesOwner`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwner {
    pub from: RepositoryTransferredChangesOwnerFrom,
}
impl ::std::convert::From<&RepositoryTransferredChangesOwner>
    for RepositoryTransferredChangesOwner
{
    fn from(value: &RepositoryTransferredChangesOwner) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryTransferredChangesOwnerFrom`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwnerFrom {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub user: ::std::option::Option<User>,
}
impl ::std::convert::From<&RepositoryTransferredChangesOwnerFrom>
    for RepositoryTransferredChangesOwnerFrom
{
    fn from(value: &RepositoryTransferredChangesOwnerFrom) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RepositoryTransferredChangesOwnerFrom {
    fn default() -> Self {
        Self {
            user: Default::default(),
        }
    }
}
#[doc = "`RepositoryUnarchived`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository unarchived event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"unarchived\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"archived\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"archived\": {"]
#[doc = "              \"description\": \"Whether the repository is archived.\","]
#[doc = "              \"default\": false,"]
#[doc = "              \"type\": \"boolean\","]
#[doc = "              \"enum\": ["]
#[doc = "                false"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchived {
    pub action: RepositoryUnarchivedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: RepositoryUnarchivedRepository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryUnarchived> for RepositoryUnarchived {
    fn from(value: &RepositoryUnarchived) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryUnarchivedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"unarchived\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryUnarchivedAction {
    #[serde(rename = "unarchived")]
    Unarchived,
}
impl ::std::convert::From<&Self> for RepositoryUnarchivedAction {
    fn from(value: &RepositoryUnarchivedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryUnarchivedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unarchived => write!(f, "unarchived"),
        }
    }
}
impl ::std::str::FromStr for RepositoryUnarchivedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "unarchived" => Ok(Self::Unarchived),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryUnarchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryUnarchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryUnarchivedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RepositoryUnarchivedRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"archived\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"archived\": {"]
#[doc = "          \"description\": \"Whether the repository is archived.\","]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\","]
#[doc = "          \"enum\": ["]
#[doc = "            false"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchivedRepository {
    #[doc = "Whether to allow auto-merge for pull requests."]
    #[serde(default)]
    pub allow_auto_merge: bool,
    #[doc = "Whether to allow private forks"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allow_forking: ::std::option::Option<bool>,
    #[doc = "Whether to allow merge commits for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_merge_commit: bool,
    #[doc = "Whether to allow rebase merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_rebase_merge: bool,
    #[doc = "Whether to allow squash merges for pull requests."]
    #[serde(default = "defaults::default_bool::<true>")]
    pub allow_squash_merge: bool,
    pub archive_url: ::std::string::String,
    pub archived: bool,
    pub assignees_url: ::std::string::String,
    pub blobs_url: ::std::string::String,
    pub branches_url: ::std::string::String,
    pub clone_url: ::std::string::String,
    pub collaborators_url: ::std::string::String,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub compare_url: ::std::string::String,
    pub contents_url: ::std::string::String,
    pub contributors_url: ::std::string::String,
    pub created_at: RepositoryUnarchivedRepositoryCreatedAt,
    #[doc = "The default branch of the repository."]
    pub default_branch: ::std::string::String,
    #[doc = "Whether to delete head branches when pull requests are merged"]
    #[serde(default)]
    pub delete_branch_on_merge: bool,
    pub deployments_url: ::std::string::String,
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Returns whether or not this repository is disabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disabled: ::std::option::Option<bool>,
    pub downloads_url: ::std::string::String,
    pub events_url: ::std::string::String,
    pub fork: bool,
    pub forks: i64,
    pub forks_count: i64,
    pub forks_url: ::std::string::String,
    pub full_name: ::std::string::String,
    pub git_commits_url: ::std::string::String,
    pub git_refs_url: ::std::string::String,
    pub git_tags_url: ::std::string::String,
    pub git_url: ::std::string::String,
    #[doc = "Whether downloads are enabled."]
    pub has_downloads: bool,
    #[doc = "Whether issues are enabled."]
    pub has_issues: bool,
    pub has_pages: bool,
    #[doc = "Whether projects are enabled."]
    pub has_projects: bool,
    #[doc = "Whether the wiki is enabled."]
    pub has_wiki: bool,
    pub homepage: ::std::option::Option<::std::string::String>,
    pub hooks_url: ::std::string::String,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the repository"]
    pub id: i64,
    pub issue_comment_url: ::std::string::String,
    pub issue_events_url: ::std::string::String,
    pub issues_url: ::std::string::String,
    pub keys_url: ::std::string::String,
    pub labels_url: ::std::string::String,
    pub language: ::std::option::Option<::std::string::String>,
    pub languages_url: ::std::string::String,
    pub license: ::std::option::Option<License>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub master_branch: ::std::option::Option<::std::string::String>,
    pub merges_url: ::std::string::String,
    pub milestones_url: ::std::string::String,
    pub mirror_url: ::std::option::Option<::std::string::String>,
    #[doc = "The name of the repository."]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub notifications_url: ::std::string::String,
    pub open_issues: i64,
    pub open_issues_count: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<::std::string::String>,
    pub owner: User,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub permissions: ::std::option::Option<RepositoryUnarchivedRepositoryPermissions>,
    #[doc = "Whether the repository is private or public."]
    pub private: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub public: ::std::option::Option<bool>,
    pub pulls_url: ::std::string::String,
    pub pushed_at: RepositoryUnarchivedRepositoryPushedAt,
    pub releases_url: ::std::string::String,
    pub size: i64,
    pub ssh_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stargazers: ::std::option::Option<i64>,
    pub stargazers_count: i64,
    pub stargazers_url: ::std::string::String,
    pub statuses_url: ::std::string::String,
    pub subscribers_url: ::std::string::String,
    pub subscription_url: ::std::string::String,
    pub svn_url: ::std::string::String,
    pub tags_url: ::std::string::String,
    pub teams_url: ::std::string::String,
    pub trees_url: ::std::string::String,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub watchers: i64,
    pub watchers_count: i64,
}
impl ::std::convert::From<&RepositoryUnarchivedRepository> for RepositoryUnarchivedRepository {
    fn from(value: &RepositoryUnarchivedRepository) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryUnarchivedRepositoryCreatedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryUnarchivedRepositoryCreatedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
}
impl ::std::convert::From<&Self> for RepositoryUnarchivedRepositoryCreatedAt {
    fn from(value: &RepositoryUnarchivedRepositoryCreatedAt) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RepositoryUnarchivedRepositoryCreatedAt {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryUnarchivedRepositoryCreatedAt {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RepositoryUnarchivedRepositoryCreatedAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RepositoryUnarchivedRepositoryCreatedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryUnarchivedRepositoryCreatedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryUnarchivedRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"admin\","]
#[doc = "    \"pull\","]
#[doc = "    \"push\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maintain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"triage\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchivedRepositoryPermissions {
    pub admin: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maintain: ::std::option::Option<bool>,
    pub pull: bool,
    pub push: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub triage: ::std::option::Option<bool>,
}
impl ::std::convert::From<&RepositoryUnarchivedRepositoryPermissions>
    for RepositoryUnarchivedRepositoryPermissions
{
    fn from(value: &RepositoryUnarchivedRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryUnarchivedRepositoryPushedAt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryUnarchivedRepositoryPushedAt {
    Variant0(i64),
    Variant1(::chrono::DateTime<::chrono::offset::Utc>),
    Variant2,
}
impl ::std::convert::From<&Self> for RepositoryUnarchivedRepositoryPushedAt {
    fn from(value: &RepositoryUnarchivedRepositoryPushedAt) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for RepositoryUnarchivedRepositoryPushedAt {
    fn from(value: i64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::chrono::DateTime<::chrono::offset::Utc>>
    for RepositoryUnarchivedRepositoryPushedAt
{
    fn from(value: ::chrono::DateTime<::chrono::offset::Utc>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RepositoryVulnerabilityAlertCreate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository_vulnerability_alert create event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"create\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"affected_package_name\","]
#[doc = "        \"affected_range\","]
#[doc = "        \"external_identifier\","]
#[doc = "        \"external_reference\","]
#[doc = "        \"fixed_in\","]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"affected_package_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"affected_range\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismiss_reason\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismisser\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"external_identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"external_reference\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"fixed_in\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreate {
    pub action: RepositoryVulnerabilityAlertCreateAction,
    pub alert: RepositoryVulnerabilityAlertCreateAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertCreate>
    for RepositoryVulnerabilityAlertCreate
{
    fn from(value: &RepositoryVulnerabilityAlertCreate) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryVulnerabilityAlertCreateAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"create\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryVulnerabilityAlertCreateAction {
    #[serde(rename = "create")]
    Create,
}
impl ::std::convert::From<&Self> for RepositoryVulnerabilityAlertCreateAction {
    fn from(value: &RepositoryVulnerabilityAlertCreateAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryVulnerabilityAlertCreateAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Create => write!(f, "create"),
        }
    }
}
impl ::std::str::FromStr for RepositoryVulnerabilityAlertCreateAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "create" => Ok(Self::Create),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertCreateAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryVulnerabilityAlertCreateAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"affected_package_name\","]
#[doc = "    \"affected_range\","]
#[doc = "    \"external_identifier\","]
#[doc = "    \"external_reference\","]
#[doc = "    \"fixed_in\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"affected_package_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"affected_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismiss_reason\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismisser\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"external_identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"external_reference\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"fixed_in\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreateAlert {
    pub affected_package_name: ::std::string::String,
    pub affected_range: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub created_at: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismiss_reason: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismissed_at: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismisser: ::std::option::Option<User>,
    pub external_identifier: ::std::string::String,
    pub external_reference: ::std::string::String,
    pub fixed_in: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ghsa_id: ::std::option::Option<::std::string::String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub severity: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertCreateAlert>
    for RepositoryVulnerabilityAlertCreateAlert
{
    fn from(value: &RepositoryVulnerabilityAlertCreateAlert) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryVulnerabilityAlertDismiss`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository_vulnerability_alert dismiss event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"dismiss\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"affected_package_name\","]
#[doc = "        \"affected_range\","]
#[doc = "        \"dismiss_reason\","]
#[doc = "        \"dismissed_at\","]
#[doc = "        \"dismisser\","]
#[doc = "        \"external_identifier\","]
#[doc = "        \"external_reference\","]
#[doc = "        \"fixed_in\","]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"affected_package_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"affected_range\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismiss_reason\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismisser\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"external_identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"external_reference\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"fixed_in\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismiss {
    pub action: RepositoryVulnerabilityAlertDismissAction,
    pub alert: RepositoryVulnerabilityAlertDismissAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertDismiss>
    for RepositoryVulnerabilityAlertDismiss
{
    fn from(value: &RepositoryVulnerabilityAlertDismiss) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryVulnerabilityAlertDismissAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dismiss\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryVulnerabilityAlertDismissAction {
    #[serde(rename = "dismiss")]
    Dismiss,
}
impl ::std::convert::From<&Self> for RepositoryVulnerabilityAlertDismissAction {
    fn from(value: &RepositoryVulnerabilityAlertDismissAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryVulnerabilityAlertDismissAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dismiss => write!(f, "dismiss"),
        }
    }
}
impl ::std::str::FromStr for RepositoryVulnerabilityAlertDismissAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dismiss" => Ok(Self::Dismiss),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertDismissAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryVulnerabilityAlertDismissAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"affected_package_name\","]
#[doc = "    \"affected_range\","]
#[doc = "    \"dismiss_reason\","]
#[doc = "    \"dismissed_at\","]
#[doc = "    \"dismisser\","]
#[doc = "    \"external_identifier\","]
#[doc = "    \"external_reference\","]
#[doc = "    \"fixed_in\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"affected_package_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"affected_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismiss_reason\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismisser\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"external_identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"external_reference\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"fixed_in\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismissAlert {
    pub affected_package_name: ::std::string::String,
    pub affected_range: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub created_at: ::std::option::Option<::std::string::String>,
    pub dismiss_reason: ::std::string::String,
    pub dismissed_at: ::std::string::String,
    pub dismisser: User,
    pub external_identifier: ::std::string::String,
    pub external_reference: ::std::string::String,
    pub fixed_in: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ghsa_id: ::std::option::Option<::std::string::String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub severity: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertDismissAlert>
    for RepositoryVulnerabilityAlertDismissAlert
{
    fn from(value: &RepositoryVulnerabilityAlertDismissAlert) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryVulnerabilityAlertEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_vulnerability_alert$create\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_vulnerability_alert$dismiss\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/repository_vulnerability_alert$resolve\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RepositoryVulnerabilityAlertEvent {
    Create(RepositoryVulnerabilityAlertCreate),
    Dismiss(RepositoryVulnerabilityAlertDismiss),
    Resolve(RepositoryVulnerabilityAlertResolve),
}
impl ::std::convert::From<&Self> for RepositoryVulnerabilityAlertEvent {
    fn from(value: &RepositoryVulnerabilityAlertEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<RepositoryVulnerabilityAlertCreate>
    for RepositoryVulnerabilityAlertEvent
{
    fn from(value: RepositoryVulnerabilityAlertCreate) -> Self {
        Self::Create(value)
    }
}
impl ::std::convert::From<RepositoryVulnerabilityAlertDismiss>
    for RepositoryVulnerabilityAlertEvent
{
    fn from(value: RepositoryVulnerabilityAlertDismiss) -> Self {
        Self::Dismiss(value)
    }
}
impl ::std::convert::From<RepositoryVulnerabilityAlertResolve>
    for RepositoryVulnerabilityAlertEvent
{
    fn from(value: RepositoryVulnerabilityAlertResolve) -> Self {
        Self::Resolve(value)
    }
}
#[doc = "`RepositoryVulnerabilityAlertResolve`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"repository_vulnerability_alert resolve event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolve\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"affected_package_name\","]
#[doc = "        \"affected_range\","]
#[doc = "        \"external_identifier\","]
#[doc = "        \"external_reference\","]
#[doc = "        \"fixed_in\","]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"affected_package_name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"affected_range\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismiss_reason\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismissed_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"dismisser\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"external_identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"external_reference\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"fixed_in\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolve {
    pub action: RepositoryVulnerabilityAlertResolveAction,
    pub alert: RepositoryVulnerabilityAlertResolveAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertResolve>
    for RepositoryVulnerabilityAlertResolve
{
    fn from(value: &RepositoryVulnerabilityAlertResolve) -> Self {
        value.clone()
    }
}
#[doc = "`RepositoryVulnerabilityAlertResolveAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolve\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RepositoryVulnerabilityAlertResolveAction {
    #[serde(rename = "resolve")]
    Resolve,
}
impl ::std::convert::From<&Self> for RepositoryVulnerabilityAlertResolveAction {
    fn from(value: &RepositoryVulnerabilityAlertResolveAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RepositoryVulnerabilityAlertResolveAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolve => write!(f, "resolve"),
        }
    }
}
impl ::std::str::FromStr for RepositoryVulnerabilityAlertResolveAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolve" => Ok(Self::Resolve),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertResolveAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RepositoryVulnerabilityAlertResolveAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The security alert of the vulnerable dependency."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The security alert of the vulnerable dependency.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"affected_package_name\","]
#[doc = "    \"affected_range\","]
#[doc = "    \"external_identifier\","]
#[doc = "    \"external_reference\","]
#[doc = "    \"fixed_in\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"affected_package_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"affected_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismiss_reason\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismissed_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dismisser\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"external_identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"external_reference\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"fixed_in\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolveAlert {
    pub affected_package_name: ::std::string::String,
    pub affected_range: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub created_at: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismiss_reason: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismissed_at: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dismisser: ::std::option::Option<User>,
    pub external_identifier: ::std::string::String,
    pub external_reference: ::std::string::String,
    pub fixed_in: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ghsa_id: ::std::option::Option<::std::string::String>,
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub severity: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RepositoryVulnerabilityAlertResolveAlert>
    for RepositoryVulnerabilityAlertResolveAlert
{
    fn from(value: &RepositoryVulnerabilityAlertResolveAlert) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"secret_scanning_alert created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"number\","]
#[doc = "        \"resolution\","]
#[doc = "        \"resolved_at\","]
#[doc = "        \"resolved_by\","]
#[doc = "        \"secret_type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"resolution\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"resolved_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"resolved_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"secret_type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreated {
    pub action: SecretScanningAlertCreatedAction,
    pub alert: SecretScanningAlertCreatedAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
}
impl ::std::convert::From<&SecretScanningAlertCreated> for SecretScanningAlertCreated {
    fn from(value: &SecretScanningAlertCreated) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecretScanningAlertCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for SecretScanningAlertCreatedAction {
    fn from(value: &SecretScanningAlertCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecretScanningAlertCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for SecretScanningAlertCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecretScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecretScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecretScanningAlertCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"number\","]
#[doc = "    \"resolution\","]
#[doc = "    \"resolved_at\","]
#[doc = "    \"resolved_by\","]
#[doc = "    \"secret_type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"resolution\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"resolved_at\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"resolved_by\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"secret_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreatedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: ::std::string::String,
}
impl ::std::convert::From<&SecretScanningAlertCreatedAlert> for SecretScanningAlertCreatedAlert {
    fn from(value: &SecretScanningAlertCreatedAlert) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/secret_scanning_alert$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/secret_scanning_alert$reopened\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/secret_scanning_alert$resolved\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SecretScanningAlertEvent {
    Created(SecretScanningAlertCreated),
    Reopened(SecretScanningAlertReopened),
    Resolved(SecretScanningAlertResolved),
}
impl ::std::convert::From<&Self> for SecretScanningAlertEvent {
    fn from(value: &SecretScanningAlertEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecretScanningAlertCreated> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<SecretScanningAlertReopened> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertReopened) -> Self {
        Self::Reopened(value)
    }
}
impl ::std::convert::From<SecretScanningAlertResolved> for SecretScanningAlertEvent {
    fn from(value: SecretScanningAlertResolved) -> Self {
        Self::Resolved(value)
    }
}
#[doc = "`SecretScanningAlertReopened`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"secret_scanning_alert reopened event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"reopened\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"number\","]
#[doc = "        \"resolution\","]
#[doc = "        \"resolved_at\","]
#[doc = "        \"resolved_by\","]
#[doc = "        \"secret_type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"resolution\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"resolved_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"resolved_by\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"secret_type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopened {
    pub action: SecretScanningAlertReopenedAction,
    pub alert: SecretScanningAlertReopenedAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&SecretScanningAlertReopened> for SecretScanningAlertReopened {
    fn from(value: &SecretScanningAlertReopened) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertReopenedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reopened\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecretScanningAlertReopenedAction {
    #[serde(rename = "reopened")]
    Reopened,
}
impl ::std::convert::From<&Self> for SecretScanningAlertReopenedAction {
    fn from(value: &SecretScanningAlertReopenedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecretScanningAlertReopenedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reopened => write!(f, "reopened"),
        }
    }
}
impl ::std::str::FromStr for SecretScanningAlertReopenedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reopened" => Ok(Self::Reopened),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecretScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecretScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecretScanningAlertReopenedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"number\","]
#[doc = "    \"resolution\","]
#[doc = "    \"resolved_at\","]
#[doc = "    \"resolved_by\","]
#[doc = "    \"secret_type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"resolution\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"resolved_at\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"resolved_by\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"secret_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopenedAlert {
    pub number: i64,
    pub resolution: (),
    pub resolved_at: (),
    pub resolved_by: (),
    pub secret_type: ::std::string::String,
}
impl ::std::convert::From<&SecretScanningAlertReopenedAlert> for SecretScanningAlertReopenedAlert {
    fn from(value: &SecretScanningAlertReopenedAlert) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertResolved`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"secret_scanning_alert resolved event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"alert\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alert\": {"]
#[doc = "      \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"number\","]
#[doc = "        \"resolution\","]
#[doc = "        \"resolved_at\","]
#[doc = "        \"resolved_by\","]
#[doc = "        \"secret_type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"number\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"resolution\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"false_positive\","]
#[doc = "            \"wontfix\","]
#[doc = "            \"revoked\","]
#[doc = "            \"used_in_tests\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"resolved_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"resolved_by\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"secret_type\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolved {
    pub action: SecretScanningAlertResolvedAction,
    pub alert: SecretScanningAlertResolvedAlert,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&SecretScanningAlertResolved> for SecretScanningAlertResolved {
    fn from(value: &SecretScanningAlertResolved) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertResolvedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecretScanningAlertResolvedAction {
    #[serde(rename = "resolved")]
    Resolved,
}
impl ::std::convert::From<&Self> for SecretScanningAlertResolvedAction {
    fn from(value: &SecretScanningAlertResolvedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecretScanningAlertResolvedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
        }
    }
}
impl ::std::str::FromStr for SecretScanningAlertResolvedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecretScanningAlertResolvedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecretScanningAlertResolvedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecretScanningAlertResolvedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The secret scanning alert involved in the event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The secret scanning alert involved in the event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"number\","]
#[doc = "    \"resolution\","]
#[doc = "    \"resolved_at\","]
#[doc = "    \"resolved_by\","]
#[doc = "    \"secret_type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"resolution\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"false_positive\","]
#[doc = "        \"wontfix\","]
#[doc = "        \"revoked\","]
#[doc = "        \"used_in_tests\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolved_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"resolved_by\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"secret_type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolvedAlert {
    pub number: i64,
    pub resolution: SecretScanningAlertResolvedAlertResolution,
    pub resolved_at: ::std::string::String,
    pub resolved_by: User,
    pub secret_type: ::std::string::String,
}
impl ::std::convert::From<&SecretScanningAlertResolvedAlert> for SecretScanningAlertResolvedAlert {
    fn from(value: &SecretScanningAlertResolvedAlert) -> Self {
        value.clone()
    }
}
#[doc = "`SecretScanningAlertResolvedAlertResolution`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"false_positive\","]
#[doc = "    \"wontfix\","]
#[doc = "    \"revoked\","]
#[doc = "    \"used_in_tests\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecretScanningAlertResolvedAlertResolution {
    #[serde(rename = "false_positive")]
    FalsePositive,
    #[serde(rename = "wontfix")]
    Wontfix,
    #[serde(rename = "revoked")]
    Revoked,
    #[serde(rename = "used_in_tests")]
    UsedInTests,
}
impl ::std::convert::From<&Self> for SecretScanningAlertResolvedAlertResolution {
    fn from(value: &SecretScanningAlertResolvedAlertResolution) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecretScanningAlertResolvedAlertResolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FalsePositive => write!(f, "false_positive"),
            Self::Wontfix => write!(f, "wontfix"),
            Self::Revoked => write!(f, "revoked"),
            Self::UsedInTests => write!(f, "used_in_tests"),
        }
    }
}
impl ::std::str::FromStr for SecretScanningAlertResolvedAlertResolution {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "false_positive" => Ok(Self::FalsePositive),
            "wontfix" => Ok(Self::Wontfix),
            "revoked" => Ok(Self::Revoked),
            "used_in_tests" => Ok(Self::UsedInTests),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecretScanningAlertResolvedAlertResolution {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SecretScanningAlertResolvedAlertResolution
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecretScanningAlertResolvedAlertResolution {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SecurityAdvisoryEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/security_advisory$performed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/security_advisory$published\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/security_advisory$updated\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/security_advisory$withdrawn\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SecurityAdvisoryEvent {
    Performed(SecurityAdvisoryPerformed),
    Published(SecurityAdvisoryPublished),
    Updated(SecurityAdvisoryUpdated),
    Withdrawn(SecurityAdvisoryWithdrawn),
}
impl ::std::convert::From<&Self> for SecurityAdvisoryEvent {
    fn from(value: &SecurityAdvisoryEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecurityAdvisoryPerformed> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPerformed) -> Self {
        Self::Performed(value)
    }
}
impl ::std::convert::From<SecurityAdvisoryPublished> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryPublished) -> Self {
        Self::Published(value)
    }
}
impl ::std::convert::From<SecurityAdvisoryUpdated> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryUpdated) -> Self {
        Self::Updated(value)
    }
}
impl ::std::convert::From<SecurityAdvisoryWithdrawn> for SecurityAdvisoryEvent {
    fn from(value: SecurityAdvisoryWithdrawn) -> Self {
        Self::Withdrawn(value)
    }
}
#[doc = "`SecurityAdvisoryPerformed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"security_advisory performed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"security_advisory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"performed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_advisory\": {"]
#[doc = "      \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cvss\","]
#[doc = "        \"cwes\","]
#[doc = "        \"description\","]
#[doc = "        \"ghsa_id\","]
#[doc = "        \"identifiers\","]
#[doc = "        \"published_at\","]
#[doc = "        \"references\","]
#[doc = "        \"severity\","]
#[doc = "        \"summary\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"vulnerabilities\","]
#[doc = "        \"withdrawn_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cvss\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"score\","]
#[doc = "            \"vector_string\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"score\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"vector_string\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"cwes\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"cwe_id\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"cwe_id\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"identifiers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"type\","]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"references\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"vulnerabilities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"first_patched_version\","]
#[doc = "              \"package\","]
#[doc = "              \"severity\","]
#[doc = "              \"vulnerable_version_range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"first_patched_version\": {"]
#[doc = "                \"type\": ["]
#[doc = "                  \"object\","]
#[doc = "                  \"null\""]
#[doc = "                ],"]
#[doc = "                \"required\": ["]
#[doc = "                  \"identifier\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"identifier\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"package\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"ecosystem\","]
#[doc = "                  \"name\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"ecosystem\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"severity\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"vulnerable_version_range\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"withdrawn_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformed {
    pub action: SecurityAdvisoryPerformedAction,
    pub security_advisory: SecurityAdvisoryPerformedSecurityAdvisory,
}
impl ::std::convert::From<&SecurityAdvisoryPerformed> for SecurityAdvisoryPerformed {
    fn from(value: &SecurityAdvisoryPerformed) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"performed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecurityAdvisoryPerformedAction {
    #[serde(rename = "performed")]
    Performed,
}
impl ::std::convert::From<&Self> for SecurityAdvisoryPerformedAction {
    fn from(value: &SecurityAdvisoryPerformedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecurityAdvisoryPerformedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Performed => write!(f, "performed"),
        }
    }
}
impl ::std::str::FromStr for SecurityAdvisoryPerformedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "performed" => Ok(Self::Performed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecurityAdvisoryPerformedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecurityAdvisoryPerformedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecurityAdvisoryPerformedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cvss\","]
#[doc = "    \"cwes\","]
#[doc = "    \"description\","]
#[doc = "    \"ghsa_id\","]
#[doc = "    \"identifiers\","]
#[doc = "    \"published_at\","]
#[doc = "    \"references\","]
#[doc = "    \"severity\","]
#[doc = "    \"summary\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"vulnerabilities\","]
#[doc = "    \"withdrawn_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cvss\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"score\","]
#[doc = "        \"vector_string\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"score\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"vector_string\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"cwes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"cwe_id\","]
#[doc = "          \"name\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"cwe_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"identifiers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"type\","]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"value\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"references\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerabilities\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"first_patched_version\","]
#[doc = "          \"package\","]
#[doc = "          \"severity\","]
#[doc = "          \"vulnerable_version_range\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"first_patched_version\": {"]
#[doc = "            \"type\": ["]
#[doc = "              \"object\","]
#[doc = "              \"null\""]
#[doc = "            ],"]
#[doc = "            \"required\": ["]
#[doc = "              \"identifier\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"identifier\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"package\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ecosystem\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ecosystem\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"severity\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"vulnerable_version_range\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"withdrawn_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPerformedSecurityAdvisoryCvss,
    pub cwes: ::std::vec::Vec<SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>,
    pub description: ::std::string::String,
    pub ghsa_id: ::std::string::String,
    pub identifiers: ::std::vec::Vec<SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>,
    pub published_at: ::std::string::String,
    pub references: ::std::vec::Vec<SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>,
    pub severity: ::std::string::String,
    pub summary: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub vulnerabilities:
        ::std::vec::Vec<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisory>
    for SecurityAdvisoryPerformedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryCvss`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"score\","]
#[doc = "    \"vector_string\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"score\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"vector_string\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryCvss>
    for SecurityAdvisoryPerformedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryCwesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cwe_id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cwe_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCwesItem {
    pub cwe_id: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub value: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem {
    pub url: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"first_patched_version\","]
#[doc = "    \"package\","]
#[doc = "    \"severity\","]
#[doc = "    \"vulnerable_version_range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"first_patched_version\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"required\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ecosystem\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerable_version_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version: ::std::option::Option<
        SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    >,
    pub package: SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: ::std::string::String,
    pub vulnerable_version_range: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: ::std::string::String,
}
impl
    ::std::convert::From<
        &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    > for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ecosystem\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublished`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"security_advisory published event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"security_advisory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"published\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_advisory\": {"]
#[doc = "      \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cvss\","]
#[doc = "        \"cwes\","]
#[doc = "        \"description\","]
#[doc = "        \"ghsa_id\","]
#[doc = "        \"identifiers\","]
#[doc = "        \"published_at\","]
#[doc = "        \"references\","]
#[doc = "        \"severity\","]
#[doc = "        \"summary\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"vulnerabilities\","]
#[doc = "        \"withdrawn_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cvss\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"score\","]
#[doc = "            \"vector_string\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"score\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"vector_string\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"cwes\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"cwe_id\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"cwe_id\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"identifiers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"type\","]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"references\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"vulnerabilities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"first_patched_version\","]
#[doc = "              \"package\","]
#[doc = "              \"severity\","]
#[doc = "              \"vulnerable_version_range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"first_patched_version\": {"]
#[doc = "                \"type\": ["]
#[doc = "                  \"object\","]
#[doc = "                  \"null\""]
#[doc = "                ],"]
#[doc = "                \"required\": ["]
#[doc = "                  \"identifier\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"identifier\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"package\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"ecosystem\","]
#[doc = "                  \"name\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"ecosystem\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"severity\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"vulnerable_version_range\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"withdrawn_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublished {
    pub action: SecurityAdvisoryPublishedAction,
    pub security_advisory: SecurityAdvisoryPublishedSecurityAdvisory,
}
impl ::std::convert::From<&SecurityAdvisoryPublished> for SecurityAdvisoryPublished {
    fn from(value: &SecurityAdvisoryPublished) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"published\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecurityAdvisoryPublishedAction {
    #[serde(rename = "published")]
    Published,
}
impl ::std::convert::From<&Self> for SecurityAdvisoryPublishedAction {
    fn from(value: &SecurityAdvisoryPublishedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecurityAdvisoryPublishedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Published => write!(f, "published"),
        }
    }
}
impl ::std::str::FromStr for SecurityAdvisoryPublishedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "published" => Ok(Self::Published),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecurityAdvisoryPublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecurityAdvisoryPublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecurityAdvisoryPublishedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cvss\","]
#[doc = "    \"cwes\","]
#[doc = "    \"description\","]
#[doc = "    \"ghsa_id\","]
#[doc = "    \"identifiers\","]
#[doc = "    \"published_at\","]
#[doc = "    \"references\","]
#[doc = "    \"severity\","]
#[doc = "    \"summary\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"vulnerabilities\","]
#[doc = "    \"withdrawn_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cvss\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"score\","]
#[doc = "        \"vector_string\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"score\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"vector_string\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"cwes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"cwe_id\","]
#[doc = "          \"name\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"cwe_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"identifiers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"type\","]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"value\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"references\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerabilities\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"first_patched_version\","]
#[doc = "          \"package\","]
#[doc = "          \"severity\","]
#[doc = "          \"vulnerable_version_range\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"first_patched_version\": {"]
#[doc = "            \"type\": ["]
#[doc = "              \"object\","]
#[doc = "              \"null\""]
#[doc = "            ],"]
#[doc = "            \"required\": ["]
#[doc = "              \"identifier\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"identifier\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"package\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ecosystem\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ecosystem\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"severity\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"vulnerable_version_range\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"withdrawn_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisory {
    pub cvss: SecurityAdvisoryPublishedSecurityAdvisoryCvss,
    pub cwes: ::std::vec::Vec<SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>,
    pub description: ::std::string::String,
    pub ghsa_id: ::std::string::String,
    pub identifiers: ::std::vec::Vec<SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>,
    pub published_at: ::std::string::String,
    pub references: ::std::vec::Vec<SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>,
    pub severity: ::std::string::String,
    pub summary: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub vulnerabilities:
        ::std::vec::Vec<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisory>
    for SecurityAdvisoryPublishedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryCvss`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"score\","]
#[doc = "    \"vector_string\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"score\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"vector_string\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryCvss>
    for SecurityAdvisoryPublishedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryCwesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cwe_id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cwe_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCwesItem {
    pub cwe_id: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub value: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem {
    pub url: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"first_patched_version\","]
#[doc = "    \"package\","]
#[doc = "    \"severity\","]
#[doc = "    \"vulnerable_version_range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"first_patched_version\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"required\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ecosystem\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerable_version_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version: ::std::option::Option<
        SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    >,
    pub package: SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: ::std::string::String,
    pub vulnerable_version_range: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: ::std::string::String,
}
impl
    ::std::convert::From<
        &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    > for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ecosystem\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"security_advisory updated event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"security_advisory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"updated\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_advisory\": {"]
#[doc = "      \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cvss\","]
#[doc = "        \"cwes\","]
#[doc = "        \"description\","]
#[doc = "        \"ghsa_id\","]
#[doc = "        \"identifiers\","]
#[doc = "        \"published_at\","]
#[doc = "        \"references\","]
#[doc = "        \"severity\","]
#[doc = "        \"summary\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"vulnerabilities\","]
#[doc = "        \"withdrawn_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cvss\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"score\","]
#[doc = "            \"vector_string\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"score\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"vector_string\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"cwes\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"cwe_id\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"cwe_id\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"identifiers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"type\","]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"references\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"vulnerabilities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"first_patched_version\","]
#[doc = "              \"package\","]
#[doc = "              \"severity\","]
#[doc = "              \"vulnerable_version_range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"first_patched_version\": {"]
#[doc = "                \"type\": ["]
#[doc = "                  \"object\","]
#[doc = "                  \"null\""]
#[doc = "                ],"]
#[doc = "                \"required\": ["]
#[doc = "                  \"identifier\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"identifier\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"package\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"ecosystem\","]
#[doc = "                  \"name\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"ecosystem\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"severity\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"vulnerable_version_range\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"withdrawn_at\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdated {
    pub action: SecurityAdvisoryUpdatedAction,
    pub security_advisory: SecurityAdvisoryUpdatedSecurityAdvisory,
}
impl ::std::convert::From<&SecurityAdvisoryUpdated> for SecurityAdvisoryUpdated {
    fn from(value: &SecurityAdvisoryUpdated) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"updated\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecurityAdvisoryUpdatedAction {
    #[serde(rename = "updated")]
    Updated,
}
impl ::std::convert::From<&Self> for SecurityAdvisoryUpdatedAction {
    fn from(value: &SecurityAdvisoryUpdatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecurityAdvisoryUpdatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Updated => write!(f, "updated"),
        }
    }
}
impl ::std::str::FromStr for SecurityAdvisoryUpdatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "updated" => Ok(Self::Updated),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecurityAdvisoryUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecurityAdvisoryUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecurityAdvisoryUpdatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cvss\","]
#[doc = "    \"cwes\","]
#[doc = "    \"description\","]
#[doc = "    \"ghsa_id\","]
#[doc = "    \"identifiers\","]
#[doc = "    \"published_at\","]
#[doc = "    \"references\","]
#[doc = "    \"severity\","]
#[doc = "    \"summary\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"vulnerabilities\","]
#[doc = "    \"withdrawn_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cvss\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"score\","]
#[doc = "        \"vector_string\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"score\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"vector_string\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"cwes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"cwe_id\","]
#[doc = "          \"name\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"cwe_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"identifiers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"type\","]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"value\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"references\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerabilities\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"first_patched_version\","]
#[doc = "          \"package\","]
#[doc = "          \"severity\","]
#[doc = "          \"vulnerable_version_range\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"first_patched_version\": {"]
#[doc = "            \"type\": ["]
#[doc = "              \"object\","]
#[doc = "              \"null\""]
#[doc = "            ],"]
#[doc = "            \"required\": ["]
#[doc = "              \"identifier\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"identifier\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"package\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ecosystem\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ecosystem\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"severity\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"vulnerable_version_range\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"withdrawn_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisory {
    pub cvss: SecurityAdvisoryUpdatedSecurityAdvisoryCvss,
    pub cwes: ::std::vec::Vec<SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>,
    pub description: ::std::string::String,
    pub ghsa_id: ::std::string::String,
    pub identifiers: ::std::vec::Vec<SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>,
    pub published_at: ::std::string::String,
    pub references: ::std::vec::Vec<SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>,
    pub severity: ::std::string::String,
    pub summary: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub vulnerabilities:
        ::std::vec::Vec<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisory>
    for SecurityAdvisoryUpdatedSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryCvss`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"score\","]
#[doc = "    \"vector_string\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"score\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"vector_string\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryCvss>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cwe_id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cwe_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem {
    pub cwe_id: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub value: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem {
    pub url: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"first_patched_version\","]
#[doc = "    \"package\","]
#[doc = "    \"severity\","]
#[doc = "    \"vulnerable_version_range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"first_patched_version\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"required\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ecosystem\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerable_version_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version: ::std::option::Option<
        SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    >,
    pub package: SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: ::std::string::String,
    pub vulnerable_version_range: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: ::std::string::String,
}
impl
    ::std::convert::From<
        &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    > for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ecosystem\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawn`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"security_advisory withdrawn event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"security_advisory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"withdrawn\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"security_advisory\": {"]
#[doc = "      \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cvss\","]
#[doc = "        \"cwes\","]
#[doc = "        \"description\","]
#[doc = "        \"ghsa_id\","]
#[doc = "        \"identifiers\","]
#[doc = "        \"published_at\","]
#[doc = "        \"references\","]
#[doc = "        \"severity\","]
#[doc = "        \"summary\","]
#[doc = "        \"updated_at\","]
#[doc = "        \"vulnerabilities\","]
#[doc = "        \"withdrawn_at\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cvss\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"score\","]
#[doc = "            \"vector_string\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"score\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"vector_string\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"cwes\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"cwe_id\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"cwe_id\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ghsa_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"identifiers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"type\","]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"type\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"published_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"references\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"severity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"updated_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"vulnerabilities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"first_patched_version\","]
#[doc = "              \"package\","]
#[doc = "              \"severity\","]
#[doc = "              \"vulnerable_version_range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"first_patched_version\": {"]
#[doc = "                \"type\": ["]
#[doc = "                  \"object\","]
#[doc = "                  \"null\""]
#[doc = "                ],"]
#[doc = "                \"required\": ["]
#[doc = "                  \"identifier\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"identifier\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"package\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"ecosystem\","]
#[doc = "                  \"name\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"ecosystem\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"name\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              \"severity\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"vulnerable_version_range\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"withdrawn_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawn {
    pub action: SecurityAdvisoryWithdrawnAction,
    pub security_advisory: SecurityAdvisoryWithdrawnSecurityAdvisory,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawn> for SecurityAdvisoryWithdrawn {
    fn from(value: &SecurityAdvisoryWithdrawn) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"withdrawn\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SecurityAdvisoryWithdrawnAction {
    #[serde(rename = "withdrawn")]
    Withdrawn,
}
impl ::std::convert::From<&Self> for SecurityAdvisoryWithdrawnAction {
    fn from(value: &SecurityAdvisoryWithdrawnAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SecurityAdvisoryWithdrawnAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Withdrawn => write!(f, "withdrawn"),
        }
    }
}
impl ::std::str::FromStr for SecurityAdvisoryWithdrawnAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SecurityAdvisoryWithdrawnAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecurityAdvisoryWithdrawnAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecurityAdvisoryWithdrawnAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The details of the security advisory, including summary, description, and severity."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The details of the security advisory, including summary, description, and severity.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cvss\","]
#[doc = "    \"cwes\","]
#[doc = "    \"description\","]
#[doc = "    \"ghsa_id\","]
#[doc = "    \"identifiers\","]
#[doc = "    \"published_at\","]
#[doc = "    \"references\","]
#[doc = "    \"severity\","]
#[doc = "    \"summary\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"vulnerabilities\","]
#[doc = "    \"withdrawn_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cvss\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"score\","]
#[doc = "        \"vector_string\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"score\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"vector_string\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"cwes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"cwe_id\","]
#[doc = "          \"name\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"cwe_id\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ghsa_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"identifiers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"type\","]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"value\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"published_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"references\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerabilities\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"first_patched_version\","]
#[doc = "          \"package\","]
#[doc = "          \"severity\","]
#[doc = "          \"vulnerable_version_range\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"first_patched_version\": {"]
#[doc = "            \"type\": ["]
#[doc = "              \"object\","]
#[doc = "              \"null\""]
#[doc = "            ],"]
#[doc = "            \"required\": ["]
#[doc = "              \"identifier\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"identifier\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"package\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ecosystem\","]
#[doc = "              \"name\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ecosystem\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"name\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"severity\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"vulnerable_version_range\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"withdrawn_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisory {
    pub cvss: SecurityAdvisoryWithdrawnSecurityAdvisoryCvss,
    pub cwes: ::std::vec::Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>,
    pub description: ::std::string::String,
    pub ghsa_id: ::std::string::String,
    pub identifiers: ::std::vec::Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>,
    pub published_at: ::std::string::String,
    pub references: ::std::vec::Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>,
    pub severity: ::std::string::String,
    pub summary: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub vulnerabilities:
        ::std::vec::Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>,
    pub withdrawn_at: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisory>
    for SecurityAdvisoryWithdrawnSecurityAdvisory
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisory) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryCvss`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"score\","]
#[doc = "    \"vector_string\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"score\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"vector_string\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCvss {
    pub score: f64,
    pub vector_string: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCvss>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCvss
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCvss) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cwe_id\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cwe_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem {
    pub cwe_id: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem {
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    pub value: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem {
    pub url: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"first_patched_version\","]
#[doc = "    \"package\","]
#[doc = "    \"severity\","]
#[doc = "    \"vulnerable_version_range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"first_patched_version\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"required\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"identifier\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"package\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ecosystem\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ecosystem\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"severity\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"vulnerable_version_range\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem {
    pub first_patched_version: ::std::option::Option<
        SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    >,
    pub package: SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage,
    pub severity: ::std::string::String,
    pub vulnerable_version_range: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"identifier\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
    pub identifier: ::std::string::String,
}
impl
    ::std::convert::From<
        &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    > for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
    fn from(
        value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
    ) -> Self {
        value.clone()
    }
}
#[doc = "`SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ecosystem\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ecosystem\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage {
    pub ecosystem: ::std::string::String,
    pub name: ::std::string::String,
}
impl ::std::convert::From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage>
    for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage
{
    fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
        value.clone()
    }
}
#[doc = "`SimplePullRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Simple Pull Request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"_links\","]
#[doc = "    \"active_lock_reason\","]
#[doc = "    \"assignee\","]
#[doc = "    \"assignees\","]
#[doc = "    \"author_association\","]
#[doc = "    \"auto_merge\","]
#[doc = "    \"base\","]
#[doc = "    \"body\","]
#[doc = "    \"closed_at\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commits_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"diff_url\","]
#[doc = "    \"draft\","]
#[doc = "    \"head\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"issue_url\","]
#[doc = "    \"labels\","]
#[doc = "    \"locked\","]
#[doc = "    \"merge_commit_sha\","]
#[doc = "    \"merged_at\","]
#[doc = "    \"milestone\","]
#[doc = "    \"node_id\","]
#[doc = "    \"number\","]
#[doc = "    \"patch_url\","]
#[doc = "    \"requested_reviewers\","]
#[doc = "    \"requested_teams\","]
#[doc = "    \"review_comment_url\","]
#[doc = "    \"review_comments_url\","]
#[doc = "    \"state\","]
#[doc = "    \"statuses_url\","]
#[doc = "    \"title\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_links\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"comments\","]
#[doc = "        \"commits\","]
#[doc = "        \"html\","]
#[doc = "        \"issue\","]
#[doc = "        \"review_comment\","]
#[doc = "        \"review_comments\","]
#[doc = "        \"self\","]
#[doc = "        \"statuses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"commits\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"html\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"issue\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comment\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"review_comments\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"self\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        },"]
#[doc = "        \"statuses\": {"]
#[doc = "          \"$ref\": \"#/definitions/link\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"active_lock_reason\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolved\","]
#[doc = "        \"off-topic\","]
#[doc = "        \"too heated\","]
#[doc = "        \"spam\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignee\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"assignees\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/user\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"author_association\": {"]
#[doc = "      \"$ref\": \"#/definitions/author_association\""]
#[doc = "    },"]
#[doc = "    \"auto_merge\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"body\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"closed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commits_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"diff_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"draft\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"label\","]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\","]
#[doc = "        \"user\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"label\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repository\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"user\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"issue_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/label\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"merge_commit_sha\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"merged_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"milestone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/milestone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"patch_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"requested_reviewers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/user\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/team\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requested_teams\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/team\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"review_comment_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"review_comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"statuses_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequest {
    pub active_lock_reason: ::std::option::Option<SimplePullRequestActiveLockReason>,
    pub assignee: ::std::option::Option<User>,
    pub assignees: ::std::vec::Vec<User>,
    pub author_association: AuthorAssociation,
    pub auto_merge: (),
    pub base: SimplePullRequestBase,
    pub body: ::std::string::String,
    pub closed_at: ::std::option::Option<::std::string::String>,
    pub comments_url: ::std::string::String,
    pub commits_url: ::std::string::String,
    pub created_at: ::std::string::String,
    pub diff_url: ::std::string::String,
    pub draft: bool,
    pub head: SimplePullRequestHead,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub issue_url: ::std::string::String,
    pub labels: ::std::vec::Vec<Label>,
    #[serde(rename = "_links")]
    pub links: SimplePullRequestLinks,
    pub locked: bool,
    pub merge_commit_sha: ::std::option::Option<::std::string::String>,
    pub merged_at: ::std::option::Option<::std::string::String>,
    pub milestone: ::std::option::Option<Milestone>,
    pub node_id: ::std::string::String,
    pub number: i64,
    pub patch_url: ::std::string::String,
    pub requested_reviewers: ::std::vec::Vec<SimplePullRequestRequestedReviewersItem>,
    pub requested_teams: ::std::vec::Vec<Team>,
    pub review_comment_url: ::std::string::String,
    pub review_comments_url: ::std::string::String,
    pub state: SimplePullRequestState,
    pub statuses_url: ::std::string::String,
    pub title: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&SimplePullRequest> for SimplePullRequest {
    fn from(value: &SimplePullRequest) -> Self {
        value.clone()
    }
}
#[doc = "`SimplePullRequestActiveLockReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolved\","]
#[doc = "    \"off-topic\","]
#[doc = "    \"too heated\","]
#[doc = "    \"spam\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SimplePullRequestActiveLockReason {
    #[serde(rename = "resolved")]
    Resolved,
    #[serde(rename = "off-topic")]
    OffTopic,
    #[serde(rename = "too heated")]
    TooHeated,
    #[serde(rename = "spam")]
    Spam,
}
impl ::std::convert::From<&Self> for SimplePullRequestActiveLockReason {
    fn from(value: &SimplePullRequestActiveLockReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SimplePullRequestActiveLockReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolved => write!(f, "resolved"),
            Self::OffTopic => write!(f, "off-topic"),
            Self::TooHeated => write!(f, "too heated"),
            Self::Spam => write!(f, "spam"),
        }
    }
}
impl ::std::str::FromStr for SimplePullRequestActiveLockReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolved" => Ok(Self::Resolved),
            "off-topic" => Ok(Self::OffTopic),
            "too heated" => Ok(Self::TooHeated),
            "spam" => Ok(Self::Spam),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SimplePullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SimplePullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SimplePullRequestActiveLockReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SimplePullRequestBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestBase {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&SimplePullRequestBase> for SimplePullRequestBase {
    fn from(value: &SimplePullRequestBase) -> Self {
        value.clone()
    }
}
#[doc = "`SimplePullRequestHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"label\","]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\","]
#[doc = "    \"user\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"label\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"user\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestHead {
    pub label: ::std::string::String,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: Repository,
    pub sha: ::std::string::String,
    pub user: User,
}
impl ::std::convert::From<&SimplePullRequestHead> for SimplePullRequestHead {
    fn from(value: &SimplePullRequestHead) -> Self {
        value.clone()
    }
}
#[doc = "`SimplePullRequestLinks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"comments\","]
#[doc = "    \"commits\","]
#[doc = "    \"html\","]
#[doc = "    \"issue\","]
#[doc = "    \"review_comment\","]
#[doc = "    \"review_comments\","]
#[doc = "    \"self\","]
#[doc = "    \"statuses\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"commits\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"html\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"issue\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comment\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"review_comments\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"self\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    },"]
#[doc = "    \"statuses\": {"]
#[doc = "      \"$ref\": \"#/definitions/link\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestLinks {
    pub comments: Link,
    pub commits: Link,
    pub html: Link,
    pub issue: Link,
    pub review_comment: Link,
    pub review_comments: Link,
    #[serde(rename = "self")]
    pub self_: Link,
    pub statuses: Link,
}
impl ::std::convert::From<&SimplePullRequestLinks> for SimplePullRequestLinks {
    fn from(value: &SimplePullRequestLinks) -> Self {
        value.clone()
    }
}
#[doc = "`SimplePullRequestRequestedReviewersItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SimplePullRequestRequestedReviewersItem {
    User(User),
    Team(Team),
}
impl ::std::convert::From<&Self> for SimplePullRequestRequestedReviewersItem {
    fn from(value: &SimplePullRequestRequestedReviewersItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<User> for SimplePullRequestRequestedReviewersItem {
    fn from(value: User) -> Self {
        Self::User(value)
    }
}
impl ::std::convert::From<Team> for SimplePullRequestRequestedReviewersItem {
    fn from(value: Team) -> Self {
        Self::Team(value)
    }
}
#[doc = "`SimplePullRequestState`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SimplePullRequestState {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
}
impl ::std::convert::From<&Self> for SimplePullRequestState {
    fn from(value: &SimplePullRequestState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SimplePullRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
        }
    }
}
impl ::std::str::FromStr for SimplePullRequestState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SimplePullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SimplePullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SimplePullRequestState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipCancelled`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship cancelled event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"cancelled\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelled {
    pub action: SponsorshipCancelledAction,
    pub sender: User,
    pub sponsorship: SponsorshipCancelledSponsorship,
}
impl ::std::convert::From<&SponsorshipCancelled> for SponsorshipCancelled {
    fn from(value: &SponsorshipCancelled) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipCancelledAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"cancelled\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipCancelledAction {
    #[serde(rename = "cancelled")]
    Cancelled,
}
impl ::std::convert::From<&Self> for SponsorshipCancelledAction {
    fn from(value: &SponsorshipCancelledAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipCancelledAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Cancelled => write!(f, "cancelled"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipCancelledAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipCancelledAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipCancelledSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelledSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipCancelledSponsorship> for SponsorshipCancelledSponsorship {
    fn from(value: &SponsorshipCancelledSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreated {
    pub action: SponsorshipCreatedAction,
    pub sender: User,
    pub sponsorship: SponsorshipCreatedSponsorship,
}
impl ::std::convert::From<&SponsorshipCreated> for SponsorshipCreated {
    fn from(value: &SponsorshipCreated) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for SponsorshipCreatedAction {
    fn from(value: &SponsorshipCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipCreatedSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreatedSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipCreatedSponsorship> for SponsorshipCreatedSponsorship {
    fn from(value: &SponsorshipCreatedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEdited {
    pub action: SponsorshipEditedAction,
    pub changes: SponsorshipEditedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipEditedSponsorship,
}
impl ::std::convert::From<&SponsorshipEdited> for SponsorshipEdited {
    fn from(value: &SponsorshipEdited) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for SponsorshipEditedAction {
    fn from(value: &SponsorshipEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipEditedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub privacy_level: ::std::option::Option<SponsorshipEditedChangesPrivacyLevel>,
}
impl ::std::convert::From<&SponsorshipEditedChanges> for SponsorshipEditedChanges {
    fn from(value: &SponsorshipEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SponsorshipEditedChanges {
    fn default() -> Self {
        Self {
            privacy_level: Default::default(),
        }
    }
}
#[doc = "`SponsorshipEditedChangesPrivacyLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChangesPrivacyLevel {
    #[doc = "The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&SponsorshipEditedChangesPrivacyLevel>
    for SponsorshipEditedChangesPrivacyLevel
{
    fn from(value: &SponsorshipEditedChangesPrivacyLevel) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipEditedSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipEditedSponsorship> for SponsorshipEditedSponsorship {
    fn from(value: &SponsorshipEditedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$cancelled\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$pending_cancellation\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$pending_tier_change\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship$tier_changed\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SponsorshipEvent {
    Cancelled(SponsorshipCancelled),
    Created(SponsorshipCreated),
    Edited(SponsorshipEdited),
    PendingCancellation(SponsorshipPendingCancellation),
    PendingTierChange(SponsorshipPendingTierChange),
    TierChanged(SponsorshipTierChanged),
}
impl ::std::convert::From<&Self> for SponsorshipEvent {
    fn from(value: &SponsorshipEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SponsorshipCancelled> for SponsorshipEvent {
    fn from(value: SponsorshipCancelled) -> Self {
        Self::Cancelled(value)
    }
}
impl ::std::convert::From<SponsorshipCreated> for SponsorshipEvent {
    fn from(value: SponsorshipCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<SponsorshipEdited> for SponsorshipEvent {
    fn from(value: SponsorshipEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<SponsorshipPendingCancellation> for SponsorshipEvent {
    fn from(value: SponsorshipPendingCancellation) -> Self {
        Self::PendingCancellation(value)
    }
}
impl ::std::convert::From<SponsorshipPendingTierChange> for SponsorshipEvent {
    fn from(value: SponsorshipPendingTierChange) -> Self {
        Self::PendingTierChange(value)
    }
}
impl ::std::convert::From<SponsorshipTierChanged> for SponsorshipEvent {
    fn from(value: SponsorshipTierChanged) -> Self {
        Self::TierChanged(value)
    }
}
#[doc = "`SponsorshipPendingCancellation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship pending_cancellation event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending_cancellation\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"description\": \"The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellation {
    pub action: SponsorshipPendingCancellationAction,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub effective_date: ::std::option::Option<::std::string::String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingCancellationSponsorship,
}
impl ::std::convert::From<&SponsorshipPendingCancellation> for SponsorshipPendingCancellation {
    fn from(value: &SponsorshipPendingCancellation) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipPendingCancellationAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending_cancellation\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipPendingCancellationAction {
    #[serde(rename = "pending_cancellation")]
    PendingCancellation,
}
impl ::std::convert::From<&Self> for SponsorshipPendingCancellationAction {
    fn from(value: &SponsorshipPendingCancellationAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipPendingCancellationAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PendingCancellation => write!(f, "pending_cancellation"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipPendingCancellationAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending_cancellation" => Ok(Self::PendingCancellation),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipPendingCancellationAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipPendingCancellationAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipPendingCancellationAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipPendingCancellationSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellationSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipPendingCancellationSponsorship>
    for SponsorshipPendingCancellationSponsorship
{
    fn from(value: &SponsorshipPendingCancellationSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipPendingTierChange`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship pending_tier_change event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending_tier_change\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"tier\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"effective_date\": {"]
#[doc = "      \"description\": \"The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChange {
    pub action: SponsorshipPendingTierChangeAction,
    pub changes: SponsorshipPendingTierChangeChanges,
    #[doc = "The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub effective_date: ::std::option::Option<::std::string::String>,
    pub sender: User,
    pub sponsorship: SponsorshipPendingTierChangeSponsorship,
}
impl ::std::convert::From<&SponsorshipPendingTierChange> for SponsorshipPendingTierChange {
    fn from(value: &SponsorshipPendingTierChange) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipPendingTierChangeAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending_tier_change\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipPendingTierChangeAction {
    #[serde(rename = "pending_tier_change")]
    PendingTierChange,
}
impl ::std::convert::From<&Self> for SponsorshipPendingTierChangeAction {
    fn from(value: &SponsorshipPendingTierChangeAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipPendingTierChangeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PendingTierChange => write!(f, "pending_tier_change"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipPendingTierChangeAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending_tier_change" => Ok(Self::PendingTierChange),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipPendingTierChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipPendingTierChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipPendingTierChangeAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipPendingTierChangeChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"tier\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChanges {
    pub tier: SponsorshipPendingTierChangeChangesTier,
}
impl ::std::convert::From<&SponsorshipPendingTierChangeChanges>
    for SponsorshipPendingTierChangeChanges
{
    fn from(value: &SponsorshipPendingTierChangeChanges) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipPendingTierChangeChangesTier`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChangesTier {
    pub from: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipPendingTierChangeChangesTier>
    for SponsorshipPendingTierChangeChangesTier
{
    fn from(value: &SponsorshipPendingTierChangeChangesTier) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipPendingTierChangeSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipPendingTierChangeSponsorship>
    for SponsorshipPendingTierChangeSponsorship
{
    fn from(value: &SponsorshipPendingTierChangeSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Sponsorship Tier\","]
#[doc = "  \"description\": \"The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"is_custom_ammount\","]
#[doc = "    \"is_one_time\","]
#[doc = "    \"monthly_price_in_cents\","]
#[doc = "    \"monthly_price_in_dollars\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"is_custom_ammount\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"is_one_time\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_cents\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"monthly_price_in_dollars\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTier {
    pub created_at: ::std::string::String,
    pub description: ::std::string::String,
    pub is_custom_ammount: bool,
    pub is_one_time: bool,
    pub monthly_price_in_cents: i64,
    pub monthly_price_in_dollars: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
}
impl ::std::convert::From<&SponsorshipTier> for SponsorshipTier {
    fn from(value: &SponsorshipTier) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipTierChanged`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"sponsorship tier_changed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"sender\","]
#[doc = "    \"sponsorship\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"tier_changed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"tier\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorship\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"created_at\","]
#[doc = "        \"node_id\","]
#[doc = "        \"privacy_level\","]
#[doc = "        \"sponsor\","]
#[doc = "        \"sponsorable\","]
#[doc = "        \"tier\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"created_at\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy_level\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"sponsor\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"sponsorable\": {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        \"tier\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChanged {
    pub action: SponsorshipTierChangedAction,
    pub changes: SponsorshipTierChangedChanges,
    pub sender: User,
    pub sponsorship: SponsorshipTierChangedSponsorship,
}
impl ::std::convert::From<&SponsorshipTierChanged> for SponsorshipTierChanged {
    fn from(value: &SponsorshipTierChanged) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipTierChangedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"tier_changed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SponsorshipTierChangedAction {
    #[serde(rename = "tier_changed")]
    TierChanged,
}
impl ::std::convert::From<&Self> for SponsorshipTierChangedAction {
    fn from(value: &SponsorshipTierChangedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SponsorshipTierChangedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::TierChanged => write!(f, "tier_changed"),
        }
    }
}
impl ::std::str::FromStr for SponsorshipTierChangedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tier_changed" => Ok(Self::TierChanged),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SponsorshipTierChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SponsorshipTierChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SponsorshipTierChangedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SponsorshipTierChangedChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"tier\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChanges {
    pub tier: SponsorshipTierChangedChangesTier,
}
impl ::std::convert::From<&SponsorshipTierChangedChanges> for SponsorshipTierChangedChanges {
    fn from(value: &SponsorshipTierChangedChanges) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipTierChangedChangesTier`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChangesTier {
    pub from: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipTierChangedChangesTier>
    for SponsorshipTierChangedChangesTier
{
    fn from(value: &SponsorshipTierChangedChangesTier) -> Self {
        value.clone()
    }
}
#[doc = "`SponsorshipTierChangedSponsorship`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"created_at\","]
#[doc = "    \"node_id\","]
#[doc = "    \"privacy_level\","]
#[doc = "    \"sponsor\","]
#[doc = "    \"sponsorable\","]
#[doc = "    \"tier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy_level\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sponsor\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sponsorable\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"tier\": {"]
#[doc = "      \"$ref\": \"#/definitions/sponsorship-tier\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedSponsorship {
    pub created_at: ::std::string::String,
    pub node_id: ::std::string::String,
    pub privacy_level: ::std::string::String,
    pub sponsor: User,
    pub sponsorable: User,
    pub tier: SponsorshipTier,
}
impl ::std::convert::From<&SponsorshipTierChangedSponsorship>
    for SponsorshipTierChangedSponsorship
{
    fn from(value: &SponsorshipTierChangedSponsorship) -> Self {
        value.clone()
    }
}
#[doc = "`StarCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"star created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"starred_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"starred_at\": {"]
#[doc = "      \"description\": \"The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StarCreated {
    pub action: StarCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: ::std::string::String,
}
impl ::std::convert::From<&StarCreated> for StarCreated {
    fn from(value: &StarCreated) -> Self {
        value.clone()
    }
}
#[doc = "`StarCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StarCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for StarCreatedAction {
    fn from(value: &StarCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StarCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for StarCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StarCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StarCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StarCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StarDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"star deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"starred_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"starred_at\": {"]
#[doc = "      \"description\": \"The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.\","]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StarDeleted {
    pub action: StarDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action."]
    pub starred_at: (),
}
impl ::std::convert::From<&StarDeleted> for StarDeleted {
    fn from(value: &StarDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`StarDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StarDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for StarDeletedAction {
    fn from(value: &StarDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StarDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for StarDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StarDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StarDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StarDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StarEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/star$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/star$deleted\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StarEvent {
    Created(StarCreated),
    Deleted(StarDeleted),
}
impl ::std::convert::From<&Self> for StarEvent {
    fn from(value: &StarEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StarCreated> for StarEvent {
    fn from(value: StarCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<StarDeleted> for StarEvent {
    fn from(value: StarDeleted) -> Self {
        Self::Deleted(value)
    }
}
#[doc = "`StatusEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"status event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"branches\","]
#[doc = "    \"commit\","]
#[doc = "    \"context\","]
#[doc = "    \"created_at\","]
#[doc = "    \"description\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"sha\","]
#[doc = "    \"state\","]
#[doc = "    \"target_url\","]
#[doc = "    \"updated_at\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"branches\": {"]
#[doc = "      \"description\": \"An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"commit\","]
#[doc = "          \"name\","]
#[doc = "          \"protected\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"commit\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"sha\","]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"sha\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"name\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"protected\": {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"commit\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"comments_url\","]
#[doc = "        \"commit\","]
#[doc = "        \"committer\","]
#[doc = "        \"html_url\","]
#[doc = "        \"node_id\","]
#[doc = "        \"parents\","]
#[doc = "        \"sha\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"comments_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"commit\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"author\","]
#[doc = "            \"comment_count\","]
#[doc = "            \"committer\","]
#[doc = "            \"message\","]
#[doc = "            \"tree\","]
#[doc = "            \"url\","]
#[doc = "            \"verification\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"author\": {"]
#[doc = "              \"allOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/committer\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"date\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"date\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"tsAdditionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"comment_count\": {"]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"committer\": {"]
#[doc = "              \"allOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/committer\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"date\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"date\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"tsAdditionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tree\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"sha\","]
#[doc = "                \"url\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"sha\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"url\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            },"]
#[doc = "            \"verification\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"payload\","]
#[doc = "                \"reason\","]
#[doc = "                \"signature\","]
#[doc = "                \"verified\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"payload\": {"]
#[doc = "                  \"type\": ["]
#[doc = "                    \"string\","]
#[doc = "                    \"null\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"reason\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"expired_key\","]
#[doc = "                    \"not_signing_key\","]
#[doc = "                    \"gpgverify_error\","]
#[doc = "                    \"gpgverify_unavailable\","]
#[doc = "                    \"unsigned\","]
#[doc = "                    \"unknown_signature_type\","]
#[doc = "                    \"no_user\","]
#[doc = "                    \"unverified_email\","]
#[doc = "                    \"bad_email\","]
#[doc = "                    \"unknown_key\","]
#[doc = "                    \"malformed_signature\","]
#[doc = "                    \"invalid\","]
#[doc = "                    \"valid\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"signature\": {"]
#[doc = "                  \"type\": ["]
#[doc = "                    \"string\","]
#[doc = "                    \"null\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"verified\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"committer\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/user\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"parents\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"html_url\","]
#[doc = "              \"sha\","]
#[doc = "              \"url\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"html_url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              },"]
#[doc = "              \"sha\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"url\": {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"format\": \"uri\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"context\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"The optional human-readable description added to the status.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"The unique identifier of the status.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"description\": \"The Commit SHA.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pending\","]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"error\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"target_url\": {"]
#[doc = "      \"description\": \"The optional link added to the status.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub avatar_url: ::std::option::Option<::std::string::String>,
    #[doc = "An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches."]
    pub branches: ::std::vec::Vec<StatusEventBranchesItem>,
    pub commit: StatusEventCommit,
    pub context: ::std::string::String,
    pub created_at: ::std::string::String,
    #[doc = "The optional human-readable description added to the status."]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "The unique identifier of the status."]
    pub id: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    #[doc = "The Commit SHA."]
    pub sha: ::std::string::String,
    #[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
    pub state: StatusEventState,
    #[doc = "The optional link added to the status."]
    pub target_url: ::std::option::Option<::std::string::String>,
    pub updated_at: ::std::string::String,
}
impl ::std::convert::From<&StatusEvent> for StatusEvent {
    fn from(value: &StatusEvent) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventBranchesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"commit\","]
#[doc = "    \"name\","]
#[doc = "    \"protected\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"commit\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sha\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"protected\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItem {
    pub commit: StatusEventBranchesItemCommit,
    pub name: ::std::string::String,
    pub protected: bool,
}
impl ::std::convert::From<&StatusEventBranchesItem> for StatusEventBranchesItem {
    fn from(value: &StatusEventBranchesItem) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventBranchesItemCommit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"sha\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItemCommit {
    pub sha: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&StatusEventBranchesItemCommit> for StatusEventBranchesItemCommit {
    fn from(value: &StatusEventBranchesItemCommit) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"comments_url\","]
#[doc = "    \"commit\","]
#[doc = "    \"committer\","]
#[doc = "    \"html_url\","]
#[doc = "    \"node_id\","]
#[doc = "    \"parents\","]
#[doc = "    \"sha\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comments_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"commit\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"author\","]
#[doc = "        \"comment_count\","]
#[doc = "        \"committer\","]
#[doc = "        \"message\","]
#[doc = "        \"tree\","]
#[doc = "        \"url\","]
#[doc = "        \"verification\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"author\": {"]
#[doc = "          \"allOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/committer\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"date\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"date\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"tsAdditionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"comment_count\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"committer\": {"]
#[doc = "          \"allOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/committer\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"date\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"date\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"tsAdditionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tree\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sha\","]
#[doc = "            \"url\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sha\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"url\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"uri\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"verification\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"payload\","]
#[doc = "            \"reason\","]
#[doc = "            \"signature\","]
#[doc = "            \"verified\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"payload\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"reason\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"expired_key\","]
#[doc = "                \"not_signing_key\","]
#[doc = "                \"gpgverify_error\","]
#[doc = "                \"gpgverify_unavailable\","]
#[doc = "                \"unsigned\","]
#[doc = "                \"unknown_signature_type\","]
#[doc = "                \"no_user\","]
#[doc = "                \"unverified_email\","]
#[doc = "                \"bad_email\","]
#[doc = "                \"unknown_key\","]
#[doc = "                \"malformed_signature\","]
#[doc = "                \"invalid\","]
#[doc = "                \"valid\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"signature\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"verified\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"committer\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/user\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parents\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"html_url\","]
#[doc = "          \"sha\","]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"html_url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          },"]
#[doc = "          \"sha\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommit {
    pub author: ::std::option::Option<User>,
    pub comments_url: ::std::string::String,
    pub commit: StatusEventCommitCommit,
    pub committer: ::std::option::Option<User>,
    pub html_url: ::std::string::String,
    pub node_id: ::std::string::String,
    pub parents: ::std::vec::Vec<StatusEventCommitParentsItem>,
    pub sha: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&StatusEventCommit> for StatusEventCommit {
    fn from(value: &StatusEventCommit) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"comment_count\","]
#[doc = "    \"committer\","]
#[doc = "    \"message\","]
#[doc = "    \"tree\","]
#[doc = "    \"url\","]
#[doc = "    \"verification\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/committer\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"comment_count\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"committer\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/committer\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"date\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tree\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sha\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"verification\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"payload\","]
#[doc = "        \"reason\","]
#[doc = "        \"signature\","]
#[doc = "        \"verified\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"payload\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reason\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"expired_key\","]
#[doc = "            \"not_signing_key\","]
#[doc = "            \"gpgverify_error\","]
#[doc = "            \"gpgverify_unavailable\","]
#[doc = "            \"unsigned\","]
#[doc = "            \"unknown_signature_type\","]
#[doc = "            \"no_user\","]
#[doc = "            \"unverified_email\","]
#[doc = "            \"bad_email\","]
#[doc = "            \"unknown_key\","]
#[doc = "            \"malformed_signature\","]
#[doc = "            \"invalid\","]
#[doc = "            \"valid\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"signature\": {"]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"verified\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommit {
    pub author: StatusEventCommitCommitAuthor,
    pub comment_count: i64,
    pub committer: StatusEventCommitCommitCommitter,
    pub message: ::std::string::String,
    pub tree: StatusEventCommitCommitTree,
    pub url: ::std::string::String,
    pub verification: StatusEventCommitCommitVerification,
}
impl ::std::convert::From<&StatusEventCommitCommit> for StatusEventCommitCommit {
    fn from(value: &StatusEventCommitCommit) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommitAuthor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitAuthor {
    pub date: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The git author's email address."]
    pub email: ::std::option::Option<::std::string::String>,
    #[doc = "The git author's name."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub username: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&StatusEventCommitCommitAuthor> for StatusEventCommitCommitAuthor {
    fn from(value: &StatusEventCommitCommitAuthor) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommitCommitter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/committer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"date\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitCommitter {
    pub date: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "The git author's email address."]
    pub email: ::std::option::Option<::std::string::String>,
    #[doc = "The git author's name."]
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub username: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&StatusEventCommitCommitCommitter> for StatusEventCommitCommitCommitter {
    fn from(value: &StatusEventCommitCommitCommitter) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommitTree`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"sha\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitTree {
    pub sha: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&StatusEventCommitCommitTree> for StatusEventCommitCommitTree {
    fn from(value: &StatusEventCommitCommitTree) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommitVerification`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"payload\","]
#[doc = "    \"reason\","]
#[doc = "    \"signature\","]
#[doc = "    \"verified\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"payload\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"expired_key\","]
#[doc = "        \"not_signing_key\","]
#[doc = "        \"gpgverify_error\","]
#[doc = "        \"gpgverify_unavailable\","]
#[doc = "        \"unsigned\","]
#[doc = "        \"unknown_signature_type\","]
#[doc = "        \"no_user\","]
#[doc = "        \"unverified_email\","]
#[doc = "        \"bad_email\","]
#[doc = "        \"unknown_key\","]
#[doc = "        \"malformed_signature\","]
#[doc = "        \"invalid\","]
#[doc = "        \"valid\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"verified\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitVerification {
    pub payload: ::std::option::Option<::std::string::String>,
    pub reason: StatusEventCommitCommitVerificationReason,
    pub signature: ::std::option::Option<::std::string::String>,
    pub verified: bool,
}
impl ::std::convert::From<&StatusEventCommitCommitVerification>
    for StatusEventCommitCommitVerification
{
    fn from(value: &StatusEventCommitCommitVerification) -> Self {
        value.clone()
    }
}
#[doc = "`StatusEventCommitCommitVerificationReason`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"expired_key\","]
#[doc = "    \"not_signing_key\","]
#[doc = "    \"gpgverify_error\","]
#[doc = "    \"gpgverify_unavailable\","]
#[doc = "    \"unsigned\","]
#[doc = "    \"unknown_signature_type\","]
#[doc = "    \"no_user\","]
#[doc = "    \"unverified_email\","]
#[doc = "    \"bad_email\","]
#[doc = "    \"unknown_key\","]
#[doc = "    \"malformed_signature\","]
#[doc = "    \"invalid\","]
#[doc = "    \"valid\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StatusEventCommitCommitVerificationReason {
    #[serde(rename = "expired_key")]
    ExpiredKey,
    #[serde(rename = "not_signing_key")]
    NotSigningKey,
    #[serde(rename = "gpgverify_error")]
    GpgverifyError,
    #[serde(rename = "gpgverify_unavailable")]
    GpgverifyUnavailable,
    #[serde(rename = "unsigned")]
    Unsigned,
    #[serde(rename = "unknown_signature_type")]
    UnknownSignatureType,
    #[serde(rename = "no_user")]
    NoUser,
    #[serde(rename = "unverified_email")]
    UnverifiedEmail,
    #[serde(rename = "bad_email")]
    BadEmail,
    #[serde(rename = "unknown_key")]
    UnknownKey,
    #[serde(rename = "malformed_signature")]
    MalformedSignature,
    #[serde(rename = "invalid")]
    Invalid,
    #[serde(rename = "valid")]
    Valid,
}
impl ::std::convert::From<&Self> for StatusEventCommitCommitVerificationReason {
    fn from(value: &StatusEventCommitCommitVerificationReason) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StatusEventCommitCommitVerificationReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExpiredKey => write!(f, "expired_key"),
            Self::NotSigningKey => write!(f, "not_signing_key"),
            Self::GpgverifyError => write!(f, "gpgverify_error"),
            Self::GpgverifyUnavailable => write!(f, "gpgverify_unavailable"),
            Self::Unsigned => write!(f, "unsigned"),
            Self::UnknownSignatureType => write!(f, "unknown_signature_type"),
            Self::NoUser => write!(f, "no_user"),
            Self::UnverifiedEmail => write!(f, "unverified_email"),
            Self::BadEmail => write!(f, "bad_email"),
            Self::UnknownKey => write!(f, "unknown_key"),
            Self::MalformedSignature => write!(f, "malformed_signature"),
            Self::Invalid => write!(f, "invalid"),
            Self::Valid => write!(f, "valid"),
        }
    }
}
impl ::std::str::FromStr for StatusEventCommitCommitVerificationReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "expired_key" => Ok(Self::ExpiredKey),
            "not_signing_key" => Ok(Self::NotSigningKey),
            "gpgverify_error" => Ok(Self::GpgverifyError),
            "gpgverify_unavailable" => Ok(Self::GpgverifyUnavailable),
            "unsigned" => Ok(Self::Unsigned),
            "unknown_signature_type" => Ok(Self::UnknownSignatureType),
            "no_user" => Ok(Self::NoUser),
            "unverified_email" => Ok(Self::UnverifiedEmail),
            "bad_email" => Ok(Self::BadEmail),
            "unknown_key" => Ok(Self::UnknownKey),
            "malformed_signature" => Ok(Self::MalformedSignature),
            "invalid" => Ok(Self::Invalid),
            "valid" => Ok(Self::Valid),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StatusEventCommitCommitVerificationReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StatusEventCommitCommitVerificationReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StatusEventCommitCommitVerificationReason {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StatusEventCommitParentsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"html_url\","]
#[doc = "    \"sha\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitParentsItem {
    pub html_url: ::std::string::String,
    pub sha: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&StatusEventCommitParentsItem> for StatusEventCommitParentsItem {
    fn from(value: &StatusEventCommitParentsItem) -> Self {
        value.clone()
    }
}
#[doc = "The new state. Can be `pending`, `success`, `failure`, or `error`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The new state. Can be `pending`, `success`, `failure`, or `error`.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pending\","]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"error\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StatusEventState {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "error")]
    Error,
}
impl ::std::convert::From<&Self> for StatusEventState {
    fn from(value: &StatusEventState) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StatusEventState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pending => write!(f, "pending"),
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Error => write!(f, "error"),
        }
    }
}
impl ::std::str::FromStr for StatusEventState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pending" => Ok(Self::Pending),
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "error" => Ok(Self::Error),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StatusEventState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StatusEventState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StatusEventState {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Groups of organization members that gives permissions on specified repositories."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Team\","]
#[doc = "  \"description\": \"Groups of organization members that gives permissions on specified repositories.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"members_url\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"permission\","]
#[doc = "    \"privacy\","]
#[doc = "    \"repositories_url\","]
#[doc = "    \"slug\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Description of the team\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the team\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"members_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Name of the team\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parent\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"required\": ["]
#[doc = "        \"description\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"members_url\","]
#[doc = "        \"name\","]
#[doc = "        \"node_id\","]
#[doc = "        \"permission\","]
#[doc = "        \"privacy\","]
#[doc = "        \"repositories_url\","]
#[doc = "        \"slug\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"description\": \"Description of the team\","]
#[doc = "          \"type\": ["]
#[doc = "            \"string\","]
#[doc = "            \"null\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Unique identifier of the team\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"members_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri-template\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"Name of the team\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"permission\": {"]
#[doc = "          \"description\": \"Permission that the team will have for its repositories\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"privacy\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"open\","]
#[doc = "            \"closed\","]
#[doc = "            \"secret\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"repositories_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"slug\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"description\": \"URL for the team\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"permission\": {"]
#[doc = "      \"description\": \"Permission that the team will have for its repositories\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\","]
#[doc = "        \"secret\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repositories_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the team\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Team {
    #[doc = "Description of the team"]
    pub description: ::std::option::Option<::std::string::String>,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: ::std::string::String,
    #[doc = "Name of the team"]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parent: ::std::option::Option<TeamParent>,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: ::std::string::String,
    pub privacy: TeamPrivacy,
    pub repositories_url: ::std::string::String,
    pub slug: ::std::string::String,
    #[doc = "URL for the team"]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Team> for Team {
    fn from(value: &Team) -> Self {
        value.clone()
    }
}
#[doc = "`TeamAddEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team_add event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"organization\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamAddEvent {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    pub repository: Repository,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamAddEvent> for TeamAddEvent {
    fn from(value: &TeamAddEvent) -> Self {
        value.clone()
    }
}
#[doc = "`TeamAddedToRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team added_to_repository event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"added_to_repository\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamAddedToRepository {
    pub action: TeamAddedToRepositoryAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamAddedToRepository> for TeamAddedToRepository {
    fn from(value: &TeamAddedToRepository) -> Self {
        value.clone()
    }
}
#[doc = "`TeamAddedToRepositoryAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"added_to_repository\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamAddedToRepositoryAction {
    #[serde(rename = "added_to_repository")]
    AddedToRepository,
}
impl ::std::convert::From<&Self> for TeamAddedToRepositoryAction {
    fn from(value: &TeamAddedToRepositoryAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamAddedToRepositoryAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AddedToRepository => write!(f, "added_to_repository"),
        }
    }
}
impl ::std::str::FromStr for TeamAddedToRepositoryAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "added_to_repository" => Ok(Self::AddedToRepository),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamAddedToRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamAddedToRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamAddedToRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TeamCreated`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team created event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"created\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamCreated {
    pub action: TeamCreatedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamCreated> for TeamCreated {
    fn from(value: &TeamCreated) -> Self {
        value.clone()
    }
}
#[doc = "`TeamCreatedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"created\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamCreatedAction {
    #[serde(rename = "created")]
    Created,
}
impl ::std::convert::From<&Self> for TeamCreatedAction {
    fn from(value: &TeamCreatedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamCreatedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Created => write!(f, "created"),
        }
    }
}
impl ::std::str::FromStr for TeamCreatedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "created" => Ok(Self::Created),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamCreatedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TeamDeleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team deleted event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"deleted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamDeleted {
    pub action: TeamDeletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamDeleted> for TeamDeleted {
    fn from(value: &TeamDeleted) -> Self {
        value.clone()
    }
}
#[doc = "`TeamDeletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"deleted\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamDeletedAction {
    #[serde(rename = "deleted")]
    Deleted,
}
impl ::std::convert::From<&Self> for TeamDeletedAction {
    fn from(value: &TeamDeletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamDeletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Deleted => write!(f, "deleted"),
        }
    }
}
impl ::std::str::FromStr for TeamDeletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "deleted" => Ok(Self::Deleted),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamDeletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TeamEdited`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team edited event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"changes\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"edited\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"description\": \"The changes to the team if the action was `edited`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"privacy\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"description\": \"The previous version of the team's privacy if the action was `edited`.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"repository\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"permissions\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"permissions\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"from\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"from\": {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"admin\": {"]
#[doc = "                      \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\","]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    },"]
#[doc = "                    \"pull\": {"]
#[doc = "                      \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\","]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    },"]
#[doc = "                    \"push\": {"]
#[doc = "                      \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\","]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEdited {
    pub action: TeamEditedAction,
    pub changes: TeamEditedChanges,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamEdited> for TeamEdited {
    fn from(value: &TeamEdited) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"edited\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamEditedAction {
    #[serde(rename = "edited")]
    Edited,
}
impl ::std::convert::From<&Self> for TeamEditedAction {
    fn from(value: &TeamEditedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamEditedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Edited => write!(f, "edited"),
        }
    }
}
impl ::std::str::FromStr for TeamEditedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "edited" => Ok(Self::Edited),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamEditedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The changes to the team if the action was `edited`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The changes to the team if the action was `edited`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"privacy\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"description\": \"The previous version of the team's privacy if the action was `edited`.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"permissions\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"permissions\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"admin\": {"]
#[doc = "                  \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\","]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"pull\": {"]
#[doc = "                  \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\","]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"push\": {"]
#[doc = "                  \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\","]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChanges {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<TeamEditedChangesDescription>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<TeamEditedChangesName>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub privacy: ::std::option::Option<TeamEditedChangesPrivacy>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<TeamEditedChangesRepository>,
}
impl ::std::convert::From<&TeamEditedChanges> for TeamEditedChanges {
    fn from(value: &TeamEditedChanges) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TeamEditedChanges {
    fn default() -> Self {
        Self {
            description: Default::default(),
            name: Default::default(),
            privacy: Default::default(),
            repository: Default::default(),
        }
    }
}
#[doc = "`TeamEditedChangesDescription`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the description if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesDescription {
    #[doc = "The previous version of the description if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&TeamEditedChangesDescription> for TeamEditedChangesDescription {
    fn from(value: &TeamEditedChangesDescription) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedChangesName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the name if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesName {
    #[doc = "The previous version of the name if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&TeamEditedChangesName> for TeamEditedChangesName {
    fn from(value: &TeamEditedChangesName) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedChangesPrivacy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"description\": \"The previous version of the team's privacy if the action was `edited`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesPrivacy {
    #[doc = "The previous version of the team's privacy if the action was `edited`."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&TeamEditedChangesPrivacy> for TeamEditedChangesPrivacy {
    fn from(value: &TeamEditedChangesPrivacy) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedChangesRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"permissions\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"permissions\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"admin\": {"]
#[doc = "              \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"pull\": {"]
#[doc = "              \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"push\": {"]
#[doc = "              \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepository {
    pub permissions: TeamEditedChangesRepositoryPermissions,
}
impl ::std::convert::From<&TeamEditedChangesRepository> for TeamEditedChangesRepository {
    fn from(value: &TeamEditedChangesRepository) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedChangesRepositoryPermissions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"admin\": {"]
#[doc = "          \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"pull\": {"]
#[doc = "          \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"push\": {"]
#[doc = "          \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissions {
    pub from: TeamEditedChangesRepositoryPermissionsFrom,
}
impl ::std::convert::From<&TeamEditedChangesRepositoryPermissions>
    for TeamEditedChangesRepositoryPermissions
{
    fn from(value: &TeamEditedChangesRepositoryPermissions) -> Self {
        value.clone()
    }
}
#[doc = "`TeamEditedChangesRepositoryPermissionsFrom`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"admin\": {"]
#[doc = "      \"description\": \"The previous version of the team member's `admin` permission on a repository, if the action was `edited`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"pull\": {"]
#[doc = "      \"description\": \"The previous version of the team member's `pull` permission on a repository, if the action was `edited`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"push\": {"]
#[doc = "      \"description\": \"The previous version of the team member's `push` permission on a repository, if the action was `edited`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissionsFrom {
    #[doc = "The previous version of the team member's `admin` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub admin: ::std::option::Option<bool>,
    #[doc = "The previous version of the team member's `pull` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pull: ::std::option::Option<bool>,
    #[doc = "The previous version of the team member's `push` permission on a repository, if the action was `edited`."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub push: ::std::option::Option<bool>,
}
impl ::std::convert::From<&TeamEditedChangesRepositoryPermissionsFrom>
    for TeamEditedChangesRepositoryPermissionsFrom
{
    fn from(value: &TeamEditedChangesRepositoryPermissionsFrom) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TeamEditedChangesRepositoryPermissionsFrom {
    fn default() -> Self {
        Self {
            admin: Default::default(),
            pull: Default::default(),
            push: Default::default(),
        }
    }
}
#[doc = "`TeamEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team$added_to_repository\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team$created\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team$deleted\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team$edited\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/team$removed_from_repository\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TeamEvent {
    AddedToRepository(TeamAddedToRepository),
    Created(TeamCreated),
    Deleted(TeamDeleted),
    Edited(TeamEdited),
    RemovedFromRepository(TeamRemovedFromRepository),
}
impl ::std::convert::From<&Self> for TeamEvent {
    fn from(value: &TeamEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TeamAddedToRepository> for TeamEvent {
    fn from(value: TeamAddedToRepository) -> Self {
        Self::AddedToRepository(value)
    }
}
impl ::std::convert::From<TeamCreated> for TeamEvent {
    fn from(value: TeamCreated) -> Self {
        Self::Created(value)
    }
}
impl ::std::convert::From<TeamDeleted> for TeamEvent {
    fn from(value: TeamDeleted) -> Self {
        Self::Deleted(value)
    }
}
impl ::std::convert::From<TeamEdited> for TeamEvent {
    fn from(value: TeamEdited) -> Self {
        Self::Edited(value)
    }
}
impl ::std::convert::From<TeamRemovedFromRepository> for TeamEvent {
    fn from(value: TeamRemovedFromRepository) -> Self {
        Self::RemovedFromRepository(value)
    }
}
#[doc = "`TeamParent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"description\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"members_url\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"permission\","]
#[doc = "    \"privacy\","]
#[doc = "    \"repositories_url\","]
#[doc = "    \"slug\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Description of the team\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Unique identifier of the team\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"members_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Name of the team\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"permission\": {"]
#[doc = "      \"description\": \"Permission that the team will have for its repositories\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"privacy\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"open\","]
#[doc = "        \"closed\","]
#[doc = "        \"secret\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"repositories_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"slug\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"URL for the team\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamParent {
    #[doc = "Description of the team"]
    pub description: ::std::option::Option<::std::string::String>,
    pub html_url: ::std::string::String,
    #[doc = "Unique identifier of the team"]
    pub id: i64,
    pub members_url: ::std::string::String,
    #[doc = "Name of the team"]
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    #[doc = "Permission that the team will have for its repositories"]
    pub permission: ::std::string::String,
    pub privacy: TeamParentPrivacy,
    pub repositories_url: ::std::string::String,
    pub slug: ::std::string::String,
    #[doc = "URL for the team"]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&TeamParent> for TeamParent {
    fn from(value: &TeamParent) -> Self {
        value.clone()
    }
}
#[doc = "`TeamParentPrivacy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\","]
#[doc = "    \"secret\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamParentPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl ::std::convert::From<&Self> for TeamParentPrivacy {
    fn from(value: &TeamParentPrivacy) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamParentPrivacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
            Self::Secret => write!(f, "secret"),
        }
    }
}
impl ::std::str::FromStr for TeamParentPrivacy {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamParentPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamParentPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamParentPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TeamPrivacy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"open\","]
#[doc = "    \"closed\","]
#[doc = "    \"secret\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamPrivacy {
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "closed")]
    Closed,
    #[serde(rename = "secret")]
    Secret,
}
impl ::std::convert::From<&Self> for TeamPrivacy {
    fn from(value: &TeamPrivacy) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamPrivacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Open => write!(f, "open"),
            Self::Closed => write!(f, "closed"),
            Self::Secret => write!(f, "secret"),
        }
    }
}
impl ::std::str::FromStr for TeamPrivacy {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "open" => Ok(Self::Open),
            "closed" => Ok(Self::Closed),
            "secret" => Ok(Self::Secret),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamPrivacy {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TeamRemovedFromRepository`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"team removed_from_repository event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"organization\","]
#[doc = "    \"sender\","]
#[doc = "    \"team\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"removed_from_repository\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"team\": {"]
#[doc = "      \"$ref\": \"#/definitions/team\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TeamRemovedFromRepository {
    pub action: TeamRemovedFromRepositoryAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    pub organization: Organization,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub repository: ::std::option::Option<Repository>,
    pub sender: User,
    pub team: Team,
}
impl ::std::convert::From<&TeamRemovedFromRepository> for TeamRemovedFromRepository {
    fn from(value: &TeamRemovedFromRepository) -> Self {
        value.clone()
    }
}
#[doc = "`TeamRemovedFromRepositoryAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"removed_from_repository\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TeamRemovedFromRepositoryAction {
    #[serde(rename = "removed_from_repository")]
    RemovedFromRepository,
}
impl ::std::convert::From<&Self> for TeamRemovedFromRepositoryAction {
    fn from(value: &TeamRemovedFromRepositoryAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TeamRemovedFromRepositoryAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RemovedFromRepository => write!(f, "removed_from_repository"),
        }
    }
}
impl ::std::str::FromStr for TeamRemovedFromRepositoryAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "removed_from_repository" => Ok(Self::RemovedFromRepository),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TeamRemovedFromRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TeamRemovedFromRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TeamRemovedFromRepositoryAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`User`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"User\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avatar_url\","]
#[doc = "    \"events_url\","]
#[doc = "    \"followers_url\","]
#[doc = "    \"following_url\","]
#[doc = "    \"gists_url\","]
#[doc = "    \"gravatar_id\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"login\","]
#[doc = "    \"node_id\","]
#[doc = "    \"organizations_url\","]
#[doc = "    \"received_events_url\","]
#[doc = "    \"repos_url\","]
#[doc = "    \"site_admin\","]
#[doc = "    \"starred_url\","]
#[doc = "    \"subscriptions_url\","]
#[doc = "    \"type\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avatar_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"email\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"followers_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"following_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gists_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"gravatar_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"login\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"organizations_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"received_events_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"repos_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"site_admin\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"starred_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"subscriptions_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Bot\","]
#[doc = "        \"User\","]
#[doc = "        \"Organization\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct User {
    pub avatar_url: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub email: ::std::option::Option<::std::string::String>,
    pub events_url: ::std::string::String,
    pub followers_url: ::std::string::String,
    pub following_url: ::std::string::String,
    pub gists_url: ::std::string::String,
    pub gravatar_id: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub login: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub node_id: ::std::string::String,
    pub organizations_url: ::std::string::String,
    pub received_events_url: ::std::string::String,
    pub repos_url: ::std::string::String,
    pub site_admin: bool,
    pub starred_url: ::std::string::String,
    pub subscriptions_url: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: UserType,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&User> for User {
    fn from(value: &User) -> Self {
        value.clone()
    }
}
#[doc = "`UserType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Bot\","]
#[doc = "    \"User\","]
#[doc = "    \"Organization\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum UserType {
    Bot,
    User,
    Organization,
}
impl ::std::convert::From<&Self> for UserType {
    fn from(value: &UserType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for UserType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bot => write!(f, "Bot"),
            Self::User => write!(f, "User"),
            Self::Organization => write!(f, "Organization"),
        }
    }
}
impl ::std::str::FromStr for UserType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Bot" => Ok(Self::Bot),
            "User" => Ok(Self::User),
            "Organization" => Ok(Self::Organization),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for UserType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for UserType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for UserType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WatchEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/watch$started\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct WatchEvent(pub WatchStarted);
impl ::std::ops::Deref for WatchEvent {
    type Target = WatchStarted;
    fn deref(&self) -> &WatchStarted {
        &self.0
    }
}
impl ::std::convert::From<WatchEvent> for WatchStarted {
    fn from(value: WatchEvent) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WatchEvent> for WatchEvent {
    fn from(value: &WatchEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<WatchStarted> for WatchEvent {
    fn from(value: WatchStarted) -> Self {
        Self(value)
    }
}
#[doc = "`WatchStarted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"watch started event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"started\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WatchStarted {
    pub action: WatchStartedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
}
impl ::std::convert::From<&WatchStarted> for WatchStarted {
    fn from(value: &WatchStarted) -> Self {
        value.clone()
    }
}
#[doc = "`WatchStartedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"started\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WatchStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl ::std::convert::From<&Self> for WatchStartedAction {
    fn from(value: &WatchStartedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WatchStartedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Started => write!(f, "started"),
        }
    }
}
impl ::std::str::FromStr for WatchStartedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WatchStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WatchStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WatchStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WebhookEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Webhook Events\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\","]
#[doc = "        \"enum\": ["]
#[doc = "          \"check_run\","]
#[doc = "          \"check_suite\","]
#[doc = "          \"code_scanning_alert\","]
#[doc = "          \"commit_comment\","]
#[doc = "          \"content_reference\","]
#[doc = "          \"create\","]
#[doc = "          \"delete\","]
#[doc = "          \"deployment\","]
#[doc = "          \"deployment_review\","]
#[doc = "          \"deployment_status\","]
#[doc = "          \"deploy_key\","]
#[doc = "          \"discussion\","]
#[doc = "          \"discussion_comment\","]
#[doc = "          \"fork\","]
#[doc = "          \"gollum\","]
#[doc = "          \"issues\","]
#[doc = "          \"issue_comment\","]
#[doc = "          \"label\","]
#[doc = "          \"member\","]
#[doc = "          \"membership\","]
#[doc = "          \"meta\","]
#[doc = "          \"milestone\","]
#[doc = "          \"organization\","]
#[doc = "          \"org_block\","]
#[doc = "          \"page_build\","]
#[doc = "          \"project\","]
#[doc = "          \"project_card\","]
#[doc = "          \"project_column\","]
#[doc = "          \"public\","]
#[doc = "          \"pull_request\","]
#[doc = "          \"pull_request_review\","]
#[doc = "          \"pull_request_review_comment\","]
#[doc = "          \"push\","]
#[doc = "          \"registry_package\","]
#[doc = "          \"release\","]
#[doc = "          \"repository\","]
#[doc = "          \"repository_dispatch\","]
#[doc = "          \"repository_import\","]
#[doc = "          \"repository_vulnerability_alert\","]
#[doc = "          \"secret_scanning_alert\","]
#[doc = "          \"star\","]
#[doc = "          \"status\","]
#[doc = "          \"team\","]
#[doc = "          \"team_add\","]
#[doc = "          \"watch\","]
#[doc = "          \"workflow_dispatch\","]
#[doc = "          \"workflow_run\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\","]
#[doc = "        \"const\": \"*\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 1,"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WebhookEvents {
    Variant0(::std::vec::Vec<WebhookEventsVariant0Item>),
    Variant1([::std::string::String; 1usize]),
}
impl ::std::convert::From<&Self> for WebhookEvents {
    fn from(value: &WebhookEvents) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WebhookEventsVariant0Item>> for WebhookEvents {
    fn from(value: ::std::vec::Vec<WebhookEventsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<[::std::string::String; 1usize]> for WebhookEvents {
    fn from(value: [::std::string::String; 1usize]) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WebhookEventsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"check_run\","]
#[doc = "    \"check_suite\","]
#[doc = "    \"code_scanning_alert\","]
#[doc = "    \"commit_comment\","]
#[doc = "    \"content_reference\","]
#[doc = "    \"create\","]
#[doc = "    \"delete\","]
#[doc = "    \"deployment\","]
#[doc = "    \"deployment_review\","]
#[doc = "    \"deployment_status\","]
#[doc = "    \"deploy_key\","]
#[doc = "    \"discussion\","]
#[doc = "    \"discussion_comment\","]
#[doc = "    \"fork\","]
#[doc = "    \"gollum\","]
#[doc = "    \"issues\","]
#[doc = "    \"issue_comment\","]
#[doc = "    \"label\","]
#[doc = "    \"member\","]
#[doc = "    \"membership\","]
#[doc = "    \"meta\","]
#[doc = "    \"milestone\","]
#[doc = "    \"organization\","]
#[doc = "    \"org_block\","]
#[doc = "    \"page_build\","]
#[doc = "    \"project\","]
#[doc = "    \"project_card\","]
#[doc = "    \"project_column\","]
#[doc = "    \"public\","]
#[doc = "    \"pull_request\","]
#[doc = "    \"pull_request_review\","]
#[doc = "    \"pull_request_review_comment\","]
#[doc = "    \"push\","]
#[doc = "    \"registry_package\","]
#[doc = "    \"release\","]
#[doc = "    \"repository\","]
#[doc = "    \"repository_dispatch\","]
#[doc = "    \"repository_import\","]
#[doc = "    \"repository_vulnerability_alert\","]
#[doc = "    \"secret_scanning_alert\","]
#[doc = "    \"star\","]
#[doc = "    \"status\","]
#[doc = "    \"team\","]
#[doc = "    \"team_add\","]
#[doc = "    \"watch\","]
#[doc = "    \"workflow_dispatch\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WebhookEventsVariant0Item {
    #[serde(rename = "check_run")]
    CheckRun,
    #[serde(rename = "check_suite")]
    CheckSuite,
    #[serde(rename = "code_scanning_alert")]
    CodeScanningAlert,
    #[serde(rename = "commit_comment")]
    CommitComment,
    #[serde(rename = "content_reference")]
    ContentReference,
    #[serde(rename = "create")]
    Create,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "deployment")]
    Deployment,
    #[serde(rename = "deployment_review")]
    DeploymentReview,
    #[serde(rename = "deployment_status")]
    DeploymentStatus,
    #[serde(rename = "deploy_key")]
    DeployKey,
    #[serde(rename = "discussion")]
    Discussion,
    #[serde(rename = "discussion_comment")]
    DiscussionComment,
    #[serde(rename = "fork")]
    Fork,
    #[serde(rename = "gollum")]
    Gollum,
    #[serde(rename = "issues")]
    Issues,
    #[serde(rename = "issue_comment")]
    IssueComment,
    #[serde(rename = "label")]
    Label,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "membership")]
    Membership,
    #[serde(rename = "meta")]
    Meta,
    #[serde(rename = "milestone")]
    Milestone,
    #[serde(rename = "organization")]
    Organization,
    #[serde(rename = "org_block")]
    OrgBlock,
    #[serde(rename = "page_build")]
    PageBuild,
    #[serde(rename = "project")]
    Project,
    #[serde(rename = "project_card")]
    ProjectCard,
    #[serde(rename = "project_column")]
    ProjectColumn,
    #[serde(rename = "public")]
    Public,
    #[serde(rename = "pull_request")]
    PullRequest,
    #[serde(rename = "pull_request_review")]
    PullRequestReview,
    #[serde(rename = "pull_request_review_comment")]
    PullRequestReviewComment,
    #[serde(rename = "push")]
    Push,
    #[serde(rename = "registry_package")]
    RegistryPackage,
    #[serde(rename = "release")]
    Release,
    #[serde(rename = "repository")]
    Repository,
    #[serde(rename = "repository_dispatch")]
    RepositoryDispatch,
    #[serde(rename = "repository_import")]
    RepositoryImport,
    #[serde(rename = "repository_vulnerability_alert")]
    RepositoryVulnerabilityAlert,
    #[serde(rename = "secret_scanning_alert")]
    SecretScanningAlert,
    #[serde(rename = "star")]
    Star,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "team_add")]
    TeamAdd,
    #[serde(rename = "watch")]
    Watch,
    #[serde(rename = "workflow_dispatch")]
    WorkflowDispatch,
    #[serde(rename = "workflow_run")]
    WorkflowRun,
}
impl ::std::convert::From<&Self> for WebhookEventsVariant0Item {
    fn from(value: &WebhookEventsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WebhookEventsVariant0Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CheckRun => write!(f, "check_run"),
            Self::CheckSuite => write!(f, "check_suite"),
            Self::CodeScanningAlert => write!(f, "code_scanning_alert"),
            Self::CommitComment => write!(f, "commit_comment"),
            Self::ContentReference => write!(f, "content_reference"),
            Self::Create => write!(f, "create"),
            Self::Delete => write!(f, "delete"),
            Self::Deployment => write!(f, "deployment"),
            Self::DeploymentReview => write!(f, "deployment_review"),
            Self::DeploymentStatus => write!(f, "deployment_status"),
            Self::DeployKey => write!(f, "deploy_key"),
            Self::Discussion => write!(f, "discussion"),
            Self::DiscussionComment => write!(f, "discussion_comment"),
            Self::Fork => write!(f, "fork"),
            Self::Gollum => write!(f, "gollum"),
            Self::Issues => write!(f, "issues"),
            Self::IssueComment => write!(f, "issue_comment"),
            Self::Label => write!(f, "label"),
            Self::Member => write!(f, "member"),
            Self::Membership => write!(f, "membership"),
            Self::Meta => write!(f, "meta"),
            Self::Milestone => write!(f, "milestone"),
            Self::Organization => write!(f, "organization"),
            Self::OrgBlock => write!(f, "org_block"),
            Self::PageBuild => write!(f, "page_build"),
            Self::Project => write!(f, "project"),
            Self::ProjectCard => write!(f, "project_card"),
            Self::ProjectColumn => write!(f, "project_column"),
            Self::Public => write!(f, "public"),
            Self::PullRequest => write!(f, "pull_request"),
            Self::PullRequestReview => write!(f, "pull_request_review"),
            Self::PullRequestReviewComment => write!(f, "pull_request_review_comment"),
            Self::Push => write!(f, "push"),
            Self::RegistryPackage => write!(f, "registry_package"),
            Self::Release => write!(f, "release"),
            Self::Repository => write!(f, "repository"),
            Self::RepositoryDispatch => write!(f, "repository_dispatch"),
            Self::RepositoryImport => write!(f, "repository_import"),
            Self::RepositoryVulnerabilityAlert => write!(f, "repository_vulnerability_alert"),
            Self::SecretScanningAlert => write!(f, "secret_scanning_alert"),
            Self::Star => write!(f, "star"),
            Self::Status => write!(f, "status"),
            Self::Team => write!(f, "team"),
            Self::TeamAdd => write!(f, "team_add"),
            Self::Watch => write!(f, "watch"),
            Self::WorkflowDispatch => write!(f, "workflow_dispatch"),
            Self::WorkflowRun => write!(f, "workflow_run"),
        }
    }
}
impl ::std::str::FromStr for WebhookEventsVariant0Item {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "check_run" => Ok(Self::CheckRun),
            "check_suite" => Ok(Self::CheckSuite),
            "code_scanning_alert" => Ok(Self::CodeScanningAlert),
            "commit_comment" => Ok(Self::CommitComment),
            "content_reference" => Ok(Self::ContentReference),
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "deployment" => Ok(Self::Deployment),
            "deployment_review" => Ok(Self::DeploymentReview),
            "deployment_status" => Ok(Self::DeploymentStatus),
            "deploy_key" => Ok(Self::DeployKey),
            "discussion" => Ok(Self::Discussion),
            "discussion_comment" => Ok(Self::DiscussionComment),
            "fork" => Ok(Self::Fork),
            "gollum" => Ok(Self::Gollum),
            "issues" => Ok(Self::Issues),
            "issue_comment" => Ok(Self::IssueComment),
            "label" => Ok(Self::Label),
            "member" => Ok(Self::Member),
            "membership" => Ok(Self::Membership),
            "meta" => Ok(Self::Meta),
            "milestone" => Ok(Self::Milestone),
            "organization" => Ok(Self::Organization),
            "org_block" => Ok(Self::OrgBlock),
            "page_build" => Ok(Self::PageBuild),
            "project" => Ok(Self::Project),
            "project_card" => Ok(Self::ProjectCard),
            "project_column" => Ok(Self::ProjectColumn),
            "public" => Ok(Self::Public),
            "pull_request" => Ok(Self::PullRequest),
            "pull_request_review" => Ok(Self::PullRequestReview),
            "pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
            "push" => Ok(Self::Push),
            "registry_package" => Ok(Self::RegistryPackage),
            "release" => Ok(Self::Release),
            "repository" => Ok(Self::Repository),
            "repository_dispatch" => Ok(Self::RepositoryDispatch),
            "repository_import" => Ok(Self::RepositoryImport),
            "repository_vulnerability_alert" => Ok(Self::RepositoryVulnerabilityAlert),
            "secret_scanning_alert" => Ok(Self::SecretScanningAlert),
            "star" => Ok(Self::Star),
            "status" => Ok(Self::Status),
            "team" => Ok(Self::Team),
            "team_add" => Ok(Self::TeamAdd),
            "watch" => Ok(Self::Watch),
            "workflow_dispatch" => Ok(Self::WorkflowDispatch),
            "workflow_run" => Ok(Self::WorkflowRun),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WebhookEventsVariant0Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WebhookEventsVariant0Item {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WebhookEventsVariant0Item {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Workflow`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"badge_url\","]
#[doc = "    \"created_at\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"path\","]
#[doc = "    \"state\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"badge_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"state\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Workflow {
    pub badge_url: ::std::string::String,
    pub created_at: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub path: ::std::string::String,
    pub state: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Workflow> for Workflow {
    fn from(value: &Workflow) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowDispatchEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_dispatch event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"inputs\","]
#[doc = "    \"ref\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"inputs\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowDispatchEvent {
    pub inputs:
        ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repository: Repository,
    pub sender: User,
    pub workflow: ::std::string::String,
}
impl ::std::convert::From<&WorkflowDispatchEvent> for WorkflowDispatchEvent {
    fn from(value: &WorkflowDispatchEvent) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJob`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow Job\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"check_run_url\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"labels\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"run_id\","]
#[doc = "    \"run_url\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"steps\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"check_run_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"run_id\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"run_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/workflow-step\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJob {
    pub check_run_url: ::std::string::String,
    pub completed_at: ::std::option::Option<::std::string::String>,
    pub conclusion: ::std::option::Option<WorkflowJobConclusion>,
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<::std::string::String>,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub run_id: f64,
    pub run_url: ::std::string::String,
    pub started_at: ::std::string::String,
    pub status: WorkflowJobStatus,
    pub steps: ::std::vec::Vec<WorkflowStep>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowJob> for WorkflowJob {
    fn from(value: &WorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobCompleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_job completed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow_job\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow_job\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/workflow-job\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"conclusion\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompleted {
    pub action: WorkflowJobCompletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobCompletedWorkflowJob,
}
impl ::std::convert::From<&WorkflowJobCompleted> for WorkflowJobCompleted {
    fn from(value: &WorkflowJobCompleted) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobCompletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowJobCompletedAction {
    fn from(value: &WorkflowJobCompletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobCompletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobCompletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobCompletedWorkflowJob`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-job\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"conclusion\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompletedWorkflowJob {
    pub check_run_url: ::std::string::String,
    pub completed_at: ::std::option::Option<::std::string::String>,
    pub conclusion: WorkflowJobCompletedWorkflowJobConclusion,
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<::std::string::String>,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub run_id: f64,
    pub run_url: ::std::string::String,
    pub started_at: ::std::string::String,
    pub status: WorkflowJobCompletedWorkflowJobStatus,
    pub steps: ::std::vec::Vec<WorkflowStep>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowJobCompletedWorkflowJob> for WorkflowJobCompletedWorkflowJob {
    fn from(value: &WorkflowJobCompletedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobCompletedWorkflowJobConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobCompletedWorkflowJobConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl ::std::convert::From<&Self> for WorkflowJobCompletedWorkflowJobConclusion {
    fn from(value: &WorkflowJobCompletedWorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobCompletedWorkflowJobConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobCompletedWorkflowJobConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobCompletedWorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobCompletedWorkflowJobStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobCompletedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowJobCompletedWorkflowJobStatus {
    fn from(value: &WorkflowJobCompletedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobCompletedWorkflowJobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobCompletedWorkflowJobStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobCompletedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
}
impl ::std::convert::From<&Self> for WorkflowJobConclusion {
    fn from(value: &WorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_job$completed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_job$queued\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_job$started\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WorkflowJobEvent {
    Completed(WorkflowJobCompleted),
    Queued(WorkflowJobQueued),
    Started(WorkflowJobStarted),
}
impl ::std::convert::From<&Self> for WorkflowJobEvent {
    fn from(value: &WorkflowJobEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<WorkflowJobCompleted> for WorkflowJobEvent {
    fn from(value: WorkflowJobCompleted) -> Self {
        Self::Completed(value)
    }
}
impl ::std::convert::From<WorkflowJobQueued> for WorkflowJobEvent {
    fn from(value: WorkflowJobQueued) -> Self {
        Self::Queued(value)
    }
}
impl ::std::convert::From<WorkflowJobStarted> for WorkflowJobEvent {
    fn from(value: WorkflowJobStarted) -> Self {
        Self::Started(value)
    }
}
#[doc = "`WorkflowJobQueued`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_job queued event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow_job\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow_job\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"check_run_url\","]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"head_sha\","]
#[doc = "        \"html_url\","]
#[doc = "        \"id\","]
#[doc = "        \"labels\","]
#[doc = "        \"name\","]
#[doc = "        \"node_id\","]
#[doc = "        \"run_id\","]
#[doc = "        \"run_url\","]
#[doc = "        \"started_at\","]
#[doc = "        \"status\","]
#[doc = "        \"steps\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"check_run_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"head_sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"html_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"node_id\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"run_id\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"run_url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"started_at\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queued\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"steps\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/workflow-step\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueued {
    pub action: WorkflowJobQueuedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobQueuedWorkflowJob,
}
impl ::std::convert::From<&WorkflowJobQueued> for WorkflowJobQueued {
    fn from(value: &WorkflowJobQueued) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobQueuedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobQueuedAction {
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for WorkflowJobQueuedAction {
    fn from(value: &WorkflowJobQueuedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobQueuedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobQueuedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobQueuedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobQueuedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobQueuedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobQueuedWorkflowJob`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"check_run_url\","]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"labels\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"run_id\","]
#[doc = "    \"run_url\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\","]
#[doc = "    \"steps\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"check_run_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"run_id\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"run_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queued\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/workflow-step\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueuedWorkflowJob {
    pub check_run_url: ::std::string::String,
    pub completed_at: (),
    pub conclusion: (),
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<::std::string::String>,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub run_id: f64,
    pub run_url: ::std::string::String,
    pub started_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub status: WorkflowJobQueuedWorkflowJobStatus,
    pub steps: ::std::vec::Vec<WorkflowStep>,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowJobQueuedWorkflowJob> for WorkflowJobQueuedWorkflowJob {
    fn from(value: &WorkflowJobQueuedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobQueuedWorkflowJobStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobQueuedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for WorkflowJobQueuedWorkflowJobStatus {
    fn from(value: &WorkflowJobQueuedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobQueuedWorkflowJobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobQueuedWorkflowJobStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobQueuedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobStarted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_job started event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow_job\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"started\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow_job\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/workflow-job\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"completed_at\","]
#[doc = "            \"conclusion\","]
#[doc = "            \"steps\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"completed_at\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            \"steps\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/workflow-step-in_progress\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 1,"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStarted {
    pub action: WorkflowJobStartedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow_job: WorkflowJobStartedWorkflowJob,
}
impl ::std::convert::From<&WorkflowJobStarted> for WorkflowJobStarted {
    fn from(value: &WorkflowJobStarted) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobStartedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"started\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobStartedAction {
    #[serde(rename = "started")]
    Started,
}
impl ::std::convert::From<&Self> for WorkflowJobStartedAction {
    fn from(value: &WorkflowJobStartedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobStartedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Started => write!(f, "started"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobStartedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "started" => Ok(Self::Started),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobStartedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobStartedWorkflowJob`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-job\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"completed_at\","]
#[doc = "        \"conclusion\","]
#[doc = "        \"steps\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"completed_at\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        \"steps\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/workflow-step-in_progress\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 1,"]
#[doc = "          \"minItems\": 1"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobStartedWorkflowJob {
    pub check_run_url: ::std::string::String,
    pub completed_at: (),
    pub conclusion: WorkflowJobStartedWorkflowJobConclusion,
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub labels: ::std::vec::Vec<::std::string::String>,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub run_id: f64,
    pub run_url: ::std::string::String,
    pub started_at: ::std::string::String,
    pub status: WorkflowJobStartedWorkflowJobStatus,
    pub steps: [WorkflowStepInProgress; 1usize],
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowJobStartedWorkflowJob> for WorkflowJobStartedWorkflowJob {
    fn from(value: &WorkflowJobStartedWorkflowJob) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowJobStartedWorkflowJobConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"null\","]
#[doc = "  \"enum\": ["]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct WorkflowJobStartedWorkflowJobConclusion(());
impl ::std::ops::Deref for WorkflowJobStartedWorkflowJobConclusion {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<WorkflowJobStartedWorkflowJobConclusion> for () {
    fn from(value: WorkflowJobStartedWorkflowJobConclusion) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WorkflowJobStartedWorkflowJobConclusion>
    for WorkflowJobStartedWorkflowJobConclusion
{
    fn from(value: &WorkflowJobStartedWorkflowJobConclusion) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<()> for WorkflowJobStartedWorkflowJobConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: ()) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![()].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for WorkflowJobStartedWorkflowJobConclusion {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<()>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`WorkflowJobStartedWorkflowJobStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobStartedWorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowJobStartedWorkflowJobStatus {
    fn from(value: &WorkflowJobStartedWorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobStartedWorkflowJobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobStartedWorkflowJobStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobStartedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobStartedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobStartedWorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowJobStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queued\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowJobStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowJobStatus {
    fn from(value: &WorkflowJobStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowJobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Queued => write!(f, "queued"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowJobStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queued" => Ok(Self::Queued),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowJobStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRun`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow Run\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"artifacts_url\","]
#[doc = "    \"cancel_url\","]
#[doc = "    \"check_suite_id\","]
#[doc = "    \"check_suite_node_id\","]
#[doc = "    \"check_suite_url\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"created_at\","]
#[doc = "    \"event\","]
#[doc = "    \"head_branch\","]
#[doc = "    \"head_commit\","]
#[doc = "    \"head_repository\","]
#[doc = "    \"head_sha\","]
#[doc = "    \"html_url\","]
#[doc = "    \"id\","]
#[doc = "    \"jobs_url\","]
#[doc = "    \"logs_url\","]
#[doc = "    \"name\","]
#[doc = "    \"node_id\","]
#[doc = "    \"pull_requests\","]
#[doc = "    \"repository\","]
#[doc = "    \"rerun_url\","]
#[doc = "    \"run_number\","]
#[doc = "    \"status\","]
#[doc = "    \"updated_at\","]
#[doc = "    \"url\","]
#[doc = "    \"workflow_id\","]
#[doc = "    \"workflow_url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"artifacts_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"cancel_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"check_suite_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"check_suite_node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"check_suite_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"enum\": ["]
#[doc = "        \"success\","]
#[doc = "        \"failure\","]
#[doc = "        \"neutral\","]
#[doc = "        \"cancelled\","]
#[doc = "        \"timed_out\","]
#[doc = "        \"action_required\","]
#[doc = "        \"stale\","]
#[doc = "        null"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"created_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"event\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_branch\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"head_commit\": {"]
#[doc = "      \"$ref\": \"#/definitions/commit-simple\""]
#[doc = "    },"]
#[doc = "    \"head_repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository-lite\""]
#[doc = "    },"]
#[doc = "    \"head_sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"html_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"jobs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"logs_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"node_id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pull_requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"base\","]
#[doc = "          \"head\","]
#[doc = "          \"id\","]
#[doc = "          \"number\","]
#[doc = "          \"url\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"base\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ref\","]
#[doc = "              \"repo\","]
#[doc = "              \"sha\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ref\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"repo\": {"]
#[doc = "                \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "              },"]
#[doc = "              \"sha\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"head\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"ref\","]
#[doc = "              \"repo\","]
#[doc = "              \"sha\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"ref\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"repo\": {"]
#[doc = "                \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "              },"]
#[doc = "              \"sha\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"number\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"url\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"format\": \"uri\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository-lite\""]
#[doc = "    },"]
#[doc = "    \"rerun_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"run_number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\","]
#[doc = "        \"in_progress\","]
#[doc = "        \"completed\","]
#[doc = "        \"queued\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updated_at\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"workflow_id\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"workflow_url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRun {
    pub artifacts_url: ::std::string::String,
    pub cancel_url: ::std::string::String,
    pub check_suite_id: i64,
    pub check_suite_node_id: ::std::string::String,
    pub check_suite_url: ::std::string::String,
    pub conclusion: ::std::option::Option<WorkflowRunConclusion>,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub event: ::std::string::String,
    pub head_branch: ::std::string::String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub jobs_url: ::std::string::String,
    pub logs_url: ::std::string::String,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub pull_requests: ::std::vec::Vec<WorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: ::std::string::String,
    pub run_number: i64,
    pub status: WorkflowRunStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub workflow_id: i64,
    pub workflow_url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRun> for WorkflowRun {
    fn from(value: &WorkflowRun) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_run completed event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow\": {"]
#[doc = "      \"$ref\": \"#/definitions/workflow\""]
#[doc = "    },"]
#[doc = "    \"workflow_run\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/workflow-run\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"conclusion\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"conclusion\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"success\","]
#[doc = "                \"failure\","]
#[doc = "                \"neutral\","]
#[doc = "                \"cancelled\","]
#[doc = "                \"timed_out\","]
#[doc = "                \"action_required\","]
#[doc = "                \"stale\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"tsAdditionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompleted {
    pub action: WorkflowRunCompletedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRunCompletedWorkflowRun,
}
impl ::std::convert::From<&WorkflowRunCompleted> for WorkflowRunCompleted {
    fn from(value: &WorkflowRunCompleted) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompletedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunCompletedAction {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowRunCompletedAction {
    fn from(value: &WorkflowRunCompletedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunCompletedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunCompletedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunCompletedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRun`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-run\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"conclusion\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"conclusion\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"success\","]
#[doc = "            \"failure\","]
#[doc = "            \"neutral\","]
#[doc = "            \"cancelled\","]
#[doc = "            \"timed_out\","]
#[doc = "            \"action_required\","]
#[doc = "            \"stale\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"tsAdditionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRun {
    pub artifacts_url: ::std::string::String,
    pub cancel_url: ::std::string::String,
    pub check_suite_id: i64,
    pub check_suite_node_id: ::std::string::String,
    pub check_suite_url: ::std::string::String,
    pub conclusion: WorkflowRunCompletedWorkflowRunConclusion,
    pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub event: ::std::string::String,
    pub head_branch: ::std::string::String,
    pub head_commit: CommitSimple,
    pub head_repository: RepositoryLite,
    pub head_sha: ::std::string::String,
    pub html_url: ::std::string::String,
    pub id: i64,
    pub jobs_url: ::std::string::String,
    pub logs_url: ::std::string::String,
    pub name: ::std::string::String,
    pub node_id: ::std::string::String,
    pub pull_requests: ::std::vec::Vec<WorkflowRunCompletedWorkflowRunPullRequestsItem>,
    pub repository: RepositoryLite,
    pub rerun_url: ::std::string::String,
    pub run_number: i64,
    pub status: WorkflowRunCompletedWorkflowRunStatus,
    pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
    pub url: ::std::string::String,
    pub workflow_id: i64,
    pub workflow_url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunCompletedWorkflowRun> for WorkflowRunCompletedWorkflowRun {
    fn from(value: &WorkflowRunCompletedWorkflowRun) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRunConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunCompletedWorkflowRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for WorkflowRunCompletedWorkflowRunConclusion {
    fn from(value: &WorkflowRunCompletedWorkflowRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunCompletedWorkflowRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunCompletedWorkflowRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunCompletedWorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRunPullRequestsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base\","]
#[doc = "    \"head\","]
#[doc = "    \"id\","]
#[doc = "    \"number\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItem {
    pub base: WorkflowRunCompletedWorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunCompletedWorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunCompletedWorkflowRunPullRequestsItem>
    for WorkflowRunCompletedWorkflowRunPullRequestsItem
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItem) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRunPullRequestsItemBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunCompletedWorkflowRunPullRequestsItemBase>
    for WorkflowRunCompletedWorkflowRunPullRequestsItemBase
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItemBase) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRunPullRequestsItemHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompletedWorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunCompletedWorkflowRunPullRequestsItemHead>
    for WorkflowRunCompletedWorkflowRunPullRequestsItemHead
{
    fn from(value: &WorkflowRunCompletedWorkflowRunPullRequestsItemHead) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunCompletedWorkflowRunStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunCompletedWorkflowRunStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for WorkflowRunCompletedWorkflowRunStatus {
    fn from(value: &WorkflowRunCompletedWorkflowRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunCompletedWorkflowRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunCompletedWorkflowRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunCompletedWorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRunConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"success\","]
#[doc = "    \"failure\","]
#[doc = "    \"neutral\","]
#[doc = "    \"cancelled\","]
#[doc = "    \"timed_out\","]
#[doc = "    \"action_required\","]
#[doc = "    \"stale\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunConclusion {
    #[serde(rename = "success")]
    Success,
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "neutral")]
    Neutral,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "timed_out")]
    TimedOut,
    #[serde(rename = "action_required")]
    ActionRequired,
    #[serde(rename = "stale")]
    Stale,
}
impl ::std::convert::From<&Self> for WorkflowRunConclusion {
    fn from(value: &WorkflowRunConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Success => write!(f, "success"),
            Self::Failure => write!(f, "failure"),
            Self::Neutral => write!(f, "neutral"),
            Self::Cancelled => write!(f, "cancelled"),
            Self::TimedOut => write!(f, "timed_out"),
            Self::ActionRequired => write!(f, "action_required"),
            Self::Stale => write!(f, "stale"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "success" => Ok(Self::Success),
            "failure" => Ok(Self::Failure),
            "neutral" => Ok(Self::Neutral),
            "cancelled" => Ok(Self::Cancelled),
            "timed_out" => Ok(Self::TimedOut),
            "action_required" => Ok(Self::ActionRequired),
            "stale" => Ok(Self::Stale),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRunEvent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_run$completed\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow_run$requested\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WorkflowRunEvent {
    Completed(WorkflowRunCompleted),
    Requested(WorkflowRunRequested),
}
impl ::std::convert::From<&Self> for WorkflowRunEvent {
    fn from(value: &WorkflowRunEvent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<WorkflowRunCompleted> for WorkflowRunEvent {
    fn from(value: WorkflowRunCompleted) -> Self {
        Self::Completed(value)
    }
}
impl ::std::convert::From<WorkflowRunRequested> for WorkflowRunEvent {
    fn from(value: WorkflowRunRequested) -> Self {
        Self::Requested(value)
    }
}
#[doc = "`WorkflowRunPullRequestsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base\","]
#[doc = "    \"head\","]
#[doc = "    \"id\","]
#[doc = "    \"number\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"head\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ref\","]
#[doc = "        \"repo\","]
#[doc = "        \"sha\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ref\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"repo\": {"]
#[doc = "          \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "        },"]
#[doc = "        \"sha\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItem {
    pub base: WorkflowRunPullRequestsItemBase,
    pub head: WorkflowRunPullRequestsItemHead,
    pub id: f64,
    pub number: f64,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunPullRequestsItem> for WorkflowRunPullRequestsItem {
    fn from(value: &WorkflowRunPullRequestsItem) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunPullRequestsItemBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemBase {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunPullRequestsItemBase> for WorkflowRunPullRequestsItemBase {
    fn from(value: &WorkflowRunPullRequestsItemBase) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunPullRequestsItemHead`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ref\","]
#[doc = "    \"repo\","]
#[doc = "    \"sha\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ref\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"repo\": {"]
#[doc = "      \"$ref\": \"#/definitions/repo-ref\""]
#[doc = "    },"]
#[doc = "    \"sha\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemHead {
    #[serde(rename = "ref")]
    pub ref_: ::std::string::String,
    pub repo: RepoRef,
    pub sha: ::std::string::String,
}
impl ::std::convert::From<&WorkflowRunPullRequestsItemHead> for WorkflowRunPullRequestsItemHead {
    fn from(value: &WorkflowRunPullRequestsItemHead) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunRequested`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"workflow_run requested event\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"repository\","]
#[doc = "    \"sender\","]
#[doc = "    \"workflow\","]
#[doc = "    \"workflow_run\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"requested\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"installation\": {"]
#[doc = "      \"$ref\": \"#/definitions/installation-lite\""]
#[doc = "    },"]
#[doc = "    \"organization\": {"]
#[doc = "      \"$ref\": \"#/definitions/organization\""]
#[doc = "    },"]
#[doc = "    \"repository\": {"]
#[doc = "      \"$ref\": \"#/definitions/repository\""]
#[doc = "    },"]
#[doc = "    \"sender\": {"]
#[doc = "      \"$ref\": \"#/definitions/user\""]
#[doc = "    },"]
#[doc = "    \"workflow\": {"]
#[doc = "      \"$ref\": \"#/definitions/workflow\""]
#[doc = "    },"]
#[doc = "    \"workflow_run\": {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-run\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunRequested {
    pub action: WorkflowRunRequestedAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub installation: ::std::option::Option<InstallationLite>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub organization: ::std::option::Option<Organization>,
    pub repository: Repository,
    pub sender: User,
    pub workflow: Workflow,
    pub workflow_run: WorkflowRun,
}
impl ::std::convert::From<&WorkflowRunRequested> for WorkflowRunRequested {
    fn from(value: &WorkflowRunRequested) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowRunRequestedAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunRequestedAction {
    #[serde(rename = "requested")]
    Requested,
}
impl ::std::convert::From<&Self> for WorkflowRunRequestedAction {
    fn from(value: &WorkflowRunRequestedAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunRequestedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunRequestedAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunRequestedAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowRunStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"requested\","]
#[doc = "    \"in_progress\","]
#[doc = "    \"completed\","]
#[doc = "    \"queued\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowRunStatus {
    #[serde(rename = "requested")]
    Requested,
    #[serde(rename = "in_progress")]
    InProgress,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "queued")]
    Queued,
}
impl ::std::convert::From<&Self> for WorkflowRunStatus {
    fn from(value: &WorkflowRunStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowRunStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Requested => write!(f, "requested"),
            Self::InProgress => write!(f, "in_progress"),
            Self::Completed => write!(f, "completed"),
            Self::Queued => write!(f, "queued"),
        }
    }
}
impl ::std::str::FromStr for WorkflowRunStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "requested" => Ok(Self::Requested),
            "in_progress" => Ok(Self::InProgress),
            "completed" => Ok(Self::Completed),
            "queued" => Ok(Self::Queued),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowRunStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow Step\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-step-in_progress\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/workflow-step-completed\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WorkflowStep {
    InProgress(WorkflowStepInProgress),
    Completed(WorkflowStepCompleted),
}
impl ::std::convert::From<&Self> for WorkflowStep {
    fn from(value: &WorkflowStep) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<WorkflowStepInProgress> for WorkflowStep {
    fn from(value: WorkflowStepInProgress) -> Self {
        Self::InProgress(value)
    }
}
impl ::std::convert::From<WorkflowStepCompleted> for WorkflowStep {
    fn from(value: WorkflowStepCompleted) -> Self {
        Self::Completed(value)
    }
}
#[doc = "`WorkflowStepCompleted`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow Step (Completed)\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"name\","]
#[doc = "    \"number\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"failure\","]
#[doc = "        \"skipped\","]
#[doc = "        \"success\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"completed\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepCompleted {
    pub completed_at: ::std::string::String,
    pub conclusion: WorkflowStepCompletedConclusion,
    pub name: ::std::string::String,
    pub number: i64,
    pub started_at: ::std::string::String,
    pub status: WorkflowStepCompletedStatus,
}
impl ::std::convert::From<&WorkflowStepCompleted> for WorkflowStepCompleted {
    fn from(value: &WorkflowStepCompleted) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowStepCompletedConclusion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"failure\","]
#[doc = "    \"skipped\","]
#[doc = "    \"success\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowStepCompletedConclusion {
    #[serde(rename = "failure")]
    Failure,
    #[serde(rename = "skipped")]
    Skipped,
    #[serde(rename = "success")]
    Success,
}
impl ::std::convert::From<&Self> for WorkflowStepCompletedConclusion {
    fn from(value: &WorkflowStepCompletedConclusion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowStepCompletedConclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Failure => write!(f, "failure"),
            Self::Skipped => write!(f, "skipped"),
            Self::Success => write!(f, "success"),
        }
    }
}
impl ::std::str::FromStr for WorkflowStepCompletedConclusion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "failure" => Ok(Self::Failure),
            "skipped" => Ok(Self::Skipped),
            "success" => Ok(Self::Success),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowStepCompletedConclusion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowStepCompletedConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowStepCompletedConclusion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowStepCompletedStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"completed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowStepCompletedStatus {
    #[serde(rename = "completed")]
    Completed,
}
impl ::std::convert::From<&Self> for WorkflowStepCompletedStatus {
    fn from(value: &WorkflowStepCompletedStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowStepCompletedStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Completed => write!(f, "completed"),
        }
    }
}
impl ::std::str::FromStr for WorkflowStepCompletedStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "completed" => Ok(Self::Completed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowStepCompletedStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowStepCompletedStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowStepCompletedStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WorkflowStepInProgress`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Workflow Step (In Progress)\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"completed_at\","]
#[doc = "    \"conclusion\","]
#[doc = "    \"name\","]
#[doc = "    \"number\","]
#[doc = "    \"started_at\","]
#[doc = "    \"status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"completed_at\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"conclusion\": {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"started_at\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"in_progress\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false,"]
#[doc = "  \"$schema\": \"http://json-schema.org/draft-07/schema\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepInProgress {
    pub completed_at: (),
    pub conclusion: (),
    pub name: ::std::string::String,
    pub number: i64,
    pub started_at: ::std::string::String,
    pub status: WorkflowStepInProgressStatus,
}
impl ::std::convert::From<&WorkflowStepInProgress> for WorkflowStepInProgress {
    fn from(value: &WorkflowStepInProgress) -> Self {
        value.clone()
    }
}
#[doc = "`WorkflowStepInProgressStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"in_progress\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WorkflowStepInProgressStatus {
    #[serde(rename = "in_progress")]
    InProgress,
}
impl ::std::convert::From<&Self> for WorkflowStepInProgressStatus {
    fn from(value: &WorkflowStepInProgressStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WorkflowStepInProgressStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::InProgress => write!(f, "in_progress"),
        }
    }
}
impl ::std::str::FromStr for WorkflowStepInProgressStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "in_progress" => Ok(Self::InProgress),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowStepInProgressStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowStepInProgressStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowStepInProgressStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = r" Generation of default values for serde."]
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
}
